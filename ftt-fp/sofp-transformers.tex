
\chapter{Computations in functor blocks III. Monad transformers}

\section{Slides}

\subsection{Computations within a functor context: Combining monads}

Programs often need to combine monadic effects (see code)

``Effect'' $\triangleq$ what else happens in {\footnotesize{}$A\Rightarrow M^{B}$}
besides computing $B$ from $A$

Examples of effects for some standard monads:

\texttt{\textcolor{blue}{\footnotesize{}Option}} – computation will
have no result or a single result

\texttt{\textcolor{blue}{\footnotesize{}List}} – computation will
have zero, one, or multiple results

\texttt{\textcolor{blue}{\footnotesize{}Either}} – computation may
fail to obtain its result, reports error

\texttt{\textcolor{blue}{\footnotesize{}Reader}} – computation needs
to read an external context value

\texttt{\textcolor{blue}{\footnotesize{}Writer}} – some value will
be appended to a (monoidal) accumulator

\texttt{\textcolor{blue}{\footnotesize{}Future}} – computation will
be scheduled to run later

How to combine several effects in the same functor block (\texttt{\textcolor{blue}{\footnotesize{}for}}/\texttt{\textcolor{blue}{\footnotesize{}yield}})?

{\footnotesize{}\vspace{-0.35cm}}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{darkgray}{\footnotesize{}//~This~is~not~valid~Scala!}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~result~=~for~\{~i~$\leftarrow$~1~to~n}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~j~$\leftarrow$~Future~\{~q(i)~\}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~k~$\leftarrow$~maybeError(j)~:~Try{[}Int{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~yield~f(k)}{\footnotesize\par}

\textcolor{darkgray}{\footnotesize{}//~What~should~be~the~type~of~result??}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}~ ~ ~}}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}~~}\textcolor{darkgray}{\footnotesize{}//~This~is~not~valid~Scala!}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}(1~to~n).flatMap~\{~i~$\Rightarrow$}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~Future(q(i)).flatMap~\{~j~$\Rightarrow$}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~maybeError(j).map~\{~k~$\Rightarrow$}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~~f(k)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~~~~\}\}\}}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
}}{\footnotesize\par}

The code will work if we ``unify'' all effects in a new, larger
monad

Need to compute the type of new monad that contains all given effects


\subsection{Combining monadic effects I. Trial and error\protect 

}There are several ways of combining two monads into a new monad:

If $M_{1}^{A}$ and $M_{2}^{A}$ are monads then $M_{1}^{A}\times M_{2}^{A}$
is also a monad

But $M_{1}^{A}\times M_{2}^{A}$ describes two separate values with
two separate effects

If $M_{1}^{A}$ and $M_{2}^{A}$ are monads then $M_{1}^{A}+M_{2}^{A}$
is usually not a monad

If it worked, it would be a choice between two different values /
effects

If $M_{1}^{A}$ and $M_{2}^{A}$ are monads then one of $M_{1}^{M_{2}^{A}}$
or $M_{2}^{M_{1}^{A}}$ is often a monad

Examples and counterexamples for functor composition:

Combine $Z\Rightarrow A$ and $\text{List}^{A}$ as $Z\Rightarrow\text{List}^{A}$

Combine \texttt{\textcolor{blue}{\footnotesize{}Future{[}A{]}}} and
\texttt{\textcolor{blue}{\footnotesize{}Option{[}A{]}}} as \texttt{\textcolor{blue}{\footnotesize{}Future{[}Option{[}A{]}{]}}} 

But \texttt{\textcolor{blue}{\footnotesize{}Either{[}Z, Future{[}A{]}{]}}}
and \texttt{\textcolor{blue}{\footnotesize{}Option{[}Z $\Rightarrow$
A{]}}} are not monads

Neither \texttt{\textcolor{blue}{\footnotesize{}Future{[}State{[}A{]}{]}}}
nor \texttt{\textcolor{blue}{\footnotesize{}State{[}Future{[}A{]}{]}}}
are monads

The order of effects matters when composition works both ways: 

Combine \texttt{\textcolor{blue}{\footnotesize{}Either}} ($M_{1}^{A}=Z+A$)
and \texttt{\textcolor{blue}{\footnotesize{}Writer}} ($M_{2}^{A}=W\times A$) 

as $Z+W\times A$ – either compute result and write a message, or
all fails

as $\left(Z+A\right)\times W$ – message is always written, but computation
may fail

Find a general way of defining a new monad with combined effects

Derive properties required for the new monad


\subsection{Combining monadic effects II. Lifting into a larger monad}

{\footnotesize{}\vspace{-0.15cm}}If a ``big monad'' \texttt{\textcolor{blue}{\footnotesize{}BigM{[}A{]}}}
\emph{somehow} combines all the needed effects:

{\footnotesize{}\vspace{-0.15cm}\hspace{-0.35cm}}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~This~could~be~valid~Scala...}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~result:~BigM{[}Int{]}~=~for~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~i~$\leftarrow$~lift$_{1}$(1~to~n)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~j~$\leftarrow$~lift$_{2}$(Future\{~q(i)~\})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~k~$\leftarrow$~lift$_{3}$(maybeError(j))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~yield~f(k)}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{} }}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}~}\textrm{\textcolor{darkgray}{\footnotesize{}//~If~we~define~the~various}}{\footnotesize\par}

\textrm{\textcolor{darkgray}{\footnotesize{}~//~required~``lifting''~functions:}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~lift$_{1}${[}A{]}:~Seq{[}A{]}~$\Rightarrow$~BigM{[}A{]}~=~???}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~lift$_{2}${[}A{]}:~Future{[}A{]}~$\Rightarrow$~BigM{[}A{]}~=~???}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~lift$_{3}${[}A{]}:~Try{[}A{]}~$\Rightarrow$~BigM{[}A{]}~=~???~~~}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
}}{\footnotesize\par}

Example 1: combining as \texttt{\textcolor{blue}{\footnotesize{}BigM{[}A{]}
= Future{[}Option{[}A{]}{]}}} with liftings:

{\footnotesize{}\vspace{-0.4cm}}\texttt{\textcolor{blue}{\footnotesize{}def
lift$_{1}${[}A{]}: Option{[}A{]} $\Rightarrow$ Future{[}Option{[}A{]}{]}
= Future.successful(\_)}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}def lift$_{2}${[}A{]}: Future{[}A{]}
$\Rightarrow$ Future{[}Option{[}A{]}{]} = \_.map(x $\Rightarrow$
Some(x))}}{\footnotesize\par}

{\footnotesize{}\vspace{-0.15cm}}Example 2: combining as \texttt{\textcolor{blue}{\footnotesize{}BigM{[}A{]}
= List{[}Try{[}A{]}{]}}} with liftings:

{\footnotesize{}\vspace{-0.05cm}}\texttt{\textcolor{blue}{\footnotesize{}def
lift$_{1}${[}A{]}: Try{[}A{]} $\Rightarrow$ List{[}Try{[}A{]}{]}
= x $\Rightarrow$ List(x)}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}def lift$_{2}${[}A{]}: List{[}A{]}
$\Rightarrow$ List{[}Try{[}A{]}{]} = \_.map(x $\Rightarrow$ Success(x))}}{\footnotesize\par}

{\footnotesize{}\vspace{-0.1cm}}Remains to be understood:

Finding suitable laws for the liftings; checking that the laws hold

Building a ``big monad'' out of ``smaller'' ones, with lawful
liftings

Is this always possible? Unique? Are there alternative solutions?

Ways of reducing the complexity of code; make liftings automatic


\subsection{Laws for monad liftings I. Identity laws}

Whatever identities we expect to hold for monadic programs must continue
to hold after lifting \texttt{\textcolor{blue}{\footnotesize{}M$_{1}$}}
or \texttt{\textcolor{blue}{\footnotesize{}M$_{2}$}} values into
the ``big monad'' \texttt{\textcolor{blue}{\footnotesize{}BigM}} 

We assume that \texttt{\textcolor{blue}{\footnotesize{}M$_{1}$}},
\texttt{\textcolor{blue}{\footnotesize{}M$_{2}$}}, and \texttt{\textcolor{blue}{\footnotesize{}BigM}}
already satisfy all the monad laws

Consider the various functor block constructions containing the liftings:

Left identity law after \texttt{\textcolor{blue}{\footnotesize{}lift$_{1}$}} 

{\footnotesize{}\vspace{-0.3cm}\hspace{-0.0cm}}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.54\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~Anywhere~inside~a~for/yield:}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}i~$\leftarrow$~lift$_{1}$(M$_{1}$.pure(x))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}j~$\leftarrow$~bigM(i)~}\textrm{\textcolor{darkgray}{\footnotesize{}//~Any~BigM~value.}}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}~ }}%
\begin{minipage}[t]{0.54\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~Must~be~equivalent~to...}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}i~=~x}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}j~$\leftarrow$~bigM(x)}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\smallskip{}
lift$_{1}$(M$_{1}$.pure(x)).flatMap(b) = b(x)}} — in terms of Kleisli
composition $\left(\diamond\right)$:
\begin{center}
{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}$\left(\text{pure}_{M_{1}}\bef\text{lift}_{1}\right)^{:X\Rightarrow\text{BigM}^{X}}\diamond b^{:X\Rightarrow\text{BigM}^{Y}}=b$\hspace*{\fill}with
$f^{:X\Rightarrow M^{Y}}\diamond g^{:Y\Rightarrow M^{Z}}\triangleq x\Rightarrow f(x).\text{flatMap}(g)$}{\footnotesize\par}
\par\end{center}

{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}}Right identity law
after \texttt{\textcolor{blue}{\footnotesize{}lift$_{1}$}} 

{\footnotesize{}\vspace{-0.3cm}\hspace{-0.0cm}}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.54\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~Anywhere~inside~a~for/yield:}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}x~$\leftarrow$~bigM~}\textrm{\textcolor{darkgray}{\footnotesize{}//~Any~BigM~value.}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}i~$\leftarrow$~lift$_{1}$(M$_{1}$.pure(x))}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}~ }}%
\begin{minipage}[t]{0.54\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~Must~be~equivalent~to...}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}x~$\leftarrow$~bigM}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}i~=~x}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
b.flatMap(M$_{1}$.pure andThen lift$_{1}$) = b}} — in terms of Kleisli
composition:
\begin{center}
{\footnotesize{}\vspace{-0.1cm}\hspace{-0.0cm}$b^{:X\Rightarrow\text{BigM}^{Y}}\diamond\left(\text{pure}_{M_{1}}\bef\text{lift}_{1}\right)^{:Y\Rightarrow\text{BigM}^{Y}}=b$}{\footnotesize\par}
\par\end{center}

{\footnotesize{}\vspace{-0.15cm}\hspace{-0.0cm}}The same identity
laws must hold for \texttt{\textcolor{blue}{\footnotesize{}M$_{2}$}}
and \texttt{\textcolor{blue}{\footnotesize{}lift$_{2}$}} as well


\subsection{Laws for monad liftings II. Simplifying the laws}

{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}}$\big(\text{pure}_{M_{1}}\bef\text{lift}_{1}\big)$
is a unit for the Kleisli composition $\diamond$ in the monad \texttt{\textcolor{blue}{\footnotesize{}BigM}} 

But the monad \texttt{\textcolor{blue}{\footnotesize{}BigM}} already
has a unit element, namely $\text{pure}_{\text{BigM}}$

The two-sided unit element is always unique: $\text{u}=\text{u}\diamond\text{u}^{\prime}=\text{u}^{\prime}$

So the two identity laws for $\big(\text{pure}_{M_{1}}\bef\text{lift}_{1}\big)$
can be reduced to one law:{\footnotesize{}\vspace{-0.1cm}\hspace{-0.0cm}
\[
\text{pure}_{M_{1}}\bef\text{lift}_{1}=\text{pure}_{\text{BigM}}
\]
}{\footnotesize\par}

{\footnotesize{}\vspace{-0.15cm}\hspace{-0.0cm}}Refactoring a portion
of a monadic program under \texttt{\textcolor{blue}{\footnotesize{}lift$_{1}$}}
gives another law:

{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.58\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~Anywhere~inside~a~for/yield,~this...}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}i~$\leftarrow$~lift$_{1}$(p)~}\textrm{\textcolor{darkgray}{\footnotesize{}//~Any~M$_{1}$~value.}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}j~$\leftarrow$~lift$_{1}$(q(i))~}\textrm{\textcolor{darkgray}{\footnotesize{}//~Any~M$_{1}$~value.}}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}~ }}%
\begin{minipage}[t]{0.5\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~must~be~equivalent~to...}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}pq~=~p.flatMap(q)~}\textrm{\textcolor{darkgray}{\footnotesize{}//~In~M$_{1}$.}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}j~$\leftarrow$~lift$_{1}$(pq)}\textrm{\textcolor{darkgray}{\footnotesize{}~~//~Now~lift~it.}}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
lift$_{1}$(p).flatMap(q andThen lift$_{1}$) = lift$_{1}$(p flatMap
q)}}{\footnotesize\par}

Rewritten equivalently through {\footnotesize{}$\text{flm}_{M}:\left(A\Rightarrow M^{B}\right)\Rightarrow M^{A}\Rightarrow M^{B}$}
as
\begin{center}
{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}$\text{lift}_{1}\bef\text{flm}_{\text{BigM}}\left(q\bef\text{lift}_{1}\right)=\text{flm}_{M_{1}}q\bef\text{lift}_{1}$
– both sides are functions $M_{1}^{A}\Rightarrow\text{BigM}^{B}$}{\footnotesize\par}
\par\end{center}

{\footnotesize{}\vspace{-0.3cm}\hspace{-0.0cm}}Rewritten equivalently
through {\footnotesize{}$\text{ftn}_{M}:M^{M^{A}}\Rightarrow M^{A}$,}
the law is
\begin{center}
{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}$\text{lift}_{1}\bef\text{fmap}_{\text{BigM}}\text{lift}_{1}\bef\text{ftn}_{\text{BigM}}=\text{ftn}_{M_{1}}\bef\text{lift}_{1}$
– both sides are functions $M_{1}^{M_{1}^{A}}\Rightarrow\text{BigM}^{A}$}{\footnotesize\par}
\par\end{center}

{\footnotesize{}\vspace{-0.3cm}\hspace{-0.0cm}}In terms of Kleisli
composition $\diamond_{M}$ it becomes the \textbf{composition law}:
\begin{center}
{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}$\big(b^{:X\Rightarrow M_{1}^{Y}}\bef\text{lift}_{1}\big)\diamond_{\text{BigM}}\big(c^{:Y\Rightarrow M_{1}^{Z}}\bef\text{lift}_{1}\big)=\left(b\diamond_{M_{1}}c\right)\bef\text{lift}_{1}$}{\footnotesize\par}
\par\end{center}

{\footnotesize{}\vspace{-0.3cm}\hspace{-0.0cm}}Liftings $\text{lift}_{1}$
and $\text{lift}_{2}$ must obey an identity law and a composition
law

The laws say that the liftings \textbf{commute with} the monads' operations


\subsection{Laws for monad liftings III. The naturality law}

Show that $\text{lift}_{1}:M_{1}^{A}\Rightarrow\text{BigM}^{A}$ is
a natural transformation 

It maps $\text{pure}_{M_{1}}$ to $\text{pure}_{\text{BigM}}$ and
$\text{flm}_{M_{1}}$ to $\text{flm}_{\text{BigM}}$

$\text{lift}_{1}$ is a \textbf{monadic morphism} between monads $M_{1}^{\bullet}$
and $\text{BigM}^{\bullet}$

example: monad ``interpreters'' $M^{A}\Rightarrow N^{A}$ are monadic
morphisms

The (functor) naturality law: for any $f:X\Rightarrow Y$, {\footnotesize{}\vspace{-0.1cm}}
\[
\text{lift}_{1}\bef\text{fmap}_{\text{BigM}}f=\text{fmap}_{M_{1}}f\bef\text{lift}_{1}
\]
{\footnotesize{}\vspace{-0.5cm}
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}M_{1}^{X}\ar[d]\sb(0.45){\text{fmap}_{M_{1}}\,f^{:X\Rightarrow Y}}\ar[r]\sp(0.45){\ \text{lift}_{1}} & \text{BigM}^{X}\ar[d]\sp(0.45){\text{fmap}_{\text{BigM}}\,f^{:X\Rightarrow Y}}\\
M_{1}^{Y}\ar[r]\sp(0.45){\text{lift}_{1}} & \text{BigM}^{Y}
}
\]
}Derivation of the functor naturality law for $\text{lift}_{1}$:

Express $\text{fmap}$ as $\text{fmap}_{M}f\triangleq f^{\uparrow M}=\text{flm}_{M}\left(f\bef\text{pure}_{M}\right)$
for both monads

Given $f^{:X\Rightarrow Y}$, use the law {\footnotesize{}$\text{flm}_{M_{1}}q\bef\text{lift}_{1}=\text{lift}_{1}\bef\text{flm}_{\text{BigM}}\left(q\bef\text{lift}_{1}\right)$}
to compute {\footnotesize{}$\text{flm}_{M_{1}}\left(f\bef\text{pure}_{M_{1}}\right)\bef\text{lift}_{1}=\text{lift}_{1}\bef\text{flm}_{\text{BigM}}\left(f\bef\text{pure}_{M_{1}}\bef\text{lift}_{1}\right)=\text{lift}_{1}\bef\text{flm}_{\text{BigM}}\left(f\bef\text{pure}_{\text{BigM}}\right)=\text{lift}_{1}\bef\text{fmap}_{\text{BigM}}f$}{\footnotesize\par}

A monadic morphism is always also a natural transformation of the
functors


\subsection{Monad transformers I: Motivation}

{\footnotesize{}\vspace{-0.2cm}}Combine $Z\Rightarrow A$ and $1+A$:
only $Z\Rightarrow1+A$ works, not $1+\left(Z\Rightarrow A\right)$

It is not possible to combine monads via a natural bifunctor $B^{M_{1},M_{2}}$

It is not possible to combine arbitrary monads as $M_{1}^{M_{2}^{\bullet}}$
or $M_{2}^{M_{1}^{\bullet}}$

Example: state monad $\text{St}_{S}^{A}\triangleq S\Rightarrow A\times S$
does not compose

The trick: for a fixed \textbf{base }monad $L^{\bullet}$, let $M^{\bullet}$
(\textbf{foreign }monad) vary

Call the desired result $T_{L}^{M,\bullet}$ the \textbf{monad transformer
for} $L$

In Scala: \texttt{\textcolor{blue}{\footnotesize{}MyMonadT{[}M{[}\_{]}:Monad,
A{]}}} – e.g. \texttt{\textcolor{blue}{\footnotesize{}ReaderT}}, \texttt{\textcolor{blue}{\footnotesize{}StateT}},
etc.

$T_{L}^{M,\bullet}$ is generic in $M$ but not in $L$

No general formula for monad transformers seems to exist

For each base monad $L$, a different construction is needed

Some transformers are compositions $L^{M^{\bullet}}$ or $M^{L^{\bullet}}$,
others are not

Do all monads $L$ have a transformer? (Unknown.)

{\footnotesize{}\vspace{-0.3cm}}To combine 3 or more monads, ``stack
up'' the transformers as $T_{L_{1}}^{T_{L_{2}}^{T_{L_{3}}^{M}},\bullet}$

Example in Scala: \texttt{\textcolor{blue}{\footnotesize{}StateT{[}S,
ListT{[}Reader{[}R, ?{]}, ?{]}, A{]}}} 

Substitute nested transformers into the monad argument, not as $A$

This is called a \textbf{monad stack} – but may not be \emph{functor
composition}

because e.g.~\texttt{\textcolor{blue}{\footnotesize{}State{[}S, List{[}Reader{[}R,
A{]}{]}{]}}} is not a monad


\subsection{Monad transformers II: The requirements}

{\footnotesize{}\vspace{-0.2cm}}A \textbf{monad transformer} for
a \textbf{base} monad $L^{\bullet}$ is a type constructor $T_{L}^{M,\bullet}$
parameterized by a monad $M^{\bullet}$, such that for all monads
$M^{\bullet}$:

$T_{L}^{M,\bullet}$ is a monad (the monad $M$ \textbf{transformed
with} $T_{L}$)

``Lifting'' – a monadic morphism $\text{lift}_{L}^{M}:M^{A}\leadsto T_{L}^{M,A}$

``Base lifting'' – a monadic morphism $\text{blift}:L^{A}\leadsto T_{L}^{M,A}$

The ``base lifting'' could not possibly be natural in $L^{\bullet}$

Transformed identity monad ($\text{Id}$) must become $L$, i.e.~$T_{L}^{\text{Id},\bullet}\cong L^{\bullet}$

$T_{L}^{M,\bullet}$ is \textbf{monadically natural} in $M^{\bullet}$
(but not in $L^{\bullet}$)

$T_{L}^{M,\bullet}$ is natural w.r.t.~a monadic functor $M^{\bullet}$
as a type parameter

For any monad $N^{\bullet}$ and a monadic morphism $f:M^{\bullet}\leadsto N^{\bullet}$
we need to have a monadic morphism $T_{L}^{M,\bullet}\leadsto T_{L}^{N,\bullet}$
for the transformed monads: $\text{mrun}_{L}^{M}:\left(M^{\bullet}\leadsto N^{\bullet}\right)\Rightarrow T_{L}^{M,\bullet}\leadsto T_{L}^{N,\bullet}$
with the ``lifting'' laws

If we implement $T_{L}^{M,\bullet}$ only via $M$'s monad methods,
naturality will hold 

Cf.~\texttt{\textcolor{blue}{\footnotesize{}traverse}}{\small{}$:L^{A}\Rightarrow(A\Rightarrow F^{B})\Rightarrow F^{L^{B}}$
– natural w.r.t.~applicative $F^{\bullet}$}{\small\par}

This can be used for lifting a ``runner'' $M^{A}\leadsto A$ to
$T_{L}^{M,\bullet}\leadsto T_{L}^{\text{Id},\bullet}=L^{\bullet}$

``Base runner'': lifts $L^{A}\leadsto A$ into a monadic morphism
$T_{L}^{M,\bullet}\leadsto M^{\bullet}$; so $\text{brun}_{L}^{M}:\left(L^{\bullet}\leadsto\bullet\right)\Rightarrow T_{L}^{M,\bullet}\leadsto M^{\bullet}$,
must commute with \texttt{\textcolor{blue}{\footnotesize{}lift}} and
\texttt{\textcolor{blue}{\footnotesize{}blift}} 


\subsection{Monad transformers III: First examples}

{\footnotesize{}\vspace{-0.15cm}}Recall these monad constructions:

If $M^{A}$ is a monad then $R\Rightarrow M^{A}$ is also a monad
(for a fixed type $R$)

If $M^{A}$ is a monad then $M^{Z+A\times W}$ is also a monad (for
fixed $W,$ $Z$)

This gives the monad transformers for base monads \texttt{\textcolor{blue}{\footnotesize{}Reader}},
\texttt{\textcolor{blue}{\footnotesize{}Writer}}, \texttt{\textcolor{blue}{\footnotesize{}Either}}:

\texttt{\textcolor{blue}{\footnotesize{}type ReaderT{[}R, M{[}\_{]},
A{]} = R $\Rightarrow$ M{[}A{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}type EitherT{[}Z, M{[}\_{]},
A{]} = M{[}Either{[}Z, A{]}{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}type WriterT{[}W, M{[}\_{]},
A{]} = M{[}(W, A){]}}}{\footnotesize\par}

{\footnotesize{}\vspace{-0.2cm}}\texttt{\textcolor{blue}{\footnotesize{}ReaderT}}
composes with the foreign monad from the \emph{outside}

\texttt{\textcolor{blue}{\footnotesize{}EitherT}} and \texttt{\textcolor{blue}{\footnotesize{}WriterT}}
must be composed \emph{inside} the foreign monad

{\footnotesize{}\vspace{-0.1cm}}Remaining questions:

What are transformers for other standard monads (\texttt{\textcolor{blue}{\footnotesize{}List}},
\texttt{\textcolor{blue}{\footnotesize{}State}}, \texttt{\textcolor{blue}{\footnotesize{}Cont}})?

These monads do not compose (neither ``inside'' nor ``outside''
works)!

How to derive a monad transformer for an arbitrary given monad?

For monads obtained via known monad constructions?

For monads constructed via other monad transformers? (Stack them.)

Is it always possible? (No known counterexamples.)

Is a given monad's transformer unique? (No.)

How to avoid the boilerplate around \texttt{\textcolor{blue}{\footnotesize{}lift}}?
(\texttt{\textcolor{blue}{\footnotesize{}mtl}}-style transformers)


\subsection{Monad transformers IV: The zoology of \emph{ad hoc} methods}

{\footnotesize{}\vspace{-0.2cm}}Need to choose the correct monad
transformer construction, per monad:

``Composed-inside'', base monad is inside foreign monad: $T_{L}^{M,A}=M^{L^{A}}$

Examples: the \textbf{linear} monads \texttt{\textcolor{blue}{\footnotesize{}OptionT}},
\texttt{\textcolor{blue}{\footnotesize{}WriterT}}, \texttt{\textcolor{blue}{\footnotesize{}EitherT}} 

``Composed-outside'' – the base monad is outside: $T_{L}^{M,A}=L^{M^{A}}$

Examples: \texttt{\textcolor{blue}{\footnotesize{}ReaderT}}; \texttt{\textcolor{blue}{\footnotesize{}SearchT}}
for search monad \texttt{\textcolor{blue}{\footnotesize{}S{[}A{]}
= (A $\Rightarrow$ Z) $\Rightarrow$ A}} 

More generally: all \textbf{rigid} monads have ``outside'' transformers

``Recursive'': interleaves the base monad and the foreign monad

Examples: \texttt{\textcolor{blue}{\footnotesize{}ListT}}, \texttt{\textcolor{blue}{\footnotesize{}NonEmptyListT}},
\texttt{\textcolor{blue}{\footnotesize{}FreeMonadT}} 

Monad constructions: defining a transformer for new monads

Product monads $L_{1}^{A}\times L_{2}^{A}$ – product transformer
$T_{L_{1}}^{M,A}\times T_{L_{2}}^{M,A}$

``Contrafunctor-choice'' $H^{A}\Rightarrow A$ – composed-outside
transformer

Free pointed monads $A+L^{A}$ – transformer $M^{A+T_{L}^{M,A}}$

``Irregular'': none of the above constructions work, need something
else

{\footnotesize{}$T_{\text{State}}^{M,A}=S\Rightarrow M^{S\times A}$};
{\footnotesize{}$T_{\text{Cont}}^{M,A}=\left(A\Rightarrow M^{R}\right)\Rightarrow M^{R}$};
``selector'' {\footnotesize{}$F^{A\Rightarrow P^{Q}}\Rightarrow P^{A}$}
– transformer $F^{A\Rightarrow T_{P}^{M,Q}}\Rightarrow T_{P}^{M,A}$;
codensity {\footnotesize{}$\forall R.\left(A\Rightarrow M^{R}\right)\Rightarrow M^{R}$}{\footnotesize\par}

Examples of monads $K^{A}$ for which no transformers exist? (not
known)

{\footnotesize{}\vspace{-0.4cm}}$T_{\text{Cod}}$, $T_{\text{Sel}}$,
and $T_{\text{Cont}}$ transformers have no \texttt{\textcolor{blue}{\footnotesize{}blift}},
\texttt{\textcolor{blue}{\footnotesize{}brun}}, or \texttt{\textcolor{blue}{\footnotesize{}mrun}} 

\section{Practical use}

\section{Laws and structure}

\subsection{Laws of monad transformers\label{subsec:Laws-of-monad-transformers}}

A monad transformer $T_{L}^{M,A}$ is a type constructor with a type
parameter $A$ and a monad parameter $M$, such that the following
laws hold:
\begin{enumerate}
\item \textbf{Monad construction law}: $T_{L}^{M,\bullet}$ is a lawful
monad for any monad $M$.\index{monad transformers!monad construction law}
For instance, the transformed monad $T_{L}^{M,\bullet}$ has methods
$\text{pu}_{T}$ and $\text{ftn}_{T}$ that satisfy the monad laws.
\item \textbf{Identity law}:\index{monad transformers!identity law} $T_{L}^{\text{Id},\bullet}\cong L^{\bullet}$
via a monadic isomorphism, where $\text{Id}$ is the identity monad,
$\text{Id}^{A}\triangleq A$.
\item \textbf{Lifting law}:\index{monad transformers!lifting law} For any
monad $M$, the function $\text{lift}:M^{A}\Rightarrow T_{L}^{M,A}$
is a monadic morphism. (In a shorter notation, $\text{lift}:M\leadsto T_{L}^{M}$.)
\item \textbf{Runner laws}:\index{monad transformers!runner laws} For any
monads $M$, $N$ and any monadic morphism $\phi:M\leadsto N$, the
runner $\text{mrun}\left(\phi\right):T_{L}^{M}\leadsto T_{L}^{N}$
is a monadic morphism. Moreover, the function \inputencoding{latin9}\lstinline!mrun!\inputencoding{utf8}
lifts monadic morphisms from $M\leadsto N$ to $T_{L}^{M}\leadsto T_{L}^{N}$
and must satisfy the corresponding \textbf{lifting laws\index{monad transformers!lifting laws of runner}}:
\[
\text{mrun}\left(\text{id}\right)=\text{id}\quad,\quad\quad\text{mrun}\left(\phi\right)\bef\text{mrun}\left(\chi\right)=\text{mrun}\left(\phi\bef\chi\right)\quad.
\]
It follows from the identity law $T_{L}^{\text{Id}}\cong L$ that
the base monad $L$ can be lifted into $T_{L}^{M}$: Setting $\phi=\text{pu}_{M}:\text{Id}\leadsto M$,
we obtain
\[
\text{mrun}\left(\text{pu}_{M}\right):T_{L}^{\text{Id}}\leadsto T_{L}^{M}=L\leadsto T_{L}^{M}.
\]
This function is called the \textbf{\index{monad transformers!base lifting}base
lifting}, $\text{mrun}\left(\text{pu}_{M}\right)\triangleq\text{blift}:L^{A}\Rightarrow T_{L}^{M,A}$.
The base lifting automatically satisfies the non-degeneracy law,
\[
\text{blift}\bef\text{mrun}\left(\phi^{:M\leadsto\text{Id}}\right)=\text{id}\quad,
\]
for any monadic morphism $\phi:M\leadsto\text{Id}$, because the left-hand
side equals $\text{mrun}\left(\text{pu}_{M}\bef\phi\right)$, and
the composition law for monadic morphisms gives $\text{pu}_{M}\bef\phi=\text{pu}_{\text{Id}}=\text{id}$.
\item \textbf{Base runner laws}:\index{monad transformers!base runner laws}
For any monadic morphism $\theta:L\leadsto\text{Id}$ and for any
monad $M$, the base runner $\text{brun}\left(\theta\right):T_{L}^{M}\leadsto M$
is a monadic morphism. The base runner must also satisfy the \textbf{non-degeneracy
law},\index{monad transformers!non-degeneracy law} 
\[
\text{lift}\bef\text{brun}\left(\theta\right)=\text{id}\quad.
\]
Since it is not possible to transform the base monad $L$ into an
arbitrary other monad, there are no lifting laws for \inputencoding{latin9}\lstinline!brun!\inputencoding{utf8},
unlike \inputencoding{latin9}\lstinline!mrun!\inputencoding{utf8}.
So the non-degeneracy law is not an automatic consequence of other
laws.
\end{enumerate}

\subsection{Examples of incorrect monad transformers}

The laws of monad transformers guarantee that the transformed monad
is able to represent, without loss of information, the operations
of the base monad as well as the operations of the foreign monad.
If some of these laws are omitted, we may obtain a type constructor
that does not work correctly even though it has the methods with the
required type signatures.

The simplest example of an incorrect monad transformer is obtained
by defining the transformed monad to be the unit monad, $T_{L}^{M,A}\triangleq\bbnum 1$,
for any monads $L$ and $M$. It is clear that this ``transformer''
is completely wrong: it cannot possibly keep the information about
the monads $L$ and $M$, because the methods of the unit monad discard
\emph{all} information and return $1$. However, the type constructor
$T_{L}^{M,A}$ still has all the required methods $\text{pu}_{T}$,
$\text{ftn}_{T}$, $\text{lift}_{T}$, $\text{mrun}_{T}$, and $\text{brun}_{T}$
with the required type signatures (they are constant functions returning
$1$). All these functions are automatically monadic morphisms, since
a function from any monad to the unit monad is always a monadic morphism.
So, the fake ``transformer'' satisfies almost all of the monad transformer
laws! However, the identity law $T_{L}^{\text{Id}}\cong L$ and the
non-degeneracy law $\text{lift}\bef\text{brun}\left(\theta\right)=\text{id}$
are violated since $T_{L}^{\text{Id}}=\bbnum 1\not\cong L$ and $\text{lift}\bef\text{brun}\left(\theta\right)=\left(\_\Rightarrow1\right)\neq\text{id}$.
For this reason, the unit monad is not a lawful monad transformer.

This simple example demonstrates the importance of the monad transformer
laws. A malicious programmer could give us a fake implementation of
a ``transformer'' that appears to have all the methods with the
correct type signatures but, instead of a bigger monad, constructs
a unit monad dressed up as a type constructor $T_{L}^{M,A}$. The
only way for us to detect the fraud is to find that the identity law
and the non-degeneracy law are violated.

Other examples of fake ``transformers'' violating some of the laws
are $T_{L}^{M}=L$ (no lifting law) and $T_{L}^{M}=M$ (no identity
law).

In these cases, it is intuitively clear that the fake transformer
definitions are incorrect because the information about either $L$
or $M$ is missing in $T_{L}^{M}$. A potentially working definition
of $T_{L}^{M}$ must be a type constructor whose definition somehow
combines both $L$ and $M$. Many such definitions are possible, but
few will satisfy the monad transformer laws.

\subsection{Examples of failure to define a generic monad transformer}

It appears to be impossible to define $T_{L}^{M}$ as a generic construction
that works in the same way for all monads $L$ and $M$. We will now
consider a few ways of combining the type constructors $L$ and $M$
in a way that is independent of their structure. In all these cases,
we will find that some of the monad transformer laws are violated.

General ways of combining two type constructors $L^{\bullet}$ and
$M^{\bullet}$ are functor composition $L^{M^{\bullet}}$ or $M^{L^{\bullet}}$,
disjunction $L^{\bullet}+M^{\bullet}$, and product $L^{\bullet}\times M^{\bullet}$. 

\paragraph{Functor composition}

A general way of combining two type constructors $L^{\bullet}$ and
$M^{\bullet}$ is the functor composition $L^{M^{\bullet}}$ or $M^{L^{\bullet}}$.
However, the functor composition works only for certain monads and
only in a certain order; so it cannot work as a generic monad transformer.
A simple counter-example is $L^{A}\triangleq\bbnum 1+A$ and $M^{A}\triangleq A\times A$
where $M^{L^{A}}$ is a monad but $L^{M^{A}}$ is not (see Section~???).
Another counter-example is the \inputencoding{latin9}\lstinline!State!\inputencoding{utf8}
monad, $\text{State}_{S}^{A}\triangleq S\Rightarrow S\times A$, for
which we have already shown that $\bbnum 1+\text{State}_{S}^{A}$
is not a monad and $\text{State}_{S}^{Z\Rightarrow A}$ is not a monad
(see Section~???). In other words, the \inputencoding{latin9}\lstinline!State!\inputencoding{utf8}
monad does not compose with arbitrary monads $M$ in either order.

\paragraph{Functor disjunction}

The functor disjunction $L^{\bullet}+M^{\bullet}$ is in general not
a monad when $L$ and $M$ are arbitrary monads. An immediate counter-example
is found by using two \inputencoding{latin9}\lstinline!Reader!\inputencoding{utf8}
monads, $L^{A}\triangleq R\Rightarrow A$ and $M^{A}\triangleq S\Rightarrow A$.
The disjunction $\left(R\Rightarrow A\right)+\left(S\Rightarrow A\right)$
is a functor that is not a monad (and not even applicative, see Section~???).

\paragraph{Functor product}

The functor product $L^{\bullet}\times M^{\bullet}$ is a monad for
arbitrary monads $L$ and $M$. However, there is no naturally defined
$\text{lift}:M^{\bullet}\leadsto L^{\bullet}\times M^{\bullet}$ because
we cannot create values of type $L^{A}$ out of values of type $M^{A}$
for arbitrary monads $L$ and $M$.

\paragraph{Using the free monad}

The functor composition $L^{M^{\bullet}}$ and the disjunction $L^{\bullet}+M^{\bullet}$
may not always be monads, but they are always functors. So we can
make monads out of them, by using the free monad construction. We
get $\text{Free}^{L^{M^{\bullet}}}$, the free monad over $L^{M^{\bullet}}$,
and $\text{Free}^{L^{\bullet}+M^{\bullet}}$, the free monad over
$L^{\bullet}+M^{\bullet}$. Many laws of the monad transformer are
satisfied by these constructions. However, the identity laws fail
because
\[
\text{Free}^{L^{\text{Id}^{\bullet}}}\cong\text{Free}^{L^{\bullet}}\not\cong L\quad,\quad\quad\text{Free}^{L^{\bullet}+\text{Id}^{\bullet}}\not\cong L\quad,
\]
and the lifting laws are also violated because $\text{lift}:M^{A}\Rightarrow\text{Free}^{L^{\bullet}+M^{\bullet},A}$
is not a monad morphism because it maps $\text{pu}_{M}$ into a non-pure
value of the free monad. Nevertheless, these constructions are not
useless. Once we interpret the free monad into a concrete (non-free)
monad, we could arrange to hide the violations of these laws, so that
the monad laws hold for the resulting (non-free) monad.

\paragraph{``Monoidal convolution''}

The construction called ``\textbf{monoidal convolution\index{monoidal convolution}}''
defines a new functor $L\star M$ via 
\begin{equation}
\left(L\star M\right)^{A}\triangleq\exists P\exists Q.\left(P\times Q\Rightarrow A\right)\times L^{P}\times M^{Q}\quad.\label{eq:definition-of-monoidal-convolution}
\end{equation}
This formula can be seen as a combination of the co-Yoneda identities
\[
L^{A}\cong\exists P.L^{P}\times\left(P\Rightarrow A\right)\quad,\quad\quad M^{A}\cong\exists Q.M^{Q}\times\left(Q\Rightarrow A\right)\quad.
\]
The functor product $L\times M$ is equivalent to
\begin{align}
 & L^{A}\times M^{A}\nonumber \\
{\color{greenunder}\text{co-Yoneda identities for }L^{A}\text{ and }M^{A}:}\quad & \cong\exists P.L^{P}\times\gunderline{\left(P\Rightarrow A\right)}\times\exists Q.M^{Q}\times\gunderline{\left(Q\Rightarrow A\right)}\nonumber \\
{\color{greenunder}\text{equivalence in Eq.~(\ref{eq:equivalence-pq-a-for-monoidal-convolution})}:}\quad & \cong\exists P.\exists Q.L^{P}\times M^{Q}\times\left(P+Q\Rightarrow A\right)\label{eq:product-l-m-for-monoidal-convolution}
\end{align}
where we used the type equivalence 
\begin{equation}
\left(P\Rightarrow A\right)\times\left(Q\Rightarrow A\right)\cong P+Q\Rightarrow A\quad.\label{eq:equivalence-pq-a-for-monoidal-convolution}
\end{equation}
If we (arbitrarily) replace $P+Q\Rightarrow A$ by $P\times Q\Rightarrow A$
in Eq.~(\ref{eq:product-l-m-for-monoidal-convolution}), we will
obtain Eq.~(\ref{eq:definition-of-monoidal-convolution}).

The monoidal convolution $L\star M$ always produces a functor since
Eq.~(\ref{eq:definition-of-monoidal-convolution}) is covariant in
$A$. An example where the monoidal convolution fails to produce a
monad transformer is $L^{A}\triangleq1+A$ and $M^{A}\triangleq R\Rightarrow A$.
We compute the functor $L\star M$ and establish that it is not a
monad:
\begin{align*}
 & \left(L\star M\right)^{A}\\
{\color{greenunder}\text{definitions of }L,M,\star:}\quad & =\exists P\exists Q.\gunderline{\left(P\times Q\Rightarrow A\right)}\times\left(\bbnum 1+P\right)\times\left(R\Rightarrow Q\right)\\
{\color{greenunder}\text{curry the arguments, move quantifier}:}\quad & =\exists P.\left(\bbnum 1+P\right)\times\gunderline{\exists Q.\left(Q\Rightarrow P\Rightarrow A\right)\times\left(R\Rightarrow Q\right)}\\
{\color{greenunder}\text{co-Yoneda identity with }\exists Q:}\quad & =\exists P.\left(\bbnum 1+P\right)\times\left(\gunderline{R\Rightarrow P}\Rightarrow A\right)\\
{\color{greenunder}\text{swap curried arguments}:}\quad & =\exists P.\left(\bbnum 1+P\right)\times\left(P\Rightarrow R\Rightarrow A\right)\\
{\color{greenunder}\text{co-Yoneda identity with }\exists P:}\quad & =\bbnum 1+\left(R\Rightarrow A\right)\quad.
\end{align*}
This functor is not a monad (see Section~???).

\paragraph{Codensity tricks{*}{*}{*}}
\begin{itemize}
\item codensity monad over $L^{M^{\bullet}}$: $F^{A}\triangleq\forall B.\,\big(A\Rightarrow L^{M^{B}}\big)\Rightarrow L^{M^{B}}$
– no lift 
\item Codensity-$L$ transformer: $\text{Cod}_{L}^{M,A}\triangleq\forall B.\left(A\Rightarrow L^{B}\right)\Rightarrow L^{M^{B}}$
– no lift 
\begin{itemize}
\item applies the continuation transformer to $M^{A}\cong\forall B.\left(A\Rightarrow B\right)\Rightarrow M^{B}$
\end{itemize}
\item Codensity composition: $F^{A}\triangleq\forall B.\left(M^{A}\Rightarrow L^{B}\right)\Rightarrow L^{B}$
– not a monad
\begin{itemize}
\item Counterexample: $M^{A}\triangleq R\Rightarrow A$ and $L^{A}\triangleq S\Rightarrow A$
\end{itemize}
\end{itemize}

\subsection{Properties of monadic morphisms}

A natural transformation $\phi^{A}:M^{A}\Rightarrow N^{A}$, equivalently
written as $\phi:M^{\bullet}\leadsto N^{\bullet}$, is called a \textbf{monadic
morphism}\index{monadic morphism} between monads $M$ and $N$ if
the following two laws hold:
\begin{align*}
{\color{greenunder}\text{identity law for }\phi:}\quad & \text{pu}_{M}\bef\phi=\text{pu}_{N}\quad,\\
{\color{greenunder}\text{composition law for }\phi:}\quad & \text{ftn}_{M}\bef\phi=\phi^{\uparrow M}\bef\phi\bef\text{ftn}_{N}\quad.
\end{align*}


\subsubsection{Statement \label{subsec:Statement-pure-M-is-monadic-morphism}\ref{subsec:Statement-pure-M-is-monadic-morphism}}

For any monad $M$, the method $\text{pu}_{M}:A\Rightarrow M^{A}$
is a monadic morphism $\text{pu}_{M}:\text{Id}\leadsto M$ between
the identity monad and $M$.

\subparagraph{Proof}

The identity law requires $\text{pu}_{\text{Id}}\bef\text{pu}_{M}=\text{pu}_{M}$.
This holds because $\text{pu}_{\text{Id}}=\text{id}$. The composition
law requires $\text{ftn}_{\text{Id}}\bef\text{pu}_{M}=\text{pu}_{M}^{\uparrow\text{Id}}\bef\text{pu}_{M}\bef\text{ftn}_{M}$.
Since $\text{ftn}_{\text{Id}}=\text{id}$, the left-hand side of the
composition law simplifies to $\text{pu}_{M}$. Transform the right-hand
side:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pu}_{M}:}\quad & \gunderline{\text{pu}_{M}^{\uparrow\text{Id}}}\bef\text{pu}_{M}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{lifting to the identity functor}:}\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{left identity law for }M:}\quad & =\text{pu}_{M}\quad.
\end{align*}


\subsubsection{Exercise \label{subsec:Exercise-fmap-is-not-monadic-morphism}\ref{subsec:Exercise-fmap-is-not-monadic-morphism}\index{exercises}}

Suppose $M$ is a given monad, $Z$ is a fixed type, and a fixed value
$m:M^{Z}$ is given. \textbf{(a)} Consider the function $f$ defined
as
\begin{align*}
 & f:\left(Z\Rightarrow A\right)\Rightarrow M^{A}\quad,\\
 & f\left(q^{:Z\Rightarrow A}\right)\triangleq q^{\uparrow M}m\quad.
\end{align*}
Prove that $f$ is \emph{not} a monadic morphism from the reader monad
$R^{A}\triangleq Z\Rightarrow A$ to the monad $M$, despite having
the correct type signature.

\textbf{(b)} Under the same assumptions, consider the function $\phi$
defined as
\begin{align*}
 & \phi:\left(Z\Rightarrow M^{A}\right)\Rightarrow M^{A}\quad,\\
 & \phi\left(q^{:Z\Rightarrow M^{A}}\right)\triangleq\text{flm}_{M}\left(q\right)\left(m\right)\quad.
\end{align*}
Show that $\phi$ is \emph{not} a monadic morphism from the monad
$Q^{A}\triangleq Z\Rightarrow M^{A}$ to $M$.

\subsubsection{Statement \label{subsec:Statement-monadic-morphism-composition}\ref{subsec:Statement-monadic-morphism-composition}}

If $L$, $M$, $N$ are monads and $\phi:L^{\bullet}\leadsto M^{\bullet}$
and $\chi:M^{\bullet}\leadsto N^{\bullet}$ are monadic morphisms
then the composition $\phi\bef\chi:L^{\bullet}\leadsto N^{\bullet}$
is also a monadic morphism.

\subparagraph{Proof}

The identity law for $\phi\bef\chi$ is
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pu}_{N}:}\quad & \gunderline{\text{pu}_{L}\bef(\phi}\bef\chi)\\
{\color{greenunder}\text{identity law for }\phi:}\quad & =\text{pu}_{M}\bef\chi\\
{\color{greenunder}\text{identity law for }\chi:}\quad & =\text{pu}_{N}\quad.
\end{align*}
The composition law for $\phi\bef\chi$ is
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{ftn}_{L}\bef\phi\bef\chi:}\quad & (\phi\bef\gunderline{\chi)^{\uparrow L}\bef(\phi}\bef\chi)\bef\text{ftn}_{N}\\
{\color{greenunder}\text{naturality of }\phi:}\quad & =\phi^{\uparrow L}\bef\phi\bef\gunderline{\chi^{\uparrow M}\bef\chi\bef\text{ftn}_{N}}\\
{\color{greenunder}\text{composition law for }\chi:}\quad & =\gunderline{\phi^{\uparrow L}\bef\phi\bef\text{ftn}_{M}}\bef\chi\\
{\color{greenunder}\text{composition law for }\phi:}\quad & =\text{ftn}_{L}\bef\phi\bef\chi\quad.
\end{align*}


\subsubsection{Statement \label{subsec:Statement-M-to-M-times-M-is-monadic-morphism}\ref{subsec:Statement-M-to-M-times-M-is-monadic-morphism}}

For any monad $M$, the function $\Delta:M^{A}\Rightarrow M^{A}\times M^{A}$
is a monadic morphism between monads $M$ and $M\times M$.

\subparagraph{Proof}

The methods $\text{pu}_{M\times M}$ and $\text{ftn}_{M\times M}$
are defined by
\begin{align*}
 & \text{pu}_{M\times M}(x)=\text{pu}_{M}(x)\times\text{pu}_{M}(x)=x\triangleright\text{pu}_{M}\bef\Delta\quad,\\
 & \text{ftn}_{M\times M}:M^{M^{\bullet}\times M^{\bullet}}\times M^{M^{\bullet}\times M^{\bullet}}\Rightarrow M^{\bullet}\times M^{\bullet}\\
 & =m_{1}\times m_{2}\Rightarrow(m_{1}\triangleright\nabla_{1}^{\uparrow M}\bef\text{ftn}_{M})\times(m_{2}\triangleright\nabla_{2}^{\uparrow M}\bef\text{ftn}_{M})\\
 & =\Delta\bef(\nabla_{1}\bef\nabla_{1}^{\uparrow M}\bef\text{ftn}_{M})\boxtimes(\nabla_{2}\bef\nabla_{2}^{\uparrow M}\bef\text{ftn}_{M})\\
 & =???
\end{align*}
{*}{*}{*} Do we need to use Statement~\ref{subsec:Statement-projection-is-monadic-morphism}
here? If so, prove that first.

\subsubsection{Statement \label{subsec:Statement-product-of-monadic-morphisms}\ref{subsec:Statement-product-of-monadic-morphisms}}

For any monads $K$, $L$, $M$, $N$ and monadic morphisms $\phi:K^{\bullet}\leadsto M^{\bullet}$
and $\chi:L^{\bullet}\leadsto N^{\bullet}$, the function product
$\phi\boxtimes\chi:K^{\bullet}\times L^{\bullet}\leadsto M^{\bullet}\times N^{\bullet}$
is a monadic morphism between the product monads $K\times L$ and
$M\times N$.

\subsubsection{Statement \label{subsec:Statement-projection-is-monadic-morphism}\ref{subsec:Statement-projection-is-monadic-morphism}}

For any monads $M$ and $N$, the function $\nabla_{1}:M^{\bullet}\times N^{\bullet}\leadsto M^{\bullet}$
is a monadic morphism. Same for $\nabla_{2}:M^{\bullet}\times N^{\bullet}\leadsto N^{\bullet}$.

\subsubsection{Statement \label{subsec:Statement-product-swap-is-monadic-morphism}\ref{subsec:Statement-product-swap-is-monadic-morphism}}

For any monads $M$ and $N$, the component-swapping function $\sigma:M^{\bullet}\times N^{\bullet}\leadsto N^{\bullet}\times M^{\bullet}$
is a monadic morphism.

\subparagraph{Proof}

The code for $\sigma$ can be written as a combination of other functions
as $\sigma=\Delta\bef\left(\nabla_{2}\boxtimes\nabla_{1}\right)$.
The functions $\Delta$, $\nabla_{1}$, and $\nabla_{2}$ are monadic
morphisms by Statements~\ref{subsec:Statement-M-to-M-times-M-is-monadic-morphism}
and~\ref{subsec:Statement-projection-is-monadic-morphism}. The function
product $\nabla_{1}\boxtimes\nabla_{2}$ is a monadic morphism by
Statement~\ref{subsec:Statement-product-of-monadic-morphisms}. So
$\sigma$ is a composition of monadic morphisms; by Statement~\ref{subsec:Statement-monadic-morphism-composition},
$\sigma$ is a monadic morphism.

\subsection{Functor composition with transformed monads}

Suppose we are working with a base monad $L$ and a foreign monad
$M$, and we have constructed the transformed monad $T_{L}^{M}$.
In this section, let us denote the transformed monad simply by $T$. 

A useful property of monad transformers is that the monad $T$ adequately
describes the effects of both monads $L$ and $M$ at the same time.
Suppose we are working with a deeply nested type constructor involving
many functor layers of monads $L$, $M$, and $T$ such as
\[
T^{M^{T^{L^{M^{L^{A}}}}}}\quad.
\]
The properties of the transformer allow us to convert this type to
a single layer of the transformed monad $T$. In this example, we
will have a natural transformation
\[
T^{M^{T^{L^{M^{L^{A}}}}}}\Rightarrow T^{A}\quad.
\]
To achieve this, we first use the methods $\text{blift}$ and $\text{lift}$
to convert each layer of $L$ or $M$ to a layer of $T$, lifting
into functors as necessary. The result will be a number of nested
layers of $T$. Second, we use $\text{ftn}_{T}$ as many times as
necessary to flatten all nested layers of $T$ into a single layer.
The result is a value of type $T^{A}$.

\subsection{Stacking two monads\label{subsec:Stacking-two-monads}}

Suppose we know the transformers $T_{P}$ and $T_{Q}$ for some given
monads $P$ and $Q$. We can transform $Q$ with $P$ and obtain a
monad $R^{A}\triangleq T_{P}^{Q,A}$. What would be the monad transformer
$T_{R}$ for the monad $R$?

A simple solution is to first transform the foreign monad $M$ with
$T_{Q}$, obtaining a new monad $T_{Q}^{M,\bullet}$, and then to
transform that new monad with $T_{P}$. So the formula for the transformer
$T_{R}$ is
\[
T_{R}^{M,A}=T_{P}^{T_{Q}^{M,\bullet},A}\quad.
\]
Here the monad $T_{Q}^{M,\bullet}$ was substituted into $T_{P}^{M,A}$
as the foreign monad $M$ (not as the type parameter $A$). This way
of composition is called \textbf{stacking\index{monad transformers!stacking}}
the monad transformers. 

In Scala code, this ``stacking'' composition is written as\inputencoding{latin9}
\begin{lstlisting}
type RT[M, A] = PT[QT[M, ?], A]
\end{lstlisting}
\inputencoding{utf8}The resulting monad is a \textbf{stack\index{monads!stack of}} of
three monads $P$, $Q$, and $M$. The order of monads in the stack
is significant since, in general, there will be no monadic isomorphism
between monads stacked in a different order.

We will now show that the transformer $T_{R}$ is lawful (satisfies
all five laws shown in Section~\ref{subsec:Laws-of-monad-transformers}),
as long as both $T_{P}$ and $T_{Q}$ satisfy the same five laws.
To shorten the notation, we talk about a ``monad $T_{P}^{M}$''
meaning the monad defined as $T_{P}^{M,\bullet}$ or, more verbosely,
the monad $G^{A}\triangleq T_{P}^{M,A}$.

\paragraph{Monad construction law}

We need to show that $T_{P}^{T_{Q}^{M}}$ is a monad for any monad
$M$. The monad construction law for $T_{Q}$ says that $T_{Q}^{M}$
is a monad. The monad construction law for $T_{P}$ says that $T_{P}^{S}$
is a monad for any monad $S$; in particular, for $S=T_{Q}^{M}$.
Therefore, $T_{P}^{S}=T_{P}^{T_{Q}^{M}}$ is a monad, as required.

\paragraph{Identity law}

We need to show that $T_{P}^{T_{Q}^{\text{Id}}}\cong T_{P}^{Q}$ via
a monadic isomorphism. The identity law for $T_{Q}$ says that $T_{Q}^{\text{Id}}\cong Q$
via a monadic isomorphism. So, we already have a monadic morphism
$\phi:Q\leadsto T_{Q}^{\text{Id}}$ and its inverse, $\chi:T_{Q}^{\text{Id}}\leadsto Q$.
The runner $\text{mrun}_{P}$ for $T_{P}$ can be applied to both
$\phi$ and $\chi$ since they are monadic morphisms. So we obtain
two new monadic morphisms,
\[
\text{mrun}_{P}\left(\phi\right):T_{P}^{Q}\leadsto T_{P}^{T_{Q}^{\text{Id}}}\quad;\quad\quad\text{mrun}_{P}\left(\chi\right):T_{P}^{T_{Q}^{\text{Id}}}\leadsto T_{P}^{Q}\quad.
\]
Are these two monadic morphisms inverses of each other? To show this,
we need to verify that
\[
\text{mrun}_{P}\left(\phi\right)\bef\text{mrun}_{P}\left(\chi\right)=\text{id}\quad,\quad\quad\text{mrun}_{P}\left(\chi\right)\bef\text{mrun}_{P}\left(\phi\right)=\text{id}\quad.
\]
By the runner law for $T_{P}$, we have $\text{mrun}_{P}\left(f\right)\bef\text{mrun}_{P}\left(g\right)=\text{mrun}_{P}\left(f\bef g\right)$
for any two monadic morphisms $f$ and $g$. We also have $\text{mrun}_{P}\left(\text{id}\right)=\text{id}$
by the same law. So, 
\begin{align*}
\text{mrun}_{P}\left(\phi\right)\bef\text{mrun}_{P}\left(\chi\right) & =\text{mrun}_{P}\left(\phi\bef\chi\right)=\text{mrun}_{P}\left(\text{id}\right)=\text{id}\quad,\\
\text{mrun}_{P}\left(\chi\right)\bef\text{mrun}_{P}\left(\phi\right) & =\text{mrun}_{P}\left(\chi\bef\phi\right)=\text{mrun}_{P}\left(\text{id}\right)=\text{id}\quad.
\end{align*}
We have indeed obtained a monadic isomorphism between $T_{P}^{Q}$
and $T_{P}^{T_{Q}^{\text{Id}}}$.

\paragraph{Lifting law}

We need to show that there exists a monadic morphism $M\leadsto T_{P}^{T_{Q}^{M}}$
for any monad $M$. The lifting law for $T_{Q}$ gives a monadic morphism
$\text{lift}_{Q}:M\leadsto T_{Q}^{M}$. The lifting law for $T_{P}$
can be applied to the monad $T_{Q}^{M}$, which gives a monadic morphism
\[
\text{lift}_{P}:T_{Q}^{M}\leadsto T_{P}^{T_{Q}^{M}}\quad.
\]
The composition of this with $\text{lift}_{Q}$ is a monadic morphism
of the required type $M\leadsto T_{P}^{T_{Q}^{M}}$. (A composition
of monadic morphisms is again a monadic morphism by Statement~\ref{subsec:Statement-monadic-morphism-composition}.)

\paragraph{Runner law}

We need to show that there exists a lawful lifting 
\[
\text{mrun}_{R}:\left(M\leadsto N\right)\Rightarrow T_{P}^{T_{Q}^{M}}\leadsto T_{P}^{T_{Q}^{N}}\quad.
\]
First, we have to define $\text{mrun}_{R}\phi$ for any given $\phi:M\leadsto N$.
We use the lifting law for $T_{Q}$ to get a monadic morphism
\[
\text{lift}_{Q}\phi:T_{Q}^{M}\leadsto T_{Q}^{N}\quad.
\]
Now we can apply the lifting law for $T_{P}$ to this monadic morphism
and obtain
\[
\text{lift}_{P}\left(\text{lift}_{Q}\phi\right):T_{P}^{T_{Q}^{M}}\leadsto T_{P}^{T_{Q}^{N}}\quad.
\]
This function has the correct type signature. So we can define
\[
\text{lift}_{R}\triangleq\text{lift}_{Q}\bef\text{lift}_{P}=\text{lift}_{P}\circ\text{lift}_{Q}\quad.
\]
It remains to prove that $\text{lift}_{R}$ is a lawful lifting. We
use the fact that both $\text{lift}_{P}$ and $\text{lift}_{Q}$ are
lawful liftings; we need to show that their composition is also a
lawful lifting. To verify the identity law of lifting, apply $\text{lift}_{R}$
to an identity function $\text{id}:M\leadsto M$,
\begin{align*}
 & \text{lift}_{R}\left(\text{id}^{:M\leadsto M}\right)=\text{lift}_{P}\gunderline{\left(\text{lift}_{Q}\text{id}^{:M\leadsto M}\right)}\\
{\color{greenunder}\text{identity law for }\text{lift}_{Q}:}\quad & =\text{lift}_{P}\big(\text{id}^{:T_{Q}^{M}\leadsto T_{Q}^{M}}\big)\\
{\color{greenunder}\text{identity law for }\text{lift}_{P}:}\quad & =\text{id}\quad.
\end{align*}
To verify the composition law of lifting, apply $\text{lift}_{R}$
to a composition of two monadic morphisms $\phi:L\leadsto M$ and
$\chi:M\leadsto N$,
\begin{align*}
\text{lift}_{R}\left(\phi\bef\chi\right) & =\text{lift}_{P}\gunderline{\left(\text{lift}_{Q}\left(\phi\bef\chi\right)\right)}\\
{\color{greenunder}\text{composition law for }\text{lift}_{Q}:}\quad & =\gunderline{\text{lift}_{P}}\left(\text{lift}_{Q}\phi\bef\text{lift}_{Q}\chi\right)\\
{\color{greenunder}\text{composition law for }\text{lift}_{P}:}\quad & =\gunderline{\text{lift}_{P}\left(\text{lift}_{Q}\phi\right)}\bef\gunderline{\text{lift}_{P}\left(\text{lift}_{Q}\phi\right)}\\
{\color{greenunder}\text{definition of }\text{lift}_{R}:}\quad & =\text{lift}_{R}\phi\bef\text{lift}_{R}\chi\quad.
\end{align*}


\paragraph{Base runner law}

We need to show that for any monadic morphism $\theta:T_{P}^{Q}\leadsto\text{Id}$
and for any monad $M$, there exists a monadic morphism $\text{brun}_{R}\theta:T_{P}^{T_{Q}^{M}}\leadsto M$.
To define this morphism for a given $\theta$, we clearly need to
use the base runners for $T_{P}$ and $T_{Q}$. The base runner for
$T_{Q}$ has the type signature
\[
\text{brun}_{Q}:\left(Q\leadsto\text{Id}\right)\Rightarrow T_{Q}^{M}\leadsto M\quad.
\]
We can apply the base runner for $T_{P}$ to $T_{Q}^{M}$ as the foreign
monad,
\[
\text{brun}_{P}:\left(P\leadsto\text{Id}\right)\Rightarrow T_{P}^{T_{Q}^{M}}\leadsto T_{Q}^{M}\quad.
\]
It is now clear that we could obtain a monadic morphism $T_{P}^{T_{Q}^{M}}\leadsto M$
if we had some monadic morphisms $\phi:P\leadsto\text{Id}$ and $\chi:Q\leadsto\text{Id}$,
\[
\text{brun}_{P}\phi\bef\text{brun}_{Q}\chi:T_{P}^{T_{Q}^{M}}\leadsto M\quad.
\]
However, we are only given a single monadic morphism $\theta:T_{P}^{Q}\leadsto\text{Id}$.
How can we compute $\phi$ and $\chi$ out of $\theta$? We can use
the liftings $\text{blift}_{P}:P\leadsto T_{P}^{Q}$ and $\text{lift}_{P}:Q\leadsto T_{P}^{Q}$,
which are both monadic morphisms, and compose them with $\theta$:
\[
\left(\text{blift}_{P}\bef\theta\right):P\leadsto\text{Id}\quad;\quad\quad\left(\text{lift}_{P}\bef\theta\right):Q\leadsto\text{Id}\quad.
\]
So we can define the monadic morphism $\text{brun}_{R}\theta$ as
\begin{align*}
\text{brun}_{R}\theta & :T_{P}^{T_{Q}^{M}}\leadsto M\quad,\\
\text{brun}_{R}\theta & \triangleq\text{brun}_{P}\left(\text{blift}_{P}\bef\theta\right)\bef\text{brun}_{Q}\left(\text{lift}_{P}\bef\theta\right)\quad.
\end{align*}
Since we have defined $\text{brun}_{R}\theta$ as a composition of
monadic morphisms, $\text{brun}_{R}\theta$ is a monadic morphism
by Statement~\ref{subsec:Statement-monadic-morphism-composition}.

To verify the non-degeneracy law of the base runner, $\text{lift}_{R}\bef\text{brun}_{R}\theta=\text{id}$,
we need to use the non-degeneracy laws for the base runners of $T_{P}$
and $T_{Q}$, which are 
\[
\text{lift}_{P}\bef\text{brun}_{P}\chi^{:P\leadsto\text{Id}}=\text{id}\quad,\quad\quad\text{lift}_{Q}\bef\text{brun}_{Q}\psi^{:Q\leadsto\text{Id}}=\text{id}\quad.
\]
Then we can write
\begin{align*}
 & \gunderline{\text{lift}_{R}}\bef\gunderline{\text{brun}_{R}\theta}\\
{\color{greenunder}\text{expand definitions}:}\quad & =\text{lift}_{Q}\bef\gunderline{\text{lift}_{P}\bef\text{brun}_{P}\left(\text{blift}_{P}\bef\theta\right)}\bef\text{brun}_{Q}\left(\text{lift}_{P}\bef\theta\right)\\
{\color{greenunder}\text{non-degeneracy for }\text{brun}_{P}:}\quad & =\gunderline{\text{lift}_{Q}\bef\text{brun}_{Q}\left(\text{lift}_{P}\bef\theta\right)}\\
{\color{greenunder}\text{non-degeneracy for }\text{brun}_{Q}:}\quad & =\text{id}\quad.
\end{align*}


\subsection{Stacking any number of monads\label{subsec:Stacking-any-number-of-monads}}

The monad transformer for $T_{P}^{Q}$ can be applied to another monad
$K$; the result is the transformed monad
\[
S^{A}\triangleq T_{P}^{T_{Q}^{K},A}.
\]
What is the monad transformer for the monad $S$? Assuming that we
know the monad transformer $T_{K}$, we could stack the transformers
one level higher:
\[
T_{S}^{M,A}\triangleq T_{P}^{T_{Q}^{T_{K}^{M}},A}\quad.
\]
This looks like a stack of four monads $P$, $Q$, $K$, and $M$.
Note that the type parameter $A$ is used as $T_{P}^{(...),A}$, that
is, it belongs to the \emph{outer} transformer $T_{P}$.

We can now define a transformer stack for any number of monads $P$,
$Q$, ..., $Z$ in a similar way,
\begin{equation}
T_{S}^{M,A}\triangleq T_{P}^{T_{Q}^{\iddots^{T_{Z}^{M}}},A}\quad.\label{eq:general-transformer-stack}
\end{equation}
The type parameter $A$ will always remain at the outer transformer
level, while the foreign monad $M$ will be in the innermost nested
position.

It turns out that $T_{S}$ is a lawful monad transformer for \emph{any}
number of stacked monads. We can prove this by induction on the number
of monads. In the previous section, we have derived the transformer
laws for any \emph{three} stacked monads (two monads $P$, $Q$ within
the transformer and one foreign monad $M$). Now we need to derive
the same laws for a general transformer stack, such as that in Eq.~(\ref{eq:general-transformer-stack}).
Let us temporarily denote by $J$ the monad 
\[
J\triangleq T_{Q}^{\iddots^{T_{Z}^{\text{Id}}}}\quad,
\]
where we used the identity monad $\text{Id}$ in the place normally
taken by a foreign monad $M$. The monad $J$ is a shorter transformer
stack than $S$, so the inductive assumption tells us that the transformer
laws already hold for the transformer $T_{J}$ defined as
\[
T_{J}^{M}\triangleq T_{Q}^{\iddots^{T_{Z}^{M}}}\quad.
\]
Since both $T_{P}$ and $T_{J}$ are lawful transformers, their stacking
composition $T_{P}^{T_{J}^{M}}$ is also a lawful transformer (this
was shown in the Section~\ref{subsec:Stacking-two-monads}). In our
notation, $T_{S}^{M,A}=T_{P}^{T_{J}^{M},A}$, and so we have shown
that $T_{S}^{M,A}$ is a lawful transformer.

\section{Monad transformers via functor composition: General properties\label{sec:Monad-transformers-that-use-composition}}

We have seen examples of monad transformers that work via functor
composition, either as composed-inside or as composed-outside. The
simplest examples are the \inputencoding{latin9}\lstinline!OptionT!\inputencoding{utf8}
transformer,
\[
L^{A}\triangleq\bbnum 1+A,\quad\quad T_{L}^{M,A}\triangleq M^{L^{A}}=M^{\bbnum 1+A}\quad,
\]
which puts the base monad $L$ \emph{inside} the monad $M$, and the
\inputencoding{latin9}\lstinline!ReaderT!\inputencoding{utf8} transformer,
\[
L^{A}\triangleq R\Rightarrow A,\quad\quad T_{L}^{M,A}\triangleq L^{M^{A}}=R\Rightarrow M^{A}\quad,
\]
which puts the base monad $L$ \emph{outside} the foreign monad $M$. 

We can prove many properties of both kinds of monad transformers via
a single derivation if we temporarily drop the distinction between
the base monad and the foreign monad. We simply assume that two different
monads, $L$ and $M$, have a functor composition $T^{\bullet}\triangleq L^{M^{\bullet}}$
that also happens to be a monad. Since the assumptions on the monads
$L$ and $M$ are the same, the resulting properties of the composed
monad $T$ will apply equally to both kinds of monad transformers.

To interpret the results, we will assume that $L$ is the base monad
for the composed-outside transformers, and that $M$ is the base monad
for the composed-inside transformers. For instance, we will be able
to prove the laws of liftings $L\leadsto T$ and $M\leadsto T$ regardless
of the choice of the base monad.

What properties of monad transformers will \emph{not} be derivable
in this way? Monad transformers depend on the structure on the base
monad, but not on the structure of the foreign monad; the transformer's
methods \inputencoding{latin9}\lstinline!pure!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
are generic in the foreign monad. This is expressed via the monad
transformer laws for the runners \inputencoding{latin9}\lstinline!mrun!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!brun!\inputencoding{utf8}, which
we will need to derive separately for each of the two kinds of transformers.

\subsection{Motivation for the \texttt{swap} function}

The first task is to show that the composed monad $T^{\bullet}\triangleq L^{M^{\bullet}}$
obeys the monad laws. For this, we need to define the methods for
the monad $T$, namely \inputencoding{latin9}\lstinline!pure!\inputencoding{utf8}
(short notation ``$\text{pu}_{T}$'') and \texttt{}\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
(short notation ``$\text{ftn}_{T}$''), with the type signatures
\[
\text{pu}_{T}:A\Rightarrow L^{M^{A}}\quad,\quad\text{ftn}_{T}:L^{M^{L^{M^{A}}}}\Rightarrow L^{M^{A}}\quad.
\]
How can we implement these methods? \emph{All we know} about $L$
and $M$ is that they are monads with their own methods $\text{pu}_{L}$,
$\text{ftn}_{L}$, $\text{pu}_{M}$, and $\text{ftn}_{M}$. We can
easily implement 
\begin{equation}
\text{pu}_{T}\triangleq\text{pu}_{M}\bef\text{pu}_{L}\quad.\label{eq:def-of-pure-T}
\end{equation}
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}A\ar[r]\sp(0.5){\text{pu}_{M}}\ar[rd]\sb(0.45){\text{pu}_{T}\triangleq} & M^{A}\ar[d]\sp(0.45){\text{pu}_{L}}\\
 & L^{M^{A}}
}
\]
It remains to implement $\text{ftn}_{T}$. In the type $L^{M^{L^{M^{A}}}}$,
we have two layers of the functor $L$ and two layers of the functor
$M$. We could use the available method $\text{ftn}_{L}$ to flatten
the two layers of $L$ if we could \emph{somehow} bring these nested
layers together. However, these layers are separated by a layer of
the functor $M$. To show this layered structure in a more visual
way, let us employ another notation for the functor composition, 
\[
L\circ M\triangleq L^{M^{\bullet}}\quad.
\]
In this notation, the type signature for \texttt{}\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
is written as
\[
\text{ftn}_{T}:L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]
If we had $L\circ L\circ M\circ M$ here, we would have applied $\text{ftn}_{L}$
and flattened the two layers of the functor $L$. Then we would have
flattened the remaining two layers of the functor $M$. How can we
achieve this? The trick is to \emph{assume} that we have a function
called \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
(short notation ``$\text{sw}$''), which can interchange the order
of the layers. The type signature of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
is
\[
\text{sw}:M\circ L\leadsto L\circ M\quad,
\]
which is equivalently written in a more verbose notation as
\[
\text{sw}:M^{L^{A}}\Rightarrow L^{M^{A}}\quad.
\]
If this operation were \emph{somehow} defined for the two monads $L$
and $M$, we could implement $\text{ftn}_{T}$ by first swapping the
order of the inner layers $M$ and $L$ as 
\[
L\circ M\circ L\circ M\leadsto L\circ L\circ M\circ M
\]
and then applying the \texttt{}\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
methods of the monads $L$ and $M$. The resulting code for the function
$\text{ftn}_{T}$ and the corresponding type diagram are
\begin{equation}
\text{ftn}_{T}\triangleq\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:define-flatten-via-swap}
\end{equation}
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}L^{M^{L^{M^{A}}}}\ar[r]\sp(0.5){\text{sw}^{\uparrow L}}\ar[rrd]\sb(0.5){\text{ftn}_{T}\triangleq} & L^{L^{M^{M^{A}}}}\ar[r]\sp(0.5){\text{ftn}_{L}} & L^{M^{M^{A}}}\ar[d]\sp(0.5){\text{ftn}_{M}^{\uparrow L}}\\
 &  & L^{M^{A}}
}
\]

It turns out that in \emph{both} cases (the composed-inside and the
composed-outside transformers), the new monad's \texttt{}\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
method can be defined through the \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
operation. For the two kinds of transformers, the type signatures
of these functions are
\begin{align*}
\text{composed-inside}:\quad\text{ftn}_{T}:M^{L^{M^{L^{A}}}}\Rightarrow M^{L^{A}}\quad, & \quad\text{sw}:L^{M^{A}}\Rightarrow M^{L^{A}}\quad,\\
\text{composed-outside}:\quad\text{ftn}_{T}:L^{M^{L^{M^{A}}}}\Rightarrow L^{M^{A}}\quad, & \quad\text{sw}:M^{L^{A}}\Rightarrow L^{M^{A}}\quad.
\end{align*}


\subsubsection{The difference between the operations \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!sequence!\inputencoding{utf8}}

There is a certain similarity between the \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
operation introduced here and the \inputencoding{latin9}\lstinline!sequence!\inputencoding{utf8}
operation introduced in Chapter~\ref{chap:9-Traversable-functors-and}
for traversable functors. Indeed, the type signature of the sequence
operation is 
\[
\text{seq}:L^{F^{A}}\Rightarrow F^{L^{A}}\quad,
\]
where $F$ is an arbitrary applicative functor (which could be $M$,
since monads are applicative functors) and $L$ is a traversable functor.
However, the similarity stops here. The laws required for the \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
operation to yield a monad $T$ are different from the laws of traversable
functors. In particular, if we wish $M^{L^{\bullet}}$ to be a monad,
it is insufficient to require the monad $L$ to be a traversable functor.
A simple counterexample is found with $L^{A}\triangleq A\times A$
and $M^{A}\triangleq1+A$. Both $L$ and $M$ are traversable (since
they are polynomial functors); but their composition $Q^{A}\triangleq1+A\times A$
is not a monad.

Another difference between \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!sequence!\inputencoding{utf8}
is that the \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
operation needs to be generic in the foreign monad, which may be either
$L$ or $M$ according to the type of the monad transformer; whereas
\inputencoding{latin9}\lstinline!sequence!\inputencoding{utf8} is
always generic in the applicative functor $F$. %
\begin{comment}
\emph{This is actually confusing! Let's not do this and always write
$\text{sw}_{L}^{M}:M^{L^{A}}\Rightarrow L^{M^{A}}$}

To denote more clearly the monad with respect to which \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
is generic, we may write
\begin{align*}
\text{sw}_{L}^{M}:L^{M^{A}}\Rightarrow M^{L^{A}}\quad & \text{for the composed-inside transformers,}\\
\text{sw}_{L}^{M}:M^{L^{A}}\Rightarrow L^{M^{A}}\quad & \text{for the composed-outside transformers.}
\end{align*}
The superscript $M$ in $\text{sw}_{L}^{M}$ shows that $M$ is a
\emph{type parameter} in \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8};
that is, \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
is generic in the monad $M$. The subscript $L$ in $\text{sw}_{L}^{M}$
shows that the implementations of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
may need to use completely different code for different monads $L$.
\end{comment}

To avoid confusion, I use the name ``swap'' rather than ``sequence''
for the function $\text{sw}_{L,M}:M^{L^{\bullet}}\leadsto L^{M^{\bullet}}$
in the context of monad transformers. Let us now find out what laws
are required for the \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
operation.\footnote{The \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8} operation
was used in a \href{http://web.cecs.pdx.edu/~mpj/pubs/composing.html}{1993 paper}
``Composing monads'' by M.~P.~Jones and L.~Duponcheel. They studied
various ways of composing monads and also gave some arguments to show
that no generic transformer could compose all monads $L$, $M$. The
impossibility of a generic monad composition is demonstrated by the
\inputencoding{latin9}\lstinline!State!\inputencoding{utf8} monad
that, as I show in this chapter, does not compose with arbitrary other
monads $M$ – either from inside or from outside.}

\subsection{Deriving the necessary laws for \texttt{swap}}

The first law is that \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
must be a natural transformation. Since \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
has only one type parameter, there is one naturality law: for any
function $f:A\Rightarrow B$, 
\begin{equation}
f^{\uparrow L\uparrow M}\bef\text{sw}=\text{sw}\bef f^{\uparrow M\uparrow L}\quad.\label{eq:swap-law-0-naturality}
\end{equation}
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}M^{L^{A}}\ar[r]\sp(0.5){f^{\uparrow L\uparrow M}}\ar[d]\sb(0.45){\text{sw}} & M^{L^{B}}\ar[d]\sp(0.45){\text{sw}}\\
L^{M^{A}}\ar[r]\sp(0.5){f^{\uparrow M\uparrow L}} & L^{M^{B}}
}
\]

To derive further laws for \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8},
consider the requirement that the transformed monad $T$ should satisfy
the monad laws:
\begin{align*}
\text{pu}_{T}\bef\text{ftn}_{T}=\text{id}\quad, & \quad\quad\text{pu}_{T}^{\uparrow T}\bef\text{ftn}_{T}=\text{id}\quad,\\
\text{ftn}_{T}^{\uparrow T}\bef\text{ftn}_{T} & =\text{ftn}_{T}\bef\text{ftn}_{T}\quad.
\end{align*}
Additionally, $T$ must satisfy the laws of a monad transformer. We
will now discover the laws for \texttt{swap} that make the laws for
$\text{ftn}_{T}$ hold automatically, as long as $\text{ftn}_{T}$
is derived from \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
using Eq.~(\ref{eq:define-flatten-via-swap}).

We substitute Eq.~(\ref{eq:define-flatten-via-swap}) into the left
identity law for $\text{ftn}_{T}$ and simplify:
\begin{align}
\text{id} & =\text{pu}_{T}\bef\gunderline{\text{ftn}_{T}}\nonumber \\
{\color{greenunder}\text{replace }\text{ftn}_{T}\text{ using Eq.~(\ref{eq:define-flatten-via-swap})}:}\quad & =\text{pu}_{T}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
{\color{greenunder}\text{replace }\text{pu}_{T}\text{ using Eq.~(\ref{eq:def-of-pure-T})}:}\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
{\color{greenunder}\text{naturality of }\text{pu}_{L}:}\quad & =\text{pu}_{M}\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
{\color{greenunder}\text{left identity law for }L:}\quad & =\text{pu}_{M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:left-identity-ftn-T}
\end{align}
How could the last expression in Eq.~(\ref{eq:left-identity-ftn-T})
be equal to $\text{id}$? We know nothing about the \texttt{}\inputencoding{latin9}\lstinline!pure!\inputencoding{utf8}
and \texttt{}\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
methods of the monads $L$ and $M$, except that these methods satisfy
their monad laws. We could satisfy the law in Eq.~(\ref{eq:left-identity-ftn-T})
if we somehow reduce that expression to
\[
\text{pu}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}=\left(\text{pu}_{M}\bef\text{ftn}_{M}\right)^{\uparrow L}=\text{id}\quad.
\]
This will be possible only if we are able to interchange the order
of function compositions with $\text{sw}$ and eliminate \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
from the expression. So, we must require the ``outer-identity law''
for \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8},
\begin{equation}
\text{pu}_{M}\bef\text{sw}=\text{pu}_{M}^{\uparrow L}\quad.\label{eq:swap-law-1-M-identity}
\end{equation}
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{3pc}L^{A}\ar[r]\sp(0.5){\text{pu}_{M}}\ar[rd]\sb(0.4){\text{pu}_{M}^{\uparrow L}} & M^{L^{A}}\ar[d]\sp(0.4){\text{sw}}\\
 & L^{M^{A}}
}
\]
Intuitively, this law says that a pure layer of the monad $M$ remains
pure after interchanging the order of layers with \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}.

With this law, we can finish the derivation in Eq.~(\ref{eq:left-identity-ftn-T})
as
\begin{align*}
 & \text{pu}_{M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{outer-identity law for }\text{sw}:}\quad & =\text{pu}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{functor composition law for }L:}\quad & =\left(\text{pu}_{M}\bef\text{ftn}_{M}\right)^{\uparrow L}\\
{\color{greenunder}\text{left identity law for }M:}\quad & =\text{id}^{\uparrow L}\\
{\color{greenunder}\text{functor identity law for }L:}\quad & =\text{id}\quad.
\end{align*}
So, the $M$-identity law for \texttt{swap} entails the left identity
law for $T$.

In the same way, we motivate the ``inner-identity'' law for \texttt{swap},
\begin{equation}
\text{pu}_{L}^{\uparrow M}\bef\text{sw}=\text{pu}_{L}\quad.\label{eq:swap-law-2-L-identity}
\end{equation}
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{3pc}M^{A}\ar[r]\sp(0.5){\text{pu}_{L}^{\uparrow M}}\ar[rd]\sb(0.45){\text{pu}_{L}} & M^{L^{A}}\ar[d]\sp(0.4){\text{sw}}\\
 & L^{M^{A}}
}
\]
This law expresses the idea that a pure layer of the functor $L$
remains pure after swapping the order of layers.

Assuming this law, we can derive the right identity law for $T$:
\begin{align*}
 & \text{pu}_{T}^{\uparrow T}\bef\text{ftn}_{T}\\
{\color{greenunder}\left(\text{by definition, }f^{\uparrow T}\triangleq f^{\uparrow M\uparrow L}\right):}\quad & =\left(\text{pu}_{T}\right)^{\uparrow M\uparrow L}\bef\text{ftn}_{T}\\
{\color{greenunder}\text{definitions of }\text{pu}_{T}\text{ and }\text{ftn}_{T}:}\quad & =\text{pu}_{M}^{\uparrow M\uparrow L}\bef\gunderline{\text{pu}_{L}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{inner-identity law for }\text{sw},\text{ under }^{\uparrow L}:}\quad & =\text{pu}_{M}^{\uparrow M\uparrow L}\bef\gunderline{\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{right identity law for }L:}\quad & =\text{pu}_{M}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}=\gunderline{\left(\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}\right)}^{\uparrow L}\\
{\color{greenunder}\text{right identity law for }M:}\quad & =\text{id}^{\uparrow L}=\text{id}\quad.
\end{align*}

Deriving the monad associativity law for $T$,
\[
\text{ftn}_{T}^{\uparrow T}\bef\text{ftn}_{T}=\text{ftn}_{T}\bef\text{ftn}_{T}\quad,
\]
turns out to require \emph{two} further laws for \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}.
Let us see why.

Substituting the definition of $\text{ftn}_{T}$ into the associativity
law, we get
\begin{align}
 & \left(\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\right)^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
 & \quad=\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:t-assoc-law-expanded}
\end{align}
The only hope of proving this law is being able to interchange $\text{ftn}_{L}$
as well as $\text{ftn}_{M}$ with $\text{sw}$. In other words, the
\texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function should be in some way adapted to the \texttt{}\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
methods of both monads $L$ and $M$.

Let us look for such interchange laws. One possibility is to have
a law involving $\text{ftn}_{M}\bef\text{sw}$, which is a function
of type $M^{M^{L^{A}}}\Rightarrow L^{M^{A}}$ or, in another notation,
$M\circ M\circ L\leadsto L\circ M$. This function first flattens
the two adjacent layers of $M$, obtaining $M\circ L$, and then swaps
the two remaining layers, moving the $L$ layer outside. Let us think
about what law could exist for this kind of transformation. It is
plausible that we may obtain the same result if we first swap the
layers twice, so that the $L$ layer moves to the outside, obtaining
$L\circ M\circ M$, and then flatten the two inner $M$ layers. Writing
this assumption in code, we obtain the ``outer-interchange'' law
\begin{equation}
\text{ftn}_{M}\bef\text{sw}=\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:swap-law-3-M-interchange}
\end{equation}
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{3pc} & M^{M^{L^{A}}}\ar[r]\sp(0.5){\text{ftn}_{M}}\ar[ld]\sb(0.45){\text{sw}^{\uparrow M}} & M^{L^{A}}\ar[d]\sp(0.4){\text{sw}}\\
M^{L^{M^{A}}}\ar[r]\sb(0.5){\text{sw}} & L^{M^{M^{A}}}\ar[r]\sb(0.5){\text{ftn}_{M}^{\uparrow L}} & L^{M^{A}}
}
\]

The analogous ``inner-interchange'' law involving two layers of
$L$ and a transformation $M\circ L\circ L\leadsto L\circ M$ is written
as
\begin{equation}
\text{ftn}_{L}^{\uparrow M}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\quad.\label{eq:swap-law-4-L-interchange}
\end{equation}
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{3pc} & M^{L^{L^{A}}}\ar[r]\sp(0.5){\text{ftn}_{L}^{\uparrow M}}\ar[ld]\sb(0.45){\text{sw}} & M^{L^{A}}\ar[d]\sp(0.4){\text{sw}}\\
L^{M^{L^{A}}}\ar[r]\sb(0.5){\text{sw}^{\uparrow L}} & L^{L^{M^{A}}}\ar[r]\sb(0.5){\text{ftn}_{L}} & L^{M^{A}}
}
\]

At this point, we have simply written down these two interchange laws,
hoping that they will help us derive the associativity law for $T$.
We will now verify that this is indeed so.

Both sides of the law in Eq.~(\ref{eq:t-assoc-law-expanded}) involve
compositions of several \inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}s
and \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}s.
The heuristic idea of the proof is to use various laws to move all
\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}s to
right of the composition, while moving all \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}s
to the left. In this way we will transform both sides of Eq.~(\ref{eq:t-assoc-law-expanded})
into a similar form, hoping to prove that they are equal.

We begin with the right-hand side of Eq.~(\ref{eq:t-assoc-law-expanded})
since it is simpler than the left-hand side, and look for ways of
using the interchange laws. At every step of the calculation, there
happens to be only one place where some law can be applied:
\begin{align*}
 & \text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{composition for }L:}\quad & =\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\left(\text{ftn}_{M}\bef\text{sw}\right)}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{outer-interchange for }\text{sw}:}\quad & =\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\left(\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}\right)}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{composition for }L:}\quad & =\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{sw}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\gunderline{\text{ftn}_{M}^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{ftn}_{L}:}\quad & =\text{sw}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef\left(\text{sw}^{\uparrow M}\bef\text{sw}\right)^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{ftn}_{L}:}\quad & =\text{sw}^{\uparrow L}\bef\gunderline{\left(\text{sw}^{\uparrow M}\bef\text{sw}\right)^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\end{align*}
Now all \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}s
are on the left and all \inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}s
on the right of the expression.

Transform the right-hand side of Eq.~(\ref{eq:t-assoc-law-expanded})
in the same way as
\begin{align*}
 & \left(\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}}\right)^{\uparrow M\uparrow L}\gunderline{\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{functor composition}:}\quad & =\left(\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\right)^{\uparrow M\uparrow L}\bef\gunderline{\left(\text{ftn}_{M}^{\uparrow L\uparrow M}\bef\text{sw}\right)}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{sw}:}\quad & =\left(\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\right)^{\uparrow M\uparrow L}\bef\big(\text{sw}\bef\gunderline{\text{ftn}_{M}^{\uparrow M\uparrow L}}\big)^{\uparrow L}\gunderline{\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{ftn}_{L}:}\quad & =\text{sw}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{L}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}}\\
{\color{greenunder}\text{associativity of }\text{ftn}_{M}:}\quad & =\text{sw}^{\uparrow L\uparrow M\uparrow L}\bef\gunderline{\left(\text{ftn}_{L}^{\uparrow M}\bef\text{sw}\right)}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{inner-interchange for }\text{sw}:}\quad & =\text{sw}^{\uparrow L\uparrow M\uparrow L}\bef\big(\text{sw}\bef\text{sw}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}}\big)^{\uparrow L}\gunderline{\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{associativity of }\text{ftn}_{L}:}\quad & =\big(\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}\bef\text{sw}^{\uparrow L}\big)^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\end{align*}
We have again managed to move all \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}s
to the left and all \inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}s
to the right of the expression. 

Comparing now the two sides of the associativity law, we see that
all the \inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}s
occur in the same combination: $\text{ftn}_{L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}$.
It remains to show that 
\[
\text{sw}^{\uparrow L}\bef\left(\text{sw}^{\uparrow M}\bef\text{sw}\right)^{\uparrow L\uparrow L}=\big(\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}\bef\text{sw}^{\uparrow L}\big)^{\uparrow L}\quad.
\]
or equivalently
\[
\left(\text{sw}\bef\text{sw}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}\right)^{\uparrow L}=\big(\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}\bef\text{sw}^{\uparrow L}\big)^{\uparrow L}\quad.
\]
The two sides are equal due to the naturality law of \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8},
\[
\text{sw}\bef\text{sw}^{\uparrow M\uparrow L}=\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}.
\]
This completes the proof of the following theorem:

\subsubsection{Theorem \label{sec:Theorem-swap-laws-to-monad-transformer-first-law}\ref{sec:Theorem-swap-laws-to-monad-transformer-first-law}}

If two monads $L$ and $M$ are such that there exists a function
\[
\text{sw}_{L,M}:M^{L^{A}}\Rightarrow L^{M^{A}}
\]
(called ``\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}''),
which is a natural transformation satisfying four additional laws:
\begin{align*}
{\color{greenunder}\text{outer-identity}:}\quad & \text{pu}_{L}^{\uparrow M}\bef\text{sw}_{L,M}=\text{pu}_{L}\quad,\\
{\color{greenunder}\text{inner-identity}:}\quad & \text{pu}_{M}\bef\text{sw}_{L,M}=\text{pu}_{M}^{\uparrow L}\quad,\\
{\color{greenunder}\text{outer-interchange}:}\quad & \text{ftn}_{L}^{\uparrow M}\bef\text{sw}_{L,M}=\text{sw}_{L,M}\bef\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\quad,\\
{\color{greenunder}\text{inner-interchange}:}\quad & \text{ftn}_{M}\bef\text{sw}_{L,M}=\text{sw}_{L,M}^{\uparrow M}\bef\text{sw}_{L,M}\bef\text{ftn}_{M}^{\uparrow L}\quad,
\end{align*}
then the functor composition
\[
T^{A}\triangleq L^{M^{A}}
\]
is a monad with the methods \inputencoding{latin9}\lstinline!pure!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
defined by
\begin{align}
\text{pu}_{T} & \triangleq\text{pu}_{M}\bef\text{pu}_{L}\quad,\label{eq:def-pure-T-via-pure-L-and-pure-M}\\
\text{ftn}_{T} & \triangleq\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:def-flatten-T-via-sw-and-flatten-L-M}
\end{align}


\subsection{Intuition behind the laws of \texttt{swap}}

The interchange laws for \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
guarantee that any functor composition built up from $L$ and $M$,
e.g.~like this,
\[
M\circ M\circ L\circ M\circ L\circ L\circ M\circ M\circ L\quad,
\]
can be simplified to a value of type $T^{A}=L^{M^{A}}$ by flattening
the layers using $\text{ftn}_{L}$, $\text{ftn}_{M}$, or $\text{ftn}_{T}$,
or by interchanging the layers with \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}.
We may apply flattening or interchange in any order, and we will always
get the same final value of type $T^{A}$.

In other words, the monadic effects of the monads $L$ and $M$ can
be arbitrarily interleaved, swapped, and flattened in any order, with
no change to the final results. The programmer is free to refactor
a monadic program, say, by first computing some $L$-effects in a
separate functor block of $L$-\inputencoding{latin9}\lstinline!flatMap!\inputencoding{utf8}s
and only then combining the result with the rest of the computation
in the monad $T$. Regardless of the refactoring, the monad $T$ computes
all the effects correctly. This is what programmers would expect of
the monad $T$, if it is to be regarded as a useful monad transformer.

We will now derive the properties of the monad $T$ that follow from
the interchange laws. We will find that it is easier to formulate
these laws in terms of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
than in terms of $\text{ftn}_{T}$. In practice, all known examples
of compositional monad transformers (the ``linear'' and the ``rigid''
monads) are defined via \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}.

\subsection{Deriving \texttt{swap} from \texttt{flatten\label{subsec:Deriving-swap-from-flatten}}}

We have shown that the \texttt{}\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
method of the monad $T^{\bullet}=L^{M^{\bullet}}$ can be defined
via the \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
method. However, we have seen examples of some composable monads (such
as \texttt{}\inputencoding{latin9}\lstinline!Reader!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8})
where we already know the definitions of the \texttt{}\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
method for the composed monad $T$. Does a suitable \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function exist for these examples? In other words, if a \texttt{}\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
function for the monad $T=L\circ M$ is already known, can we establish
whether a \texttt{}\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function exists such that the\emph{ given} \texttt{}\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
function is expressed via Eq.~(\ref{eq:define-flatten-via-swap})? 

To answer this question, let us look at the type signature of \texttt{}\inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
for $T$:
\[
\text{ftn}_{T}:L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]
This type signature is different from $\text{sw}:M\circ L\leadsto L\circ M$
only because the argument of $\text{ftn}_{T}$ has extra layers of
the functors $L$ and $M$ that are placed outside the $M\circ L$
composition. We can use the \inputencoding{latin9}\lstinline!pure!\inputencoding{utf8}
methods of $M$ and $L$ to add these extra layers to a value of type
$M\circ L$, without modifying any monadic effects present in $M\circ L$.
This will allow us to apply $\text{ftn}_{T}$ and to obtain a value
of type $L\circ M$. The resulting code for the function $\text{ftn}_{T}$
and the corresponding type diagram are
\begin{equation}
\text{sw}=\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{pu}_{L}\bef\text{ftn}_{T}\quad.\label{eq:define-swap-via-flatten}
\end{equation}
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{4pc}M^{L^{A}}\ar[r]\sp(0.5){\text{pu}_{M}^{\uparrow L\uparrow M}}\ar[rrd]\sb(0.5){\text{sw}\triangleq} & M^{L^{M^{A}}}\ar[r]\sp(0.5){\text{pu}_{L}} & L^{M^{L^{M^{A}}}}\ar[d]\sp(0.45){\text{ftn}_{T}}\\
 &  & L^{M^{A}}
}
\]

We have expressed $\text{ftn}_{T}$ and $\text{sw}$ through each
other. Are these functions always equivalent? To decide this, we need
to answer two questions:
\begin{enumerate}
\item If we first define $\text{ftn}_{T}$ using Eq.~(\ref{eq:define-flatten-via-swap})
through a given implementation of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
and then substitute that $\text{ftn}_{T}$ into Eq.~(\ref{eq:define-swap-via-flatten}),
will we always recover the initially given function $\text{sw}$?
(Yes, assuming naturality for \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}.)
\item If we first define $\text{sw}$ using Eq.~(\ref{eq:define-swap-via-flatten})
through a given implementation of $\text{ftn}_{T}$ and then substitute
that $\text{sw}$ into Eq.~(\ref{eq:define-flatten-via-swap}), will
we always recover the initially given function $\text{ftn}_{T}$?
(No, not without additional laws for $\text{ftn}_{T}$.)
\end{enumerate}
To answer the first question, substitute $\text{ftn}_{T}$ from Eq.~(\ref{eq:define-flatten-via-swap})
into Eq.~(\ref{eq:define-swap-via-flatten}):
\begin{align*}
 & \text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{pu}_{L}\bef\gunderline{\text{ftn}_{T}}\\
{\color{greenunder}\text{substitute }\text{ftn}_{T}:}\quad & =\text{pu}_{M}^{\uparrow L\uparrow M}\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{pu}_{L}:}\quad & =\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{left identity law for }L:}\quad & =\gunderline{\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{sw}}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{sw}:}\quad & =\text{sw}\bef\gunderline{\text{pu}_{M}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}}\\
{\color{greenunder}\text{functor composition for }L:}\quad & =\text{sw}\bef\gunderline{\left(\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}\right)}^{\uparrow L}\\
{\color{greenunder}\text{right identity law for }M:}\quad & =\text{sw}\quad.
\end{align*}
So, indeed, we always recover the initial \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function.

To answer the second question, substitute $\text{sw}$ from Eq.~(\ref{eq:define-swap-via-flatten})
into Eq.~(\ref{eq:define-flatten-via-swap}):
\begin{align}
 & \gunderline{\text{sw}}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
{\color{greenunder}\text{substitute }\text{sw}:}\quad & =\gunderline{\left(\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{pu}_{L}\bef\text{ftn}_{T}\right)^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
{\color{greenunder}\text{functor composition }:}\quad & =\text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:deriv-sw-from-ftn-a}
\end{align}
At this point, we are stuck: we can find no laws to transform the
last expression. Without assuming additional laws, it \emph{does not
follow} that the right-hand side of Eq.~(\ref{eq:deriv-sw-from-ftn-a})
is equal to $\text{ftn}_{T}$. Let us now derive those additional
laws. 

The only sub-expression in Eq.~(\ref{eq:deriv-sw-from-ftn-a}) that
we could possibly transform is the composition $\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}$.
So, we need to assume a law involving the expression 
\[
\big(\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}\big):L\circ L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]
This function flattens the two layers of $\left(L\circ M\right)$
and then flattens the remaining two layers of $L$. Another function
with the same type signature could first flatten the two \emph{outside}
layers of $L$ and then flatten the two remaining layers of $\left(L\circ M\right)$:
\[
\big(\text{ftn}_{L}\bef\text{ftn}_{T}\big):L\circ L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]
So we conjecture that a possibly useful additional law for $\text{ftn}_{T}$
is 
\[
\text{ftn}_{L}\bef\text{ftn}_{T}=\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}\quad.
\]
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}L^{L^{M^{L^{M^{A}}}}}\ar[r]\sp(0.5){\text{ftn}_{L}}\ar[d]\sb(0.5){\text{ftn}_{T}^{\uparrow L}} & L^{M^{L^{M^{A}}}}\ar[d]\sp(0.5){\text{ftn}_{T}}\\
L^{L^{M^{A}}}\ar[r]\sb(0.5){\text{ftn}_{L}} & L^{M^{A}}
}
\]
This law expresses a kind of ``compatibility'' between the monads
$L$ and $T$.

With this law, the right-hand side of Eq.~(\ref{eq:deriv-sw-from-ftn-a})
becomes
\begin{align*}
 & \text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\gunderline{\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{right identity law of }L:}\quad & =\text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\end{align*}
Again, we cannot proceed unless we assume a law involving the expression
\[
\big(\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\big):L\circ M\circ L\circ M\circ M\leadsto L\circ M\quad.
\]
This function first flattens the two layers of $\left(L\circ M\right)$
and then flattens the remaining two layers of $M$. An alternative
order of flattenings is to first flatten the \emph{innermost} two
layers of $M$:
\[
\big(\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\big):L\circ M\circ L\circ M\circ M\leadsto L\circ M\quad.
\]
The second conjectured law is therefore
\[
\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}=\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\quad.
\]
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}L^{M^{L^{M^{M^{A}}}}}\ar[r]\sp(0.5){\text{ftn}_{T}}\ar[d]\sb(0.5){\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}} & L^{M^{M^{A}}}\ar[d]\sp(0.5){\text{ftn}_{M}^{\uparrow L}}\\
L^{M^{L^{M^{A}}}}\ar[r]\sb(0.5){\text{ftn}_{T}} & L^{M^{A}}
}
\]
This law expresses a kind of ``compatibility'' between the monads
$M$ and $T$.

Assuming this law, we can finally complete the derivation:
\begin{align*}
 & \text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{substitute the second conjecture}:}\quad & =\gunderline{\text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}}\bef\text{ftn}_{T}\\
{\color{greenunder}\text{functor composition }:}\quad & =\gunderline{\left(\text{pu}_{M}\bef\text{ftn}_{M}\right)}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\\
{\color{greenunder}\text{left identity law of }M:}\quad & =\text{ftn}_{T}\quad.
\end{align*}
We recovered the initial $\text{ftn}_{T}$ by assuming two additional
laws.

It turns out that these additional laws will always hold when $\text{ftn}_{T}$
is defined via \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
(see Exercise~\ref{par:Exercise-1-interchange-laws-for-ftn-T}).

It may be hard to verify directly the monad laws for $L\circ M$ because
of deeply nested type constructors, e.g.~$L\circ M\circ L\circ M\circ L\circ M$.
If the monad $L\circ M$ has a \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
method (in practice, this is always the case), it is simpler to verify
the laws of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
and then obtain the monad laws of $L\circ M$ via Theorem~\ref{sec:Theorem-swap-laws-to-monad-transformer-first-law}.

\subsubsection{Exercise \label{par:Exercise-1-interchange-laws-for-ftn-T}\ref{par:Exercise-1-interchange-laws-for-ftn-T} }

Assuming that
\begin{itemize}
\item $L$ and $M$ are monads,
\item the method \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
is a natural transformation $M\circ L\leadsto L\circ M$,
\item the method $\text{ftn}_{T}$ of the monad $T=L\circ M$ is \emph{defined}
via \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8} by
Eq.~(\ref{eq:define-flatten-via-swap}),
\end{itemize}
show that the two interchange laws must hold for $\text{ftn}_{T}$:
\begin{align*}
{\color{greenunder}\text{inner-interchange }:}\quad & \text{ftn}_{L}\bef\text{ftn}_{T}=\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}\quad,\\
{\color{greenunder}\text{outer-interchange }:}\quad & \text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}=\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\quad.
\end{align*}


\subsubsection{Exercise \label{par:Exercise-2-prove-compat-laws-for-T-from-swap}\ref{par:Exercise-2-prove-compat-laws-for-T-from-swap}}

With the same assumptions as Exercise~\ref{par:Exercise-1-interchange-laws-for-ftn-T}
and additionally assuming the inner and outer identity laws for \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
(see Theorem~\ref{sec:Theorem-swap-laws-to-monad-transformer-first-law}),
show that the monad $T^{\bullet}\triangleq L^{M^{\bullet}}$ satisfies
two ``pure compatibility'' laws,\textbf{\index{pure compatibility laws}}
\begin{align*}
{\color{greenunder}\text{inner-pure-compatibility}:}\quad & \text{ftn}_{L}=\text{pu}_{M}^{\uparrow L}\bef\text{ftn}_{T}\quad:L^{L^{M^{A}}}\Rightarrow L^{M^{A}}\quad,\\
{\color{greenunder}\text{outer-pure-compatibility}:}\quad & \text{ftn}_{M}^{\uparrow L}=\text{pu}_{L}^{\uparrow T}\bef\text{ftn}_{T}\quad:L^{M^{M^{A}}}\Rightarrow L^{M^{A}}\quad,
\end{align*}
or, expressed equivalently through the $\text{flm}$ methods instead
of $\text{ftn}$,
\begin{align*}
\text{flm}_{L}f^{:A\Rightarrow L^{M^{B}}} & =\text{pure}_{M}^{\uparrow L}\bef\text{flm}_{T}f^{:A\Rightarrow L^{M^{B}}}\quad,\\
\big(\text{flm}_{M}f^{:A\Rightarrow M^{B}}\big)^{\uparrow L} & =\text{pure}_{L}^{\uparrow T}\bef\text{flm}_{T}(f^{\uparrow L})\quad.
\end{align*}


\subsection{Monad transformer identity law: Proofs}

The identity law requires that $T_{L}^{M}\cong L$ if $M=\text{Id}$.
We will now prove this law assuming that $\text{pu}_{T}$ and $\text{ftn}_{T}$
are defined by Eqs.~(\ref{eq:def-pure-T-via-pure-L-and-pure-M})–(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M}),
and that the two identity laws of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
hold (see Theorem~\ref{sec:Theorem-swap-laws-to-monad-transformer-first-law}),
\begin{align*}
{\color{greenunder}\text{outer-identity}:}\quad & \text{pu}_{L}^{\uparrow M}\bef\text{sw}_{L,M}=\text{pu}_{L}\quad,\\
{\color{greenunder}\text{inner-identity}:}\quad & \text{pu}_{M}\bef\text{sw}_{L,M}=\text{pu}_{M}^{\uparrow L}\quad.
\end{align*}
Note that $M$ is the foreign monad for composed-outside transformers,
$T_{L}^{M}=L\circ M$. Setting $M=\text{Id}$ in the inner-identity
law, we obtain 
\[
\text{pu}_{\text{Id}}\bef\text{sw}_{L,\text{Id}}=\text{pu}_{\text{Id}}^{\uparrow L}\quad.
\]
Since $\text{pu}_{\text{Id}}=\text{id}$, it follows that $\text{sw}_{L,\text{Id}}=\text{id}$.
In a similar way, for composed-inside transformers $T_{L}^{M}=M\circ L$
we need to switch the roles of $M$ and $L$ in the same computation
and substitute $L=\text{id}$ into the outer-identity law,
\[
\text{pu}_{\text{Id}}^{\uparrow M}\bef\text{sw}_{\text{Id},M}=\text{pu}_{\text{Id}}\quad.
\]
 We obtain $\text{sw}_{\text{Id},M}=\text{id}$.

Note that $\text{sw}_{L,\text{Id}}:L^{A}\Rightarrow L^{A}$ is a natural
transformation for a monad $L$, so one may heuristically expect $\text{sw}_{L,\text{Id}}$
to be equal to the identity map (the only natural transformation $L^{A}\Rightarrow L^{A}$
that exists for all monads $L$). Similarly, one may expect that $\text{sw}_{\text{Id},M}:M^{A}\Rightarrow M^{A}=\text{id}$
since it is a natural transformation. But these are only heuristic
expectations, while we have just shown that the properties $\text{sw}_{L,\text{Id}}=\text{id}$
and $\text{sw}_{\text{Id},M}=\text{id}$ follow from the previously
established laws of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
without any new assumptions. These properties will be needed in the
proofs below. 

To demonstrate a monadic isomorphism between the monads $T_{L}^{\text{Id}}$
and $L$, we will consider separately the cases of composed-inside
and composed-outside transformers.

For composed-inside transformers $T_{L}^{M}=M\circ L$, we set $M=\text{Id}$
and find that the monad $T_{L}^{\text{Id}}=\text{Id}\circ L=L$ is
the same type constructor as $L$. So, the isomorphism maps between
$T_{L}^{\text{Id}}$ and $L$ are simply the identity maps in both
directions, $\text{id}:T_{L}^{\text{Id},A}\Rightarrow L^{A}$ and
$\text{id}:L^{A}\Rightarrow T_{L}^{\text{Id},A}$. 

For composed-outside transformers $T_{L}^{M}=L\circ M$, the monad
$T_{L}^{\text{Id}}=L\circ\text{Id}=L$ is again the same type constructor
as $L$. The isomorphisms between $T_{L}^{\text{Id}}$ and $L$ are
again the identity maps in both directions, $\text{id}:T_{L}^{\text{Id},A}\Rightarrow L^{A}$
and $\text{id}:L^{A}\Rightarrow T_{L}^{\text{Id},A}$. 

We have found the isomorphism maps between $T_{L}^{\text{Id}}$ and
$L$. However, we still need to verify that the monad structure of
$T_{L}^{\text{Id}}$ is the same as that of $L$; otherwise the isomorphism
would not be a \emph{monadic} isomorphism (i.e.~an isomorphism that
preserves the structure of the monads). To verify this, it is sufficient
to show that the methods $\text{pu}_{T}$ and $\text{ftn}_{T}$ defined
by Eqs.~(\ref{eq:def-pure-T-via-pure-L-and-pure-M})–(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})
for the monad $T_{L}^{\text{Id}}$ are \emph{the same functions} as
the given methods $\text{pu}_{L}$ and $\text{ftn}_{L}$ of the monad
$L$. If the monad's methods are the same functions, i.e.~$\text{pu}_{L}=\text{pu}_{T}$
and $\text{ftn}_{L}=\text{ftn}_{T}$, then the identity map $\text{id}:T^{A}\Rightarrow L^{A}$
will satisfy the laws of the monadic morphism,
\[
\text{pu}_{T}\bef\text{id}=\text{pu}_{L}\quad,\quad\quad\text{ftn}_{T}\bef\text{id}=\text{id}^{\uparrow T}\bef\text{id}\bef\text{ftn}_{L}\quad.
\]
In the same way, the laws of the monadic morphism will hold for the
identity map in the direction $L\leadsto T$. 

\paragraph{For composed-inside transformers:}

We need to show that $\text{pu}_{M}=\text{pu}_{T}$ and $\text{ftn}_{M}=\text{ftn}_{T}$.
Designate $L$ as the foreign monad and $M$ as the base monad in
Eq.~(\ref{eq:def-pure-T-via-pure-L-and-pure-M}), as appropriate
for the composed-inside transformer $T_{L}^{M}=M\circ L$. Setting
the foreign monad to identity, $L=\text{Id}$, in Eq.~(\ref{eq:def-pure-T-via-pure-L-and-pure-M})
gives
\[
\text{pu}_{T}=\text{pu}_{M}\bef\text{pu}_{\text{Id}}=\text{pu}_{M}.
\]

To show that $\text{ftn}_{M}=\text{ftn}_{T}$, we use Eq.~(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})
with $L=\text{Id}$:
\begin{align*}
 & \text{ftn}_{T}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})}:}\quad & =\text{sw}_{\text{Id},M}^{\uparrow\text{Id}}\bef\text{ftn}_{\text{Id}}\bef\text{ftn}_{M}^{\uparrow\text{Id}}\\
{\color{greenunder}\text{use \ensuremath{\text{ftn}_{\text{Id}}}=\text{id} and \ensuremath{\text{sw}_{\text{Id},M}}=\text{id}}:}\quad & =\text{ftn}_{M}\quad.
\end{align*}


\paragraph{For composed-outside transformers:}

We need to show that $\text{pu}_{L}=\text{pu}_{T}$ and $\text{ftn}_{L}=\text{ftn}_{T}$.
Designate $M$ as the foreign monad and $L$ as the base monad in
Eq.~(\ref{eq:def-pure-T-via-pure-L-and-pure-M}), as appropriate
for the composed-outside transformer $T_{L}^{M}=L\circ M$. Setting
the foreign monad to identity, $M=\text{Id}$, in Eq.~(\ref{eq:def-pure-T-via-pure-L-and-pure-M})
gives
\[
\text{pu}_{T}=\text{pu}_{\text{Id}}\bef\text{pu}_{L}=\text{pu}_{L}.
\]

To show that $\text{ftn}_{L}=\text{ftn}_{T}$, use Eq.~(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})
with $M=\text{Id}$:
\begin{align*}
 & \text{ftn}_{T}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})}:}\quad & =\text{sw}_{L,\text{Id}}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{\text{Id}}^{\uparrow L}\\
{\color{greenunder}\text{use \ensuremath{\text{ftn}_{\text{Id}}}=\text{id} and \ensuremath{\text{sw}_{L,\text{Id}}}=\text{id}}:}\quad & =\text{ftn}_{L}\quad.
\end{align*}


\subsection{Monad transformer lifting laws: Proofs}

We will now derive the laws of monad transformer liftings from the
laws of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8},
using Eqs.~(\ref{eq:def-pure-T-via-pure-L-and-pure-M})–(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})
as definitions of the methods of $T$.

To be specific, let us assume that $L$ is the base monad of the transformer.
Only the monads' names will need to change for the other choice of
the base monad.

The lifting morphisms of a compositional monad transformer are defined
by
\begin{align*}
\text{lift} & =\text{pu}_{L}:M^{A}\Rightarrow L^{M^{A}}\quad,\\
\text{blift} & =\text{pu}_{M}^{\uparrow L}:L^{A}\Rightarrow L^{M^{A}}\quad.
\end{align*}
Their laws of liftings (the identity and the composition laws) are
\begin{align*}
\text{pu}_{M}\bef\text{lift}=\text{pu}_{T}\quad,\quad & \quad\text{pu}_{L}\bef\text{blift}=\text{pu}_{T}\quad,\\
\text{ftn}_{M}\bef\text{lift}=\text{lift}^{\uparrow M}\bef\text{lift}\bef\text{ftn}_{T}\quad,\quad & \quad\text{ftn}_{L}\bef\text{blift}=\text{blift}^{\uparrow L}\bef\text{blift}\bef\text{ftn}_{T}\quad.
\end{align*}
The identity laws are verified quickly,
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pu}_{T}:}\quad & \text{pu}_{M}\bef\text{lift}=\text{pu}_{M}\bef\text{pu}_{L}\\
{\color{greenunder}\text{definition of }\text{pu}_{T}:}\quad & =\text{pu}_{T}\quad,\\
{\color{greenunder}\text{expect to equal }\text{pu}_{T}:}\quad & \text{pu}_{L}\bef\text{blift}=\text{pu}_{L}\bef\text{pu}_{M}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{pu}_{L}:}\quad & =\text{pu}_{M}\bef\text{pu}_{L}=\text{pu}_{T}\quad.
\end{align*}
To verify the composition laws, we need to start from their right-hand
sides because the left-hand sides cannot be simplified. We then substitute
the definition of $\text{ftn}_{T}$ in terms of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}.
The composition law for $\text{lift}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{ftn}_{M}\bef\text{pu}_{L}:}\quad & \text{lift}^{\uparrow M}\bef\text{lift}\bef\text{ftn}_{T}\\
{\color{greenunder}\text{definitions of }\text{lift}\text{ and }\text{ftn}_{T}:}\quad & =\text{pu}_{L}^{\uparrow M}\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{pu}_{L}:}\quad & =\text{pu}_{L}^{\uparrow M}\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{left identity law of }L:}\quad & =\gunderline{\text{pu}_{L}^{\uparrow M}\bef\text{sw}}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{inner-identity law of }\text{sw}:}\quad & =\text{pu}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{pu}_{L}:}\quad & =\text{ftn}_{M}\bef\text{pu}_{L}\quad.
\end{align*}
The composition law for $\text{blift}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{ftn}_{L}\bef\text{pu}_{M}^{\uparrow L}:}\quad & \text{blift}^{\uparrow L}\bef\text{blift}\bef\text{ftn}_{T}\\
{\color{greenunder}\text{definitions of }\text{blift}\text{ and }\text{ftn}_{T}:}\quad & =\text{pu}_{M}^{\uparrow L\uparrow L}\bef\gunderline{\text{pu}_{M}^{\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{functor composition in }L:}\quad & =\text{pu}_{M}^{\uparrow L\uparrow L}\bef\gunderline{\left(\text{pu}_{M}\bef\text{sw}\right)}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{outer-identity law of }\text{sw}:}\quad & =\gunderline{\left(\text{pu}_{M}^{\uparrow L\uparrow L}\bef\text{pu}_{M}^{\uparrow L\uparrow L}\right)}\bef\gunderline{\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{ftn}_{L}:}\quad & =\text{ftn}_{L}\bef\big(\text{pu}_{M}^{\uparrow L}\bef\gunderline{\text{pu}_{M}^{\uparrow L}\big)\bef\text{ftn}_{M}^{\uparrow L}}\\
{\color{greenunder}\text{right identity law of }M:}\quad & =\text{ftn}_{L}\bef\text{pu}_{M}^{\uparrow L}\quad.
\end{align*}
So, the lifting laws for $T$ follow from the laws of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}.

\subsection{Monad transformer runner laws: Proofs}

The laws of runners are not symmetric with respect to the base monad
and the foreign monad: the runner, \inputencoding{latin9}\lstinline!mrun!\inputencoding{utf8},
is generic in the foreign monad (but not in the base monad). In each
case, the \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function must be monadically natural with respect to the \emph{foreign}
monad. So, this law needs to be written differently, depending on
the choice of the base monad. Let us consider separately the situations
when either $L$ or $M$ is the base monad.

\paragraph{If the base monad is $L$, }

the runners are
\begin{align*}
\text{mrun}\,\phi^{:M^{\bullet}\leadsto N^{\bullet}} & :L^{M^{\bullet}}\leadsto L^{N^{\bullet}}\quad,\quad\quad\text{mrun}\,\phi=\phi^{\uparrow L}\quad;\\
\text{brun}\,\theta^{:L^{\bullet}\leadsto\bullet} & :L^{M^{\bullet}}\leadsto M^{\bullet}\quad,\quad\quad\text{brun}\,\theta=\theta\quad.
\end{align*}
The laws of runners require that $\text{mrun}\,\phi$ and $\text{brun}\,\theta$
must be monadic morphisms, i.e.~the identity and composition laws
must hold for $\text{mrun}\,\phi$ and $\text{brun}\,\theta$:
\begin{align*}
\text{pu}_{L\circ M}\bef\text{mrun}\,\phi & =\text{pu}_{L\circ N}\quad,\\
\text{ftn}_{L\circ M}\bef\text{mrun}\,\phi & =\left(\text{mrun}\,\phi\right)^{\uparrow M\uparrow L}\bef\text{mrun}\,\phi\bef\text{ftn}_{L\circ N}\quad,\\
\text{pu}_{L\circ M}\bef\text{brun}\,\theta & =\text{pu}_{M}\quad,\\
\text{ftn}_{L\circ M}\bef\text{brun}\,\theta & =\left(\text{brun}\,\theta\right)^{\uparrow M\uparrow L}\bef\text{brun}\,\theta\bef\text{ftn}_{M}\quad.
\end{align*}
To derive these laws, we may use the identity and composition laws
of monadic morphisms for $\phi$ and $\theta$. We also use Eqs.~(\ref{eq:def-pure-T-via-pure-L-and-pure-M})–(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})
as definitions of the monad $T$. Additionally, the \textbf{monadic
naturality\index{monadic naturality}} of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
with respect to $\phi$ and $\theta$ are assumed to hold,
\[
\text{sw}_{L,M}\bef\phi^{\uparrow L}=\phi\bef\text{sw}_{L,N}\quad,\quad\quad\text{sw}_{L,M}\bef\theta=\theta^{\uparrow M}\quad.
\]
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3pc}M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[d]\sb(0.4){\phi} & L^{M^{A}}\ar[d]\sp(0.4){\phi^{\uparrow L}} & M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[rd]\sb(0.45){\theta^{\uparrow M}} & L^{M^{A}}\ar[d]\sp(0.4){\theta}\\
N^{L^{A}}\ar[r]\sb(0.5){\text{sw}_{L,N}} & L^{N^{A}} &  & M^{A}
}
\]

The first law to be shown is the identity law for $\text{mrun}\,\phi$:
\begin{align*}
{\color{greenunder}\text{expect this to equal }\text{pu}_{L\circ N}:}\quad & \text{pu}_{L\circ M}\bef\text{mrun}\,\phi\\
{\color{greenunder}\text{definitions of }\text{mrun}\text{ and }\text{pu}_{L\circ M}:}\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\phi^{\uparrow L}}\\
{\color{greenunder}\text{naturality of }\text{pu}_{L}:}\quad & =\gunderline{\text{pu}_{M}\bef\phi}\bef\text{pu}_{L}\\
{\color{greenunder}\text{identity law for }\phi:}\quad & =\text{pu}_{N}\bef\text{pu}_{L}\\
{\color{greenunder}\text{definition of }\text{pu}_{L\circ N}:}\quad & =\text{pu}_{L\circ N}\quad.
\end{align*}
The next law to be shown is the composition law for $\text{mrun}\,\phi$:
\begin{align*}
{\color{greenunder}\text{expect this to equal }\text{ftn}_{T}\bef\phi^{\uparrow L}:}\quad & \left(\text{mrun}\,\phi\right)^{\uparrow M\uparrow L}\bef\text{mrun}\,\phi\bef\text{ftn}_{L\circ N}\\
{\color{greenunder}\text{definitions of }\text{mrun}\text{ and }\text{ftn}_{L\circ N}:}\quad & =\phi^{\uparrow L\uparrow M\uparrow L}\bef\gunderline{\phi^{\uparrow L}\bef\text{sw}_{L,N}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{N}^{\uparrow L}\\
{\color{greenunder}\text{monadic naturality of }\text{sw}_{L,M}:}\quad & =\gunderline{\phi^{\uparrow L\uparrow M\uparrow L}\bef\text{sw}_{L,M}^{\uparrow L}}\bef\phi^{\uparrow L\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{N}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{sw}_{L,M}:}\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\phi^{\uparrow M\uparrow L\uparrow L}\bef\phi^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{N}^{\uparrow L}\\
{\color{greenunder}\text{naturality of }\text{ftn}_{L}:}\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\left(\phi^{\uparrow M}\bef\phi\bef\text{ftn}_{N}\right)}^{\uparrow L}\\
{\color{greenunder}\text{composition law for }\phi:}\quad & =\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\bef\phi^{\uparrow L}\\
{\color{greenunder}\text{definition of }\text{ftn}_{T}:}\quad & =\gunderline{\text{ftn}_{T}}\bef\phi^{\uparrow L}\quad.
\end{align*}
The next law is the identity law for $\text{brun}$:
\begin{align*}
{\color{greenunder}\text{expect this to equal }\text{pu}_{M}:}\quad & \text{pu}_{L\circ M}\bef\text{brun}\,\theta\\
{\color{greenunder}\text{definitions of }\text{brun}\text{ and }\text{pu}_{L\circ M}:}\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\theta}\\
{\color{greenunder}\text{identity law for }\theta:}\quad & =\text{pu}_{M}\quad.
\end{align*}
The last law to be shown is the composition law for $\text{brun}\,\theta$.
Begin with its right-hand side since it is simpler,
\begin{align*}
 & \left(\text{brun}\,\theta\right)^{\uparrow M\uparrow L}\bef\text{brun}\,\theta\bef\text{ftn}_{M}\\
{\color{greenunder}\text{definition of }\text{brun}:}\quad & =\theta^{\uparrow M\uparrow L}\bef\theta\bef\text{ftn}_{M}\quad.
\end{align*}
We cannot simplify this expression any more, and yet it is still different
from the left-hand side. So let us transform the left-hand side, hoping
to obtain the same expression. In particular, we need to move $\text{ftn}_{M}$
to the right and $\theta$ to the left: 
\begin{align*}
 & \text{ftn}_{L\circ M}\bef\text{brun}\,\theta\\
{\color{greenunder}\text{definitions of }\text{ftn}_{L\circ M}\text{ and }\text{brun}:}\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}\bef\theta}\\
{\color{greenunder}\text{naturality of }\theta:}\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef\theta}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{composition law for }\theta:}\quad & =\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\theta^{\uparrow L}}\bef\theta\bef\text{ftn}_{M}\\
{\color{greenunder}\text{functor composition}:}\quad & =\gunderline{\left(\text{sw}_{L,M}\bef\theta\right)^{\uparrow L}}\bef\theta\bef\text{ftn}_{M}\\
{\color{greenunder}\text{monadic naturality of }\text{sw}_{L,M}:}\quad & =\gunderline{\theta^{\uparrow M\uparrow L}}\bef\theta\bef\text{ftn}_{M}\quad.
\end{align*}
We have transformed both sides of the law into the same expression.

The lifting laws for $\text{mrun}$ are
\[
\text{mrun}\left(\text{id}\right)=\text{id}\quad,\quad\quad\text{mrun}\left(\phi\right)\bef\text{mrun}\left(\chi\right)=\text{mrun}\left(\phi\bef\chi\right)\quad.
\]
Since $\text{mrun}\left(\phi\right)=\phi^{\uparrow L}$ in our case,
these laws hold because they are the same as the functor laws of $L$.

Finally, we verify the non-degeneracy law for $\text{brun}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{id}:}\quad & \text{lift}\bef\text{brun}\left(\theta\right)\\
{\color{greenunder}\text{definitions of }\text{lift}\text{ and }\text{brun}:}\quad & =\text{pu}_{L}\bef\theta\\
{\color{greenunder}\text{identity law for }\theta:}\quad & =\text{id}\quad.
\end{align*}


\paragraph{If the base monad is $M$, }

the runners have the type signatures
\begin{align*}
\text{mrun}\,\phi^{:L^{\bullet}\leadsto N^{\bullet}} & :L^{M^{\bullet}}\leadsto N^{M^{\bullet}}\quad,\quad\quad\text{mrun}\,\phi=\phi\quad;\\
\text{brun}\,\theta^{:M^{\bullet}\leadsto\bullet} & :L^{M^{\bullet}}\leadsto L^{\bullet}\quad,\quad\quad\text{brun}\,\theta=\theta^{\uparrow L}\quad.
\end{align*}
The laws of runners require that $\text{mrun}\,\phi$ and $\text{brun}\,\theta$
must be monadic morphisms, i.e.~the identity and composition laws
must hold for $\text{mrun}\,\phi$ and $\text{brun}\,\theta$:
\begin{align*}
\text{pu}_{L\circ M}\bef\text{mrun}\,\phi & =\text{pu}_{N\circ M}\quad,\\
\text{ftn}_{L\circ M}\bef\text{mrun}\,\phi & =\left(\text{mrun}\,\phi\right)^{\uparrow M\uparrow L}\bef\text{mrun}\,\phi\bef\text{ftn}_{N\circ M}\quad,\\
\text{pu}_{L\circ M}\bef\text{brun}\,\theta & =\text{pu}_{L}\quad,\\
\text{ftn}_{L\circ M}\bef\text{brun}\,\theta & =\left(\text{brun}\,\theta\right)^{\uparrow M\uparrow L}\bef\text{brun}\,\theta\bef\text{ftn}_{L}\quad.
\end{align*}
The monadic naturality laws for \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
with respect to $\phi$ and $\chi$ are 
\[
\text{sw}_{L,M}\bef\phi=\phi^{\uparrow M}\bef\text{sw}_{N,M}\quad,\quad\quad\text{sw}_{L,M}\bef\theta^{\uparrow L}=\theta\quad.
\]
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3pc}M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[d]\sb(0.4){\phi^{\uparrow M}} & L^{M^{A}}\ar[d]\sp(0.4){\phi} & M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[rd]\sb(0.45){\theta} & L^{M^{A}}\ar[d]\sp(0.4){\theta^{\uparrow L}}\\
M^{N^{A}}\ar[r]\sb(0.5){\text{sw}_{N,M}} & N^{M^{A}} &  & L^{A}
}
\]

The first law to be proved is
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pu}_{N\circ M}:}\quad & \text{pu}_{L\circ M}\bef\text{mrun}\,\phi\\
{\color{greenunder}\text{definitions of }\text{mrun}\text{ and }\text{pu}_{L\circ M}:}\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\phi}\\
{\color{greenunder}\text{identity law for }\phi:}\quad & =\text{pu}_{M}\bef\text{pu}_{N}\\
{\color{greenunder}\text{definition of }\text{pu}_{N\circ M}:}\quad & =\text{pu}_{N\circ M}\quad.
\end{align*}
The next law is the composition law for $\text{mrun}\,\phi$:
\begin{align*}
{\color{greenunder}\text{expect this to equal }\text{ftn}_{T}\bef\phi:}\quad & \left(\text{mrun}\,\phi\right)^{\uparrow M\uparrow L}\bef\text{mrun}\,\phi\bef\text{ftn}_{N\circ M}\\
{\color{greenunder}\text{definitions of }\text{mrun}\text{ and }\text{ftn}_{N\circ M}:}\quad & =\phi^{\uparrow M\uparrow L}\bef\gunderline{\phi\bef\text{sw}_{N,M}^{\uparrow N}}\bef\text{ftn}_{N}\bef\text{ftn}_{M}^{\uparrow N}\\
{\color{greenunder}\text{naturality of }\phi:}\quad & =\gunderline{\phi^{\uparrow M\uparrow L}\bef\text{sw}_{N,M}^{\uparrow L}}\bef\phi\bef\text{ftn}_{N}\bef\text{ftn}_{M}^{\uparrow N}\\
{\color{greenunder}\text{monadic naturality of }\text{sw}_{N,M}\text{ raised to }L:}\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\phi^{\uparrow L}\bef\phi\bef\text{ftn}_{N}}\bef\text{ftn}_{M}^{\uparrow N}\\
{\color{greenunder}\text{composition law for }\phi:}\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\phi\bef\text{ftn}_{M}^{\uparrow N}}\\
{\color{greenunder}\text{naturality of }\phi:}\quad & =\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\bef\phi\\
{\color{greenunder}\text{definition of }\text{ftn}_{T}:}\quad & =\gunderline{\text{ftn}_{T}}\bef\phi\quad.
\end{align*}
The next law is the identity law for $\text{brun}\left(\theta\right)$:
\begin{align*}
{\color{greenunder}\text{expect this to equal }\text{pu}_{L}:}\quad & \text{pu}_{L\circ M}\bef\text{brun}\,\theta\\
{\color{greenunder}\text{definitions of }\text{brun}\text{ and }\text{pu}_{L\circ M}:}\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\theta^{\uparrow L}}\\
{\color{greenunder}\text{naturality of }\text{pu}_{L}:}\quad & =\gunderline{\text{pu}_{M}\bef\theta}\bef\text{pu}_{L}\\
{\color{greenunder}\text{identity law for }\theta:}\quad & =\text{pu}_{L}\quad.
\end{align*}
The last law is the composition law for $\text{brun}\left(\theta\right)$.
Begin with its right-hand side,
\begin{align*}
 & \left(\text{brun}\,\theta\right)^{\uparrow M\uparrow L}\bef\text{brun}\,\theta\bef\text{ftn}_{L}\\
{\color{greenunder}\text{definition of }\text{brun}:}\quad & =\theta^{\uparrow L\uparrow M\uparrow L}\bef\theta^{\uparrow L}\bef\text{ftn}_{L}\\
{\color{greenunder}\text{functor composition}:}\quad & =\left(\theta^{\uparrow L\uparrow M}\bef\theta\right)^{\uparrow L}\bef\text{ftn}_{L}\\
{\color{greenunder}\text{naturality of }\theta:}\quad & =\left(\theta\bef\theta^{\uparrow L}\right)^{\uparrow L}\bef\text{ftn}_{L}\quad.
\end{align*}
We now transform the left-hand side, hoping to obtain the same expression.
We need to move $\text{ftn}_{L}$ to the right and $\theta$ to the
left: 
\begin{align*}
{\color{greenunder}\text{expect to equal }\theta^{\uparrow L}\bef\theta^{\uparrow L\uparrow L}\bef\text{ftn}_{L}:}\quad & \text{ftn}_{L\circ M}\bef\text{brun}\,\theta\\
{\color{greenunder}\text{definitions of }\text{ftn}_{L\circ M}\text{ and }\text{brun}:}\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}\bef\theta^{\uparrow L}}\\
{\color{greenunder}\text{composition law for }\theta:}\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef\left(\theta\bef\theta\right)^{\uparrow L}}\\
{\color{greenunder}\text{naturality of }\text{ftn}_{L}:}\quad & =\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\left(\theta\bef\theta\right)^{\uparrow L\uparrow L}}\bef\text{ftn}_{L}\\
{\color{greenunder}\text{functor composition}:}\quad & =\gunderline{\left(\text{sw}_{L,M}\bef\theta^{\uparrow L}\right)}^{\uparrow L}\bef\theta^{\uparrow L\uparrow L}\bef\text{ftn}_{L}\\
{\color{greenunder}\text{composition law for }\theta:}\quad & =\gunderline{\theta^{\uparrow L}}\bef\theta^{\uparrow L\uparrow L}\bef\text{ftn}_{L}\quad.
\end{align*}

The lifting laws for $\text{mrun}$ are
\[
\text{mrun}\left(\text{id}\right)=\text{id}\quad,\quad\quad\text{mrun}\left(\phi\right)\bef\text{mrun}\left(\chi\right)=\text{mrun}\left(\phi\bef\chi\right)\quad.
\]
Since $\text{mrun}\left(\phi\right)=\phi$ in our case, these laws
are trivially satisfied.

Finally, the non-degeneracy law for $\text{brun}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{id}:}\quad & \text{lift}\bef\text{brun}\left(\theta\right)\\
{\color{greenunder}\text{definitions of }\text{lift}\text{ and }\text{brun}:}\quad & =\text{pu}_{M}^{\uparrow L}\bef\theta^{\uparrow L}\\
{\color{greenunder}\text{identity law for }\theta:}\quad & =\text{id}^{\uparrow L}=\text{id}\quad.
\end{align*}


\subsection{Summary of results}

The derivations in Section~\ref{sec:Monad-transformers-that-use-composition}
enable us to state the following results:

\subsubsection{Theorem \label{subsec:Theorem-outside-transformer-swap-laws}\ref{subsec:Theorem-outside-transformer-swap-laws}
(composed-outside)}

For a base monad $L$ and a foreign monad $M$, the functor composition
$L\circ M$ is a lawful monad transformer if a \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function $\text{sw}_{L,M}:M\circ L\leadsto L\circ M$ exists, satisfying
the conditions of Theorem~\ref{sec:Theorem-swap-laws-to-monad-transformer-first-law}
and the monadic naturality laws
\[
\text{sw}_{L,\text{Id}}=\text{id}\quad,\quad\quad\text{sw}_{L,M}\bef\phi^{\uparrow L}=\phi\bef\text{sw}_{L,N}\quad,\quad\quad\text{sw}_{L,M}\bef\theta=\theta^{\uparrow M}\quad,
\]
with respect to arbitrary monadic morphisms $\phi:M\leadsto N$ and
$\theta:L\leadsto\text{Id}$. 

\subsubsection{Theorem \label{subsec:Theorem-inside-transformer-swap-laws}\ref{subsec:Theorem-inside-transformer-swap-laws}
(composed-inside)}

For a base monad $M$ and a foreign monad $L$, the functor composition
$L\circ M$ is a lawful monad transformer if a \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function $\text{sw}_{L,M}:M\circ L\leadsto L\circ M$ exists, satisfying
the conditions of Theorem~\ref{sec:Theorem-swap-laws-to-monad-transformer-first-law}
and the monadic naturality laws
\[
\text{sw}_{\text{Id},M}=\text{id}\quad,\quad\quad\text{sw}_{L,M}\bef\phi=\phi^{\uparrow M}\bef\text{sw}_{N,M}\quad,\quad\quad\text{sw}_{L,M}\bef\theta^{\uparrow L}=\theta\quad,
\]
with respect to arbitrary monadic morphisms $\phi:L\leadsto N$ and
$\theta:M\leadsto\text{Id}$. 

These theorems enable us to check more easily whether a given base
monad has a compositional monad transformer. It is easier to check
the laws of the \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function than to verify the monad transformer laws directly, because
the laws of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
work with a simpler type constructors than the monad transformer laws.

\section{Composed-inside transformers: Linear monads\label{sec:transformers-linear-monads}}

A monad $M$ is \textbf{linear\index{monads!linear}} if it is of
the form $M^{A}\triangleq P+Q\times A$, where $P$ and $Q$ are fixed
types, and $Q$ is a monoid. (The polynomial $P+Q\times A$ is linear
in its type parameter $A$.) Well-known examples of linear monads
are \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}, and
\inputencoding{latin9}\lstinline!Writer!\inputencoding{utf8}. The
general case $M^{A}\triangleq P+Q\times A$ represents a computation
that can fail and at the same time produce a log message. So, $M$
can be seen as a composition of \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Writer!\inputencoding{utf8}.

A different (but also linear) monad is obtained from the composition
of \inputencoding{latin9}\lstinline!Writer!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}. The
type constructor of this monad is $Q\times\left(P+A\right)$.

In general, composition of two linear monads $M_{1}^{A}\triangleq P_{1}+Q_{1}\times A$
and $M_{2}^{A}\triangleq P_{2}+Q_{2}\times A$ is again linear because
\begin{align*}
 & P_{1}+Q_{1}\times\left(P_{2}+Q_{2}\times A\right)\\
{\color{greenunder}\text{expand brackets}:}\quad & =\gunderline{P_{1}+Q_{1}\times P_{2}}+\gunderline{Q_{1}\times Q_{2}}\times A\\
{\color{greenunder}\text{define new }P,Q:}\quad & =P+Q\times A\quad.
\end{align*}
Note that we need to define $Q\triangleq Q_{1}\times Q_{2}$, and
so $Q$ is a monoid since, by assumption, $Q_{1}$ and $Q_{2}$ are
monoids.

For a linear monad $M$ and any foreign monad $L$, the functor composition
$L\circ M$ is a monad. For example, the type constructor for the
\inputencoding{latin9}\lstinline!OptionT!\inputencoding{utf8} monad
transformer can be defined as\inputencoding{latin9}
\begin{lstlisting}
type OptionT[L[_], A] = L[Option[A]]
\end{lstlisting}
\inputencoding{utf8}The \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
type constructor must be nested \emph{inside} the foreign monad \inputencoding{latin9}\lstinline!L!\inputencoding{utf8}.
This is the case for all linear monads. Also, linear monads are the
only known examples of monads whose transformers are composed inside
the foreign monad.

\subsection{Definitions of \texttt{swap} and \texttt{flatten}}

To show that the monad transformer for the base monad $M^{A}\triangleq P+Q\times A$
is $T_{M}^{L,A}=L^{M^{A}}$, we will implement a suitable \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function having the type signature
\[
\text{sw}_{N,M}:M^{L^{A}}\Rightarrow L^{M^{A}}\quad,
\]
for the base monad $M^{A}\triangleq P+Q\times A$ and an arbitrary
foreign monad $L$. We will then prove that \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
satisfies all the required laws stated in Theorem~\ref{subsec:Theorem-inside-transformer-swap-laws}.
This will guarantee that $T_{M}^{L,A}=L^{M^{A}}$ is a lawful monad
transformer.

Expanding the definition of the type constructor $M^{\bullet}$, we
can write the type signature of the \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function as 
\[
\text{sw}_{L,M}:P+Q\times L^{A}\Rightarrow L^{P+Q\times A}\quad.
\]
We can map $P$ to $L^{P}$ by applying $\text{pu}_{L}$. We can also
map $Q\times L^{A}\Rightarrow L^{Q\times A}$ since $L$ is a functor,
\[
q\times l\Rightarrow\left(a\Rightarrow q\times a\right)^{\uparrow L}l\quad.
\]
 It remains to unite these two functions. In the matrix notation,
we write
\begin{equation}
\text{sw}_{L,M}=\begin{array}{|c||c|}
P & (x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
Q\times L^{A} & q\times l\Rightarrow(a^{:A}\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l
\end{array}\quad.\label{eq:single-valued-monad-def-of-swap}
\end{equation}
In Scala, the code is\inputencoding{latin9}
\begin{lstlisting}
type M[A, P, Q] = Either[P, (Q, A)]
def swap[L[_]: Monad, A, P, Q]: M[L[A]] => L[M[A]] = {
  case Left(p) => Monad[L].pure(Left(p))
  case Right((q, la)) => la.map(a => Right((q, a)))
}
\end{lstlisting}
\inputencoding{utf8}
Given this \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function, we define the \inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
method (short notation $\text{ftn}_{T}$) for the transformed monad
$T$ by the standard formula
\[
\text{ftn}_{T}=\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\]
The \inputencoding{latin9}\lstinline!pure!\inputencoding{utf8} method
for $T$ (short notation $\text{pu}_{T}$) is $\text{pu}_{T}=\text{pu}_{M}\bef\text{pu}_{L}$.
In Scala:\inputencoding{latin9}
\begin{lstlisting}
def pure[L[_]: Monad, A, P, Q: Monoid](x: A): L[M[A]] =
  Monad[L].pure(Right((Monoid[Q].empty, x)))
def flatten[L[_]: Monad, A, P, Q: Monoid](tt: L[M[L[M[A]]]]): L[M[A]] =
  tt.map(swap).flatten.map(_.flatten) // Assuming suitable implicits in scope.
\end{lstlisting}
\inputencoding{utf8}
Now we will verify that the laws of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
hold. We will need to use the code for the methods $\text{fmap}_{M}$,
$\text{ftn}_{M}$, and $\text{pu}_{M}$ of the monad $M$:
\begin{align*}
\text{fmap}_{M}f^{:A\Rightarrow B} & =f^{\uparrow M}=\begin{array}{|c||cc|}
 & P & Q\times B\\
\hline P & \text{id} & \bbnum 0\\
Q\times A & \bbnum 0\enskip & q\times a\Rightarrow q\times f(a)
\end{array}\quad,\\
\text{pu}_{M}a^{:A} & =0^{:P}+q_{0}\times a\quad,\quad\quad\text{pu}_{M}=\begin{array}{|c||cc|}
 & P & Q\times A\\
\hline A & \bbnum 0\enskip & a\Rightarrow q_{0}\times a
\end{array}\quad,\\
\text{ftn}_{M}^{:M^{M^{A}}\Rightarrow M^{A}} & =\begin{array}{|c||cc|}
 & P & Q\times A\\
\hline P & \text{id} & \bbnum 0\\
Q\times P & q\times p\Rightarrow p & \bbnum 0\\
Q\times Q\times A & \bbnum 0 & q_{1}\times q_{2}\times a\Rightarrow\left(q_{1}\oplus q_{2}\right)\times a
\end{array}\quad.
\end{align*}


\subsection{Laws of \texttt{swap}}

We do not need to verify naturality since \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
is defined as a fully parametric function.

\paragraph{The inner-identity law}

We need to show that $\text{pu}_{L}^{\uparrow M}\bef\text{sw}=\text{pu}_{L}$:
\begin{align*}
\text{pu}_{L}^{\uparrow M}\bef\text{sw}= & \left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times a\Rightarrow q\times\text{pu}_{L}a
\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\Rightarrow(x^{:A}\Rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}l
\end{array}\right|\\
{\color{greenunder}\text{composition}:}\quad & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times a\Rightarrow\gunderline{(a^{:A}\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\left(\text{pu}_{L}a\right)}
\end{array}\right|\\
{\color{greenunder}\text{pu}_{L}\text{'s naturality}:}\quad & =\begin{array}{|c||c|}
P & x^{:P}\Rightarrow\text{pu}_{L}(x+\bbnum 0^{:Q\times A})\\
Q\times A & q\times a\Rightarrow\text{pu}_{L}(\bbnum 0^{:P}+q\times a)
\end{array}\\
{\color{greenunder}\text{matrix notation}:}\quad & =\text{pu}_{L}\quad.
\end{align*}


\paragraph{The outer-identity law}

We need to show that $\text{pu}_{M}\bef\text{sw}=\text{pu}_{M}^{\uparrow L}$:
\begin{align*}
\text{pu}_{M}\bef\text{sw} & =\left\Vert \begin{array}{cc}
\bbnum 0 & l^{:L^{A}}\Rightarrow q_{0}\times l\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\Rightarrow(x^{:A}\Rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}l
\end{array}\right|\\
{\color{greenunder}\text{composition}:}\quad & =l^{:L^{A}}\Rightarrow(x^{:A}\Rightarrow\bbnum 0^{:P}+q_{0}\times x)^{\uparrow L}l\\
{\color{greenunder}\text{definition of }\text{pu}_{M}:}\quad & =l\Rightarrow\text{pu}_{M}^{\uparrow L}l=\text{pu}_{M}\quad.
\end{align*}


\paragraph{The inner-interchange law}

Show that $\text{ftn}_{L}^{\uparrow M}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}$:
\begin{align}
\text{ftn}_{L}^{\uparrow M}\bef\text{sw}= & \left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times l\Rightarrow q\times\text{ftn}_{L}l
\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\Rightarrow(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l
\end{array}\right|\nonumber \\
 & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\Rightarrow(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}(\text{ftn}_{L}l)
\end{array}\right|\quad,\label{eq:l-interchange-simplify-1}\\
\text{sw}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}= & \left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\Rightarrow(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l
\end{array}\right|\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\nonumber \\
 & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\\
\big(q\times l\Rightarrow(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l\big)\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}
\end{array}\right|\quad.\nonumber 
\end{align}
It is quicker to simplify each expression in the last column separately
and then to compare with the column in Eq.~(\ref{eq:l-interchange-simplify-1}).
Simplify the upper expression:
\begin{align*}
 & (x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\\
{\color{greenunder}\text{naturality of }\text{pu}_{L}:}\quad & =(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\\
{\color{greenunder}\text{identity law of }L:}\quad & =\gunderline{(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{sw}}\\
{\color{greenunder}\text{definition of }\text{sw}:}\quad & =(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\quad.
\end{align*}
This equals the upper expression in Eq.~(\ref{eq:l-interchange-simplify-1}).
Simplify the lower expression;
\begin{align}
 & \big(q\times l\Rightarrow\gunderline{(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l}\big)\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\nonumber \\
{\color{greenunder}\text{definition of }\triangleright:}\quad & =q\times l\Rightarrow l\triangleright(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\quad.\label{eq:l-interchange-simplify-2}
\end{align}
Simplify the expression $(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\text{sw}^{\uparrow L}$
separately:
\begin{align}
 & (a\Rightarrow\bbnum 0^{:P}+q\times a)\bef\text{sw}\nonumber \\
{\color{greenunder}\text{composition}:}\quad & =a\Rightarrow\gunderline{\text{sw}\,(\bbnum 0^{:P}+q\times a)}\nonumber \\
{\color{greenunder}\text{definition of }\text{sw}:}\quad & =\gunderline{a\Rightarrow a\triangleright(}x\Rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\nonumber \\
{\color{greenunder}\text{omit argument}:}\quad & =(x\Rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\quad.\label{eq:l-interchange-simplify-3}
\end{align}
Then we continue simplifying Eq.~(\ref{eq:l-interchange-simplify-2}):
\begin{align*}
 & q\times l\Rightarrow l\triangleright\gunderline{(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:l-interchange-simplify-3})}:}\quad & =q\times l\Rightarrow l\triangleright\gunderline{(x\Rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\\
{\color{greenunder}\text{naturality of }\text{ftn}_{L}:}\quad & =q\times l\Rightarrow\gunderline{l\triangleright\text{ftn}_{L}}\bef(x\Rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\\
{\color{greenunder}\text{definition of }\triangleright:}\quad & =q\times l\Rightarrow(x\Rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}(\text{ftn}_{L}l)\quad.
\end{align*}
This equals the lower expression in Eq.~(\ref{eq:l-interchange-simplify-1})
after renaming $x$ to $a$.

\paragraph{The outer-interchange law}

Show that $\text{ftn}_{M}\bef\text{sw}=\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}$.
The left-hand side is written using the matrices for $\text{ftn}_{M}$
and $\text{sw}$:
\begin{align}
 & \text{ftn}_{M}\bef\text{sw}\nonumber \\
 & =\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
q\times p\Rightarrow p & \bbnum 0\\
\bbnum 0 & q_{1}\times q_{2}\times a\Rightarrow\left(q_{1}\oplus q_{2}\right)\times a
\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times l\Rightarrow(x\Rightarrow\bbnum 0+q\times x)^{\uparrow L}l
\end{array}\right|\nonumber \\
 & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
\left(q\times p\Rightarrow p+\bbnum 0\right)\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times a\Rightarrow(x\Rightarrow\bbnum 0+\left(q_{1}\oplus q_{2}\right)\times x)^{\uparrow L}a
\end{array}\right|\quad.\label{eq:m-interchange-law-of-swap-linear-monads-left-hand-side}
\end{align}
We cannot simplify this any more, so we hope to transform the right-hand
side, $\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}$,
to the same column expression. Begin by writing the matrix for $\text{sw}^{\uparrow M}$,
expanding the rows for the input type $M^{M^{L^{A}}}$:
\begin{align*}
\text{sw}^{\uparrow M}=~ & \begin{array}{|c||cc|}
P & \text{id} & \bbnum 0\\
Q\times P & \bbnum 0 & q\times p\Rightarrow q\times\text{sw}\left(p+\bbnum 0\right)\\
Q\times Q\times L^{A} & \bbnum 0 & q_{1}\times q_{2}\times l\Rightarrow q_{1}\times\text{sw}\left(\bbnum 0+q_{2}\times l\right)
\end{array}\\
 & =\begin{array}{|c||cc|}
P & \text{id} & \bbnum 0\\
Q\times P & \bbnum 0 & q\times p\Rightarrow q\times\text{pu}_{L}\left(p+\bbnum 0\right)\\
Q\times Q\times L^{A} & \bbnum 0 & q_{1}\times q_{2}\times l\Rightarrow q_{1}\times(x\Rightarrow\bbnum 0+q_{2}\times x)^{\uparrow L}l
\end{array}\quad.
\end{align*}
Then compute the composition $\text{sw}^{\uparrow M}\bef\text{sw}$
as
\begin{align*}
 & \text{sw}^{\uparrow M}\bef\text{sw}\\
 & =\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times p\Rightarrow q\times\text{pu}_{L}\left(p+\bbnum 0\right)\\
\bbnum 0 & q_{1}\times q_{2}\times l\Rightarrow q_{1}\times(x\Rightarrow\bbnum 0+q_{2}\times x)^{\uparrow L}l
\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times l\Rightarrow(x\Rightarrow\bbnum 0+q\times x)^{\uparrow L}l
\end{array}\right|\\
 & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times p\Rightarrow(x^{:M^{A}}\Rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\left(\text{pu}_{L}\left(p+\bbnum 0\right)\right)\\
q_{1}\times q_{2}\times l\Rightarrow(x^{:M^{A}}\Rightarrow\bbnum 0^{:P}+q_{1}\times x)^{\uparrow L}(x\Rightarrow\bbnum 0+q_{2}\times x)^{\uparrow L}l
\end{array}\right|\\
 & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times p\Rightarrow\text{pu}_{L}(\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right))\\
q_{1}\times q_{2}\times l\Rightarrow(x^{:M^{A}}\Rightarrow\bbnum 0+q_{1}\times(\bbnum 0+q_{2}\times x))^{\uparrow L}l
\end{array}\right|\quad.
\end{align*}
Now we need to post-compose $\text{ftn}_{M}^{\uparrow L}$ with this
column:
\begin{align*}
\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L} & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0)\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\\
(q\times p\Rightarrow\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right))\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\\
q_{1}\times q_{2}\times l\Rightarrow l\triangleright(x^{:M^{A}}\Rightarrow\bbnum 0+q_{1}\times(\bbnum 0+q_{2}\times x))^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}
\end{array}\right|\\
{\color{greenunder}\text{pu}_{L}\text{'s naturality}:}\quad & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0)\bef\text{ftn}_{M}\bef\text{pu}_{L}\\
(q\times p\Rightarrow\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right))\bef\text{ftn}_{M}\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times l\Rightarrow l\triangleright(x^{:M^{A}}\Rightarrow\gunderline{\text{ftn}_{M}\left(\bbnum 0+q_{1}\times(\bbnum 0+q_{2}\times x)\right)})^{\uparrow L}
\end{array}\right|\\
{\color{greenunder}\text{compute }\text{ftn}_{M}(...):}\quad & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow\text{ftn}_{M}(x+\bbnum 0))\bef\text{pu}_{L}\\
(q\times p\Rightarrow\text{ftn}_{M}(\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right)))\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times l\Rightarrow l\triangleright(x^{:M^{A}}\Rightarrow\bbnum 0+\left(q_{1}\oplus q_{2}\right)\times x)^{\uparrow L}
\end{array}\right|\\
{\color{greenunder}\text{compute }\text{ftn}_{M}(...):}\quad & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
(q\times p\Rightarrow p+\bbnum 0)\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times l\Rightarrow(x^{:M^{A}}\Rightarrow\bbnum 0+\left(q_{1}\oplus q_{2}\right)\times x)^{\uparrow L}l
\end{array}\right|\quad.
\end{align*}
After renaming $l$ to $a$, this is the same as the column in Eq.~(\ref{eq:m-interchange-law-of-swap-linear-monads-left-hand-side}).

\paragraph{Monadic naturality laws}

Verify the laws of Theorem~\ref{subsec:Theorem-inside-transformer-swap-laws},
\[
\text{sw}_{\text{Id},M}=\text{id}\quad,\quad\quad\text{sw}_{L,M}\bef\phi=\phi^{\uparrow M}\bef\text{sw}_{N,M}\quad,\quad\quad\text{sw}_{L,M}\bef\theta^{\uparrow L}=\theta\quad.
\]
for arbitrary monadic morphisms $\phi:L\leadsto N$ and $\theta:M\leadsto\text{Id}$.

The first law is the swap identity law, $\text{sw}_{\text{Id},M}=\text{id}$:
\begin{align*}
 & \text{sw}_{\text{Id},M}\\
{\color{greenunder}\text{Eq.~(\ref{eq:single-valued-monad-def-of-swap}) with }L=\text{Id}:}\quad & =\begin{array}{|c||c|}
P & (x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{\text{Id}}\\
Q\times\text{Id}^{A} & q\times l\Rightarrow(a^{:A}\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow\text{Id}}l
\end{array}\\
{\color{greenunder}\text{matrix notation}:}\quad & =\begin{array}{|c||c|}
P & x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A}\\
Q\times A & q\times a\Rightarrow\bbnum 0^{:P}+q\times a
\end{array}\\
 & =\text{id}\quad.
\end{align*}

Begin with the left-hand side of the second law,
\begin{align*}
 & \text{sw}_{L,M}\bef\phi\\
{\color{greenunder}\text{definition of }\text{sw}_{L,M}:}\quad & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\Rightarrow(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l
\end{array}\right|\gunderline{\bef\phi}\\
{\color{greenunder}\text{compose with }\phi:}\quad & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\bef\phi\\
q\times l\Rightarrow l\triangleright\gunderline{(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\phi}
\end{array}\right|\\
{\color{greenunder}\text{naturality of }\phi:}\quad & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{N}\\
q\times l\Rightarrow l\triangleright\phi\bef(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow N}
\end{array}\right|\quad.
\end{align*}
The right-hand side is
\begin{align*}
 & \phi^{\uparrow M}\bef\text{sw}_{N,M}\\
 & =\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times l\Rightarrow q\times\phi\left(l\right)
\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{N}\\
q\times n\Rightarrow n\triangleright(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow N}
\end{array}\right|\\
{\color{greenunder}\text{composition}:}\quad & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{N}\\
q\times l\Rightarrow n\triangleright\phi\bef(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow N}
\end{array}\right|\quad.
\end{align*}
Both sides of the second law are now shown to be equal.

The left-hand side of the third law is
\begin{align}
 & \text{sw}_{L,M}\bef\theta^{\uparrow L}\nonumber \\
{\color{greenunder}\text{compose with }\theta^{\uparrow L}:}\quad & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\text{pu}_{L}\bef\theta^{\uparrow L}}\\
q\times l\Rightarrow l\triangleright(a\Rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\theta^{\uparrow L}
\end{array}\right|\nonumber \\
{\color{greenunder}\text{naturality of }\text{pu}_{L}:}\quad & =\left\Vert \begin{array}{c}
(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\theta\bef\text{pu}_{L}\\
q\times l\Rightarrow l\triangleright\big(a\Rightarrow\theta(\bbnum 0^{:P}+q\times a)\big)^{\uparrow L}
\end{array}\right|\quad.\label{eq:linear-monads-monadic-naturality-of-swap-2}
\end{align}
We expect this to equal the right-hand side, which we write as
\begin{align}
 & m^{:M^{L^{A}}}\Rightarrow\theta(m)\nonumber \\
{\color{greenunder}\text{matrix notation}:}\quad & =\left\Vert \begin{array}{c}
x^{:P}\Rightarrow\theta(x+\bbnum 0^{:Q\times L^{A}})\\
q\times l\Rightarrow\theta(\bbnum 0^{:P}+q\times l)
\end{array}\right|\quad.\label{eq:linear-monads-monadic-naturality-of-swap-1}
\end{align}
Now consider each line in Eq.~(\ref{eq:linear-monads-monadic-naturality-of-swap-2})
separately. The upper line can be transformed as
\begin{align*}
 & (x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\theta\bef\text{pu}_{L}}\\
{\color{greenunder}\text{naturality of }\theta:}\quad & =(x^{:P}\Rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\text{pu}_{L}^{\uparrow M}}\bef\theta\\
{\color{greenunder}\text{definition of }^{\uparrow M}:}\quad & =x^{:P}\Rightarrow\left\Vert \begin{array}{cc}
x\enskip & \bbnum 0\end{array}\right|\triangleright\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times l\Rightarrow q\times\text{pu}_{L}l
\end{array}\right|\bef\theta\\
{\color{greenunder}\text{matrix notation}:}\quad & =x^{:P}\Rightarrow(x+\bbnum 0^{:Q\times L^{A}})\triangleright\theta\quad.
\end{align*}
This is now equal to the upper line of Eq.~(\ref{eq:linear-monads-monadic-naturality-of-swap-1}).

To proceed with the proof for the lower line of Eq.~(\ref{eq:linear-monads-monadic-naturality-of-swap-2}),
we need to evaluate the monadic morphism $\theta:M^{A}\Rightarrow A$
on a specific value of type $M^{A}$ of the form $\bbnum 0+q\times a$.
We note that the value $\theta(\bbnum 0+q\times a)$ must be of type
$A$ and must be computed in the same way for all types $A$, because
$\theta$ is a natural transformation. It seems clear that the result
cannot depend on the value $q^{:Q}$ since $Q$ is a type not related
to $A$. In other words, we expect that $\theta(\bbnum 0+q\times a)=a$
as a consequence of naturality of $\theta$. To derive this formally,
we use the trick of starting with a unit type, $\bbnum 1$, and mapping
it to $a$ within the naturality law. For any values $q^{:Q}$, $a^{:A}$,
we define 
\begin{align*}
 & m^{:P+Q\times A}\triangleq\bbnum 0^{:P}+q\times a\quad,\\
 & m_{1}^{:P+Q\times\bbnum 1}\triangleq\bbnum 0^{:P}+q\times1\quad.
\end{align*}
We can compute $m$ from $m_{1}$ if we replace $1$ by $a$ under
the functor $M$. To write this as a formula, define the function
$f^{:\bbnum 1\Rightarrow A}$ as $f\triangleq\left(\_\Rightarrow a\right)$
using the fixed value $a$. Then we have $m=f^{\uparrow M}m_{1}$.
Now we apply both sides of the naturality law $f^{\uparrow M}\bef\theta=\theta\bef f$
to the value $m_{1}$:
\[
m_{1}\triangleright f^{\uparrow M}\bef\theta=m_{1}\triangleright\theta\bef f\quad.
\]
Simplify the left-hand side to
\[
m_{1}\triangleright f^{\uparrow M}\bef\theta=\theta(f^{\uparrow M}m_{1})=\theta(m)=\theta(\bbnum 0^{:P}+q\times a)\quad.
\]
Simplify the right-hand side to 
\[
m_{1}\triangleright\theta\bef f=f\left(\theta\left(m_{1}\right)\right)=a\quad,
\]
since $f$ always returns $a$. Therefore 
\begin{equation}
\theta(\bbnum 0^{:P}+q\times a)=a\quad.\label{eq:runner-on-linear-monads}
\end{equation}
We can now compute the second line in Eq.~(\ref{eq:linear-monads-monadic-naturality-of-swap-2})
as
\begin{align*}
 & q\times l\Rightarrow l\triangleright\big(a\Rightarrow\theta(\bbnum 0^{:P}+q\times a)\big)^{\uparrow L}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:runner-on-linear-monads})}:}\quad & =q\times l\Rightarrow l\,\gunderline{\triangleright\,\big(a\Rightarrow a\big)^{\uparrow L}}\\
{\color{greenunder}\text{identity law}:}\quad & =q\times l\Rightarrow l\quad.
\end{align*}
The second line in Eq.~(\ref{eq:linear-monads-monadic-naturality-of-swap-1})
is the same function, $q\times l\Rightarrow l$.

This concludes the proof of the swap laws for linear monads. It follows
that linear monads have monad transformers of composed-inside kind.

\subsection{Composition of transformers for linear monads}

We have just shown that the ``\inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}/\inputencoding{latin9}\lstinline!Writer!\inputencoding{utf8}''
monad $M^{A}\triangleq P+Q\times A$ has the \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function that satisfies the laws necessary for a composed-inside transformer.
The other type of linear monad is the ``\inputencoding{latin9}\lstinline!Writer!\inputencoding{utf8}/\inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}''
monad $W^{A}\triangleq Q\times\left(P+A\right)$. Wo we need to show
separately that the monad $W$ has a lawful \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function? Actually, this follows from the stacking property of monad
transformers (see Sections~\ref{subsec:Stacking-two-monads}–\ref{subsec:Stacking-any-number-of-monads}).
The monad $W$ is a functor composition of the \inputencoding{latin9}\lstinline!Writer!\inputencoding{utf8}
monad $Q\times A$ with the \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
monad $P+A$, which is the same as applying the \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
monad's transformer to the \inputencoding{latin9}\lstinline!Writer!\inputencoding{utf8}
monad. Because of the transformer stacking property, the monad transformer
of $W$ works as composed-inside.

We can show in general that the functor composition of any two linear
monads has a composed-inside transformer. Suppose $M_{1}$ and $M_{2}$
are linear monads, so their transformers are of the composed-inside
kind:
\[
T_{M_{1}}^{N}=N\circ M_{1}\quad,\quad\quad T_{M_{2}}^{N}=N\circ M_{2}\quad.
\]
The functor composition of $M_{1}$ and $M_{2}$ can be seen as a
monad stack,
\[
M_{1}\circ M_{2}=T_{M_{2}}^{M_{1}}\quad.
\]
What is the transformer for the monad $M_{1}\circ M_{2}$? For any
foreign monad $N$, we have the transformer stack
\[
T_{M_{2}}^{T_{M_{1}}^{N}}=T_{M_{2}}^{N\circ M_{1}}=N\circ M_{1}\circ M_{2}\quad.
\]
Since this is a transformer stack, it is a lawful monad transformer,
as we have seen in Section~\ref{subsec:Stacking-two-monads}. So,
this is the monad transformer for $M_{1}\circ M_{2}$, and it is of
the composed-inside kind.

\section{Composed-outside transformers: Rigid monads\label{sec:transformers-rigid-monads}}

Section~\ref{sec:transformers-linear-monads} shows that the composed-inside
monad transformers are available only for a limited subset of all
monads, namely the monads\index{monads!linear} of the form $M^{A}=P+Q\times A$
and $M^{A}=Q\times\left(P+A\right)$, called ``linear''. It turns
out that the composed-\emph{outside} transformers are available for
a significantly wider range of monads. Those monads are called ``rigid''
because one of their general properties is having a single ``shape''
(Theorem~\ref{subsec:Statement-rigid-functor-wrapped-unit-is-unit}
in Section~\ref{subsec:Rigid-functors}).\index{monads!rigid} (There
does not seem to be an already accepted name for monads of this kind.)

\paragraph{Definition of rigid monads}

A monad $R$ is \textbf{rigid} if it has a lawful composed-outside
monad transformer, $T_{R}^{M}=R\circ M$, where $M$ is a foreign
monad. 

This definition does not explain what monads are rigid or how to recognize
a non-rigid monad. These questions will be answered below.

Two simplest examples of rigid monads are the \inputencoding{latin9}\lstinline!Reader!\inputencoding{utf8}
monad and the \inputencoding{latin9}\lstinline!Search!\inputencoding{utf8}
monad, 
\begin{align*}
\text{(the \texttt{Reader} monad)} & :\quad\quad R^{A}\triangleq Z\Rightarrow A\quad,\\
\text{(the \texttt{Search} monad)} & :\quad\quad S^{A}\triangleq\left(A\Rightarrow Z\right)\Rightarrow A\quad,
\end{align*}
where $Z$ is a fixed type. These monads have composed-outside transformers:
\begin{align*}
\text{(the \texttt{ReaderT} transformer)} & :\quad\quad T_{R}^{M,A}\triangleq Z\Rightarrow M^{A}\quad,\\
\text{(the \texttt{SearchT} transformer)} & :\quad\quad T_{S}^{M,A}\triangleq\left(M^{A}\Rightarrow Z\right)\Rightarrow M^{A}\quad.
\end{align*}
To build intuition for rigid monads, we will look at some general
constructions that create new rigid monads or combine existing rigid
monads into new ones. In this section, we will prove that the following
four constructions produce rigid monads:
\begin{enumerate}
\item Choice: $C^{A}\triangleq H^{A}\Rightarrow A$ is a rigid monad if
$H$ is any contrafunctor.
\item Composition: $P\circ R$ is a rigid monad if $P$ and $R$ are rigid
monads.
\item Product: $P^{A}\times R^{A}$ is a rigid monad if $P$ and $R$ are
rigid monads.
\item Selector: $S^{A}\triangleq F^{A\Rightarrow R^{Q}}\Rightarrow R^{A}$
is a rigid monad for any rigid monad $R$, any functor $F$, and any
fixed type $Q$.
\end{enumerate}
I do not know whether these four constructions are the only possible
ways of creating new rigid monads. Below I will also mention other
open questions I have about rigid monads.

\subsection{Rigid monad construction 1: choice\label{subsec:Rigid-monad-construction-1-choice}}

The construction I call \index{monads!choice monad}the \textbf{choice}
monad, $R^{A}\triangleq H^{A}\Rightarrow A$, defines a rigid monad
$R$ for \emph{any} given contrafunctor $H$. 

This monad chooses a value of type $A$ given a contrafunctor $H$
that may \emph{consume} values of type $A$ (and presumably could
check some conditions on those values). The contrafunctor $H$ could
be a constant contrafunctor $H^{A}\triangleq Q$, a function such
as $H^{A}\triangleq A\Rightarrow Q$, or a more complicated contrafunctor.

Different choices of the contrafunctor $H$ give specific examples
of rigid monads, such as $R^{A}\triangleq\bbnum 1$ (the unit monad),
$R^{A}\triangleq A$ (the identity monad), $R^{A}\triangleq Z\Rightarrow A$
(the reader monad), as well as the \textbf{search}\footnote{See \href{http://math.andrej.com/2008/11/21/}{http://math.andrej.com/2008/11/21/}}\textbf{
monad}\index{monads!search monad}\index{search monad} $R^{A}\triangleq\left(A\Rightarrow Q\right)\Rightarrow A$. 

The search monad represents the effect of searching for a value of
type $A$ that satisfies a condition expressed through a function
of type $A\Rightarrow Q$. The simplest example of a search monad
is found by setting $Q\triangleq\text{Bool}$. One may implement a
function of type $\left(A\Rightarrow\text{Bool}\right)\Rightarrow A$
that \emph{somehow} finds a value of type $A$ that might satisfy
the given predicate of type $A\Rightarrow\text{Bool}$. The intention
is to return a value that, if possible, satisfies the predicate. If
no such value can be found, \emph{some} value of type $A$ is still
returned.

A closely related monad is the search-with-failure monad, $R^{A}\triangleq\left(A\Rightarrow\text{Bool}\right)\Rightarrow\bbnum 1+A$.
This (non-rigid) monad will return an empty value $1+\bbnum 0^{:A}$
if no value satisfing the predicate was found. There is a natural
transformation from the search monad to the search-with-failure monad,
implemented by checking whether the value returned by the search monad
does actually satisfies the predicate.

Assume that $H$ is a contrafunctor and $M$ is a monad, and denote
for brevity 
\[
T^{A}\triangleq R^{M^{A}}\triangleq H^{M^{A}}\Rightarrow M^{A}\quad.
\]
We will first give a self-contained proof that $T$ is a monad. To
verify the laws of monad transformers for $T$, we will derive the
\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8} function
and verify its laws.

\subsubsection{Statement \label{subsec:Statement-choice-monad-direct-proof}\ref{subsec:Statement-choice-monad-direct-proof}}

$T^{\bullet}\triangleq R^{M^{\bullet}}\triangleq H^{M^{\bullet}}\Rightarrow M^{\bullet}$
is a monad if $M$ is any monad and $H$ is any contrafunctor. (If
we set $M^{A}\triangleq A$, this also proves that $R$ itself is
a monad.)

\subparagraph{Proof}

We need to define the monad instance for $T$ and prove the identity
and the associativity laws for $T$, assuming that the monad $M$
satisfies these laws.

To define the monad instance for $T$, it is convenient to use the
Kleisli formulation of the monad. In this formulation, we consider
Kleisli morphisms of type $A\Rightarrow T^{B}$ and then define the
Kleisli identity morphism, $\text{pu}_{T}:A\Rightarrow T^{A}$, and
the Kleisli product operation $\diamond_{T}$,
\[
f^{:A\Rightarrow T^{B}}\diamond_{T}g^{:B\Rightarrow T^{C}}:A\Rightarrow T^{C}\quad.
\]
We are then required to define the operation $\diamond_{T}$ and to
prove identity and associativity laws for it.

We notice that since the type constructor $R$ is itself a function
type $H^{A}\Rightarrow A$, the type of the Kleisli morphism $A\Rightarrow T^{B}$
is actually $A\Rightarrow T^{B}\triangleq A\Rightarrow H^{M^{B}}\Rightarrow M^{B}$.
While proving the monad laws for $T$, we will need to use the monad
laws for $M$ (since $M$ is an arbitrary, unknown monad). In order
to use the monad laws for $M$, it would be helpful if we had the
Kleisli morphisms for $M$ of type $A\Rightarrow M^{B}$ more easily
available. If we flip the curried arguments of the Kleisli morphism
type $A\Rightarrow H^{M^{B}}\Rightarrow M^{B}$ and instead consider
the \textbf{flipped Kleisli\index{flipped Kleisli}} morphisms of
type $H^{M^{B}}\Rightarrow A\Rightarrow M^{B}$, the type $A\Rightarrow M^{B}$
will be easier to reason about. Since the type $A\Rightarrow H^{M^{B}}\Rightarrow M^{B}$
is equivalent to $A\Rightarrow H^{M^{B}}\Rightarrow M^{B}$, any laws
we prove for the flipped Kleisli morphisms will yield the corresponding
laws for the standard Kleisli morphisms. The use of flipped Kleisli
morphisms makes the proof significantly shorter.

We temporarily denote by $\tilde{\text{pu}}_{T}$ and $\tilde{\diamond}_{T}$
the flipped Kleisli operations:
\begin{align*}
\tilde{\text{pu}}_{T} & :\ H^{M^{A}}\Rightarrow A\Rightarrow M^{A}\\
f^{:H^{M^{B}}\Rightarrow A\Rightarrow M^{B}}\tilde{\diamond}_{T}g^{:H^{M^{C}}\Rightarrow B\Rightarrow M^{C}} & :\ H^{M^{C}}\Rightarrow A\Rightarrow M^{C}\quad.
\end{align*}

To define the operations $\tilde{\text{pu}}_{T}$ and $\tilde{\diamond}_{T}$,
we may use the methods $\text{pu}_{M}$ and $\text{flm}_{M}$ as well
as the Kleisli product $\diamond_{M}$ for the given monad $M$. The
definitions are
\begin{align*}
\tilde{\text{pu}}_{T} & =q\Rightarrow\text{pu}_{M}\quad\text{(the argument }q\text{ is unused)},\\
f\tilde{\diamond}_{T}g & =q\Rightarrow\left(f\,p\right)\diamond_{M}\left(g\,q\right)\quad\text{where}\\
 & \quad p^{:H^{M^{B}}}=\left(\text{flm}_{M}\left(g\,q\right)\right)^{\downarrow H}q\quad.
\end{align*}
This definition works by using the Kleisli product $\diamond_{M}$
on values $f\,p:A\Rightarrow M^{B}$ and $g\,q:B\Rightarrow M^{C}$.
To obtain a value $p:H^{M^{B}}$, we use the function $\text{flm}_{M}\left(g\,q\right):M^{B}\Rightarrow M^{C}$
to $H$-contramap $q:H^{M^{C}}$ into $p:H^{M^{B}}$.

Written as a single expression, the definition of $\tilde{\diamond}_{T}$
is
\begin{equation}
f\tilde{\diamond}_{T}g=q\Rightarrow f\left(\left(\text{flm}_{M}\left(g\,q\right)\right)^{\downarrow H}q\right)\diamond_{M}\left(g\,q\right)\quad.\label{eq:def-flipped-kleisli}
\end{equation}
Checking the left identity law:
\begin{align*}
 & \tilde{\text{pu}}_{T}\tilde{\diamond}_{T}g\\
{\color{greenunder}\text{definition of }\tilde{\diamond}_{T}:}\quad & =q\Rightarrow\gunderline{\tilde{\text{pu}}_{T}\left(\left(\text{flm}_{M}\left(g\,q\right)\right)^{\downarrow H}q\right)}\diamond_{M}\left(g\,q\right)\\
{\color{greenunder}\text{definition of }\tilde{\text{pu}}_{T}:}\quad & =q\Rightarrow\gunderline{\text{pu}_{M}\diamond_{M}}g\,q\\
{\color{greenunder}\text{left identity law for }M:}\quad & =q\Rightarrow g\,q\\
{\color{greenunder}\text{function expansion}:}\quad & =g
\end{align*}
Checking the right identity law:
\begin{align*}
 & f\tilde{\diamond}_{T}\tilde{\text{pu}}_{T}\\
{\color{greenunder}\text{definition of }\tilde{\diamond}_{T}:}\quad & =q\Rightarrow f\left(\left(\text{flm}_{M}\left(\tilde{\text{pu}}_{T}q\right)\right)^{\downarrow H}q\right)\diamond_{M}\gunderline{\left(\tilde{\text{pu}}_{T}q\right)}\\
{\color{greenunder}\text{definition of }\tilde{\text{pu}}_{T}:}\quad & =q\Rightarrow f\left(\left(\text{flm}_{M}\left(\text{pu}_{M}\right)\right)^{\downarrow H}q\right)\gunderline{\diamond_{M}\text{pu}_{M}}\\
{\color{greenunder}\text{right identity law for }M:}\quad & =q\Rightarrow f\gunderline{\left(\left(\text{id}\right)^{\downarrow H}q\right)}\\
{\color{greenunder}\text{identity law for }H:}\quad & =q\Rightarrow f\,q\\
{\color{greenunder}\text{function expansion}:}\quad & =f
\end{align*}
Checking the associativity law: $\left(f\tilde{\diamond}_{T}g\right)\tilde{\diamond}_{T}h$
must equal $f\tilde{\diamond}_{T}\left(g\tilde{\diamond}_{T}h\right)$.
We have
\begin{align*}
 & \left(f\tilde{\diamond}_{T}g\right)\tilde{\diamond}_{T}h\\
 & =\left(s\Rightarrow f\left(\left(\text{flm}_{M}\left(g\,s\right)\right)^{\downarrow H}s\right)\diamond_{M}\left(g\,s\right)\right)\tilde{\diamond}_{T}h\\
 & =q\Rightarrow f\left(\left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}r\right)\diamond_{M}\left(g\,r\right)\diamond_{M}\left(h\,q\right)\quad\text{where}\\
 & \quad\quad\quad r\triangleq\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\quad;
\end{align*}
while 
\begin{align*}
 & f\tilde{\diamond}_{T}\left(g\tilde{\diamond}_{T}h\right)\\
 & =f\tilde{\diamond}_{T}\left(q\Rightarrow g\left(\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\right)\diamond_{M}\left(h\,q\right)\right)\\
 & =q\Rightarrow f\left(\left(\text{flm}_{M}\,k\right)^{\downarrow H}q\right)\diamond_{M}u\quad\text{where}\\
 & \quad\quad\quad r\triangleq\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\quad\text{and}\\
 & \quad\quad\quad u\triangleq\left(g\,r\right)\diamond_{M}\left(h\,q\right)\quad.
\end{align*}
It remains to show that the following two expressions are equal,
\begin{align*}
 & f\left(\left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}r\right)\diamond_{M}\left(g\,r\right)\diamond_{M}\left(h\,q\right)\quad\text{and}\\
 & f\left(\left(\text{flm}_{M}\left(\left(g\,r\right)\diamond_{M}\left(h\,q\right)\right)\right)^{\downarrow H}q\right)\diamond_{M}\left(g\,r\right)\diamond_{M}\left(h\,q\right),\quad\text{where}\\
 & \quad\quad\quad r\triangleq\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\quad.
\end{align*}
These two expressions differ only by the following sub-expressions,
\[
\left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}r
\]
and 
\[
\left(\text{flm}_{M}\left(\left(g\,r\right)\diamond_{M}\left(h\,q\right)\right)\right)^{\downarrow H}q\quad,
\]
where $r\triangleq\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q$.
Writing out the value $r$ in the last argument of $\left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}r$
but leaving $r$ unexpanded everywhere else, we now rewrite the differing
sub-expressions as
\begin{align*}
 & \left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\quad\text{and}\\
 & \left(\text{flm}_{M}\left(\left(g\,r\right)\diamond_{M}\left(h\,q\right)\right)\right)^{\downarrow H}q\quad.
\end{align*}
Now it becomes apparent that we need to put the two ``$\text{flm}_{M}$''s
closer together and to combine them by using the associativity law
of the monad $M$. Then we can rewrite the first sub-expression and
transform it into the second one:
\begin{align*}
 & \gunderline{\left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}}q\\
{\color{greenunder}\text{composition law for }H:}\quad & =\left(\text{flm}_{M}\left(g\,r\right)\bef\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\\
{\color{greenunder}\text{associativity law for }M:}\quad & =\gunderline{\left(\text{flm}_{M}\left(\left(g\,r\right)\bef\text{flm}_{M}\left(h\,q\right)\right)\right)}^{\downarrow H}q\\
{\color{greenunder}\text{definition of }\diamond_{M}\text{ via }\text{flm}_{M}:}\quad & =\left(\text{flm}_{M}\left(\left(g\,r\right)\diamond_{M}\left(h\,q\right)\right)\right)^{\downarrow H}q\quad.
\end{align*}
This proves the associativity law for $\tilde{\diamond}_{T}$.

\subsubsection{Statement \label{subsec:Statement-choice-monad-definition-of-flm}\ref{subsec:Statement-choice-monad-definition-of-flm}}

The monad methods for $T$ defined in Statement~\ref{subsec:Statement-choice-monad-direct-proof}
can be written equivalently as 
\begin{align}
\text{pu}_{T} & (a^{:A}):\ H^{M^{A}}\Rightarrow M^{A}\quad,\nonumber \\
\text{pu}_{T} & (a)\triangleq\left(\_\Rightarrow\text{pu}_{M}a\right)\quad;\nonumber \\
\text{flm}_{T} & \big(f^{:A\Rightarrow H^{M^{B}}\Rightarrow M^{B}}\big):\ \big(H^{M^{A}}\Rightarrow M^{A}\big)\Rightarrow H^{M^{B}}\Rightarrow M^{B}\quad,\nonumber \\
\text{flm}_{T} & f\triangleq t^{:R^{M^{A}}}\Rightarrow q^{:H^{M^{B}}}\Rightarrow\big(\text{flm}_{M}(x^{:A}\Rightarrow f\,x\,q)\big)^{\uparrow R}t\,q\quad.\label{eq:rigid-monad-flm-T-def}
\end{align}
Expressed through $R$'s \inputencoding{latin9}\lstinline!flatMap!\inputencoding{utf8}
method, which is implemented as
\begin{equation}
\text{flm}_{R}g^{:A\Rightarrow R^{B}}=t^{:R^{A}}\Rightarrow q^{:H^{B}}\Rightarrow(x^{:A}\Rightarrow g\,x\,q)^{\uparrow R}t\,q\quad,\label{eq:rigid-monad-flm-R-def}
\end{equation}
the method $\text{flm}_{T}$ can be written as
\begin{equation}
\text{flm}_{T}f=\text{flm}_{R}\left(y\Rightarrow q\Rightarrow\text{flm}_{M}(x\Rightarrow f\,x\,q)\,y\right)\quad.\label{eq:rigid-monad-def-flm-t-via-flm-r}
\end{equation}


\subparagraph{Proof}

The definition of $\tilde{\diamond}_{T}$ in Statement~\ref{subsec:Statement-choice-monad-direct-proof}
used the flipped types of Kleisli morphisms, which is not the standard
way of defining the methods of a monad. To restore the standard type
signatures, we need to unflip the arguments:
\begin{align*}
 & f^{:A\Rightarrow H^{M^{B}}\Rightarrow M^{B}}\diamond_{T}g^{:B\Rightarrow H^{M^{C}}\Rightarrow M^{C}}:\ A\Rightarrow H^{M^{C}}\Rightarrow M^{C}\quad;\\
 & f\diamond_{T}g=t\Rightarrow q\Rightarrow\left(\tilde{f}\left(\left(\text{flm}_{M}\left(b\Rightarrow g\,b\,q\right)\right)^{\downarrow H}q\right)\diamond_{M}\left(b\Rightarrow g\,b\,q\right)\right)t\quad,
\end{align*}
where $\tilde{f}\triangleq h\Rightarrow k\Rightarrow f\,k\,h$ is
the flipped version of $f$. To replace $\diamond_{M}$ by $\text{flm}_{M}$,
express $x\diamond_{M}y=x\bef\text{flm}_{M}y$ to find
\[
f\diamond_{T}g=t\Rightarrow q\Rightarrow\left(\tilde{f}\left(p^{\downarrow H}q\right)\bef p\right)t\quad\text{where }p=\text{flm}_{M}\left(x\Rightarrow g\,x\,q\right)\quad.
\]
To obtain an implementation of $\text{flm}_{T}$, express $\text{flm}_{T}$
through $\diamond_{T}$ as 
\[
\text{flm}_{T}g^{:A\Rightarrow T^{B}}=\text{id}^{:T^{A}\Rightarrow T^{A}}\diamond_{T}g\quad.
\]
Now we need to substitute $f^{:T^{A}\Rightarrow T^{A}}=\text{id}$
into $f\diamond_{T}g$. Noting that $\tilde{f}$ will then become
\[
\tilde{f}=\left(h\Rightarrow k\Rightarrow\text{id}\,k\,h\right)=\left(h\Rightarrow k\Rightarrow k\,h\right)\quad,
\]
we get
\begin{align*}
 & \text{flm}_{T}g^{:A\Rightarrow T^{B}}=\text{id}\bef\text{flm}_{T}g\\
{\color{greenunder}\text{definition of }\diamond_{T}:}\quad & =t^{:T^{A}}\Rightarrow q^{H^{M^{B}}}\Rightarrow\left(\tilde{f}\left(p^{\downarrow H}q\right)\bef p\right)t\\
 & \quad\quad\text{where }p\triangleq\text{flm}_{M}\left(x\Rightarrow g\,x\,q\right)\\
{\color{greenunder}\text{substitute }f=\text{id}:}\quad & =t\Rightarrow q\Rightarrow\left(\left(h\Rightarrow k\Rightarrow k\,h\right)\left(p^{\downarrow H}q\right)\bef p\right)t\\
{\color{greenunder}\text{apply }k\text{ to }p^{\downarrow H}q:}\quad & =t\Rightarrow q\Rightarrow\left(\left(k\Rightarrow k\left(p^{\downarrow H}q\right)\right)\bef p\right)t\\
{\color{greenunder}\text{definition of }\bef:}\quad & =t\Rightarrow q\Rightarrow p\left(t\left(p^{\downarrow H}q\right)\right)\quad.
\end{align*}
By definition of the functor $R^{A}\triangleq H^{A}\Rightarrow A$,
we raise any function $p^{:A\Rightarrow B}$ into $R$ as 
\begin{align*}
p^{\uparrow R} & :\left(H^{A}\Rightarrow A\right)\Rightarrow H^{B}\Rightarrow B\quad,\\
p^{\uparrow R}r^{H^{A}\Rightarrow A} & \triangleq p^{\downarrow H}\bef r\bef p\\
 & =q^{H^{B}}\Rightarrow p\left(r\left(p^{\downarrow H}q\right)\right)\quad.
\end{align*}
Finally, renaming $g$ to $f$, we obtain the desired code,
\[
\text{flm}_{T}f=t\Rightarrow q\Rightarrow p^{\uparrow R}t\,q\quad\text{where }p\triangleq\text{flm}_{M}\left(x\Rightarrow f\,x\,q\right)\quad.
\]

To express $\text{flm}_{T}$ via $\text{flm}_{R}$, we just need to
choose the value of $g$ such that Eq.~(\ref{eq:rigid-monad-flm-R-def})
becomes equal to Eq.~(\ref{eq:rigid-monad-flm-T-def}). Comparing
these two expressions, we find that we need
\[
\text{flm}_{M}(x\Rightarrow f\,x\,q)=(y\Rightarrow g\,y\,q)\quad.
\]
This is achieved if we define $g\,y\,q=\text{flm}_{M}(x^{:A}\Rightarrow f\,x\,q)\,y$,
or equivalently 
\[
g=y\Rightarrow q\Rightarrow\text{flm}_{M}(x\Rightarrow f\,x\,q)\,y\quad.
\]
This gives the desired Eq.~(\ref{eq:rigid-monad-def-flm-t-via-flm-r}).

\subsubsection{Statement \label{subsec:Statement-choice-monad-flatten-swap}\ref{subsec:Statement-choice-monad-flatten-swap}}

The monad $T$ has the methods \inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8} defined
by
\begin{align}
\text{ftn}_{T} & =t^{:T^{T^{A}}}\Rightarrow q^{:H^{M^{A}}}\Rightarrow q\triangleright\bigg(t\triangleright\big(\text{flm}_{M}(x^{:R^{M^{A}}}\Rightarrow x\,q)\big)^{\uparrow R}\bigg)\quad,\label{eq:rigid-monad-def-of-ftn-t-via-forward}\\
\text{sw}_{R,M} & =m^{:M^{R^{A}}}\Rightarrow q^{:H^{M^{A}}}\Rightarrow\big(r^{:R^{A}}\Rightarrow r(\text{pu}_{M}^{\downarrow H}q)\big)^{\uparrow M}m\quad.\label{eq:rigid-monad-short-formula-for-swap}
\end{align}
These functions are computationally equivalent (can be derived from
each other). In the $\triangleright$-notation, the formula for $\text{sw}_{R,M}$
is
\begin{equation}
q\triangleright\big(m\triangleright\text{sw}_{R,M}\big)=m\triangleright(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)^{\uparrow M}\quad.\label{eq:rigid-monad-1-forward-formula-for-swap}
\end{equation}


\subparagraph{Proof}

Using Eq.~(\ref{eq:rigid-monad-flm-T-def}) and the relationship
$\text{ftn}_{T}=\text{flm}_{T}\text{id}^{:T^{A}\Rightarrow T^{A}}$,
we find
\begin{align*}
\text{ftn}_{T}t^{:T^{T^{A}}} & =\gunderline{\text{flm}_{T}}(\text{id})\,t\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-flm-T-def})}:}\quad & =q\Rightarrow\big(\text{flm}_{M}(x^{:A}\Rightarrow f\,x\,q)\big)^{\uparrow R}\gunderline{t\,q}\\
{\color{greenunder}\text{definition of }\triangleright:}\quad & =q\Rightarrow\gunderline{q\triangleright\big(t\triangleright\big(}\text{flm}_{M}(x^{:A}\Rightarrow f\,x\,q)\big)^{\uparrow R}\big)\quad.
\end{align*}
Using Eq.~(\ref{eq:rigid-monad-def-flm-t-via-flm-r}) instead of
Eq.~(\ref{eq:rigid-monad-flm-T-def}), we get
\begin{align*}
\text{ftn}_{T} & =\text{flm}_{T}(\text{id})\\
 & =\text{flm}_{R}\left(y\Rightarrow q\Rightarrow\text{flm}_{M}(x\Rightarrow x\,q)\,y\right)\quad.
\end{align*}


\paragraph{Deriving the formulas for $\text{sw}_{R,M}$}

We start with $\text{ftn}_{T}$ as just obtained and substitute into
Eq.~(\ref{eq:define-swap-via-flatten}):
\begin{align}
\text{sw}_{R,M}(m) & =m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\bef\gunderline{\text{ftn}_{T}}\nonumber \\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-def-flm-t-via-flm-r})}:}\quad & =m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\gunderline{\text{pu}_{R}\bef\text{flm}_{R}}\left(y\Rightarrow q\Rightarrow\text{flm}_{M}(x\Rightarrow x\,q)\,y\right)\nonumber \\
{\color{greenunder}\text{left identity law of }R:}\quad & =m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\gunderline{\bef}\big(y\Rightarrow q\Rightarrow\text{flm}_{M}(x\Rightarrow x\,q)\gunderline{\,y}\big)\nonumber \\
{\color{greenunder}\triangleright\text{ notation}:}\quad & =m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\gunderline{\triangleright\big(y\Rightarrow}q\Rightarrow\gunderline y\triangleright\text{flm}_{M}(x\Rightarrow x\,q)\big)\\
{\color{greenunder}\text{apply to argument }y:}\quad & =q\Rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\triangleright\gunderline{\text{flm}_{M}}\left(x\Rightarrow x\,q\right)\nonumber \\
{\color{greenunder}\text{express }\text{flm}_{M}\text{ via }\text{ftn}_{M}:}\quad & =q\Rightarrow m\triangleright\gunderline{\text{pu}_{M}^{\uparrow R\uparrow M}\bef(x\Rightarrow x\,q)^{\uparrow M}}\bef\text{ftn}_{M}\nonumber \\
{\color{greenunder}\text{composition law of }M:}\quad & =q\Rightarrow m\triangleright\big(\text{pu}_{M}^{\uparrow R}\bef(x\Rightarrow x\,q)\big)^{\uparrow M}\bef\text{ftn}_{M}\quad.\label{eq:rigid-monad-swap-derivation2}
\end{align}
\begin{comment}
To derive the formula for $\text{sw}_{R,M}$, we start with $\text{ftn}_{T}$
as just obtained and substitute into Eq.~(\ref{eq:define-swap-via-flatten}):
\begin{align}
 & \text{sw}_{R,M}(m)=m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\gunderline{\bef\text{ftn}_{T}}\nonumber \\
{\color{greenunder}\triangleright\text{ notation}:}\quad & =\big(m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\big)\triangleright\gunderline{\text{ftn}_{T}}\nonumber \\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-def-of-ftn-t-via-forward})}:}\quad & =q\Rightarrow q\triangleright\bigg(\big(m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\gunderline{\big)\triangleright\big(}\text{flm}_{M}(x\Rightarrow x\,q)\big)^{\uparrow R}\bigg)\nonumber \\
{\color{greenunder}\triangleright\text{ notation}:}\quad & =q\Rightarrow q\triangleright\bigg(m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\gunderline{\text{pu}_{R}\bef\big(\text{flm}_{M}(x\Rightarrow x\,q)\big)^{\uparrow R}}\bigg)\nonumber \\
{\color{greenunder}\text{pu}_{R}\text{'s naturality}:}\quad & =q\Rightarrow q\triangleright\bigg(m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{flm}_{M}(x\Rightarrow x\,q)\bef\text{pu}_{R}\bigg)\quad.\label{eq:rigid-monad-swap-derivation1}
\end{align}
To proceed, we need to use the definition of $\text{pu}_{R}$ written
as $\text{pu}_{R}x\,y=x$, or in the forwarding notation, 
\[
y\triangleright\left(x\triangleright\text{pu}_{R}\right)=x\quad.
\]
With this simplification at hand, we continue from Eq.~(\ref{eq:rigid-monad-swap-derivation1})
as
\begin{align*}
{\color{greenunder}\text{Eq.~(\ref{eq:rigid-monad-swap-derivation1})}:}\quad & q\Rightarrow q\triangleright\bigg(\big(m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{flm}_{M}(x\Rightarrow x\,q)\gunderline{\big)\triangleright\text{pu}_{R}}\bigg)\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-pure-t-simplification})}:}\quad & =q\Rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\gunderline{\text{flm}_{M}(x\Rightarrow x\,q)}\\
{\color{greenunder}\text{express }\text{flm}_{M}\text{ via }\text{ftn}_{M}:}\quad & =q\Rightarrow m\triangleright\gunderline{\text{pu}_{M}^{\uparrow R\uparrow M}\bef(x\Rightarrow x\,q)^{\uparrow M}}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{composition law of }M:}\quad & =q\Rightarrow m\triangleright\big(\text{pu}_{M}^{\uparrow R}\bef(x\Rightarrow x\,q)\big)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}
\end{comment}
It appears that simplifying this expression requires to rewrite the
function $\text{pu}_{M}^{\uparrow R}\bef(x\Rightarrow x\,q)$. To
proceed further, we need to use the definition of raising a function
$f^{:A\Rightarrow B}$ to the functor $R$,
\[
f^{\uparrow R}\triangleq r^{:R^{A}}\Rightarrow f^{\downarrow H}\bef r\bef f\quad,
\]
so we can write
\begin{align}
 & \text{pu}_{M}^{\uparrow R}\bef(x\Rightarrow x\,q)\nonumber \\
{\color{greenunder}\text{function composition}:}\quad & =r\Rightarrow\gunderline{\text{pu}_{M}^{\uparrow R}r\,q}\nonumber \\
{\color{greenunder}\text{definition of }^{\uparrow R}:}\quad & =\gunderline{r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\bef}\text{pu}_{M}\nonumber \\
{\color{greenunder}\text{forward composition}:}\quad & =\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\bef\text{pu}_{M}\quad.\label{eq:rigid-monad-swap-derivation3}
\end{align}
In deriving Eq.~(\ref{eq:rigid-monad-swap-derivation3}), we used
the general property of the forward composition,
\[
x\Rightarrow y\triangleright f(x,y)\bef g\quad=\quad\left(x\Rightarrow y\triangleright f(x,y)\right)\bef g\quad,
\]
where $g$ must not depend on $x$ or $y$. We can now rewrite Eq.~(\ref{eq:rigid-monad-swap-derivation2})
as
\begin{align*}
 & q\Rightarrow m\triangleright\big(\gunderline{\text{pu}_{M}^{\uparrow R}\bef(x\Rightarrow x\,q)}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-swap-derivation3})}:}\quad & =q\Rightarrow m\triangleright\big(\gunderline{(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\bef\text{pu}_{M}}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{functor composition for }M:}\quad & =q\Rightarrow m\triangleright\big((r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\bef\gunderline{\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{identity law of }M:}\quad & =q\Rightarrow\gunderline{m\triangleright\big(}(r\Rightarrow\gunderline{q\triangleright\text{pu}_{M}^{\downarrow H}\bef r})\big)^{\uparrow M}\\
{\color{greenunder}\triangleright\text{ notation}:}\quad & =q\Rightarrow\big(r\Rightarrow r(\text{pu}_{M}^{\downarrow H}q)\big)^{\uparrow M}m\quad.
\end{align*}
The last expression coincides with Eq.~(\ref{eq:rigid-monad-short-formula-for-swap}).

The formula~(\ref{eq:rigid-monad-1-forward-formula-for-swap}) follows
by applying Eq.~(\ref{eq:rigid-monad-short-formula-for-swap}) to
the arguments $m$ and $q$. To make the computation clearer, we rename
the bound variables $m$ and $q$ inside Eq.~(\ref{eq:rigid-monad-short-formula-for-swap})
to $m_{1}$ and $q_{1}$:
\begin{align*}
 & q\triangleright\big(\gunderline{m\triangleright\big(m_{1}}\Rightarrow q_{1}\Rightarrow\big(r\Rightarrow r(\text{pu}_{M}^{\downarrow H}q_{1})\big)^{\uparrow M}\gunderline{m_{1}}\big)\big)\\
{\color{greenunder}\text{apply to argument }m:}\quad & =\gunderline{q\triangleright\big(q_{1}}\Rightarrow m\triangleright\big(r\Rightarrow r(\text{pu}_{M}^{\downarrow H}\gunderline{q_{1}})\big)^{\uparrow M}\big)\\
{\color{greenunder}\text{apply to argument }q:}\quad & =m\triangleright\big(r\Rightarrow\gunderline{r(\text{pu}_{M}^{\downarrow H}q)}\big)^{\uparrow M}\\
{\color{greenunder}\triangleright\text{ notation}:}\quad & =m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\quad.
\end{align*}


\paragraph{Deriving $\text{ftn}_{T}$ from $\text{sw}_{R,M}$}

Given the \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function defined by Eq.~(\ref{eq:rigid-monad-short-formula-for-swap}),
we can recover the original $\text{ftn}_{T}$ function from Eq.~(\ref{eq:rigid-monad-def-of-ftn-t-via-forward})
via the standard formula~(\ref{eq:define-flatten-via-swap}), $\text{ftn}_{T}=\text{sw}^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{M}^{\uparrow R}$:
\begin{align}
 & \text{sw}^{\uparrow R}\bef\gunderline{\text{ftn}_{R}\bef\text{ftn}_{M}^{\uparrow R}}\nonumber \\
{\color{greenunder}\text{naturality of }\text{ftn}_{R}:}\quad & =\gunderline{\text{sw}^{\uparrow R}\bef\text{ftn}_{M}^{\uparrow R\uparrow R}}\bef\text{ftn}_{R}\nonumber \\
{\color{greenunder}\text{composition under }R:}\quad & =\big(\text{sw}\bef\text{ftn}_{M}^{\uparrow R}\gunderline{\big)^{\uparrow R}\bef\text{ftn}_{R}}\nonumber \\
{\color{greenunder}\text{relating }\text{flm}_{R}\text{ and }\text{ftn}_{R}:}\quad & =\gunderline{\text{flm}_{R}(}\text{sw}\bef\text{ftn}_{M}^{\uparrow R})\nonumber \\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-flm-R-def})}:}\quad & =t\Rightarrow q\Rightarrow(x^{:A}\Rightarrow(\text{sw}\bef\text{ftn}_{M}^{\uparrow R})\,x\,q)^{\uparrow R}\,t\,q\quad.\label{eq:rigid-monad-swap-ftn-derivation-4a}
\end{align}
To proceed, we need to transform $\text{sw}\bef\text{ftn}_{M}^{\uparrow R}$
in some way:
\begin{align}
 & \text{sw}\bef\text{ftn}_{M}^{\uparrow R}\nonumber \\
{\color{greenunder}\text{definitions}:}\quad & =\big(m\Rightarrow q\Rightarrow m\triangleright\big((r\Rightarrow\gunderline q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\big)\bef(\gunderline{r\Rightarrow\text{ftn}_{M}^{\downarrow H}\bef r\bef\text{ftn}_{M}})\nonumber \\
{\color{greenunder}\text{composition}:}\quad & =m\Rightarrow\gunderline{\text{ftn}_{M}^{\downarrow H}}\bef\big(q\Rightarrow m\triangleright\big((r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\nonumber \\
{\color{greenunder}\text{expansion}:}\quad & =m\Rightarrow\big(q\Rightarrow\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}}\big)\bef\big(q\Rightarrow m\triangleright\big((r\Rightarrow\gunderline q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\nonumber \\
{\color{greenunder}\text{composition}:}\quad & =m\Rightarrow\big(q\Rightarrow m\triangleright\big((r\Rightarrow\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r)\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\quad.\label{eq:rigid-monad-swap-ftn-derivation4}
\end{align}
We can transform the sub-expression $(r\Rightarrow q\triangleright\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}\bef r)$
to
\begin{align}
{\color{greenunder}\triangleright\text{ notation}:}\quad & r\Rightarrow q\triangleright\gunderline{\text{ftn}_{M}^{\downarrow H}\bef\text{pu}_{M}^{\downarrow H}}\bef r\nonumber \\
{\color{greenunder}\text{composition law of }H:}\quad & =r\Rightarrow q\triangleright(\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}})^{\downarrow H}\bef r\nonumber \\
{\color{greenunder}\text{left identity law of }M:}\quad & =r\Rightarrow\gunderline{q\triangleright r}\nonumber \\
{\color{greenunder}\triangleright\text{ notation}:}\quad & =r\Rightarrow r(q)\quad.\label{eq:rigid-monad-swap-ftn-derivation5}
\end{align}
Using this simplification, we continue transforming Eq.~(\ref{eq:rigid-monad-swap-ftn-derivation4})
as
\begin{align*}
 & m\Rightarrow\big(q\Rightarrow m\triangleright\big((r\Rightarrow\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}\bef r})\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-swap-ftn-derivation5})}:}\quad & =m\Rightarrow\gunderline{\big(}q\Rightarrow m\triangleright(r\Rightarrow r(q))^{\uparrow M}\gunderline{\big)\bef}\text{ftn}_{M}\\
{\color{greenunder}\text{composition}:}\quad & =m\Rightarrow q\Rightarrow m\triangleright(r\Rightarrow r(q)\gunderline{)^{\uparrow M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{relating }\text{flm}_{M}\text{ and }\text{ftn}_{M}:}\quad & =m\Rightarrow q\Rightarrow\text{flm}_{M}\left(r\Rightarrow r(q)\right)m\quad.
\end{align*}
Substituting this instead of $\text{sw}\bef\text{ftn}_{M}^{\uparrow R}$
into Eq.~(\ref{eq:rigid-monad-swap-ftn-derivation-4a}), we get
\begin{align*}
 & \quad t\Rightarrow q\Rightarrow(x\Rightarrow(\gunderline{\text{sw}\bef\text{ftn}_{M}^{\uparrow R}})\,x\,q)^{\uparrow R}\,t\,q\\
 & =t\Rightarrow q\Rightarrow(x\Rightarrow\text{flm}_{M}\left(r\Rightarrow r(q)\right)x)^{\uparrow R}\,t\,q\quad.
\end{align*}
The last expression is the same as Eq.~(\ref{eq:rigid-monad-def-of-ftn-t-via-forward}).

\subsubsection{Statement \label{subsec:Statement-swap-laws-rigid-monad}\ref{subsec:Statement-swap-laws-rigid-monad}}

Without assuming the monad laws for the function $\text{ftn}_{T}$,
the laws in Theorem~\ref{sec:Theorem-swap-laws-to-monad-transformer-first-law}
hold for the \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function defined by Eq.~(\ref{eq:rigid-monad-short-formula-for-swap}).

\subparagraph{Proof}

After replacing the base monad $L$ by $R$, the required laws are
\begin{align*}
\text{pu}_{R}^{\uparrow M}\bef\text{sw}=\text{pu}_{R}\quad, & \quad\quad\text{pu}_{M}\bef\text{sw}=\text{pu}_{M}^{\uparrow R}\quad,\\
\text{ftn}_{R}^{\uparrow M}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow R}\bef\text{ftn}_{R}\quad, & \quad\quad\text{ftn}_{M}\bef\text{sw}=\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow R}\quad.
\end{align*}


\paragraph{Proof of the inner-identity law}

Compute
\begin{align}
 & \text{pu}_{R}^{\uparrow M}\bef\gunderline{\text{sw}}\nonumber \\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-short-formula-for-swap})}:}\quad & =\big(m\Rightarrow\gunderline{m\triangleright\text{pu}_{R}^{\uparrow M}}\big)\bef\big(m\Rightarrow q\Rightarrow\gunderline m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\big)\nonumber \\
{\color{greenunder}\text{function composition}:}\quad & =m\Rightarrow q\Rightarrow m\triangleright\gunderline{\text{pu}_{R}^{\uparrow M}\bef\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}}\nonumber \\
{\color{greenunder}\text{functor law of }M:}\quad & =m\Rightarrow q\Rightarrow m\triangleright\big(\text{pu}_{R}\bef\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\big)^{\uparrow M}\quad.\label{eq:swap-laws-derivation1a}
\end{align}
To proceed, we simplify the expression $\text{pu}_{R}\bef(r\Rightarrow...)$:
\begin{align}
 & \text{pu}_{R}\bef\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\nonumber \\
{\color{greenunder}\text{argument expansion}:}\quad & =(m\Rightarrow m\triangleright\text{pu}_{R})\bef\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright r\big)\nonumber \\
{\color{greenunder}\text{function composition}:}\quad & =m\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright\left(m\triangleright\text{pu}_{R}\right)\quad.\label{eq:swap-laws-derivation1}
\end{align}
We now have to use the definition of $\text{pu}_{R}$, which is $\text{pu}_{R}=x\Rightarrow y\Rightarrow x$,
or in the forwarding notation, 
\begin{equation}
y\triangleright\left(x\triangleright\text{pu}_{R}\right)=x\quad.\label{eq:rigid-monad-pure-t-simplification-1}
\end{equation}
With this simplification at hand, we continue from Eq.~(\ref{eq:swap-laws-derivation1})
to
\begin{align*}
 & m\Rightarrow\gunderline{q\triangleright\text{pu}_{M}^{\downarrow H}}\triangleright\left(m\triangleright\text{pu}_{R}\right)\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-pure-t-simplification-1})}:}\quad & =m\Rightarrow m=\text{id}\quad.
\end{align*}
Therefore, Eq.~(\ref{eq:swap-laws-derivation1a}) becomes
\begin{align*}
 & m\Rightarrow q\Rightarrow m\triangleright\gunderline{\big(\text{pu}_{R}\bef\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\big)^{\uparrow M}}\\
 & =(m\Rightarrow q\Rightarrow\gunderline{m\triangleright\text{id}})\\
 & =(m\Rightarrow q\Rightarrow m)=\text{pu}_{R}\quad.
\end{align*}
This proves the inner-identity law.

\paragraph{Proof of the outer-identity law}

The left-hand side of this law is
\begin{align*}
 & \text{pu}_{M}\bef\gunderline{\text{sw}}\\
{\color{greenunder}\text{Eq.~(\ref{eq:rigid-monad-short-formula-for-swap})}:}\quad & =\big(m\Rightarrow\gunderline{m\triangleright\text{pu}_{M}}\big)\bef\big(m\Rightarrow q\Rightarrow\gunderline m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\big)\\
{\color{greenunder}\text{function composition}:}\quad & =m\Rightarrow q\Rightarrow m\triangleright\gunderline{\text{pu}_{M}\bef\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}}\\
{\color{greenunder}\text{naturality of }\text{pu}_{M}:}\quad & =m\Rightarrow q\Rightarrow m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\bef\text{pu}_{M}\\
{\color{greenunder}\triangleright\text{ notation}:}\quad & =m\Rightarrow q\Rightarrow\gunderline{m\triangleright\big(r\Rightarrow}q\triangleright\text{pu}_{M}^{\downarrow H}\bef\gunderline r\bef\text{pu}_{M}\big)\\
{\color{greenunder}\text{apply function to }m:}\quad & =m\Rightarrow\gunderline{q\Rightarrow q}\triangleright\text{pu}_{M}^{\downarrow H}\bef m\bef\text{pu}_{M}\\
{\color{greenunder}\text{argument expansion}:}\quad & =m\Rightarrow\text{pu}_{M}^{\downarrow H}\bef m\bef\text{pu}_{M}\\
{\color{greenunder}\text{definition of }{}^{\uparrow R}:}\quad & =\text{pu}_{M}^{\uparrow R}\quad.
\end{align*}
This is equal to the right-hand side of the law.

\paragraph{Proof of the inner-interchange law}

The law is written as
\begin{equation}
\vspace{-0.25cm}\text{ftn}_{R}^{\uparrow M}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow R}\bef\text{ftn}_{R}\quad.\label{eq:swap-law-3-formulation-R-M}
\end{equation}
We will apply both sides of the law to arbitrary $m^{:M^{R^{R^{A}}}}$
and $q^{:H^{M^{A}}}$, and transform both sides to the same expression. 

Below, we will need a simplified formula for $\text{ftn}_{R}$ derived
from Eq.~(\ref{eq:rigid-monad-flm-R-def}):
\begin{align}
\text{ftn}_{R} & =\text{flm}_{R}(\text{id})\nonumber \\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-flm-R-def})}:}\quad & =t\Rightarrow q\Rightarrow(x\Rightarrow x\,q)^{\uparrow R}t\,q\nonumber \\
{\color{greenunder}\text{definition of }^{\uparrow R}:}\quad & =t\Rightarrow q\Rightarrow\gunderline{\big(r\Rightarrow}(x\Rightarrow x\,q)^{\downarrow H}\bef r\bef(x\Rightarrow x\,)\gunderline{\big)\,t}\,q\nonumber \\
{\color{greenunder}\text{apply to argument}:}\quad & =t\Rightarrow q\Rightarrow\big((x\Rightarrow q\triangleright x)^{\downarrow H}\bef t\bef(x\gunderline{\Rightarrow x\,q})\gunderline{\big)\,q}\nonumber \\
{\color{greenunder}\text{use }\triangleright\text{ notation}:}\quad & =t\Rightarrow q\Rightarrow\gunderline{q\triangleright\big(q\triangleright(}x\Rightarrow q\triangleright x)^{\downarrow H}\bef t\big)\quad.\label{eq:ftn-R-simplified}
\end{align}
We first apply the left-hand side of the law~(\ref{eq:swap-law-3-formulation-R-M})
to $m$ and $q$:
\begin{align*}
 & q\triangleright\big(m\triangleright\text{ftn}_{R}^{\uparrow M}\gunderline{\bef}\text{sw}\big)\\
\triangleright\text{ notation}: & =q\triangleright\big(m\triangleright\text{ftn}_{R}^{\uparrow M}\triangleright\gunderline{\text{sw}}\big)\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:}\quad & =m\triangleright\gunderline{\text{ftn}_{R}^{\uparrow M}\bef(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)^{\uparrow M}}\\
{\color{greenunder}\text{composition law for }M:}\quad & =m\triangleright\big(\text{ftn}_{R}\bef(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\quad.
\end{align*}
We now need to simplify the sub-expression under $(...)^{\uparrow M}$:
\begin{align*}
 & \text{ftn}_{R}\gunderline{\bef(r}\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright r)\\
{\color{greenunder}\text{function composition}:}\quad & =r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright\gunderline{\text{ftn}_{R}(r)}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:ftn-R-simplified})}:}\quad & =r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright\big(q\triangleright\gunderline{\text{pu}_{M}^{\downarrow H}\triangleright(x\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright x)^{\downarrow H}}\bef r\big)\\
{\color{greenunder}\text{composition law for }H:}\quad & =r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef\big(q\triangleright(x\Rightarrow q\triangleright\gunderline{\text{pu}_{M}^{\downarrow H}\bef x\bef\text{pu}_{M}})^{\downarrow H}\bef r\big)\\
{\color{greenunder}\text{definition of }^{\uparrow R}:}\quad & =r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef\big(q\triangleright(x\Rightarrow q\triangleright\text{pu}_{M}^{\uparrow R}(x))^{\downarrow H}\bef r\big)\quad.
\end{align*}
The left-hand side of the law~(\ref{eq:swap-law-3-formulation-R-M})
then becomes
\[
m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef\big(q\triangleright(x\Rightarrow q\triangleright\text{pu}_{M}^{\uparrow R}(x))^{\downarrow H}\bef r\big)\big)^{\uparrow M}\quad.
\]
Now apply the right-hand side of the law~(\ref{eq:swap-law-3-formulation-R-M})
to $m$ and $q$:
\begin{align}
 & q\triangleright\big(m\triangleright\text{sw}\bef\gunderline{\text{sw}^{\uparrow R}}\bef\text{ftn}_{R}\big)\nonumber \\
{\color{greenunder}\text{definition of }^{\uparrow R}:}\quad & =q\triangleright\big(\gunderline{m\triangleright\text{sw}\triangleright(x}\Rightarrow\text{sw}^{\downarrow H}\bef x\bef\text{sw})\triangleright\text{ftn}_{R}\big)\nonumber \\
{\color{greenunder}\text{apply to arguments}:}\quad & =q\triangleright\big(\gunderline{\text{ftn}_{R}(}\text{sw}^{\downarrow H}\bef\text{sw}(m)\bef\text{sw})\big)\nonumber \\
{\color{greenunder}\text{use Eq.~(\ref{eq:ftn-R-simplified})}:}\quad & =q\triangleright\big(q\triangleright\gunderline{(x\Rightarrow q\triangleright x)^{\downarrow H}\bef\text{sw}^{\downarrow H}}\bef\text{sw}(m)\bef\text{sw}\big)\nonumber \\
{\color{greenunder}\text{composition law of }H:}\quad & =q\triangleright\big(q\triangleright\big(\gunderline{\text{sw}\bef(x\Rightarrow q\triangleright x)}\big)^{\downarrow H}\bef\text{sw}(m)\bef\text{sw}\big)\quad.\label{eq:swap-laws-derivation2}
\end{align}
To proceed, we simplify the sub-expression $\text{sw}(m)\bef\text{sw}$
separately by computing the function compositions:
\begin{align*}
 & \text{sw}(m)\bef\text{sw}\\
 & =(q_{1}\Rightarrow m\triangleright\big(r\Rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\gunderline{)\bef(}y\Rightarrow q_{2}\Rightarrow y\triangleright\big(r\Rightarrow q_{2}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M})\\
 & =q_{1}\Rightarrow q_{2}\Rightarrow(m\triangleright\big(r\Rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M})\triangleright\big(}r\Rightarrow q_{2}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M}}\\
 & =q_{1}\Rightarrow q_{2}\Rightarrow m\triangleright\big(\big(r\Rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)\bef\big(}r\Rightarrow q_{2}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)\big)^{\uparrow M}}\quad.
\end{align*}
Using this formula, we can write, for any $z$ of a suitable type,
\begin{align}
q\triangleright(z\triangleright\text{sw}(m)\bef\text{sw}) & =m\triangleright\big(\big(r\Rightarrow z\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)\bef\big(r\Rightarrow}q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\big)^{\uparrow M}\nonumber \\
{\color{greenunder}\text{function composition}:}\quad & =m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(z\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\quad.\label{eq:swap-law-3-derivation-1}
\end{align}
Now we can substitute this into Eq.~(\ref{eq:swap-laws-derivation2}):
\begin{align*}
 & q\triangleright\big(q\triangleright\big(\text{sw}\bef(x\Rightarrow q\triangleright x)\big)^{\downarrow H}\triangleright\gunderline{\text{sw}(m)\bef\text{sw}}\big)\\
{\color{greenunder}\text{use Eq.~(\ref{eq:swap-law-3-derivation-1})}:}\quad & =m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\gunderline{\big(\text{sw}\bef(x\Rightarrow q\triangleright x)\big)^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r)\big)^{\uparrow M}\\
{\color{greenunder}H\text{'s composition}:}\quad & =m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\big(\gunderline{\text{pu}_{M}\bef\text{sw}}\bef(x\Rightarrow q\triangleright x)\big)^{\downarrow H}\bef r)\big)^{\uparrow M}\\
{\color{greenunder}\text{outer-identity}:}\quad & =m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\big(\gunderline{\text{pu}_{M}^{\uparrow R}\bef(x\Rightarrow q\triangleright x)}\big)^{\downarrow H}\bef r)\big)^{\uparrow M}\\
{\color{greenunder}\text{composition}:}\quad & =m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\big(x\Rightarrow q\triangleright\text{pu}_{M}^{\uparrow R}(x)\big)^{\downarrow H}\bef r)\big)^{\uparrow M}\quad.
\end{align*}
We arrived at the same expression as the left-hand side of the law.

\paragraph{Proof of the outer-interchange law}

The law is written as
\begin{equation}
\vspace{-0.25cm}\text{ftn}_{M}\bef\text{sw}=\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow R}\quad.\label{eq:swap-law-4-formulation-R-M}
\end{equation}
We will apply both sides of the law to arbitrary $m^{:M^{M^{R^{A}}}}$
and $q^{:H^{M^{A}}}$, and transform both sides to the same expression.
We begin with the more complicated right-hand side:
\begin{align}
 & q\triangleright\big(m\triangleright\text{sw}^{\uparrow M}\gunderline{\bef}\text{sw}\gunderline{\bef}\text{ftn}_{M}^{\uparrow R}\big)\nonumber \\
{\color{greenunder}\triangleright\text{ notation}:}\quad & =q\triangleright\big((m\triangleright\text{sw}^{\uparrow M}\triangleright\text{sw})\triangleright\gunderline{\text{ftn}_{M}^{\uparrow R}}\big)\nonumber \\
{\color{greenunder}\text{definition of }^{\uparrow R}:}\quad & =q\triangleright\big(\text{ftn}_{M}^{\downarrow H}\gunderline{\bef}(m\triangleright\text{sw}^{\uparrow M}\triangleright\text{sw})\gunderline{\bef}\text{ftn}_{M}\big)\nonumber \\
{\color{greenunder}\triangleright\text{ notation}:}\quad & =\big(\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}}\triangleright(\gunderline{m\triangleright\text{sw}^{\uparrow M}}\triangleright\gunderline{\text{sw}})\big)\triangleright\text{ftn}_{M}\nonumber \\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:}\quad & =\big(m\triangleright\gunderline{\text{sw}^{\uparrow M}}\triangleright\big(r\Rightarrow q\triangleright\gunderline{\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r\gunderline{\big)^{\uparrow M}}\big)\triangleright\text{ftn}_{M}\nonumber \\
{\color{greenunder}\text{composition for }H\text{ and }M:}\quad & =m\triangleright\big(\text{sw}\bef\big(r\Rightarrow q\triangleright(\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}})^{\downarrow H}\bef r\big)\big)^{\uparrow M}\bef\text{ftn}_{M}\nonumber \\
{\color{greenunder}\text{left identity law of }M:}\quad & =m\triangleright\big(\text{sw}\bef(r\Rightarrow q\triangleright r)\big)^{\uparrow M}\bef\text{ftn}_{M}\quad.\label{eq:rigid-monad-1-swap-law-4-derivation-5}
\end{align}
Let us simplify the sub-expression $\text{sw}\bef(r\Rightarrow q\triangleright r)$
separately:
\begin{align}
 & \gunderline{\text{sw}}\bef\big(r\Rightarrow q\triangleright r\big)=(x\Rightarrow x\triangleright\text{sw})\bef(r\Rightarrow q\triangleright r)\nonumber \\
{\color{greenunder}\text{function composition}:}\quad & =(x\Rightarrow\gunderline{q\triangleright(x\triangleright\text{sw})})\nonumber \\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:}\quad & =\gunderline{x\Rightarrow x\triangleright\big(}r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\nonumber \\
{\color{greenunder}\text{expand argument}:}\quad & =\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\quad.\label{eq:rigid-monad-1-swap-derivation-6}
\end{align}
Substituting this expression into Eq.~(\ref{eq:rigid-monad-1-swap-law-4-derivation-5}),
we get
\begin{align*}
 & m\triangleright\big(\gunderline{\text{sw}\bef(r\Rightarrow q\triangleright r)}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-1-swap-derivation-6})}:}\quad & =m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{naturality of }\text{ftn}_{M}:}\quad & =m\triangleright\text{ftn}_{M}\bef\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\quad.
\end{align*}

Now write the left-hand side of the law:
\begin{align*}
 & q\triangleright\big(m\triangleright\text{ftn}_{M}\gunderline{\bef}\text{sw}\big)=q\triangleright\big(m\triangleright\text{ftn}_{M}\triangleright\gunderline{\text{sw}}\big)\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:}\quad & =m\triangleright\text{ftn}_{M}\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\quad.
\end{align*}
This is equal to the right-hand side we just obtained.

\subsubsection{Statement \label{subsec:Statement-rigid-monad-1-swap-naturality-laws}\ref{subsec:Statement-rigid-monad-1-swap-naturality-laws}}

The monadic naturality laws in Theorem~\ref{subsec:Theorem-outside-transformer-swap-laws}
hold for the \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function defined by Eq.~(\ref{eq:rigid-monad-short-formula-for-swap})
and the base monad $L\triangleq R$.

\subparagraph{Proof}

The monadic naturality laws are 
\[
\text{sw}_{R,\text{Id}}=\text{id}\quad,\quad\quad\text{sw}_{R,M}\bef\phi^{\uparrow R}=\phi\bef\text{sw}_{R,N}\quad,\quad\quad\text{sw}_{R,M}\bef\theta=\theta^{\uparrow M}\quad,
\]
where $\phi:M\leadsto N$ and $\theta:R\leadsto\text{Id}$ are arbitrary
monadic morphisms. %
\begin{comment}
Eq.~(\ref{eq:rigid-monad-swap-derivation2}) gives
\[
\text{sw}_{R,M}(m)=q\Rightarrow m\triangleright\big(\text{pu}_{M}^{\uparrow R}\bef(x\Rightarrow x\,q)\big)^{\uparrow M}\bef\text{ftn}_{M}
\]
\end{comment}

To verify the first law, set $M=\text{Id}$ in Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})
and get {*}{*}{*}
\begin{align*}
 & q\triangleright(m\triangleright\text{sw}_{R,\text{Id}})\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:}\quad & =m\triangleright\big(r\Rightarrow q\triangleright\gunderline{\text{pu}_{M}^{\downarrow H}}\bef r\gunderline{\big)^{\uparrow M}}\\
{\color{greenunder}\text{use }M=\text{Id}\text{ and }\text{pu}_{M}=\text{id}:}\quad & =\gunderline{m\triangleright(r\Rightarrow}q\triangleright r)\\
{\color{greenunder}\text{apply to argument }m:}\quad & =q\triangleright\gunderline m=q\triangleright(m\triangleright\text{id})\quad.
\end{align*}
So, $\text{sw}_{R,\text{Id}}=\text{id}$ when applied to arbitrary
argument values $m$ and $q$.

To verify the second law, apply both sides to arbitrary $m$ and $q$.
The left-hand side:
\begin{align*}
 & q\triangleright\big(m\triangleright\text{sw}_{R,M}\gunderline{\bef}\phi^{\uparrow R}\big)=q\triangleright\big(m\triangleright\text{sw}_{R,M}\triangleright\gunderline{\phi^{\uparrow R}}\big)\\
\text{definition of }^{\uparrow R}: & =q\triangleright\big(\phi^{\downarrow H}\bef(m\triangleright\text{sw}_{R,M})\bef\phi\big)\\
{\color{greenunder}\triangleright\text{ notation}:}\quad & =\gunderline{(q\triangleright\phi^{\downarrow H})}\triangleright(m\triangleright\gunderline{\text{sw}_{R,M}})\triangleright\phi\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:}\quad & =m\triangleright\big(r\Rightarrow q\triangleright\gunderline{\phi^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r\big)^{\uparrow M}\triangleright\phi\\
{\color{greenunder}\text{composition law for }H:}\quad & =m\triangleright\big(r\Rightarrow q\triangleright(\gunderline{\text{pu}_{M}\bef\phi})^{\downarrow H}\bef r\big)^{\uparrow M}\bef\phi\\
{\color{greenunder}\text{identity law for }\phi:}\quad & =m\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{N}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M}\bef\phi}\\
{\color{greenunder}\text{naturality of }\phi:}\quad & =m\triangleright\gunderline{\phi\bef\big(}r\Rightarrow q\triangleright\text{pu}_{N}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow N}}\quad.
\end{align*}
The right-hand side, when applied to $m$ and $q$, gives the same
expression:
\begin{align*}
 & q\triangleright(m\triangleright\phi\bef\text{sw}_{R,N})=q\triangleright(m\triangleright\phi\triangleright\gunderline{\text{sw}_{R,N})}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:}\quad & =m\triangleright\phi\triangleright\big(r\Rightarrow q\triangleright\text{pu}_{N}^{\downarrow H}\bef r\big)^{\uparrow N}\quad.
\end{align*}

To argue that the third law holds,\footnote{I could not find a fully rigorous proof of the third monadic naturality
law. Below I will indicate the part of the proof that lacks rigor.} apply the left-hand side to $m$ and $q$:
\begin{align}
 & q\triangleright(m\triangleright\text{sw}_{R,M}\bef\theta)=q\triangleright(m\triangleright\text{sw}_{R,M}\triangleright\theta)\nonumber \\
 & =q\triangleright\big((q_{1}\Rightarrow m\triangleright\big(r\Rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M})\triangleright\theta\big)\quad.\label{eq:rigid-monad-1-derivation7}
\end{align}
This expression cannot be simplified any further; and neither can
the right-hand side $q\triangleright(m\triangleright\theta^{\uparrow M})$.
We need more detailed information about the function $\theta$. 

The type of $\theta$ is
\[
\theta:\forall A.\,(H^{A}\Rightarrow A)\Rightarrow A\quad.
\]
To implement a function of this type, we need to write code that takes
an argument of type $H^{A}\Rightarrow A$ and returns a value of type
$A$. Since the type $A$ is arbitrary, the code of $\theta$ cannot
store a fixed value of type $A$ to use as the return value. The only
possibility to implement a function $\theta$ with the required type
signature seems to be by substituting a value of type $H^{A}$ into
the given argument of type $H^{A}\Rightarrow A$, which will return
the result of type $A$. So,\footnote{This is where an argument is lacking: I did not prove that the type
$\forall A.\,(H^{A}\Rightarrow A)\Rightarrow A$ is really \emph{equivalent}
to $\forall A.\,H^{A}$. With this assumption, the proof is rigorous.} we need to produce a value of type $H^{A}$ for an arbitrary type
$A$, that is, a value of type $\forall A.\,H^{A}$. Using the contravariant
Yoneda identity, we can simplify this type expression to the type
$H^{\bbnum 1}$:
\begin{align*}
 & \forall A.\,H^{A}\cong\forall A.\,\gunderline{\bbnum 1}\Rightarrow H^{A}\\
{\color{greenunder}\text{use identity }(A\Rightarrow\bbnum 1)\cong\bbnum 1:}\quad & =\forall A.\,(A\Rightarrow\bbnum 1)\Rightarrow H^{A}\\
{\color{greenunder}\text{contravariant Yoneda identity}:}\quad & =H^{\bbnum 1}\quad.
\end{align*}
So, we can construct a $\theta$ if we store a value $h_{1}$ of type
$H^{\bbnum 1}$ and compute $h:H^{A}$ as
\[
h^{:H^{A}}=h_{1}^{:H^{1}}\triangleright(a^{:A}\Rightarrow1)^{\downarrow H}\quad.
\]
Given a fixed value $h_{1}:H^{\bbnum 1}$, the code of $\theta$ is
therefore
\begin{equation}
\big(r^{:H^{A}\Rightarrow A}\big)\triangleright\theta\triangleq h_{1}\triangleright(\_\Rightarrow1)^{\downarrow H}\triangleright r\quad.\label{eq:rigid-monad-base-runner-1}
\end{equation}
Let us check whether this $\theta$ is a monadic morphism $R\leadsto\text{Id}$.
We need to verify the two laws of monadic morphisms,
\[
\text{pu}_{R}\bef\theta=\text{id}\quad,\quad\quad\text{ftn}_{R}\bef\theta=\theta^{\uparrow R}\bef\theta=\theta\bef\theta\quad.
\]
The identity law, applied to an arbitrary $x:A$, is
\begin{align*}
 & x\triangleright\text{pu}_{R}\bef\theta=(x\triangleright\text{pu}_{R}\gunderline{)\triangleright\theta}\\
{\color{greenunder}\text{definition of }r\triangleright\theta:}\quad & =h_{1}\triangleright(\_\Rightarrow1)^{\downarrow H}\triangleright(\gunderline{x\triangleright\text{pu}_{R}})\\
{\color{greenunder}\text{definition of }x\triangleright\text{pu}_{R}:}\quad & =\big(h_{1}\triangleright(\_\Rightarrow1)^{\downarrow H}\gunderline{\big)\triangleright(\_\Rightarrow}x)\\
{\color{greenunder}\text{function composition}:}\quad & =x\quad.
\end{align*}
This verifies the identity law. 

The composition law, applied to an arbitrary $r:R^{R^{A}}$, expands
to
\begin{align*}
 & r\triangleright\text{ftn}_{R}\bef\theta=\gunderline{r\triangleright\text{ftn}_{R}}\triangleright\theta\\
{\color{greenunder}\text{definition of }\text{ftn}_{R}:}\quad & =\gunderline{r\triangleright\big(t\Rightarrow}q\Rightarrow q\triangleright\big(q\triangleright(x\Rightarrow q\triangleright x)^{\downarrow H}\bef t\big)\big)\triangleright\theta\\
{\color{greenunder}\text{apply to }r:}\quad & =\big(q\Rightarrow q\triangleright\big(q\triangleright(x\Rightarrow q\triangleright x)^{\downarrow H}\bef r\big)\gunderline{\big)\triangleright\theta}\\
{\color{greenunder}\text{definition~(\ref{eq:rigid-monad-base-runner-1}) of }\theta:}\quad & =h_{1}\triangleright(\_\Rightarrow1)^{\downarrow H}\triangleright\gunderline{\big(q\Rightarrow}q\triangleright\big(q\triangleright(x\Rightarrow q\triangleright x)^{\downarrow H}\bef r\big)\big)\\
{\color{greenunder}\text{apply to }h_{1}\triangleright(\_\Rightarrow1)^{\downarrow H}:}\quad & =h_{1}\triangleright(\_\Rightarrow1)^{\downarrow H}\triangleright\big(h_{1}\triangleright\gunderline{(\_\Rightarrow1)^{\downarrow H}\bef(x\Rightarrow...)^{\downarrow H}}\bef r\big)\\
{\color{greenunder}\text{composition under }H:}\quad & =\gunderline{h_{1}\triangleright(\_\Rightarrow1)^{\downarrow H}}\triangleright\big(\gunderline{h_{1}\triangleright(\_\Rightarrow1)^{\downarrow H}}\triangleright r\big)\\
{\color{greenunder}\text{definition~(\ref{eq:rigid-monad-base-runner-1}) of }\theta:}\quad & =r\triangleright\theta\triangleright\theta=r\triangleright\theta\bef\theta\quad.
\end{align*}
This verifies the composition law; so $\theta$ is indeed a monadic
morphism.

Using the code of $\theta$ defined in Eq.~(\ref{eq:rigid-monad-base-runner-1}),
we can now verify the monadic naturality law of $\text{sw}_{R,M}$
(with respect to the runners $\theta$ of that form). The left-hand
side of the law is given by Eq.~(\ref{eq:rigid-monad-1-derivation7})
and is rewritten as
\begin{align*}
 & q\triangleright\big((q_{1}\Rightarrow m\triangleright\big(r\Rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\gunderline{)\triangleright\theta}\big)\\
{\color{greenunder}\text{definition of }\theta:}\quad & =q\triangleright\big(h_{1}\triangleright(\_\Rightarrow1)^{\downarrow H}\gunderline{\triangleright(q_{1}\Rightarrow}m\triangleright\big(r\Rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M})\big)\\
{\color{greenunder}\text{apply to argument}:}\quad & =q\triangleright\big(m\triangleright\big(r\Rightarrow h_{1}\triangleright\gunderline{(\_\Rightarrow1)^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r\big)^{\uparrow M}\big)\\
{\color{greenunder}H\text{'s composition law}:}\quad & =q\triangleright\big(m\triangleright\big(r\Rightarrow h_{1}\triangleright(\gunderline{\text{pu}_{M}\bef(\_\Rightarrow1)})^{\downarrow H}\bef r\big)^{\uparrow M}\big)\\
{\color{greenunder}\text{compose functions}:}\quad & =q\triangleright\big(m\triangleright\big(r\Rightarrow h_{1}\triangleright(\gunderline{\_\Rightarrow1})^{\downarrow H}\triangleright r\big)^{\uparrow M}\big)\quad.
\end{align*}
The right-hand side is
\begin{align*}
 & q\triangleright(m\triangleright\gunderline{\theta}^{\uparrow M})\\
{\color{greenunder}\text{function expansion}:}\quad & =q\triangleright\big(m\triangleright\big(r\Rightarrow\gunderline{r\triangleright\theta}\big)^{\uparrow M}\big)\\
{\color{greenunder}\text{definition~(\ref{eq:rigid-monad-base-runner-1}) of }\theta:}\quad & =q\triangleright\big(m\triangleright\big(r\Rightarrow h_{1}\triangleright(\_\Rightarrow1)^{\downarrow H}\triangleright r\big)^{\uparrow M}\big)\quad.
\end{align*}
This expression is now the same as the left-hand side.

\begin{comment}
Statement 4.

The rigid monad $R^{A}\triangleq H^{A}\Rightarrow A$ satisfies the
two compatibility laws with respect to any monad $M$.

Proof.

Denote for brevity $T^{\bullet}\triangleq R^{M^{\bullet}}$ and rewrite
the compatibility laws in terms of $\text{flm}$ instead of $\text{ftn}$
(since our expressions for the monad $T$ always need to involve $\text{flm}_{M}$).
Then the two laws that we need to prove are 
\begin{align*}
\text{flm}_{R}f^{:A\Rightarrow R^{M^{B}}} & =\text{pure}_{M}^{\uparrow R}\bef\text{flm}_{T}f\quad\text{as functions }R^{A}\Rightarrow R^{M^{B}},\\
\big(\text{flm}_{M}f^{A\Rightarrow M^{B}}\big)^{\uparrow R} & =\text{pure}_{R}^{\uparrow T}\bef\text{flm}_{T}\big(f^{\uparrow R}\big)\quad\text{as functions }R^{M^{A}}\Rightarrow R^{M^{B}}.
\end{align*}
A definition of $\text{flm}_{R}$ is obtained from $\text{flm}_{T}$
by choosing the identity monad $M^{A}\triangleq A$ instead of an
arbitrary monad $M$. This replaces $\text{flm}_{M}$ by $\text{id}$:
\begin{align*}
\text{flm}_{T}f^{:A\Rightarrow R^{M^{B}}} & =t^{:R^{M^{A}}}\Rightarrow q^{H^{M^{B}}}\Rightarrow\left(\text{flm}_{M}\left(x^{:A}\Rightarrow f\,x\,q\right)\right)^{\uparrow R}t\,q\quad;\\
\text{flm}_{R}f^{:A\Rightarrow R^{B}} & =r^{:R^{A}}\Rightarrow q^{H^{B}}\Rightarrow\left(x^{:A}\Rightarrow f\,x\,q\right)^{\uparrow R}r\,q\quad.
\end{align*}
To prove the first compatibility law, rewrite its right-hand side
as
\begin{align*}
 & \text{pure}_{M}^{\uparrow R}\bef\text{flm}_{T}f\\
{\color{greenunder}\text{definition of }\text{flm}_{T}:}\quad & =\left(r^{:R^{A}}\Rightarrow\text{pure}_{M}^{\uparrow R}r\right)\bef\left(r\Rightarrow q\Rightarrow\left(\text{flm}_{M}\left(x\Rightarrow f\,x\,q\right)\right)^{\uparrow R}r\,q\right)\\
{\color{greenunder}\text{expand }\bef\text{and simplify}:}\quad & =r\Rightarrow q\Rightarrow\left(\text{flm}_{M}\left(x\Rightarrow f\,x\,q\right)\right)^{\uparrow R}\left(\text{pure}_{M}^{\uparrow R}r\right)\,q\\
{\color{greenunder}\text{composition law for }R:}\quad & =r\Rightarrow q\Rightarrow\left(\text{pure}_{M}\bef\text{flm}_{M}\left(x\Rightarrow f\,x\,q\right)\right)^{\uparrow R}r\,q\\
{\color{greenunder}\text{left identity law for }M:}\quad & =r\Rightarrow q\Rightarrow\left(x\Rightarrow f\,x\,q\right)^{\uparrow R}r\,q\\
{\color{greenunder}\text{definition of }\text{flm}_{R}:}\quad & =\text{flm}_{R}f\quad.
\end{align*}

To prove the second compatibility law, rewrite its right-hand side
as
\begin{align*}
 & \text{pure}_{R}^{\uparrow T}\bef\text{flm}_{T}\big(f^{\uparrow R}\big)\\
{\color{greenunder}\text{definition of }\text{flm}_{T}\big(f^{\uparrow R}\big):}\quad & =\left(t^{:T^{A}}\Rightarrow\text{pure}_{R}^{\uparrow T}t\right)\bef\left(t\Rightarrow q\Rightarrow\left(\text{flm}_{M}\left(x\Rightarrow f^{\uparrow R}x\,q\right)\right)^{\uparrow R}t\,q\right)\\
{\color{greenunder}\text{expand }\bef\text{ and simplify}:}\quad & =t^{:T^{A}}\Rightarrow q\Rightarrow\left(\text{flm}_{M}\left(x^{:R^{A}}\Rightarrow f^{\uparrow R}x\,q\right)\right)^{\uparrow R}\left(\text{pure}_{R}^{\uparrow M\uparrow R}t\right)\,q\\
{\color{greenunder}\text{composition law for }R:}\quad & =t\Rightarrow q\Rightarrow\left(\text{pure}_{R}^{\uparrow M}\bef\text{flm}_{M}\left(x^{:R^{A}}\Rightarrow f^{\uparrow R}x\,q\right)\right)^{\uparrow R}t\,q\\
{\color{greenunder}\text{left naturality of }\text{flm}_{M}:}\quad & =t\Rightarrow q\Rightarrow\left(\text{flm}_{M}\left(x^{:A}\Rightarrow\left(\text{pure}_{R}\bef f^{\uparrow R}\right)x\,q\right)\right)^{\uparrow R}t\,q\\
{\color{greenunder}\text{naturality of }\text{pure}_{R}:}\quad & =t\Rightarrow q\Rightarrow\left(\text{flm}_{M}\left(x^{:A}\Rightarrow\text{pure}_{R}\left(f\,x\right)\,q\right)\right)^{\uparrow R}t\,q\\
{\color{greenunder}\text{definition of }\text{pure}_{R}:}\quad & =t\Rightarrow q\Rightarrow\left(\text{flm}_{M}\left(x^{:A}\Rightarrow f\,x\right)\right)^{\uparrow R}t\,q\\
{\color{greenunder}\text{unapply }f\text{ and }\text{flm}_{M}f:}\quad & =t\Rightarrow q\Rightarrow\left(\text{flm}_{M}f\right)^{\uparrow R}t\,q=\left(\text{flm}_{M}f\right)^{\uparrow R}\quad.
\end{align*}

Statement 5.

Assume that $R$ and $M$ are arbitrary (not necessarily rigid) monads
such that the functor composition $T^{\bullet}\triangleq R^{M^{\bullet}}$
is also a monad whose method $\text{pure}_{T}$ is defined by
\[
\text{pure}_{R^{M}}=\text{pure}_{M}\bef\text{pure}_{R}\quad.
\]
Then the two ``liftings'' and the two ``runners'' defined by
\begin{align*}
\text{lift}:M^{\bullet}\leadsto R^{M^{\bullet}} & \triangleq\text{pure}_{R}\quad,\\
\text{blift}:R^{\bullet}\leadsto R^{M^{\bullet}} & \triangleq\text{pure}_{M}^{\uparrow R}\quad,\\
\text{mrun}\,\big(\phi^{:M^{\bullet}\leadsto N^{\bullet}}\big):R^{M^{\bullet}}\Rightarrow R^{N^{\bullet}} & \triangleq\phi^{\uparrow R}\quad,\\
\text{brun}\,\theta^{:R^{\bullet}\leadsto\bullet}:R^{M^{\bullet}}\Rightarrow M^{\bullet} & \triangleq\theta^{:R^{M^{\bullet}}\leadsto M^{\bullet}}\quad,
\end{align*}
will satisfy the identity laws
\begin{align*}
\text{pure}_{M}\bef\text{lift} & =\text{pure}_{T}\quad,\\
\text{pure}_{R}\bef\text{blift} & =\text{pure}_{T}\quad,\\
\text{pure}_{R^{M}}\bef\left(\text{mrun}\,\phi\right) & =\text{pure}_{N}\bef\text{pure}_{R}\quad,\\
\text{pure}_{R^{M}}\bef\left(\text{brun}\,\theta\right) & =\text{pure}_{M}\quad,
\end{align*}
where we assume that $\phi:M^{\bullet}\leadsto N^{\bullet}$ and $\theta:M^{\bullet}\leadsto\bullet$
are monadic morphisms, and $N$ is an arbitrary monad.

Proof.

The first law is a direct consequence of the definition of $\text{lift}$.
The second law follows from the naturality of $\text{pure}_{R}$,
\[
\text{pure}_{R}\bef\text{pure}_{M}^{\uparrow R}=\text{pure}_{M}\bef\text{pure}_{R}\quad.
\]
The third law follows from the identity law for $\phi$,
\[
\text{pure}_{M}\bef\phi=\text{pure}_{N},
\]
 if we write
\begin{align*}
 & \text{pure}_{R^{M}}\bef\left(\text{mrun}\,\phi\right)\\
{\color{greenunder}\text{definitions of }\text{pure}_{R^{M}}\text{ and }\text{mrun}:}\quad & =\text{pure}_{M}\bef\text{pure}_{R}\bef\phi^{\uparrow R}\\
{\color{greenunder}\text{naturality of }\text{pure}_{R}:}\quad & =\text{pure}_{M}\bef\phi\bef\text{pure}_{R}\\
{\color{greenunder}\text{identity law for }\phi:}\quad & =\text{pure}_{N}\bef\text{pure}_{R}\quad.
\end{align*}
The fourth law follows from the identity law for $\theta$,
\[
\text{pure}_{R}\bef\theta=\text{id},
\]
if we write
\begin{align*}
 & \text{pure}_{R^{M}}\bef\left(\text{brun}\,\theta\right)\\
{\color{greenunder}\text{definitions of }\text{pure}_{R^{M}}\text{ and }\text{brun}:}\quad & =\text{pure}_{M}\bef\text{pure}_{R}\bef\theta\\
{\color{greenunder}\text{identity law for }\theta:}\quad & =\text{pure}_{M}\quad.
\end{align*}
In this proof, we have not actually used the assumption that $R$,
$M$, $R^{M^{\bullet}}$, and $N$ are monads. We only used the naturality
of $\text{pure}_{R}$. So, it is sufficient to assume that these functors
are pointed, and that $\phi$ and $\theta$ are morphisms of pointed
functors. However, the four laws we just derived are mainly useful
as identity laws for monad transformer methods.

Statement 6.

A monad transformer for the rigid monad $R^{A}\triangleq H^{A}\Rightarrow A$
is $T_{R}^{M,A}\triangleq R^{M^{A}}$, with the four required methods
defined as
\begin{align*}
\text{lift}^{:M^{\bullet}\leadsto T^{\bullet}} & \triangleq\text{pure}_{R}\quad,\\
\text{blift}^{:R^{\bullet}\leadsto T^{\bullet}} & \triangleq\text{pure}_{M}^{\uparrow R}\quad,\\
\text{mrun}\,\phi^{:M^{\bullet}\leadsto N^{\bullet}} & \triangleq\phi^{\uparrow R}\quad,\\
\text{brun}\,\theta^{:R^{\bullet}\leadsto\bullet} & \triangleq\theta^{:R^{M^{\bullet}}\leadsto M^{\bullet}}\quad.
\end{align*}
Each of these four methods is a monadic morphism for any monadic morphism
$\phi:M^{\bullet}\leadsto N^{\bullet}$, where $M$ and $N$ are arbitrary
(not necessarily rigid) monads, and for any monadic morphism $\theta:R^{A}\leadsto A$.

Proof.

Since $\text{blift}$ is a special case of $\text{mrun}$, we only
need to prove the monadic morphism laws for the three methods: $\text{lift}$,
$\text{mrun}$, and $\text{brun}$.

The identity laws follow from Statement~5, since $T_{R}^{M,\bullet}=R^{M^{\bullet}}$
is a functor composition. It remains to verify the composition laws,
\begin{align*}
\left(f^{:A\Rightarrow M^{B}}\bef\text{lift}\right)\diamond_{R^{M}}\left(g^{:B\Rightarrow M^{C}}\bef\text{lift}\right) & =\left(f\diamond_{M}g\right)\bef\text{lift}\quad,\\
\left(f^{:A\Rightarrow R^{M^{B}}}\bef\text{mrun}\,\phi\right)\diamond_{R^{N}}\left(g^{:B\Rightarrow R^{M^{C}}}\bef\text{mrun}\,\phi\right) & =\left(f\diamond_{R^{M}}g\right)\bef\text{mrun}\,\phi\quad,\\
\left(f^{:A\Rightarrow R^{M^{B}}}\bef\text{brun}\,\theta\right)\diamond_{M}\left(g^{:B\Rightarrow R^{M^{C}}}\bef\text{brun}\,\theta\right) & =\left(f\diamond_{R^{M}}g\right)\bef\text{brun}\,\theta\quad.
\end{align*}

For the first law, we need to use the definition of $\text{lift}\triangleq\text{pure}_{R}$,
which is
\[
\text{pure}_{R}x^{:A}\triangleq\_^{:H^{A}}\Rightarrow x\quad.
\]
So the definition of $\text{lift}$ can be written as 
\[
f\bef\text{lift}=x^{:A}\Rightarrow\_^{:H^{M^{B}}}\Rightarrow f\,x
\]
as a function that ignores its second argument (of type $H^{M^{B}}$).
It is convenient to use the flipped Kleisli product $\tilde{\diamond}_{R^{M}}$
defined before in eq.~(\ref{eq:def-flipped-kleisli}). We compute
\begin{align*}
 & \left(f^{:A\Rightarrow M^{B}}\bef\text{lift}\right)\tilde{\diamond}_{R^{M}}\left(g^{:B\Rightarrow M^{C}}\bef\text{lift}\right)\\
{\color{greenunder}\text{definition of }\text{lift}:}\quad & =\left(\_\Rightarrow f\right)\tilde{\diamond}_{R^{M}}\left(\_\Rightarrow g\right)\\
{\color{greenunder}\text{eq. (\ref{eq:def-flipped-kleisli})}:}\quad & =q^{:H^{M^{B}}}\Rightarrow\left(\_\Rightarrow f\right)\left(\left(\text{flm}_{M}\left(\left(\_\Rightarrow g\right)\,q\right)\right)^{\downarrow H}q\right)\diamond_{M}\left(\left(\_\Rightarrow g\right)\,q\right)\\
{\color{greenunder}\text{expanding the functions}:}\quad & =q\Rightarrow f\diamond_{M}g\\
{\color{greenunder}\text{unflipping the definition of }\text{lift}:}\quad & =q\Rightarrow x\Rightarrow\left(\left(f\diamond_{M}g\right)\bef\text{lift}\right)a\,x\quad.
\end{align*}
Note that the last function, of type $H^{M^{B}}\Rightarrow A\Rightarrow M^{B}$,
ignores its first argument. Therefore, after unflipping this Kleisli
function, it will ignore its second argument. This is precisely what
the function $\left(f\diamond_{M}g\right)\bef\text{lift}$ must do.

For the second and third laws, we need to use the composition laws
for $\phi$ and $\theta$, which can be written as
\begin{align*}
\left(f^{:A\Rightarrow M^{B}}\bef\phi\right)\diamond_{N}\left(g^{:B\Rightarrow M^{C}}\bef\phi\right) & =\left(f\diamond_{M}g\right)\bef\phi\quad,\\
\left(f^{:A\Rightarrow R^{B}}\bef\theta\right)\bef\left(g^{:B\Rightarrow M^{C}}\bef\theta\right) & =\left(f\diamond_{M}g\right)\bef\theta\quad.
\end{align*}
\end{comment}


\subsection{Rigid monad construction 2: composition}

Functor composition is the second construction that produces rigid
monads. This is a consequence of the properties of monad transformer
stacks.

\subsubsection{Statement \label{subsec:Statement-composition-rigid-monads}\ref{subsec:Statement-composition-rigid-monads}}

The composition $R_{1}^{R_{2}^{\bullet}}$ of two rigid monads $R_{1}$
and $R_{2}$ is also a rigid monad.

\subparagraph{Proof}

Since $R_{1}$ is rigid, its outside-composition $R_{1}\circ M$ with
any other monad $M$ is a monad. So $R_{1}\circ R_{2}$ is a monad.
To show that $R_{1}\circ R_{2}$ is a rigid monad, we need to show
that its monad transformer is of the composed-outside kind. By Theorem~\ref{subsec:Stacking-two-monads},
the stacking of monad transformers $T_{R_{1}}$and $T_{R_{2}}$ is
a lawful monad transformer. Since the transformers for $R_{1}$ and
$R_{2}$ are of the composed-outside kind, $T_{R_{1}}^{M}=R_{1}\circ M$
and $T_{R_{2}}^{M}=R_{2}\circ M$, the stack of transformers is 
\[
T_{R_{1}}^{T_{R_{2}}^{M}}=R_{1}\circ T_{R_{2}}^{M}=R_{1}\circ(R_{2}\circ M)=R_{1}\circ R_{2}\circ M\quad.
\]
Therefore $T^{M}\triangleq R_{1}\circ R_{2}\circ M$ is a monad transformer
applied to the foreign monad $M$. This shows, by definition of a
rigid monad, that $R_{1}\circ R_{2}$ is a rigid monad.

\subsubsection{Example \label{subsec:Example-rigid-composition-1}\ref{subsec:Example-rigid-composition-1}}

Consider the functor composition of the \inputencoding{latin9}\lstinline!Search!\inputencoding{utf8}
monad $R_{1}^{A}\triangleq\left(A\Rightarrow Q\right)\Rightarrow A$
and the \inputencoding{latin9}\lstinline!Reader!\inputencoding{utf8}
monad $R_{2}^{A}\triangleq Z\Rightarrow A$:
\[
P^{A}\triangleq((Z\Rightarrow A)\Rightarrow Q)\Rightarrow Z\Rightarrow A\quad.
\]
It follows from Statement~\ref{subsec:Statement-composition-rigid-monads}
that the functor $P^{\bullet}$ is a rigid monad; so $P$'s transformer
is of the composed-outside kind. The the transformed monad for any
foreign monad $M$ is 
\[
T^{A}\triangleq((Z\Rightarrow M^{A})\Rightarrow Q)\Rightarrow Z\Rightarrow M^{A}\quad.
\]
To define the monad methods for $T$, we need to have the definitions
of the transformers $T_{R_{1}}^{M}$ and $T_{R_{2}}^{M}$. Since both
the \inputencoding{latin9}\lstinline!Search!\inputencoding{utf8}
and the \inputencoding{latin9}\lstinline!Reader!\inputencoding{utf8}
monads are special cases of the \inputencoding{latin9}\lstinline!Choice!\inputencoding{utf8}
monad construction (Section~\ref{subsec:Rigid-monad-construction-1-choice})
where the contrafunctor $H$ is chosen to be $H^{A}\triangleq A\Rightarrow Q$
and $H^{A}\triangleq Z$ respectively, we can use Eq.~(\ref{eq:rigid-monad-flm-T-def})
to define the \inputencoding{latin9}\lstinline!flatMap!\inputencoding{utf8}
methods for the transformers $T_{R_{1}}^{M}$ and $T_{R_{2}}^{M}$:\inputencoding{latin9}
\begin{lstlisting}
type R1[A] = (A => Q) => A
def map_R1[A, B](r1: R1[A])(f: A => B): R1[B] = { (b2q: B => Q) => f(r1(f andThen b2q)) }
def flatMap_R1[A, B, M[_]: Monad](r1: R1[M[A]])(f: A => R1[M[B]]): R1[M[B]] = {
  (q: M[B] => Q) => map_R1(r1){ (m: M[A]) => m.flatMap(x => f(x)(q)) }(q)
}

type R2[A] = Z => A
def map_R2[A, B](r2: R2[A])(f: A => B): R2[B] = { r2 andThen f }
def flatMap_R2[A, B, M[_]: Monad](r2: R2[M[A]])(f: A => R2[M[B]]): R2[M[B]] = {
  z => map_R2(r2){ (m: M[A]) => m.flatMap(x => f(x)(z)) }(z)
}   
\end{lstlisting}
\inputencoding{utf8}Now we can define the \inputencoding{latin9}\lstinline!flatMap!\inputencoding{utf8}
method for $T$ by using the monad $T_{R_{2}}^{M}$ instead of $M$
in the \inputencoding{latin9}\lstinline!flatMap!\inputencoding{utf8}
method for $T_{R_{1}}^{M}$:\inputencoding{latin9}
\begin{lstlisting}
type T[A] = R1[R2[A]]
def flatMap_T[A, B, M[_]: Monad](t: T[M[A]])(f: A => T[M[B]]): T[M[B]] = {
  (q: R2[M[B]] => Q) => map_R1(t){ (m: R2[M[A]]) => flatMap_R2(m)(x => f(x)(q)) }(q)
}
\end{lstlisting}
\inputencoding{utf8}

\paragraph{Does the composed monad have \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}? }

The definitions of the monad methods for the composed monads are somewhat
complicated. In Section~\ref{subsec:Rigid-monad-construction-1-choice},
we have proved the monad transformer laws for $T_{R}^{M}\triangleq R\circ M$
by defining a \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function with type signature
\[
\text{sw}_{R,M}:M\circ R\leadsto R\circ M\quad,
\]
and proving its laws. Suppose $S$ is also a rigid monad; then the
composed monad $R\circ S$ is a rigid monad. Does $T\triangleq R\circ S$
have a suitable \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
function,
\[
\text{sw}_{T,M}:M\circ R\circ S\leadsto R\circ S\circ M\quad,
\]
satisfying all the required laws? If so, we may be able to find a
simpler definition of \inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
for the monad stack $R\circ S\circ M$. Let us briefly investigate
this question. However, keep in mind that the absence of a suitable
\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8} function
will not invalidate the composition properties of rigid monad stacks,
because those properties were established without assuming the existence
of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8} for
the composed monad.

It turns out that we need yet another law for \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
(the ``3-swap'' law) if we wish to prove that the composed monad
also has a lawful \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}. 

\subsubsection{Theorem \label{subsec:Statement-3-swap-law}\ref{subsec:Statement-3-swap-law}}

Assume that two monads $R$ and $S$ both have \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
methods, $\text{sw}_{R,M}$ and $\text{sw}_{S,M}$, satisfying the
$8$ laws listed in Theorems~\ref{sec:Theorem-swap-laws-to-monad-transformer-first-law}
and \ref{subsec:Theorem-outside-transformer-swap-laws}. Additionally,
assume that the \textbf{3-swap law\index{monads!3-swap law}} holds
with respect to an arbitrary monad $M$,
\begin{equation}
\text{sw}_{R,S}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}=\text{sw}_{S,M}\bef\text{sw}_{R,M}^{\uparrow S}\bef\text{sw}_{R,S}\quad.\label{eq:rigid-monad-3-swap-law}
\end{equation}
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}M\circ S\circ R\ar[d]\sb(0.45){\text{sw}_{S,M}}\ar[r]\sp(0.5){\text{sw}_{R,S}^{\uparrow M}} & M\circ R\circ S\ar[r]\sp(0.5){\text{sw}_{R,M}} & R\circ M\circ S\ar[d]\sp(0.4){\text{sw}_{S,M}^{\uparrow R}}\\
S\circ M\circ R\ar[r]\sp(0.5){\text{sw}_{R,M}^{\uparrow S}} & S\circ R\circ M\ar[r]\sp(0.5){\text{sw}_{R,S}} & R\circ S\circ M
}
\]
Then the composed monad $T\triangleq R\circ S$ also has a \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
method defined by 
\begin{equation}
\text{sw}_{T,M}=\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\quad,\label{eq:3-swap-def-of-sw-T-M}
\end{equation}
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}M\circ R\circ S\ar[rd]\sb(0.45){\text{sw}_{T,M}\triangleq}\ar[r]\sp(0.5){\text{sw}_{R,M}} & R\circ M\circ S\ar[d]\sp(0.5){\text{sw}_{S,M}^{\uparrow R}}\\
 & R\circ S\circ M
}
\]
which satisfies the same $8$ laws.

\paragraph{Proof}

We need to verify the $8$ laws for $\text{sw}_{T,M}$ (one naturality
law, two identity laws, two interchange laws, and three monadic naturality
laws), assuming that these $8$ laws hold for $\text{sw}_{R,M}$ and
$\text{sw}_{S,M}$. In addition, we assume that Eq.~(\ref{eq:rigid-monad-3-swap-law})
holds, where $M$ is an arbitrary monad. The monad methods of $T$
are defined by Eqs.~(\ref{eq:def-pure-T-via-pure-L-and-pure-M})–(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})
after renaming $L\triangleq R$ and $M\triangleq S$:
\begin{align}
\text{pu}_{T} & =\text{pu}_{S}\bef\text{pu}_{R}\quad,\label{eq:3-swap-pu-T-via-pu-R-S}\\
\text{ftn}_{T} & =\text{sw}_{R,S}^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\quad.\label{eq:3-swap-ftn-T-via-sw-R-S}
\end{align}

As usual, we do not need to verify the naturality law for $\text{sw}_{T,M}$.

\paragraph{Identity laws}

To verify the outer-identity law:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pu}_{T}:}\quad & \text{pu}_{T}^{\uparrow M}\bef\text{sw}_{T,M}\\
{\color{greenunder}\text{use Eqs.~(\ref{eq:3-swap-def-of-sw-T-M})-(\ref{eq:3-swap-pu-T-via-pu-R-S})}:}\quad & =\text{pu}_{S}^{\uparrow M}\bef\gunderline{\text{pu}_{R}^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\\
{\color{greenunder}\text{outer-identity law for }\text{sw}_{R,M}:}\quad & =\text{pu}_{S}^{\uparrow M}\bef\gunderline{\text{pu}_{R}\bef\text{sw}_{S,M}^{\uparrow R}}\\
{\color{greenunder}\text{naturality of }\text{pu}_{R}:}\quad & =\gunderline{\text{pu}_{S}^{\uparrow M}\bef\text{sw}_{S,M}}\bef\text{pu}_{R}\\
{\color{greenunder}\text{outer-identity law for }\text{sw}_{S,M}:}\quad & =\text{pu}_{S}\bef\text{pu}_{R}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:3-swap-pu-T-via-pu-R-S})}:}\quad & =\text{pu}_{T}\quad.
\end{align*}
To verify the inner-identity law:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pu}_{M}^{\uparrow T}:}\quad & \text{pu}_{M}\bef\gunderline{\text{sw}_{T,M}}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:}\quad & =\gunderline{\text{pu}_{M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,Mi}^{\uparrow R}\\
{\color{greenunder}\text{inner-identity law for }\text{sw}_{R,M}:}\quad & =\text{pu}_{M}^{\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}=\big(\gunderline{\text{pu}_{M}\bef\text{sw}_{S,M}}\big)^{\uparrow R}\\
{\color{greenunder}\text{inner-identity law for }\text{sw}_{S,M}:}\quad & =\text{pu}_{M}^{\gunderline{\uparrow S\uparrow R}}=\text{pu}_{M}^{\uparrow T}\quad.
\end{align*}


\paragraph{Interchange laws}

The outer-interchange law is
\begin{equation}
\text{ftn}_{T}^{\uparrow M}\bef\text{sw}_{T,M}=\text{sw}_{T,M}\bef\text{sw}_{T,M}^{\uparrow T}\bef\text{ftn}_{T}\quad.\label{eq:3-swap-outer-interchange-T}
\end{equation}
We will use the outer-interchange laws for $\text{sw}_{R,M}$ and
$\text{sw}_{S,M}$:
\begin{align}
 & \text{ftn}_{R}^{\uparrow M}\bef\text{sw}_{R,M}=\text{sw}_{R,M}\bef\text{sw}_{R,M}^{\uparrow R}\bef\text{ftn}_{R}\quad,\label{eq:3-swap-outer-interchange-R}\\
 & \text{ftn}_{S}^{\uparrow M}\bef\text{sw}_{S,M}=\text{sw}_{S,M}\bef\text{sw}_{S,M}^{\uparrow S}\bef\text{ftn}_{S}\quad.\label{eq:3-swap-outer-interchange-S}
\end{align}
Begin with the right-hand side of Eq.~(\ref{eq:3-swap-outer-interchange-T})
since it is more complicated:
\begin{align*}
 & \text{sw}_{T,M}\bef\text{sw}_{T,M}^{\uparrow T}\bef\text{ftn}_{T}\\
{\color{greenunder}\text{definitions}:}\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\bef\big(\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\big)^{\uparrow S\uparrow R}\bef\text{sw}_{R,S}^{\uparrow R}}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
{\color{greenunder}^{\uparrow R}\text{-composition}:}\quad & =\text{sw}_{R,M}\bef\big(\text{sw}_{S,M}\bef\text{sw}_{R,M}^{\uparrow S}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R\uparrow S}\bef\text{sw}_{R,S}}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
{\color{greenunder}\text{sw's naturality}:}\quad & =\text{sw}_{R,M}\bef\big(\gunderline{\text{sw}_{S,M}\bef\text{sw}_{R,M}^{\uparrow S}\bef\text{sw}_{R,S}}\bef\text{sw}_{S,M}^{\uparrow S\uparrow R}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
{\color{greenunder}\text{Eq.~(\ref{eq:rigid-monad-3-swap-law})}:}\quad & =\text{sw}_{R,M}\bef\big(\gunderline{\text{sw}_{R,S}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}}\bef\text{sw}_{S,M}^{\uparrow S\uparrow R}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\quad.
\end{align*}
In the last expression, all \inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}s
are to the right of all \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}s.
So we look to rewrite the left-hand side of Eq.~(\ref{eq:3-swap-outer-interchange-T})
into the same form:
\begin{align*}
 & \text{ftn}_{T}^{\uparrow M}\bef\text{sw}_{T,M}\\
{\color{greenunder}\text{(\ref{eq:3-swap-def-of-sw-T-M}), (\ref{eq:3-swap-ftn-T-via-sw-R-S})}:}\quad & =\big(\text{sw}_{R,S}^{\uparrow R}\bef\text{ftn}_{R}\bef\gunderline{\text{ftn}_{S}^{\uparrow R}\big)^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\\
{\color{greenunder}\text{naturality}:}\quad & =\text{sw}_{R,S}^{\uparrow R\uparrow M}\bef\gunderline{\text{ftn}_{R}^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{ftn}_{S}^{\uparrow M\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}\\
{\color{greenunder}\text{Eq.~(\ref{eq:3-swap-outer-interchange-R})}:}\quad & =\text{sw}_{R,S}^{\uparrow R\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{R,M}^{\uparrow R}\bef\text{ftn}_{R}\bef\big(\gunderline{\text{ftn}_{S}^{\uparrow M}\bef\text{sw}_{S,M}}\big)^{\uparrow R}\\
{\color{greenunder}\text{Eq.~(\ref{eq:3-swap-outer-interchange-S})}:}\quad & =\text{sw}_{R,M}\bef\text{sw}_{R,S}^{\uparrow M\uparrow R}\bef\text{sw}_{R,M}^{\uparrow R}\bef\gunderline{\text{ftn}_{R}\bef\big(\text{sw}_{S,M}\bef\text{sw}_{S,M}^{\uparrow S}}\bef\text{ftn}_{S}\big)^{\uparrow R}\\
{\color{greenunder}\text{naturality}:}\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{R,S}^{\uparrow M\uparrow R}\bef\text{sw}_{R,M}^{\uparrow R}\bef\big(\text{sw}_{S,M}\bef\text{sw}_{S,M}^{\uparrow S}\big)^{\uparrow R\uparrow R}}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
{\color{greenunder}\text{composition}:}\quad & =\text{sw}_{R,M}\bef\big(\gunderline{\text{sw}_{R,S}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{sw}_{S,M}^{\uparrow S\uparrow R}}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\quad.
\end{align*}
Both sides of the outer-interchange law~(\ref{eq:3-swap-outer-interchange-T})
are now equal.

The proof of the inner-interchange law is simpler: the law says
\begin{equation}
\text{ftn}_{M}\bef\text{sw}_{T,M}=\text{sw}_{T,M}^{\uparrow M}\bef\text{sw}_{T,M}\bef\text{ftn}_{M}^{\uparrow T}\quad.\label{eq:3-swap-inner-interchange-T}
\end{equation}
We will use the inner-interchange laws for $\text{sw}_{R,M}$ and
$\text{sw}_{S,M}$:
\begin{align}
 & \text{ftn}_{M}\bef\text{sw}_{R,M}=\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{ftn}_{M}^{\uparrow R}\quad,\label{eq:3-swap-inner-interchange-R}\\
 & \text{ftn}_{M}\bef\text{sw}_{S,M}=\text{sw}_{S,M}^{\uparrow M}\bef\text{sw}_{S,M}\bef\text{ftn}_{M}^{\uparrow S}\quad.\label{eq:3-swap-inner-interchange-S}
\end{align}
Begin with the left-hand side of Eq.~(\ref{eq:3-swap-inner-interchange-T}):
\begin{align*}
 & \text{ftn}_{M}\bef\text{sw}_{T,M}=\gunderline{\text{ftn}_{M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:3-swap-inner-interchange-R})}:}\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\gunderline{\text{ftn}_{M}^{\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:3-swap-inner-interchange-S}) under }^{\uparrow R}:}\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\gunderline{\big(\text{sw}_{S,M}^{\uparrow M}\bef\text{sw}_{S,M}\bef\text{ftn}_{M}^{\uparrow S}\big)^{\uparrow R}}\\
{\color{greenunder}\text{composition under }^{\uparrow R}:}\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow M\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{ftn}_{M}^{\uparrow S\uparrow R}}
\end{align*}
The right-hand side of Eq.~(\ref{eq:3-swap-inner-interchange-T})
is 
\begin{align*}
 & \text{sw}_{T,M}^{\uparrow M}\bef\text{sw}_{T,M}\bef\text{ftn}_{M}^{\uparrow T}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:}\quad & =\big(\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\big)^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{ftn}_{M}^{\uparrow S\uparrow R}\\
{\color{greenunder}\text{naturality of }\text{sw}_{R,M}:}\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\gunderline{\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow M\uparrow R}}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{ftn}_{M}^{\uparrow S\uparrow R}\quad.
\end{align*}
The right-hand side is now equal to the left-hand side.

\paragraph{Monadic naturality laws}

We need to verify that the three laws,
\[
\text{sw}_{T,\text{Id}}=\text{id}\quad,\quad\quad\text{sw}_{T,M}\bef\phi^{\uparrow T}=\phi\bef\text{sw}_{T,N}\quad,\quad\quad\text{sw}_{T,M}\bef\theta=\theta^{\uparrow M}\quad,
\]
hold for any monadic morphisms $\phi:M\leadsto N$ and $\theta:T\leadsto\text{Id}$.
We may assume that these laws already hold for $\text{sw}_{R,M}$
and $\text{sw}_{S,M}$.

To verify the first law, write
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{id}:}\quad & \text{sw}_{T,\text{Id}}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:}\quad & =\text{sw}_{R,\text{Id}}\bef\text{sw}_{S,\text{Id}}^{\uparrow R}\\
{\color{greenunder}\text{first law for }\text{sw}_{R,\text{Id}}\text{ and }\text{sw}_{S,\text{Id}}:}\quad & =\text{id}\bef\text{id}^{\uparrow R}=\text{id}\quad.
\end{align*}
To verify the second law, write
\begin{align*}
{\color{greenunder}\text{expect to equal }\phi\bef\text{sw}_{T,N}:}\quad & \text{sw}_{T,M}\bef\phi^{\uparrow T}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:}\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\bef\phi^{\uparrow S\uparrow R}}\\
{\color{greenunder}\text{second law for }\text{sw}_{S,M}\text{ under }^{\uparrow R}:}\quad & =\gunderline{\text{sw}_{R,M}\bef\big(\phi}\bef\text{sw}_{S,N}\big)^{\uparrow R}\\
{\color{greenunder}\text{second law for }\text{sw}_{R,M}:}\quad & =\phi\bef\gunderline{\text{sw}_{R,N}\bef\text{sw}_{S,N}^{\uparrow R}}=\phi\bef\gunderline{\text{sw}_{T,N}}\quad.
\end{align*}
To verify the third law, we begin with the left-hand side,
\[
\text{sw}_{T,M}\bef\theta=\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\bef\theta\quad.
\]
At this point, no relationship or law applies to the intermediate
expression $\text{sw}_{S,M}^{\uparrow R}\bef\theta$, so we need additional
information to proceed. This information is given by Lemma~\ref{subsec:Lemma-base-runner-for-composed-monad},
which expresses $\theta=\theta_{R}\bef\theta_{S}$ where $\theta_{R}$
and $\theta_{S}$ are monadic morphisms. So, we may use $\theta_{R}$
and $\theta_{S}$ with the monadic morphism laws for $R$ and $S$,
in particular with the third law:
\[
\text{sw}_{R,M}\bef\theta_{R}=\theta_{R}^{\uparrow M}\quad,\quad\quad\text{sw}_{S,M}\bef\theta_{S}=\theta_{S}^{\uparrow M}\quad.
\]

Now we can finish the proof of the third monadic naturality law:
\begin{align*}
{\color{greenunder}\text{expect to equal }\theta^{\uparrow M}:}\quad & \text{sw}_{T,M}\bef\gunderline{\theta}\\
{\color{greenunder}\text{Lemma~\ref{subsec:Lemma-base-runner-for-composed-monad}}:}\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\bef\theta_{R}}\bef\theta_{S}\\
{\color{greenunder}\text{naturality of }\theta_{R}:}\quad & =\gunderline{\text{sw}_{R,M}\bef\theta_{R}}\bef\gunderline{\text{sw}_{S,M}\bef\theta_{S}}\\
{\color{greenunder}\text{third law for }R\text{ and }S:}\quad & =\theta_{R}^{\uparrow M}\bef\theta_{S}^{\uparrow M}=\theta^{\uparrow M}\quad.
\end{align*}


\subsubsection{Lemma \label{subsec:Lemma-base-runner-for-composed-monad}}

If $R$ is a rigid monad with a lawful \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
method $\text{sw}_{R,M}$ and $S$ is any (not necessarily rigid)
monad then any monadic morphism $\theta:R\circ S\leadsto\text{Id}$
can be expressed as a composition $\theta=\theta_{R}\bef\theta_{S}$
where 
\[
\theta_{R}\triangleq\text{pu}_{S}^{\uparrow R}\bef\theta\quad,\quad\quad\theta_{S}\triangleq\text{pu}_{R}\bef\theta
\]
are monadic morphisms. In other words, all ``runners'' $\theta$
for the composed monad $R\circ S$ can be written as a function composition
of some ``runners'' $\theta_{R}:R\leadsto\text{Id}$ and $\theta_{S}:S\leadsto\text{Id}$
for the monads $R$ and $S$. 

\paragraph{Proof}

How can we find $\theta_{R}$ and $\theta_{S}$ from the given ``runner''
$\theta$? Consider that $\theta$ will evaluate the operations of
both monads $R$ and $S$, while $\theta_{R}$ can evaluate only the
operations of $R$. To obtain $\theta_{R}:R\leadsto\text{Id}$ from
$\theta:R\circ S\leadsto\text{Id}$, we need to prepend a function
$R\leadsto R\circ S$. A suitable function of this type is 
\[
\text{pu}_{S}^{\uparrow R}:R^{A}\Rightarrow R^{S^{A}}\quad.
\]
So, $\theta_{R}=\text{pu}_{S}^{\uparrow R}\bef\theta$ has the correct
type signature, $R^{A}\Rightarrow A$. Similarly, $\theta_{S}=\text{pu}_{R}\bef\theta$
has the correct type signature, $S^{A}\Rightarrow A$. So, we can
define $\theta_{R}$ and $\theta_{S}$ from the given ``runner''
$\theta$ as
\[
\theta_{R}\triangleq\text{pu}_{S}^{\uparrow R}\bef\theta\quad,\quad\quad\theta_{S}\triangleq\text{pu}_{R}\bef\theta\quad.
\]
Since $\text{pu}_{R}$ and $\text{pu}_{S}^{\uparrow R}$ are the lifting
and the base lifting of the monad transformer $T_{R}^{S}=R\circ S$,
Theorem~\ref{subsec:Theorem-outside-transformer-swap-laws} shows
that $\text{pu}_{R}$ and $\text{pu}_{S}^{\uparrow R}$ are monadic
morphisms. Since the composition of monadic morphisms is again a monadic
morphism (Statement~\ref{subsec:Statement-monadic-morphism-composition}),
we see that $\theta_{R}$ and $\theta_{S}$ as defined above are monadic
morphisms.

It remains to verify that $\theta=\theta_{R}\bef\theta_{S}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }\theta:}\quad & \theta_{R}\bef\theta_{S}=\text{pu}_{S}^{\uparrow R}\bef\gunderline{\theta\bef\text{pu}_{R}}\bef\theta\\
{\color{greenunder}\text{naturality of }\theta:}\quad & =\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\gunderline{\uparrow T}}\bef\theta\bef\theta=\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\gunderline{\theta\bef\theta}\\
{\color{greenunder}\text{composition law of }\theta:}\quad & =\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\gunderline{\text{ftn}_{T}\bef\theta}\quad.
\end{align*}
The last line differs from the required result, $\theta$, by the
function $\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\text{ftn}_{T}$.
We will finish the proof if we show that this function is identity:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{id}:}\quad & =\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\gunderline{\text{ftn}_{T}}\quad.\\
{\color{greenunder}\text{use Eq.~(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})}:}\quad & =\text{pu}_{S}^{\uparrow R}\bef\gunderline{\text{pu}_{R}^{\uparrow S\uparrow R}\bef\text{sw}_{R,S}^{\uparrow R}}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
{\color{greenunder}\text{outer-identity law for }\text{sw}_{R,S}:}\quad & =\text{pu}_{S}^{\uparrow R}\bef\gunderline{\text{pu}_{R}^{\uparrow R}\bef\text{ftn}_{R}}\bef\text{ftn}_{S}^{\uparrow R}\\
{\color{greenunder}\text{identity law for }R:}\quad & =\gunderline{\text{pu}_{S}^{\uparrow R}\bef\text{ftn}_{S}^{\uparrow R}}\\
{\color{greenunder}\text{identity law for }S:}\quad & =\text{id}\quad.
\end{align*}


\subsection{Rigid monad construction 3: product}

\subsubsection{Statement \label{subsec:Statement-product-rigid-monads}\ref{subsec:Statement-product-rigid-monads}}

The product of rigid monads, $R_{1}^{A}\times R_{2}^{A}$, is a rigid
monad.

\subparagraph{Proof}

If we show that $R_{1}^{A}\times R_{2}^{A}$ has a composed-outside
transformer, it will follow (by definition) that $R_{1}^{A}\times R_{2}^{A}$
is a rigid monad. It follows from Theorem~\ref{subsec:Statement-product-of-monad-transformers}
(whose proof does not depend on any of the results of this section)
that the lawful monad transformer $T^{M,A}$ for the product monad
$R_{1}^{A}\times R_{2}^{A}$ is the product of transformers 
\[
T_{R_{1}}^{M,A}\times T_{R_{2}}^{M,A}=R_{1}^{M^{A}}\times R_{2}^{M^{A}}\quad,
\]
where $M$ is the foreign monad. This is the required composed-outside
transformer for the monad $R_{1}^{A}\times R_{2}^{A}$.

\subsection{Rigid monad construction 4: selector}

The \index{selector monad}\textbf{selector monad} $S^{A}\triangleq F^{A\Rightarrow R^{Q}}\Rightarrow R^{A}$
is rigid if $R^{\bullet}$ is a rigid monad, $F^{\bullet}$ is any
functor, and $Q$ is any fixed type.

\subsection{Rigid functors\label{subsec:Rigid-functors}}

The properties of rigid monads can be extended to a (possibly) larger
class of rigid functors. We begin with a definition of a rigid functor
that, unlike the definition of rigid monads (Section~\ref{sec:transformers-rigid-monads}),
does not refer to any monad transformer.

\paragraph{Definition of rigid functors}

$R$ is a \textbf{rigid functor\index{rigid functor}} if there exists
a natural transformation \inputencoding{latin9}\lstinline!fuseIn!\inputencoding{utf8}
(short notation ``$\text{fi}_{R}$'') with the type signature
\[
\text{fi}_{R}:\forall(A,B).\,(A\Rightarrow R^{B})\Rightarrow R^{A\Rightarrow B}
\]
satisfying the non-degeneracy law~\ref{eq:rigid-non-degeneracy-law}
(see below).

Not all functors admit a natural transformation with the type signature
of \inputencoding{latin9}\lstinline!fuseIn!\inputencoding{utf8}.
For example, the functor $F^{A}\triangleq Z+A$ is not rigid because
the required type signature 
\[
\forall(A,B).\,\left(A\Rightarrow Z+B\right)\Rightarrow Z+\left(A\Rightarrow B\right)
\]
cannot be implemented. However, any functor $R$ admits the opposite
natural transformation \inputencoding{latin9}\lstinline!fuseOut!\inputencoding{utf8}
(short notation $\text{fo}_{R}$), defined by
\begin{align}
\text{fo} & :\forall(A,B).\,R^{A\Rightarrow B}\Rightarrow A\Rightarrow R^{B}\quad,\nonumber \\
\text{fo} & \left(r\right)=a\Rightarrow\big(f^{:A\Rightarrow B}\Rightarrow f\left(a\right)\big)^{\uparrow R}r\quad.\label{eq:fuseOut-def}
\end{align}
The method \inputencoding{latin9}\lstinline!fuseIn!\inputencoding{utf8}
must satisfy the nondegeneracy law 
\begin{equation}
\text{fi}_{R}\bef\text{fo}_{R}=\text{id}^{:(A\Rightarrow R^{B})\Rightarrow(A\Rightarrow R^{B})}\quad.\label{eq:rigid-non-degeneracy-law}
\end{equation}
The opposite relation does not hold in general, $\text{fo}_{R}\bef\text{fi}_{R}\neq\text{id}$
(see Example~\ref{subsec:Example-fo-fi-not-id}).

Note that the type signature of $\text{fi}_{R}$ is the same as the
type signature of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
with respect to the \inputencoding{latin9}\lstinline!Reader!\inputencoding{utf8}
monad,
\[
\text{sw}_{R,M}:M^{R^{A}}\Rightarrow R^{M^{A}}\cong(Z\Rightarrow R^{A})\Rightarrow R^{Z\Rightarrow A}\text{ if we set }M^{A}\triangleq Z\Rightarrow A\quad.
\]
So we are prompted to ask whether any rigid monad having a \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
method might also admit \inputencoding{latin9}\lstinline!fuseIn!\inputencoding{utf8}.
It turns out that all rigid monads (regardless of the existence of
\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}) are also
rigid functors. While proving that statement, we will not assume that
\inputencoding{latin9}\lstinline!swap!\inputencoding{utf8} exists
for the monad $R$, but will use directly the definition of rigid
monads via the composed-outside monad transformer.

\subsubsection{Statement \label{subsec:Statement-rigid-monads-are-rigid-functors}\ref{subsec:Statement-rigid-monads-are-rigid-functors}}

A rigid monad $R$ is also a rigid functor.

\subparagraph{Proof}

By assumption, the monad $R$ has the composed-outside monad transformer
$T_{R}^{M}=R\circ M$ and the corresponding monad method $\text{ftn}_{T}$.
We can define the transformation $\text{fi}_{R}$ in the same way
as Eq.~(\ref{eq:define-swap-via-flatten}) defined the \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
method via $\text{ftn}_{T}$. To use that formula, we need to set
the foreign monad $M$ to be the \inputencoding{latin9}\lstinline!Reader!\inputencoding{utf8}
monad, $M^{B}\triangleq A\Rightarrow B$, with the fixed environment
type $A$:
\begin{equation}
\text{fi}_{R}(f^{:A\Rightarrow R^{B}})=\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\bef\text{ftn}_{T}\label{eq:rigid-monad-fuseIn-def}
\end{equation}
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{4pc}A\Rightarrow R^{B}\ar[r]\sp(0.5){\text{pu}_{M}^{\uparrow R\uparrow M}}\ar[rrd]\sb(0.5){\text{fi}_{R}\triangleq} & A\Rightarrow R^{A\Rightarrow B}\ar[r]\sp(0.5){\text{pu}_{R}} & R^{A\Rightarrow R^{A\Rightarrow B}}\ar[d]\sp(0.45){\text{ftn}_{T}}\\
 &  & R^{A\Rightarrow B}
}
\]
Since $M$ is the \inputencoding{latin9}\lstinline!Reader!\inputencoding{utf8}
monad with the environment type $A$, we have
\[
\text{pu}_{M}(x)=(\_^{:A}\Rightarrow x)\quad,\quad\quad(f^{:X\Rightarrow Y})^{\uparrow M}(r^{:A\Rightarrow X})=r\bef f\quad.
\]
The type signature of the function \inputencoding{latin9}\lstinline!fuseOut!\inputencoding{utf8},
\[
\text{fo}:R^{A\Rightarrow B}\Rightarrow A\Rightarrow R^{B}\quad,
\]
resembles ``running'' the composed monad $R^{M^{B}}$ into $R^{B}$,
given a value of the environment (of type $A$). Indeed, given a fixed
value $a^{:A}$, we can ``run'' the \inputencoding{latin9}\lstinline!Reader!\inputencoding{utf8}
monad into the identity monad. The corresponding ``runner'' $\phi_{a}^{:M\leadsto\text{Id}}$
is
\begin{equation}
\phi_{a}^{:M^{X}\Rightarrow X}=\big(m^{A\Rightarrow X}\Rightarrow m(a)\big)\quad.\label{eq:runner-phi-def}
\end{equation}
So we are inspired to use the runner law for the monad transformer
$T_{R}^{M}$. That law (which holds since we assumed that $T_{R}^{M}$
satisfies all laws) says that the lifted ``runner'' $\phi_{a}^{\uparrow R}$
is a monadic morphism $T_{R}^{M}\leadsto T_{R}^{\text{Id}}\cong T_{R}^{M}\leadsto R$.
The monadic morphism law for $\phi_{a}^{\uparrow R}$ is then written
as
\begin{equation}
\text{ftn}_{T}\bef\phi_{a}^{\uparrow R}=\phi_{a}^{\uparrow R\uparrow M\uparrow R}\bef\phi_{a}^{\uparrow R}\bef\text{ftn}_{R}\quad.\label{eq:rigid-monad-is-rigid-functor-derivation1}
\end{equation}
How could we use this law to obtain Eq.~(\ref{eq:rigid-non-degeneracy-law})?
Compare Eqs.~(\ref{eq:fuseOut-def}) and~(\ref{eq:runner-phi-def})
and derive the connection between the ``runner'' $\phi_{a}$ and
the \inputencoding{latin9}\lstinline!fuseOut!\inputencoding{utf8}
function (which always exists for any functor $R$),
\[
\text{fo}_{R}=\big(r\Rightarrow a\Rightarrow r\triangleright\phi_{a}^{\uparrow R}\big)\quad,
\]
and then rewrite the law~(\ref{eq:rigid-non-degeneracy-law}) as
\begin{align*}
{\color{greenunder}\text{expect to equal }m:}\quad & m^{:M^{R^{B}}}\triangleright\text{fi}_{R}\bef\text{fo}_{R}=\left(m\triangleright\text{fi}_{R}\right)\triangleright\gunderline{\text{fo}_{R}}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:fuseOut-def})}:}\quad & =a\Rightarrow m\triangleright\gunderline{\text{fi}_{R}}\triangleright\phi_{a}^{\uparrow R}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-fuseIn-def})}:}\quad & =a\Rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\bef\gunderline{\text{ftn}_{T}\bef\phi_{a}^{\uparrow R}}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-monad-is-rigid-functor-derivation1})}:}\quad & =a\Rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\gunderline{\text{pu}_{R}\bef\phi_{a}^{\uparrow R\uparrow M\uparrow R}\bef\phi_{a}^{\uparrow R}}\bef\text{ftn}_{R}\\
{\color{greenunder}\text{naturality of }\text{pu}_{R}:}\quad & =a\Rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\phi_{a}^{\uparrow R\uparrow M}\bef\phi_{a}\bef\gunderline{\text{pu}_{R}\bef\text{ftn}_{R}}\\
{\color{greenunder}\text{left identity law of }R:}\quad & =a\Rightarrow m\triangleright\gunderline{(\text{pu}_{M}\bef\phi_{a})}^{\uparrow R\uparrow M}\bef\phi_{a}\\
{\color{greenunder}\text{identity law for }\phi_{a}:}\quad & =a\Rightarrow m\triangleright\gunderline{\phi_{a}}\\
{\color{greenunder}\text{definition~(\ref{eq:runner-phi-def}) for }\phi_{a}:}\quad & =\gunderline{\left(a\Rightarrow m(a)\right)}=m\quad.
\end{align*}
Here we used the monadic morphism identity law for $\phi_{a}$,
\[
\text{pu}_{M}\bef\phi_{a}=\big(x\Rightarrow(\_\Rightarrow x)\big)\bef(m\Rightarrow a\triangleright m)=\left(x\Rightarrow a\triangleright(\_\Rightarrow x)\right)=\left(x\Rightarrow x\right)=\text{id}\quad.
\]


\subsubsection{Example \label{subsec:Example-fo-fi-not-id}\ref{subsec:Example-fo-fi-not-id}\index{solved examples}}

To show that the opposite of the non-degeneracy law does not always
hold, consider the rigid monads $P^{A}\triangleq Z\Rightarrow A$
and $R^{A}\triangleq\left(A\Rightarrow Q\right)\Rightarrow A$, where
$Q$ and $Z$ are fixed types. Since all rigid monads are rigid functors,
it follows that the monads $P$ and $R$ have methods $\text{fi}_{P}$,
$\text{fo}_{P}$, $\text{fi}_{R}$,$\text{fo}_{R}$ satisfying the
non-degeneracy law~(\ref{eq:rigid-non-degeneracy-law}). It turns
out that additionally $\text{fo}_{P}\bef\text{fi}_{P}=\text{id}$,
i.e.~the methods $\text{fo}_{P}$ and $\text{fi}_{P}$ are inverses
of each other, but $\text{fo}_{R}\bef\text{fi}_{R}\neq\text{id}$.

To show that $\text{fo}_{P}\bef\text{fi}_{P}=\text{id}$, consider
the type signatures of $\text{fo}_{P}$ and $\text{fi}_{P}$:
\begin{align*}
\text{fo}_{P} & :P^{A\Rightarrow B}\Rightarrow A\Rightarrow P^{B}\cong\left(Z\Rightarrow A\Rightarrow B\right)\Rightarrow\left(A\Rightarrow Z\Rightarrow B\right)\quad,\\
\text{fi}_{P} & :\big(A\Rightarrow P^{B}\big)\Rightarrow P^{A\Rightarrow B}\cong\left(A\Rightarrow Z\Rightarrow B\right)\Rightarrow\left(Z\Rightarrow A\Rightarrow B\right)\quad.
\end{align*}
The implementations of these functions are derived uniquely from type
signatures, as long as we require that these implementations are natural
transformations. The functions $\text{fo}_{P}$ and $\text{fi}_{P}$
switch the curried arguments of types $A$ and $Z$ of a function
that returns values of type $B$. It is clear that these two functions
are inverses of each other. To show this directly, consider the type
signature of $\text{fo}_{P}\bef\text{fi}_{P}$,
\[
\big(\text{fo}_{P}\bef\text{fi}_{P}\big):P^{A\Rightarrow B}\Rightarrow P^{A\Rightarrow B}\cong\left(Z\Rightarrow A\Rightarrow B\right)\Rightarrow\left(Z\Rightarrow A\Rightarrow B\right)\quad.
\]
There is only one implementation for this type signature as a natural
transformation, namely the identity function $\text{id}^{Z\Rightarrow A\Rightarrow B}$.

For the monad $R$, the type signatures of $\text{fi}_{R}$ and $\text{fo}_{R}$
are
\begin{align*}
\text{fi}_{R} & :\left(A\Rightarrow\left(B\Rightarrow Q\right)\Rightarrow B\right)\Rightarrow\left(\left(A\Rightarrow B\right)\Rightarrow Q\right)\Rightarrow A\Rightarrow B\quad,\\
\text{fo}_{R} & :\left(\left(\left(A\Rightarrow B\right)\Rightarrow Q\right)\Rightarrow A\Rightarrow B\right)\Rightarrow A\Rightarrow\left(B\Rightarrow Q\right)\Rightarrow B\quad,
\end{align*}
and the implementations are again derived uniquely from type signatures,
\begin{align*}
f^{:A\Rightarrow\left(B\Rightarrow Q\right)\Rightarrow B} & \triangleright\text{fi}_{R}=x^{:\left(A\Rightarrow B\right)\Rightarrow Q}\Rightarrow a^{:A}\Rightarrow f(a)(b^{:B}\Rightarrow x(\_\Rightarrow b))\quad,\\
g^{:\left(\left(A\Rightarrow B\right)\Rightarrow Q\right)\Rightarrow A\Rightarrow B} & \triangleright\text{fo}_{R}=a^{:A}\Rightarrow y^{:B\Rightarrow Q}\Rightarrow g(h^{:A\Rightarrow B}\Rightarrow y(h(a)))(a)\quad.
\end{align*}
We notice that the implementation of $\text{fi}_{R}$ uses a constant
function, $\left(\_\Rightarrow b\right)$, which is likely to lose
information. Indeed, while $\text{fi}_{R}\bef\text{fo}_{R}=\text{id}$
as it must be due to the rigid non-degeneracy law, we find that 
\begin{align*}
{\color{greenunder}\text{expect \emph{not} to equal }g:}\quad & g\triangleright\text{fo}_{R}\bef\text{fi}_{R}=\left(g\triangleright\text{fo}_{R}\right)\triangleright\gunderline{\text{fi}_{R}}\\
{\color{greenunder}\text{definition of }\text{fi}_{R}:}\quad & =x\Rightarrow a\Rightarrow\gunderline{\text{fo}_{R}}(g)(a)(b\Rightarrow x(\_\Rightarrow b))\\
{\color{greenunder}\text{definition of }\text{fo}_{R}:}\quad & =x\Rightarrow a\Rightarrow g\big(h^{:A\Rightarrow B}\Rightarrow h(a)\triangleright\gunderline{(b\Rightarrow}x(\_\Rightarrow b))\big)(a)\\
{\color{greenunder}\text{apply to argument }b:}\quad & =x\Rightarrow a\Rightarrow g\big(h\Rightarrow x(\_\Rightarrow h(a))\big)(a)\quad.
\end{align*}
We cannot simplify the last line any further: the functions $g$,
$h$, and $x$ are unknown, and we cannot calculate symbolically,
say, the value of $x(\_\Rightarrow h(a))$. If the last line were
equal to $g$, we would expect it to be $x\Rightarrow a\Rightarrow g(x)(a)$.
The difference is in the first argument of $g$, namely we have $h\Rightarrow x(\_\Rightarrow h(a))$
instead of $x$. The two last expressions are not always equal; they
would be equal if we had 
\[
\left(h\Rightarrow x(h)\right)=\left(h\Rightarrow x(k\Rightarrow h(k))\right)
\]
instead of $h\Rightarrow x(\_\Rightarrow h(a))$. Consider again the
argument of $x$ in the two last expressions: $k\Rightarrow h(a)$
instead of $k\Rightarrow h(k)$. Since $h$ is not always a constant
function ($h$ is an arbitrary function of type $A\Rightarrow B$),
the two expressions $k\Rightarrow h(a)$ and $k\Rightarrow h(k)$
are generally not equal. So, we must conclude that $\text{fo}_{R}\bef\text{fi}_{R}\neq\text{id}$.

\subsubsection{Exercise \label{subsec:Exercise-pair-functor-is-rigid}\ref{subsec:Exercise-pair-functor-is-rigid}\index{exercises}}

Show that the functor $F^{A}\triangleq A\times A\times A$ is rigid.

\subsubsection{Exercise \label{subsec:Exercise-option-not-rigid}\ref{subsec:Exercise-option-not-rigid}}

Show that the functor $F^{A}\triangleq\bbnum 1+A\times A$ is not
rigid.

\subsubsection{Exercise \label{subsec:Exercise-continuation-not-rigid-1}\ref{subsec:Exercise-continuation-not-rigid-1}}

Show that the functor $F^{A}\triangleq\left(A\Rightarrow Z\right)\Rightarrow Z$
is not rigid. (Here $Z$ is a fixed type.)

Since all rigid monads are rigid functors, we can reuse all the rigid
monad constructions to obtain new rigid functors. The following statement
demonstrates a construction of rigid functors that does not assume
any monadic properties. It shows that the set of all rigid functors
is larger than the set of all rigid monads.

\subsubsection{Statement \label{subsec:Statement-rigid-functor-h-p}\ref{subsec:Statement-rigid-functor-h-p}}

The functor $S^{\bullet}\triangleq H^{\bullet}\Rightarrow P^{\bullet}$
is rigid when $H$ is any contrafunctor and $P$ is any rigid functor.
(Note that $P$ does not need to be a monad.)

\subparagraph{Proof}

We assume that $\text{fi}_{P}$ and $\text{fo}_{P}$ are known and
satisfy the non-degeneracy law~(\ref{eq:rigid-non-degeneracy-law}).
The function $\text{fi}_{S}$ is then defined by
\begin{align*}
\text{fi}_{S} & :\big(A\Rightarrow H^{B}\Rightarrow P^{B}\big)\Rightarrow H^{A\Rightarrow B}\Rightarrow P^{A\Rightarrow B}\quad,\\
\text{fi}_{S} & =f^{:A\Rightarrow H^{B}\Rightarrow P^{B}}\Rightarrow h^{:H^{A\Rightarrow B}}\Rightarrow\text{fi}_{P}\big(a\Rightarrow f(a)\big(\left(b\Rightarrow\_\Rightarrow b\right)^{\downarrow H}h\big)\big)\quad,
\end{align*}
or, using the forwarding notation,
\[
h\triangleright\text{fi}_{S}(f)=\big(a\Rightarrow h\triangleright\left(b\Rightarrow\_\Rightarrow b\right)^{\downarrow H}\triangleright f(a)\big)\triangleright\text{fi}_{P}\quad.
\]
Let us write the definition of $\text{fo}_{S}$ as well,
\begin{align*}
\text{fo}_{S} & :\big(H^{A\Rightarrow B}\Rightarrow P^{A\Rightarrow B}\big)\Rightarrow A\Rightarrow H^{B}\Rightarrow P^{B}\quad,\\
\text{fo}_{S} & =g^{:H^{A\Rightarrow B}\Rightarrow P^{A\Rightarrow B}}\Rightarrow a^{:A}\Rightarrow h^{:H^{B}}\Rightarrow\text{fo}_{P}\bigg(g\big(\left(p^{:A\Rightarrow B}\Rightarrow p(a)\right)^{\downarrow H}h\big)\bigg)(a)\quad,
\end{align*}
or, using the forwarding notation,
\[
\text{fo}_{S}(g)=a\triangleright\big(h\triangleright\left(p\Rightarrow p(a)\right)^{\downarrow H}\bef g\bef\text{fo}_{P}\big)\quad.
\]
To verify the non-degeneracy law for $S$, apply both sides to some
arguments; we expect $f\triangleright(\text{fi}_{S}\bef\text{fo}_{S})$
to equal $f$ for an arbitrary $f:A\Rightarrow H^{B}\Rightarrow P^{B}$.
To compare values, we need to apply both sides further to some arguments
$a:A$ and $h:H^{B}$. So we expect the following expression to equal
$f(a)(h)$:
\begin{align*}
\quad & \left(f\triangleright\text{fi}_{S}\bef\text{fo}_{S}\right)(a)(h)=(f\triangleright\text{fi}_{S}\triangleright\gunderline{\text{fo}_{S}})(a)(h)\\
{\color{greenunder}\text{expand }\text{fo}_{S}:}\quad & =a\triangleright\big(h\triangleright\left(p\Rightarrow a\triangleright p\right)^{\downarrow H}\triangleright\gunderline{\text{fi}_{S}(f)}\triangleright\text{fo}_{P}\big)\\
{\color{greenunder}\text{expand }\text{fi}_{S}:}\quad & =a\triangleright\big(\big(a\Rightarrow h\triangleright\gunderline{\left(p\Rightarrow p(a)\right)^{\downarrow H}\bef\left(b\Rightarrow\_\Rightarrow b\right)^{\downarrow H}}\bef f(a)\big)\triangleright\text{fi}_{P}\triangleright\text{fo}_{P}\big)\\
{\color{greenunder}\text{compose }^{\downarrow H}:}\quad & =a\triangleright\big(\big(a\Rightarrow h\triangleright\gunderline{\left((b\Rightarrow\_\Rightarrow b)\bef(p\Rightarrow p(a))\right)^{\downarrow H}}\bef f(a)\big)\triangleright\text{fi}_{P}\gunderline{\triangleright}\text{fo}_{P}\big)\quad.
\end{align*}
Computing the function composition
\[
(b\Rightarrow\_\Rightarrow b)\bef(p\Rightarrow p(a))=(b\Rightarrow(\_\Rightarrow b)(a))=(b\Rightarrow b)=\text{id}\quad,
\]
and using the non-degeneracy law $\text{fi}_{P}\bef\text{fo}_{P}=\text{id}$,
we can simplify further:
\begin{align*}
 & a\triangleright\big(\big(a\Rightarrow h\triangleright\gunderline{\left((b\Rightarrow\_\Rightarrow b)\bef(p\Rightarrow p(a))\right)^{\downarrow H}}\bef f(a)\big)\triangleright\text{fi}_{P}\gunderline{\triangleright}\text{fo}_{P}\big)\\
{\color{greenunder}\text{identity law for }H:}\quad & =a\triangleright\big(\big(a\Rightarrow h\triangleright f(a)\big)\triangleright\gunderline{\text{fi}_{P}\bef\text{fo}_{P}}\big)\\
{\color{greenunder}\text{non-degeneracy}:}\quad & =\gunderline{a\triangleright\big(a\Rightarrow}h\triangleright f(a)\big)=h\triangleright f(a)\quad.
\end{align*}
This equals $f(a)(h)$, as required.%
\begin{comment}
Statement 1.

The composition $R_{1}^{R_{2}^{\bullet}}$ is a rigid functor if both
$R_{1}$ and $R_{2}$ are rigid functors.

Proof

We will show that the non-degeneracy law $\text{fi}_{T}\bef\text{fo}_{T}=\text{id}$
holds for the rigid functor $T^{\bullet}\triangleq R^{M^{\bullet}}$
as long as $M$ is rigid.

Since it is given that $M$ is rigid, we may use its method $\text{fi}_{M}$
satisfying the non-degeneracy law $\text{fo}_{M}\left(\text{fi}_{M}\,f\right)=f$.

Flip the curried arguments of the function type $A\Rightarrow T^{B}\triangleq A\Rightarrow H^{M^{B}}\Rightarrow M^{B}$,
to obtain $H^{M^{B}}\Rightarrow A\Rightarrow M^{B}$, and note that
$A\Rightarrow M^{B}$ can be mapped to $M^{A\Rightarrow B}$ using
$\text{fi}_{M}$. So we can implement $\tilde{\text{fi}}_{T}$ using
$\text{fi}_{M}$:
\begin{align*}
\tilde{\text{fi}}_{T} & :\big(H^{M^{B}}\Rightarrow A\Rightarrow M^{B}\big)\Rightarrow H^{M^{A\Rightarrow B}}\Rightarrow M^{A\Rightarrow B}\\
\tilde{\text{fi}}_{T} & =f\Rightarrow h\Rightarrow\text{fi}_{M}\left(f\big(\left(b\Rightarrow\_\Rightarrow b\right)^{\uparrow M\downarrow H}h\big)\right)\\
\tilde{\text{fo}}_{T} & :\left(H^{M^{A\Rightarrow B}}\Rightarrow M^{A\Rightarrow B}\right)\Rightarrow H^{M^{B}}\Rightarrow A\Rightarrow M^{B}\\
\tilde{\text{fo}}_{T} & =g\Rightarrow h\Rightarrow a\Rightarrow\text{fo}_{M}\left(g\big(\left(p^{:A\Rightarrow B}\Rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)\right)a
\end{align*}
To show the non-degeneracy law for $T$, compute
\begin{align*}
 & \tilde{\text{fo}}_{T}\left(\tilde{\text{fi}}_{T}f\right)h^{:H^{M^{B}}}a^{:A}\\
\text{insert the definition of }\tilde{\text{fo}}_{T}\text{: }\quad & =\text{fo}_{M}\left(\left(\tilde{\text{fi}}_{T}f\right)\big(\left(p\Rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)\right)a\\
\text{insert the definition of }\tilde{\text{fi}}_{T}\text{: }\quad & =\text{fo}_{M}\left(\text{fi}_{M}\left(f\big(\left(b\Rightarrow\_\Rightarrow b\right)^{\uparrow M\downarrow H}\left(p\Rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)\right)\right)a\\
\text{nondegeneracy law for }\text{fi}_{M}\text{: }\quad & =f\big(\left(b\Rightarrow\_\Rightarrow b\right)^{\uparrow M\downarrow H}\left(p\Rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)a\\
\text{composition laws for }M,H\text{: }\quad & =f\big(\left(b\Rightarrow\_\Rightarrow b\bef p\Rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)a\\
\text{simplify }\text{: }\quad & =f\left(\left(b\Rightarrow b\right)^{\uparrow M\downarrow H}h\right)a\\
\text{identity laws for }M,H\text{: }\quad & =f\,h\,a\quad.
\end{align*}
We obtained $\tilde{\text{fo}}_{T}\left(\tilde{\text{fi}}_{T}\,f\right)h\,a=f\,h\,a$.
Therefore the non-degeneracy law $\tilde{\text{fi}}_{T}\bef\tilde{\text{fo}}_{T}=\text{id}$
holds. 
\end{comment}
\begin{comment}
Trying the triangle notation: It seems that $\left(a\triangleright\right)$
is not so useful, we could just write $\left(f\Rightarrow f(a)\right)$
instead.
\begin{align*}
\tilde{\text{fi}}\left(f\right) & =f\triangleright\tilde{\text{fi}}=\left(b\Rightarrow\_\Rightarrow b\right)^{\downarrow H}\bef f\quad,\\
\tilde{\text{fo}}\left(g\right) & =g\triangleright\tilde{\text{fo}}=h\Rightarrow a\Rightarrow g((a\triangleright)^{\downarrow H}h)a=h\Rightarrow a\Rightarrow h\triangleright(a\triangleright)^{\downarrow H}\bef g\bef\left(a\triangleright\right)\quad.
\end{align*}
Then
\begin{align*}
 & f\triangleright\tilde{\text{fi}}\triangleright\tilde{\text{fo}}\\
 & =h\Rightarrow a\Rightarrow h\triangleright(a\triangleright)^{\downarrow H}\bef\left(f\triangleright\tilde{\text{fi}}\right)\bef\left(a\triangleright\right)\\
 & =h\Rightarrow a\Rightarrow h\triangleright(a\triangleright)^{\downarrow H}\bef\left(b\Rightarrow\_\Rightarrow b\right)^{\downarrow H}\bef f\bef\left(a\triangleright\right)\\
 & =h\Rightarrow a\Rightarrow h\triangleright\left(b\Rightarrow\_\Rightarrow b\bef\left(a\triangleright\right)\right)^{\downarrow H}\bef f\bef\left(a\triangleright\right)\\
 & =h\Rightarrow a\Rightarrow h\triangleright f\bef\left(a\triangleright\right)=h\Rightarrow a\Rightarrow h\triangleright f\triangleright\left(a\triangleright\right)\\
 & =h\Rightarrow a\Rightarrow f(h)(a)=f
\end{align*}
What are the simplification rules?
\begin{align*}
 & a\Rightarrow x\triangleright\left(a\triangleright\right)=x\quad,\\
 & a\Rightarrow a\triangleright f=f\quad,\\
 & x\triangleright\left(a\triangleright\right)=x(a)=a\triangleright x\quad,\\
 & x\triangleright y\triangleright\left(a\triangleright\right)=a\triangleright\left(x\triangleright y\right)\quad.
\end{align*}
\end{comment}


\subsubsection{Statement \label{subsec:Statement-rigid-functor-is-pointed}\ref{subsec:Statement-rigid-functor-is-pointed}}

A rigid functor $R$ is pointed; the method \inputencoding{latin9}\lstinline!pure!\inputencoding{utf8}
can be defined as
\[
\text{pu}_{R}(x^{:A})\triangleq\text{id}^{:R^{A}\Rightarrow R^{A}}\triangleright\text{fi}_{R}\triangleright(\_\Rightarrow x)^{\uparrow R}\quad.
\]
In particular, there is a selected value $r_{1}$ of type $R^{\bbnum 1}$
(``wrapped unit''), computed as 
\begin{equation}
r_{1}\triangleq\text{pu}_{R}(1)=\text{id}\triangleright\text{fi}_{R}\triangleright(\_\Rightarrow1)^{\uparrow R}\quad.\label{eq:rigid-functor-def-of-wrapped-unit}
\end{equation}


\paragraph{Proof}

The method $\text{fi}_{R}:(X\Rightarrow R^{Y})\Rightarrow R^{X\Rightarrow Y}$
with type parameters $X=R^{A}$ and $Y=A$ is applied to the identity
function $\text{id}:R^{A}=R^{A}$, considered as a value of type $X\Rightarrow R^{Y}$.
The result is a value
\[
\text{fi}_{R}(\text{id}):R^{R^{A}\Rightarrow A}\quad.
\]
The result is transformed via the raised constant function $\left(\_\Rightarrow x\right)^{\uparrow R}$,
which takes $R^{R^{A}\Rightarrow A}$ and returns $R^{A}$. The resulting
code can be written as
\[
\text{pu}_{R}(x)\triangleq(\_\Rightarrow x)^{\uparrow R}(\text{fi}_{R}(\text{id}))=\text{id}\triangleright\text{fi}_{R}\triangleright(\_\Rightarrow x)^{\uparrow R}\quad.
\]
The function $\text{pu}_{R}$ defined in this way is a natural transformation
since $\text{fi}_{R}$ is one. Applying $\text{pu}_{R}$ to a unit
value, we obtain the selected value $r_{1}$ of type $R^{\bbnum 1}$.

The next theorem shows that $r_{1}$ is the \emph{only} distinct value
of the type $R^{\bbnum 1}$. This means, in particular, that a rigid
functor cannot be a disjunctive type defined with several constructors,
such as $\bbnum 1+A+A$ or $\text{List}^{A}$. A rigid functor's type
definition must have a single constructor. This is one motivation
for the name ``rigid'': the container $R^{A}$ has a fixed shape
and bears no extra information other than holding some values of type
$A$. 

\subsubsection{Theorem \label{subsec:Statement-rigid-functor-wrapped-unit-is-unit}\ref{subsec:Statement-rigid-functor-wrapped-unit-is-unit}}

For a rigid functor $R$ with the method $\text{fi}_{R}$ satisfying
the non-degeneracy law~(\ref{eq:rigid-non-degeneracy-law}), the
type $R^{\bbnum 1}$ is equivalent to the unit type, $R^{\bbnum 1}\cong\bbnum 1$.
The value $r_{1}$ defined by Eq.~(\ref{eq:rigid-functor-def-of-wrapped-unit})
is the only available distinct value of type $R^{\bbnum 1}$. The
isomorphism map between $\bbnum 1$ and $R^{\bbnum 1}$ is the function
$\left(1\Rightarrow r_{1}\right)$.

\paragraph{Proof}

The plan of the proof is to apply both sides of the non-degeneracy
law $\text{fi}_{R}\bef\text{fo}_{R}=\text{id}$ to the identity function
of type $R^{\bbnum 1}\Rightarrow R^{\bbnum 1}$. To adapt the type
parameters, consider the generic type signature of $\text{fi}_{R}\bef\text{fo}_{R}$,
\[
\big(\text{fi}_{R}\bef\text{fo}_{R}\big):(A\Rightarrow R^{B})\Rightarrow(A\Rightarrow R^{B})\quad,
\]
and set $A=R^{\bbnum 1}$ and $B=\bbnum 1$. The left-hand side of
the law can be now applied to the identity function $\text{id}:R^{\bbnum 1}\Rightarrow R^{\bbnum 1}$,
which yields a value of type $R^{\bbnum 1}\Rightarrow R^{\bbnum 1}$,
i.e.~a function 
\[
f_{1}:R^{\bbnum 1}\Rightarrow R^{\bbnum 1}\quad,\quad\quad f_{1}\triangleq\text{fo}_{R}(\text{fi}_{R}(\text{id}))\quad.
\]
We will show that $f_{1}$ is a constant function, $f_{1}=(\_\Rightarrow r_{1})$,
always returning the same value $r_{1}$ defined in Statement~\ref{subsec:Statement-rigid-functor-is-pointed}.
However, the right-hand side of the non-degeneracy law applied to
$\text{id}$ is the identity function of type $R^{\bbnum 1}\Rightarrow R^{\bbnum 1}$.
So, the non-degeneracy law means that $f_{1}=\text{id}$. If the identity
function of type $R^{\bbnum 1}\Rightarrow R^{\bbnum 1}$ always returns
the same value ($r_{1}$), it means that $r_{1}$ is the only distinct
value of the type $R^{\bbnum 1}$.

To begin the proof, note that for any fixed type $A$, the function
type $A\Rightarrow\bbnum 1$ is equivalent to $\bbnum 1$. This is
so because there exists only one pure function of type $A\Rightarrow\bbnum 1$,
namely $(\_\Rightarrow1)$. In other words, there is only one distinct
value of the type $A\Rightarrow\bbnum 1$, and the value is the function
$\left(\_\Rightarrow1\right)$. The code of this function is uniquely
determined by its type signature.

The isomorphism between the types $A\Rightarrow\bbnum 1$ and $\bbnum 1$
is realized by the functions $u:\bbnum 1\Rightarrow A\Rightarrow\bbnum 1$
and $v:\left(A\Rightarrow\bbnum 1\right)\Rightarrow\bbnum 1$. The
code of these functions is also uniquely determined by their type
signatures:
\[
u=\big(1\Rightarrow\_^{:A}\Rightarrow1\big)\quad,\quad\quad v=\big(\_^{:A\Rightarrow\bbnum 1}\Rightarrow1\big)\quad.
\]

Applying $\text{fi}_{R}$ to the identity function of type $R^{\bbnum 1}\Rightarrow R^{\bbnum 1}$,
we obtain a value $g$, 
\[
g:R^{R^{\bbnum 1}\Rightarrow\bbnum 1}\quad,\quad\quad g\triangleq\text{id}\triangleright\text{fi}_{R}\quad.
\]
Since the type $R^{\bbnum 1}\Rightarrow\bbnum 1$ is equivalent to
$\bbnum 1$, the type $R^{R^{\bbnum 1}\Rightarrow\bbnum 1}$ is equivalent
to $R^{\bbnum 1}$. To use this equivalence explicitly, we need to
raise the isomorphisms $u$ and $v$ into the functor $R$. The isomorphism
will then map $g:R^{R^{\bbnum 1}\Rightarrow\bbnum 1}$ to some $g_{1}:R^{\bbnum 1}$
by
\[
g_{1}\triangleq v^{\uparrow R}(g)\quad.
\]
Substituting the definitions of $g$, $v$, and $r_{1}$, we find
that actually $g_{1}=r_{1}$:
\[
g_{1}=\text{id}\triangleright\text{fi}_{R}\triangleright v^{\uparrow R}=\text{id}\triangleright\text{fi}_{R}\triangleright(\_\Rightarrow1)^{\uparrow R}=r_{1}\quad.
\]
We can now map $g_{1}$ back to $g$ via the raised isomorphism $u$:
\begin{align}
g & =g_{1}\triangleright u^{\uparrow R}=r_{1}\triangleright u^{\uparrow R}\nonumber \\
{\color{greenunder}\text{definition of }u:}\quad & =r_{1}\triangleright\big(1\Rightarrow\_\Rightarrow1\big)^{\uparrow R}\quad.\label{eq:rigid-functor-derivation1}
\end{align}
Compute $\text{fo}_{R}(g)$ as
\begin{align*}
 & \text{fo}_{R}(g)=g\triangleright\text{fo}_{R}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:fuseOut-def})}:}\quad & =a^{:R^{\bbnum 1}}\Rightarrow g\triangleright\big(f^{:A\Rightarrow\bbnum 1}\Rightarrow f\left(a\right)\big)^{\uparrow R}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:rigid-functor-derivation1})}:}\quad & =a\Rightarrow r_{1}\triangleright(1\Rightarrow\_^{:A}\Rightarrow1)^{\uparrow R}\triangleright\big(f^{:A\Rightarrow\bbnum 1}\Rightarrow f\left(a\right)\big)^{\uparrow R}\\
{\color{greenunder}\text{composition under }^{\uparrow R}:}\quad & =a\Rightarrow r_{1}\triangleright(\gunderline{1\Rightarrow1})^{\uparrow R}\\
{\color{greenunder}(1\Rightarrow1)\text{ is identity}:}\quad & =(a\Rightarrow r_{1}\triangleright\text{id})=(a^{:R^{\bbnum 1}}\Rightarrow r_{1})=(\_^{:R^{\bbnum 1}}\Rightarrow r_{1})\quad.
\end{align*}
So, $\text{fo}_{R}(g)=\text{fo}_{R}(\text{fi}_{R}(\text{id}))$ is
a function of type $R^{\bbnum 1}\Rightarrow R^{\bbnum 1}$ that ignores
its argument and always returns the same value $r_{1}$.

By virtue of the non-degeneracy law, $\text{fo}_{R}(g)=\text{id}$.
We see that the identity function $\text{id}:R^{\bbnum 1}\Rightarrow R^{\bbnum 1}$
always returns the same value $r_{1}$. Applying this function to
an arbitrary value $x:R^{\bbnum 1}$, we get
\[
x=x\triangleright\text{id}=x\triangleright\text{fo}_{R}(g)=x\triangleright(\_\Rightarrow r_{1})=r_{1}\quad.
\]
It means that all values of type $R^{\bbnum 1}$ are equal to $r_{1}$.
So the function $1\Rightarrow r_{1}$ is indeed an isomorphism between
the types $\bbnum 1$ and $R^{\bbnum 1}$.

It follows from Theorem~\ref{subsec:Statement-rigid-functor-wrapped-unit-is-unit}
that a rigid functor cannot be a disjunctive type with more than one
constructor, so functors such as \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!List!\inputencoding{utf8} cannot
be rigid. This partially explains the choice of the name ``rigid'':
a rigid functor has a fixed ``shape'' of the placement of data in
it.

\subsubsection{Statement \label{subsec:Statement-rigid-functor-product}\ref{subsec:Statement-rigid-functor-product}}

Product of rigid functors is rigid.

\subparagraph{Proof}

{*}{*}{*}

\subsubsection{Statement \label{subsec:Statement-rigid-functor-composition}\ref{subsec:Statement-rigid-functor-composition}}

Product of rigid functors is rigid.

\subparagraph{Proof}

{*}{*}{*}

Some more use cases for rigid functors are shown in the next statements.
The ``$R$-valued \inputencoding{latin9}\lstinline!flatMap!\inputencoding{utf8}''
is a generalization of \inputencoding{latin9}\lstinline!flatMap!\inputencoding{utf8}
that can handle multiple $M$-effects at once; more precisely, an
$R$-container of $M$-effects.

\subsubsection{Statement \label{subsec:Statement-rigid-functor-multi-flatMap}\ref{subsec:Statement-rigid-functor-multi-flatMap}}

{*}{*}{*}For a rigid functor $R$ and a monad $M$, an ``$R$-valued
\inputencoding{latin9}\lstinline!flatMap!\inputencoding{utf8}''
can be defined,
\[
\text{rflm}_{M,R}:(A\Rightarrow R^{M^{B}})\Rightarrow M^{A}\Rightarrow R^{M^{B}}\quad.
\]

A ``refactoring'' is a program transformation that does not significantly
change the functionality. {*}{*}{*}

\subsubsection{Statement \label{subsec:Statement-rigid-functor-monadic-refactor}\ref{subsec:Statement-rigid-functor-monadic-refactor}}

{*}{*}{*}Given a rigid functor $R$, a refactoring function can be
implemented,
\[
\text{refactor}:((A\Rightarrow B)\Rightarrow C)\Rightarrow(A\Rightarrow R^{B})\Rightarrow R^{C}\quad.
\]
This function transforms a program $p(f^{:A\Rightarrow B}):C$ into
a program $\tilde{p}(\tilde{f}^{:A\Rightarrow R^{B}}):R^{C}$.

\section{Recursive monad transformers}

\subsection{Transformer for the free monad \texttt{FreeT}}

\subsection{Transformer for the list monad \texttt{ListT}}

\section{Monad transformers for monad constructions}

\subsection{Product of monad transformers}

\subsubsection{Statement \label{subsec:Statement-product-of-monad-transformers}\ref{subsec:Statement-product-of-monad-transformers}}

The transformer for a product of two monads is the product of transformers.

\subsection{Free pointed monad transformer}

\section{Irregular and incomplete monad transformers}

\subsection{The state monad transformer \texttt{StateT}}

\subsection{The continuation monad transformer \texttt{ContT}}

\subsection{The codensity monad transformer \texttt{CodT}}

The \textbf{\index{codensity monad}codensity monad} over a functor
$F$ is defined as 
\[
\text{Cod}^{F,A}\triangleq\forall B.\left(A\Rightarrow F^{B}\right)\Rightarrow F^{B}
\]

Properties:
\begin{itemize}
\item $\text{Cod}^{F,\bullet}$ is a monad for any functor $F$
\item If $F^{\bullet}$ is itself a monad then we have monadic morphisms
$\text{inC}:F^{\bullet}\leadsto\text{Cod}^{F,\bullet}$ and $\text{outC}:\text{Cod}^{F,\bullet}\leadsto F^{\bullet}$
such that $\text{inC}\,\bef\text{outC}=\text{id}$
\item A monad transformer for the codensity monad is 
\[
T_{\text{Cod}}^{M,A}=\forall B.\left(A\Rightarrow M^{F^{B}}\right)\Rightarrow M^{F^{B}}
\]
However, this transformer does not have the base lifting morphism
\[
\text{blift}:\left(\forall B.\left(A\Rightarrow F^{B}\right)\Rightarrow F^{B}\right)\Rightarrow\forall C.\left(A\Rightarrow M^{F^{C}}\right)\Rightarrow M^{F^{C}}
\]
since this type signature cannot be implemented. The codensity transformer
also does not have any of the required ``runner'' transformations
$\text{mrun}$ and $\text{brun}$,
\begin{align*}
\text{mrun} & :\left(M^{\bullet}\leadsto N^{\bullet}\right)\Rightarrow\left(\forall B.\left(A\Rightarrow M^{F^{B}}\right)\Rightarrow M^{F^{B}}\right)\Rightarrow\forall C.\left(A\Rightarrow N^{F^{C}}\right)\Rightarrow N^{F^{C}}\quad,\\
\text{brun} & :\left(\left(\forall B.\left(A\Rightarrow F^{B}\right)\Rightarrow F^{B}\right)\Rightarrow A\right)\Rightarrow\left(\forall C.\left(A\Rightarrow M^{F^{C}}\right)\Rightarrow M^{F^{C}}\right)\Rightarrow M^{A}\quad.
\end{align*}
\end{itemize}

\section{Summary and discussion}

\subsection{Exercises}

\subsubsection{Exercise \label{subsec:Exercise-monad-transformer-extra-layer}\ref{subsec:Exercise-monad-transformer-extra-layer} }

Suppose $T_{L}^{M}$ is a lawful monad transformer for the base monad
$L$ and a foreign monad $M$. Can we modify $T_{L}^{M}$ and construct
another monad transformer for $L$ that still satisfies all transformer
laws?

One possibility is to compose $T$ with an extra layer of the monads
$L$ or $M$. Define $U$ and $V$ by
\[
U^{A}\triangleq L^{T_{L}^{M,A}}\quad,\quad\quad V^{A}\triangleq M^{T_{L}^{M,A}}\quad.
\]
In a shorter notation, $U\triangleq L\circ T_{L}^{M}$ and $V\triangleq M\circ T_{L}^{M}$.
We have the \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
functions 
\begin{align*}
\text{sw}_{L,T} & :T_{L}^{M}\circ L\leadsto L\circ T_{L}^{M}\quad,\\
\text{sw}_{M,T} & :T_{L}^{M}\circ M\leadsto M\circ T_{L}^{M}\quad,
\end{align*}
defined using the already given methods $\text{lift}$ and $\text{blift}$
of $T_{L}^{M}$ as
\begin{align*}
\text{sw}_{L,T} & =\text{blift}^{\uparrow T}\bef\text{ftn}_{T}\bef\text{pu}_{L}\quad,\\
\text{sw}_{M,T} & =\text{lift}^{\uparrow T}\bef\text{ftn}_{T}\bef\text{pu}_{M}\quad.
\end{align*}
We can define the monad methods $\text{ftn}_{U}$ and $\text{ftn}_{V}$
using these \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
functions. Will $U$ and/or $V$ be lawful monad transformers for
$L$?

\begin{comment}
Chapter eleven of the functional programming tutorial computations
in a central context have been one of the teams in this tutorial and
this is a final part this which talks about moon and transformers
to begin let me look at some code that needs to compute a value in
the future but the value is of optional type so these kind of computations
often happen in application code when you are computing some value
in the future but the value itself has additional logic and option
is a simplest such example so imagine that we would like to implement
a program that computes a value using a future and then if this value
is a non-empty option the computation continues and then it can compute
another value again in the future using what was concluded before
and that computation again returns an optional type and we again see
if that is a non-empty option and if so we continue and return another
future value and so on and if at any time this option is empty after
having computed it we need to stop some way short-cut the computation
by returning a feature of none right away so that's what we have to
do so the code then starts looking like this now I just write here
option of one very simple computations for which I wouldn't have to
do such coding but in real life test as a function that takes time
to compute so I put it into a future and then it might return an empty
result I don't know that in advance let's suppose and then I need
to match on that result so you see this code is quite difficult to
read and difficult to modify that is to maintain and the reason is
that it's full of repetitions so there are all these match expressions
that always have the same structure if there is a Sun then we continue
if there is none then we were transfusion successful now it is precisely
that kind of repetition that was eliminated by using the function
block or the for yield block but so we eliminate them but only for
the outer type constructor the inner type constructor remains and
we still have to do the same thing for it and we could not use the
same for yield block to deal with the future chaining and the option
chain because this is a limitation of the function block the factor
in which we perform the computation must be the same throughout the
entire function block so the full yield delimit a block of thunder
computations where to the right-hand side of the arrow there must
be always the same factor type so future in this example once the
first line is giving you a future everything to the right of the arrow
must be of type future of something so it's future this also must
be future which it is will have having the right code like this and
so on so it could not be that in the next line I write something like
X is equal to X X going to X hoped this would not actually compile
because this X optical type option it is not of type future of something
so this would not actually compile and that's why we need to write
this code so this difficult to write and difficult to maintain code
unfortunately is unavoidable if we simply use the function block on
the type constructor that is nested when you have one monad and composed
in the type constructor with another monnet like this we will have
this problem whenever this happens so this could be a future of option
or it could be a list of either or any kind of combination like that
will give rise to ugly code of this kind so one solution that could
be easy to implement is to wrap this type constructor into a new class
for which we implement a monad syntax directly so here's how it works
so we create a type wrapper which is just a case class with a single
value inside and this wrapped value is of type future option and now
we directly define for this case class the methods map and flatmap
and they're defined by simply doing a nested map and then and the
map inside so that's nested flat map and then we write this code where
we match on the resulting option by hint so so this basically replaces
all the repetitive code above were in the case of none where we turn
a successful future of none and if the case of nonempty option then
we continue we continue with the next computation so that is the flat
map defined for this wrapped class once we have done this we also
do some convenience functions which I will talk about later such as
the lift and I define for convenience some implicit conversions so
that I can just convert future of a into this future option where
I promote a to option trivially by using some apply and another opposite
conversion converts the nested type constructor into a wrapped s to
type constructing automatically so that is what I do here once this
is defined the code above is magically transformed into this so the
pure computations are just examples like I said this is a very simple
example and don't really need to do this future option stuff in real
code this would be a function that returns a value of type future
of option of something and it could have been non-trivial could return
in the future that fails or it could return a future that succeeds
with an empty option or it could return a future with succeeds with
a non-empty option and so now the code becomes very straightforward
easy to maintain at the same time I could do operations like this
or else directly on this type where the or else refers to the optional
type inside future I implemented there or else for convenience like
this and the left is a function that transforms option a option B
into a future option A to future shouldn't be so this is kind of a
lifting of that kind so this is the basic idea of monad transformers
namely how to avoid having to write repetitive code languages and
instead write with some of course and definitions that you need to
do but eventually you would write code language so in other words
we could say we have combined a future monad and the option monad
into one big moment future with option which we can manipulate in
a functor block director with no need for pattern matching or anything
else so all the pattern matching within the future is done automatic
so this is an example of combining two monads so it is very often
necessary to combine different monad effects where effect is informal
notion it is not a specific clearly defined type it is an informal
notion which expresses the idea that in in a monad M the type of dysfunction
expresses a computation that takes a and computes perhaps a value
of B and also to compute something else or something else happens
while we were computing a value of B or maybe you compute many values
of B or maybe none at all or maybe you fail with some error message
or maybe something else happens so whatever else happens while you're
computing be from a in this function that's the effect of the monad
M and so an example would be for option is that the computation can
have no result or a single result for list computation to have multiple
results for either it could fail to obtain the result and then report
an error for the reader it always gives a result but it needs to read
an external value for that writer it always gives a result but additionally
there is some accumulator which is of a monoid type and some value
will be appended to that accumulator for the future you might compute
computer value might fail with an error but all of that will be run
later it will not be computed right away so those are the effects
of some standard monads and often you would like to combine them so
you would like to have a list of either-or future of options and learning
and that could be given combinations of more than two when you want
to combine reader and writer and future at the same time so how do
we combine effects well I just showed you a code where I combined
effects although it required me to do acquainted quite some work obviously
what you could not do is you could you could not simply write code
with first a future of something which has a future type and then
a different monad on the right side of the arrow that would not compile
so if this has a type try and this has a type future they're not compatible
future and try are not compatible types and so this would not work
if you wanted to do that and you need to do something else you'd have
to unify both right-hand sides into a bigger moment such that you
somehow transform this into the value of a bigger monad he also transformed
this into the value of a bigger movement so these operations are called
lifting so you lift the small nut into the bigger moment you also
lift the small nut and a bigger more not and then if you can do that
and I have done this in my code I just showed you using an implicit
conversion so if I can do that I can just write code like this indeed
and implicit conversions will take care or maybe I can just put some
type annotations and in there that would take care of types and then
on the right hand side of the accumulator arrow I will always have
the same type constructor and that is therefore I'm going to be valid
Scala code so to see that this is not valid it's easy to see that
because I should translate this into flat maps see the first thing
is in sequence the second thing is the future so the flat map on a
sequence takes this function but the future is a different kind type
constructor than the sequence on a flat map has a type signature that
requires a sequence here so that would not compile so the conclusion
is that in order to combine different effects in the same function
block we need to unify all these effects in a new unit that is in
some sense larger than all the previous monads and contains all of
them so the main goal of this chapter is to learn how we can compute
the type of this new moon at how can we decide what that type constructor
is how to implement the moon add instance for it for any kind of moon
does that you might want to use so there are several ways of combining
two models into a new bigger moon at that we could try and many of
these ways just won't work so the easiest way would be well why don't
I just take a product of these two moons that's a monad we know that
the reason is that this is not what we need this is a moon Atias but
it describes two separate values of type a each having a separate
effect on it that's not what we need we need a single value of type
a that has a combination of two effects possibly and that's not all
this describes now maybe a disjunction because that could be the first
effect on a or the second effect on a unfortunately this is usually
not a monad and even even if it is a monad this is really a choice
between two different effects work even two different values it's
not one value with the combination of two effects with with the first
effect and the second effect remember the Scala speech revulsion the
combination is at the same time being computed in the future and it
returns an optional result so this doesn't work now the next what
we can try is functor composition so we can pose and one of them -
we can compose in two different orders and sometimes indeed that works
it is often at one end when you compose so let's look at some examples
but if one unit is this and the second model is this then we can compose
and the composition is this type constructor and that is actually
correct it as a monad similarly future of option as I just showed
can be combined in case a moment unfortunately if you try to combine
in there in the other order for example do some following this or
something like this those are not units so you can combine option
and reader this is the reader who not only in one order you can come
compose reader outside and options if you try option outside and you're
either inside the result is not imminent also you cannot combine State
mana with other moons like this so for example neither disorder nor
that order is a minute so from these examples we see first of all
sometimes it works but sometimes it requires a specific order of composition
and it does not work with the other order and sometimes it does not
work with composition at all so I will show that later that the state
monad is such that it does not compose with other monads in either
order so as a comment when composition works both ways and example
would be either and writer so they can be composed in both ways this
would be one result of composition this would be another and both
of these are monads but these moments express different kinds of effects
so for instance here we either compute result and write a message
or everything failed we have an error message will have no result
and no blog messages here we have always a log message the computation
may fail does not give us a result of type a but the log message is
always written so we can have an error message and a log message in
the same time so these are obviously two different kinds of logic
that you could express or two different kinds of effects so the task
in front of us is of course to avoid try on there we don't want to
do that every time that we need to compose two monads we need to have
a general way defining a new combined monads and we need to show that
it is always a moment so that we don't have to prove things every
time when we write code so that is what we would like to achieve and
we would go a very long way towards that goal in this chapter so what
we would achieve is that we will have a monad say Big M big manga
that somehow combines only effects so instead of the code that I showed
here which is invalid trying to combine the sequence future and try
in a single functor block that is not valid but if we somehow define
a big model that combines sequence future and try in the same big
moment then we had also we would have three functions for lifting
I would call them lifts one left two and lifts three for now which
would lift a sequence value into the big model a future value into
the big wallet and a try value into the big magnet so then we could
just write a function block like this lift lift lift after lifting
the right hand sides are of type big M of something this is now valid
and this would work the result would be of type maybe Big M of int
or something here are two examples of these liftings so combining
future and option would require us to define two liftings option a
into future option a and future in the future optionally so these
lifters are easy define and that's how we would probably have to write
code in another example suppose we want to combine list of track list
and try so that works try inside the list networks I don't think that
try would work outside the list as I'm Oona and these are the two
lifting so that's easy enough and you see that could work now they're
still of course a lot of work to be done if we were to go this way
for each pair of moments or even for each combination which could
be very very many we would have to define these wave teams we'd have
to define the monad instance for a big M I haven't even talked about
that I haven't even said what the type of Big M is for this combination
for this I know but for this I haven't said that so how to combine
list feature and try in a single type constructor this is a non-trivial
question which is not easy to resolve by trial and error composition
would not necessarily work we need also to check that the laws of
the mana told for these moments which I also will check but haven't
done yet so all these questions remain is it always possible how to
find such a type constructor is it unique are there several options
alternative solutions are they some of them better than others these
liftings what are the laws that they have to satisfy and and so on
also can we somehow reduce the complexity instead of having to define
liftings for all possible combinations maybe we find fewer and make
other things automatic so let me first talk about the laws of liftings
so we assume that there will be a monadic program such as this one
with some liftings and we ask what are the laws for these liftings
now we assume that the monads m1 m2 and also the big model whatever
it might be already satisfied all the Monad laws how would we argue
about lifting laws so for example imagine a functor block in which
we have code like this so first we have a lifting of a pure value
so we have an m1 pure and we lift it so that becomes a big moon add
value and then we continue with some big monad stuff depends on high
now since this is just pure our initial code without liftings which
is incorrect would have been just I going to the pure of X and then
continuing with that I usually code like this is equivalent to this
kind of code where we don't need to do monadic arrow and the left
arrow we don't need that if we just use pure we just say i equals
x and continue and so we expect that with lifting it will be the same
that we can replace this code with this equivalently so this is a
law that the function lift must satisfy we write it down is like this
this is the law now of course it's not very nice to reason about code
so I prefer to reason about a more condensed notation rather than
Scala code syntax and in particular it is convenient often to use
the closely composition criminals which is composition of functions
of these types the nicely functions and so if we rewrite this code
in terms of closely functions then it looks like this the composition
of the flow-rate composition of pure of n1 and lifts one flat map
with some arbitrary B which is some x2 big animals voice this is this
B must be equal to B so that's what we get if we remember that the
classic composition is replacing this kind of code so F composition
with G is a function that is like this another law is that if we have
a lifting of pure after some valid computation then we expect that
this X again has just ik equal to Omega there's no effect here and
this should remain so after lifting so therefore this code must be
equivalent to this code writing the same code that is the equation
like this and writing it in terms of the class like composition it
becomes this equation and of course the same identity laws must hold
for the second moment in its second lifting so these moments we consider
to be only cause fruiting right now and both of them need to be lifted
into the big mullet if this construction is to be of practical use
now these laws are kind of complicated let's simplify them these laws
basically say that this function this this composition of pure em
and lift is the identity for the closely composition so this Purim
lifts to the left of B equals B and p.m. lift to the right of B also
equals B and so this function is the unit for the classic composition
but this monad already has a unit in the classical composition laneway
it as this viewer of the Big M and in the Monod the two-sided unit
element is unique and similarly this is so in a closely composition
so if you have two different unit elements U and u Prime and we can
easily write this equation which is that you Kleist a product u prime
it must be equal to u because U prime is a unit element it also must
be equal to u prime because u is the unit element and so u must be
equal to u prime so the unit element is always unique and so these
two identity laws that we have seen here can we actually produced
a single or equivalent to saying that this forward composition of
pure hand and lift it must be equal to the pure function of the big
moment so we have now reduced the identity law to a single identity
law and let us now derive another one for the lifting which is that
if we have some kind of lift one of everything so we have a portion
of a program that just uses the first moment and keeps lifting it
into the big moment we should be able to refactor this into a nomadic
program that only works within the first moment and then lift the
result of that program into the big moment so this would be the equivalent
program first we'll do the flat map in the moon atom one and then
we lift the result into the big moment so this program it is kind
of reasonable should be equivalent to this if it's not it would be
kind of strange that I cannot refactor my programs the idea is that
lifting should be transparent it should be just tight from massaging
for the moment so usually if I have a nomadic program like this imagine
there's no lifting I can always refactor it I can do this what not
somewhere else and then put the results of that flat map back here
you can always do that that's the usual associative 'ti buna so I
should be able to do the same if I lift into the big moment so that
law when written out it becomes this equation and unfortunately now
this is a little unwieldy to you to think about so let let us rewrite
it equivalently through the flat map function so the flat map function
which I did denote F L M it is with this type signature which is not
the same as the usual flat map in scala but it is easier to reason
about and then using this flat map we write this code like that so
we have a lift then we have a flat map of this function and then it's
the same as first doing a flat map and then lifting the result on
both sides of this law are functions of this type signature lifting
and one into the big moment we can further simplify this if we rewrite
flat map through flatten flatten has this type signature and the law
becomes lift one and then lift one lifted four raised to the big moment
using its map function and then followed by flat map in the big Monat
is equal to flat map in the m1 mu not followed by lift so these are
easy to obtain if you remember that flat map is map followed by flatten
in other words it's this map followed by flat so that's basically
how I get from here to here and the function Q disappears from the
law in this formulation so it becomes simpler there's no arbitrary
function from A to B nothing like that it's just both sides are functions
of this type there's only one type a involved as a type parameter
whereas in this law there is a function q and they're two type parameters
a B and in this formulation they're two arbitrary functions P and
Q so in this way the laws is simply the law is simplified can be simplified
even more if we write it in terms of Chrysler composition then it
becomes a law that is for some functions B and C of class Li type
signature the be lifted and closely composed with C lifted is equal
to twice Li composition of B and C all lifted notice I am using two
different closely compositions in this law and the left I am using
the class decomposition in the big moon on the right in the moon at
M one to make it clear I use the subscript in each case so this is
maybe slightly more difficult to read with the subscript so squint
at it and imagine that the subscript isn't there keep it just in mind
and then you see be lifted composed with C lifted is be composed C
all lifted so that's the composition law in other words the lifting
of functions before composition is equal to lifting of functions after
composition in other words the liftings commute with a closely competition
and also the lifting is commute with pure pure after lifting is the
same as the other pure and so the laws expressed the idea intuitively
that these liftings lift 1 and lift two of course as well should commute
with the operations pure and flatmap of the magnets so this is how
we can think about these laws and remember them so the liftings must
lift peer-to-peer and compress a closely composition into classically
composition additionally the liftings must be natural transformations
but actually it is a consequence of the fact that they lift pure to
pure and flatmap to flat map or flattened to flatten or glass the
composition to place the composition now the term that I use for such
functions and that commute with monads and lift purity pure and flat
map to flatten ax is monadic morphism so it's not just the function
or morphism but it's a monadic morphism in other words it's a morphism
that agrees or is compatible with the structure of the moon and and
it's a function between f1 and Big M so it is compatible in this way
with structures of these two moments whatever structure is an n1 it
maps into that corresponding structure in Big M and in the previous
chapter we already saw an example of an antique morphism although
we did not talk about it I didn't talk about it I talked about magnetic
interpreters not run one one addict program and obtain a monadic value
in another moment these must actually satisfy these laws in order
to be useful and so Mahna Mahna the interpreters are always magnetic
morphisms unless they are be very useful and now let me derive the
naturality law for this lift now lift has this type signature so naturality
for it means that if i have some function f from X to Y and I lifted
to m1 and I also lifted too big him so that's the F map of 1/2 and
I am in m1 or in Big M then the lifting must commute with that so
in other words first you lift and then you map X to Y or you first
map X to Y then you lift it doesn't matter and that is the equation
that we can write expressing this equivalent system now we can derive
this law actually from the fact that lift is a magnetic morphism so
this is not a separate law that we need to check once we know that
it is a one-man ignore thism how so this is a derivation F map can
be expressed through a flat map and pyrrha and that is a monad law
for both movements and then this is the lifting law for flat map and
instead of saying this so we write that so this column of F here is
the left hand side or actually that the right hand side of this law
is f map f lift 1 so instead of f map I write this and the result
is that so in this way I what I'm trying to get is that I replace
in this law F Maps through F Elam and the right and on the left and
I hope that I get an identity after that so I begin with the left
hand with the right hand side where I replaced F map through a felon
now I used this law that FLM of some function and then lifted is lifting
followed by a column of this where Q is equal to a composition of
F and P rm1 so that results in this expression we have left one FLN
Big M which I didn't enjoy it of composition of this Q which is this
and left so that is here now I'll use the fact that pure M followed
by lift one is pure Big M which is this law therefore I have here
F followed by pure Big M now this is flat map in Big M therefore this
is a law of Big M which is this okay which I can replace this by flat
by F map of begin so now the result is this which is the left hand
side of the law and trying to prove so I started from the right-hand
side replaced things in it identically and I got the left hand side
using the fact that lift 1 satisfies the laws of a magnetic north
ISM so monadic morphism therefore is always a natural transformation
so how do we deal with the problem of combining many moments and reducing
the amount of work so to look at an example if we can bind listen
this on that only this combination works this is a functor composition
of this and this where the reader is outside and the option is inside
the other order would not work this is not a minute and so this destroys
our hopes of somehow always writing a formula combining M 1 and M
2 for arbitrary M 1 and M 2 using some kind of natural combination
or by functor this would not work and another example is that the
state monad does not compose in any order with other moons let me
show some code that explains why not a stone if I try to compose optional
is reader in the other order then I try to combo I'd really defined
flatmap further also and define a flat map with this type signature
so I get so this o R is an option of reader and I need to get an or
R of B from or of a and the function a to or me now if FA is none
we have nothing to do except return there's no a available in our
so they cannot possibly use F and return some non-trivial for B so
we have to return none here now suppose we have a non empty option
and then we have a function R T so now how can we return an option
of artemiy we have a function that takes a and returns this or B now
unfortunately we cannot use this F either because to use F we need
a function we need the value of that a but we don't have it we have
a function from R to a we don't have an R and so we cannot apply F
to anything at this point we have to decide at this point without
applying F which will give us some option we need to return either
a nun or a some heartily so trying to return the nun here would be
bad because then I would return none in both cases so we basically
have a flat model that always returns an empty option and that has
no hope of satisfying the identity law which is that flat map of something
with pure is equal to that something but if our flat map always returns
an empty option this will never work so let's try to return a non
empty option okay so we start returning it we have an R now we can
use this function f by computing R to a of origin of type a and applying
F to that so we get an option over hard to be here but we are inside
this function we are required to return a value of type B but we don't
have that we have an option of something which could be none and this
point could be empty and if it is not empty as we can return the value
of time but if it is empty we are stuck we cannot return a value of
type B so there is no good implementation of flat map in this case
a pure we can implement with a flat map no let's look at the statement
so this is the statement type constructor so let's compose it with
reader well I need to implement flat map with this type signature
work as R is this combination the state with this radio inside now
I will follow the types and there's only one way of implementing it
so we start with a function s we need to return as RB which is s going
to a pair of s and R to me so start with s then we can compute FA
of s we get these things now we want to return the pair of s 1 and
a function are to be now how do we get a be only way to get a B is
to apply the function f to some a so we have an a yes we can apply
after a we can give an R 2 that give it a B so finally we get a B
but we have to discard this value s not we obtained lust so and this
is suspicious in the state monad we should not discard updated values
of the state yes but we have to discard it because we are returning
must return s here and the function are to be is inside so we cannot
give this s which we only computed here back over and over there and
this is indeed the problem that we described certain parts of the
state so essentially we have not used f in computing the new state
I have used f to compute the new value but F only gives you not only
gives you a value it only gives you an effect of taking on the state
and is updating we are ignoring and indeed it will violate the identity
law which is this one of the identity laws and I can show that this
is so because if I compute the flatmap according to the code over
there then it will be a function that always ignores the value which
is okay it's the pure but it always returns the unmodified state s
so the first element of the pair is always going to be unmodified
state s and this could not be equal to F it should it should equal
F this should equal f of X but it cannot because F could modify the
state language F could be of this form which modifies the state but
our flat map will never modify the state in this combination with
pure and so that cannot possibly be equal to f of X for arbitrary
functions F no F I could have an effect and we should have accumulated
that effect we are not now trying to compose state monad with reader
inside fails what about composing it outside let's take an option
another simple model and compose it outside with state Bible you know
go through this in detail but it's a very simple computation and basically
either you're always return none in your flattener an empty option
which is bad or you're stuck you're trying to return the value you
need and you don't get it you have an option of something but you
need that value itself so you have an option in the wrong place and
you're stuck you're not able to compute a be just like we're not able
to compute early previously so this shows that the state moment fails
to compose with other moments in either order so it does come to us
with some owners in one order in with other models in another order
but you cannot in advance say I compose the state monad outside with
an arbitrary other monad and that result is valid or not no that doesn't
work or inside no doesn't work so this is a problem and {[}Music{]}
the solution is actually what is called mono transformers the main
trick is that we're not going to try to combine arbitrary to monads
we're going to fix one moment which will go call the base model and
look I will denote it as L and for a fixed L I will let the other
one at vary so that will be called a foreign minute and we'll try
to assimilate the foreign minute into a fixed base model and combine
them in this way so the result is a type constructor on which I call
T LOM and it still has a type parameter you're not it here by this
placeholder symbol so this placeholder symbol is just a type parameter
that I'm not writing so I introduce this notation in the previous
chapter and this color this is written simply like that it says type
parameter that we're not writing so this type constructor depends
on both L and M and it gives you a new moment and it is such that
for a fixed L this M is actually a type parameter so this works for
a fixed L and for any M so fixed base model and arbitrary foreign
moment so that's what that transformer is it's a type constructor
it depends on L and M but it depends on them in a different way so
it is generic and M but not an L in other words for each L for each
baseman on L there is a different construction t om but the construction
is the same for all M so the fixed L the construction is the same
for all M so in other words its generic in him so right away that
is important to understand that there's no general formula that takes
a monad L and produces the transformer doesn't seem to exist so for
each L for each base moment he'll we need a different construction
of the city em the foreign moment will be generic but the basement
will not be just a parameter and finally there is a question whether
some monads have a transformer or not now I don't know how to answer
this question but I do have examples of monads that don't have full-featured
transformers and maybe this is not a problem but I do not have examples
of monads where I don't know how to make a transformer so this question
seems to be difficult and in practice every moment that we can write
down as a type constructor will have a transformer or at least halfway
I will talk about this in more detail very soon so what is the advantage
of having this approach of using this approach when we fix the base
model and vary the foreign model the advantage is that now we can
easily compose three or more units by simply composing the Transformers
since the transformer is generic in this one on M I can put that monad
M as the type parameter and I can set it to a transformer for a different
moment I'm missing here another type parameter placeholder but the
notation is difficult as it is so in Scala for example you would have
transformers such as State T of list T of freighter so you can do
that with these placeholders which correspond to my lowitz and in
this way you can stack together many many wonders with no additional
work once you have implemented transformer for each Manette you can
stack any number of them like this so no need to have a combinatorial
explosion in how many different transformers you need combined future
and option future in list list an option listen either future and
either know it just implement a transformer for list transformer for
either transform an option transformer for reader and then you just
stack them and this is called the moon a stack but make sure you don't
mix together and one on stack and composition of type constructors
will functor composition because this is not the same as a simple
composition like this the transformer is not just a composition for
someone as it is but for others it is not unlike for the state model
it is not a composition as we have seen i cannot work as a composition
also for some units the composition goes inside and for others outside
the transformer is a type constructor that is always outside but the
result of it could be that some things are inside work or even transcribed
in some difficult way that is neither composition inside nor outside
so monad stack is not the same as composing type constructors formulas
this is not a minute this would not work well that transformers will
always work they will always produce and will not satisfy all the
laws so what are the requirements for mana transformers for all foreign
there must be the following properties so first of all this must be
a monad which I call the moon at em transformed with this transform
ITL so it's a foreign moment that has been assimilated somehow onto
the base model and the result is this big larger moment that has both
effects there must be a lifting which is this function monadic morphism
between em the foreign Monat and the transformer there's also the
base lifting which lifts the basement in the new transformer but it
is not natural in L because L is not a natural type Brown or not generic
type parameter in the transformer another property is that if we take
the identity monad as M and the result must be equivalent to hell
and this is not natural because the identity monad does not have an
effect so if we transform that assimilate and that then just the effects
of L remain and that's the same as just having L now the fact that
the transformer is magnetically natural in the mannered M means that
there are these other properties namely T must be paralyzed by him
as a type parameter and for any other moment in we could we should
be able to map M - n inside the T so if we know how to map M - n using
some melodic morphism then we should also know how to map transform
the M to transformed him so this I call em Ron so if I know how to
run the moon and em into some other moment and I should know how to
run the transform model into the transform the other monitor also
these runners must commute with lifts and baseless so if I first lift
and then run for example for lift L and then I run {[}Music{]} then
I should obtain the same result as when I first run and then lift
so we will look at the precise formulation of this a little later
now this naturality will always hold automatically as long as we implement
this mu not only using the moon had methods of him we don't use the
structure of M but only call its methods pure and flat map and this
situation is similar to what happened in chapter 9 when we talked
about I talked about Traverse so this Traverse had this type signature
and it was natural with respect to negative function f so did not
use the structure of the function f only the fact that it was a negative
and this therefore can be used to run the monad for example take this
runner if it exists and lift it to this runner which is a runner from
TM to L so we can eliminate the effects of M or run them evaluate
them perform them and get just an L which are so effects of L and
M were combined in this monad we can separately run or evaluate effects
of M and the effects of L should remain similarly there should be
a base runner where we can run the effects of L inside the transferrin
monad and the result is just M left that's the base runner and again
it should commute with lift and base lifts why do we need these runners
well the only way to evaluate Mona's is to run them to actually perform
the effects and unless these laws hold performing the effects would
give incorrect results when we combine the effects so we should be
able to combine the effects without changing our ability to run them
separately so we can combine L and M effects but we can run ill and
not M work we can just run em but not l separately as much as we can
as much as we need to separate them so these are the requirements
and I will go through these requirements later to prove that they
hold for all the monad transformers here are some first examples if
we have a reader then the reader composed outside works if we have
this mu knot which is a combination of either and writer then this
can be composed inside these are monarch instructions that I have
proved in Chapter 7 and actually these are ma not transformers for
these moments from the reader and for this moment which is a combination
of either and writer so therefore these are the Transformers reader
te 30 and writer T which we can write down immediately already having
proved that these are models we still haven't proved other laws but
we have proved that the Campbell combine types Ramona's notice that
the reader composes with the foreign loan add from the outside but
either in writer compose inside that foreign unit and this must be
so other the other way around is wrong it doesn't work does not produce
a minute for her betray him which I just showed you thank God the
remaining questions for us so what about other movements so now we
chanced to know this before but what about other moments we don't
know and they don't compose me neither of them composes inside or
outside with arbitrary other monads so we also have a lot of other
melodic instructions how to find transformers for the results of those
constructions if we use them and if we know transformers for some
previous moment we made new moments out of previous moments how to
find transformers for them what about monads constructed using a transformer
what's a transformer for that and whether it's always possible as
like I said it is unknown maybe there are some owners that don't have
transformers I haven't seen good examples of that now is a transformer
unique now it is not almost sure why but usually there is one transformer
against preferred that's the simplest and that's what people usually
mean when they say the mono transformer and another final issue is
all this boilerplate around lift now lifting is still quite cumbersome
you need all this lifting and the code is cumbersome because they're
all these especially if you have more than two monads combined and
there's lift of lift of lift in different orders and that makes code
difficult to maintain so there are solutions for that which are called
MTL style transformers until stands for monad transformer library
so I'll talk about these issues in order in the rest of this chapter
here's an overview of all what I know about one on transformers each
one that has a different transformer so it's really a zoology and
each construction is ad-hoc so there's no general method for them
so some will not have composed inside transformer so these are the
option right here and either for each Monett we need to know what
that is so we will see how that works so for someone as it's composed
inside for others it's composed outside so this is the formula what
are those moments that can pose outside the reader and also there's
a unit called the search monad which is this type which I have shown
before the chapter 7 I didn't call it specifically a search moment
but this and similar moments have transformers and that can pose outside
and more generally I define I will define a class of factors that
are called the rigid and muninn saturated or have outside transformers
so they're kind of they're they're generalizing the reader and this
kind of monad there are several other such types another type of monads
is recursive lists non-empty lists and free movement they are defined
recursively and neither of the compositions worked for them they need
a different construction which is interleaving the basement and the
foreign unit inside the recursion so it cannot be just composition
another type of monads is monads obtained from constructions so for
example product a unit has a product of transformers so you need to
know the transformer for L one transformer for L 2 and then you make
a product that is the transformer for the product monent another construction
that I already described in chapter 7 is this we have a contra factor
H and have a function from its to a so this construction works for
any control factor H and gives you a moment and this moment has a
composed outside transformer it is rigid another class of one else
is free pointed minutes this is also construction from chapter 7 a
transformer for that Monod looks like this it's neither composition
outside nor inside and requires you to know the transformer for the
m'lad l and then you know how to define a transformer for this moment
finally there are irregular moments where none of these constructions
work for example the statement for the statement composition doesn't
work these constructions doesn't don't work you need to put the formula
at the precise spot inside the statement and then it works for the
continuation or not you need to put the foreign wallet in here otherwise
nothing works there is a another class of Mona's that I call selectors
for them you have to do this again it's neither composition nor constructions
like that finally there is a good density monitor which again you
have to put the foreign model inside at specific places so these are
irregular so each has its own recipe and there doesn't seem to be
much of a system here it is not clear that one odds could exist with
no transformers but one suspicious fact is that some transformers
do not have several of the required methods so for example the continuation
monad transformer does not have a base lifting in other words you
cannot lift a value of the continuation monad into the value of these
types of continuation when it is a - R - R cannot lift that into a
TOA Mart anymore for arbitrary yeah now this is a problem in my view
it means that these transformers are not fully usable they kind of
half work but unless I can lift both my monads into a transformer
I cannot really replace in the functor block the previous monad with
the big moment so in my view this is a problem and you could argue
that these transformers are incorrect they are not fully featured
they do not satisfy the required laws I couldn't get that and I will
talk about this later so now I begin with the composed inside transformers
which is the first class of transformers in my 
\end{comment}

\begin{comment}
\end{comment}

\begin{comment}
\end{comment}

\begin{comment}
\end{comment}

