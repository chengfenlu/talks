#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \bef inside a \text{} will cause a LaTeX error!
\newcommand{\bef}{\hspace{0.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY
\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt,utf8
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "Science of functional programming"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7in
\paperheight 9in
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 4
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\small\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.01mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin=4mm,framexrightmargin=4mm,xleftmargin=4mm,xrightmargin=4mm,framextopmargin={0.5mm},framexbottommargin={.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter*
Preface
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{Preface}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The goal of this book is to teach programmers how to reason mathematically
 about types and code, in a way that is directly relevant to software practice.
\end_layout

\begin_layout Standard
The material is presented here at medium to advanced level.
 It requires a certain amount of mathematical experience and is not suitable
 for people unfamiliar with school-level algebra, or for people who are
 unwilling to learn new and difficult concepts through prolonged mental
 concentration and effort.
\end_layout

\begin_layout Standard
The first two chapters are introductory and may be suitable for beginners
 in programming.
 Starting from the middle of Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:3-3-The-formal-logic-curry-howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the material becomes unsuitable for beginners.
 
\end_layout

\begin_layout Standard
The presentation in this book is self-contained.
 I define and explain all the required notations, concepts, and Scala language
 features.
 The emphasis is on clarity and understandability of all examples, mathematical
 notions, derivations, and code.
 I use some 
\emph on
non-standard
\emph default
 notations (Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Appendix-Notations"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and terminology (Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Appendix-Glossary-of-terms"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to achieve a clearer presentation of the material, especially for readers
 not familiar with today's research literature in the theory of programming
 languages.
\end_layout

\begin_layout Standard
The main intent of this book is to explain the mathematical principles that
 guide the practice of functional programming – that is, help people to
 write code.
 Therefore, all mathematical developments in this book are motivated and
 justified by practical programming issues, and are accompanied by code
 examples that illustrate their usage.
 For example, the equational laws for standard typeclasses (functor, applicative
, monad, etc.) are first motivated heuristically before deriving a set of
 mathematical equations and formulating the laws in more abstract terms.
 Each new concept or technique is explained via solved examples and drilled
 via provided exercises.
 Answers to exercises are not provided, but it is verified that the exercises
 are doable and free of errors.
 More difficult examples and exercises are marked by an asterisk (*).
\end_layout

\begin_layout Standard
A software engineer needs to know only a little of mathematical theory –
 the parts that answer questions arising in the practice of functional programmi
ng.
 So I keep the theoretical material to the minimum; 
\emph on
ars longa, vita brevis est
\emph default
.
 I do not pursue mathematical generalizations beyond practical relevance
 or immediate pedagogical usefulness.
 This limits the scope of required mathematical knowledge to bare rudiments
 of category theory, type theory, and formal logic.
 For instance, I do not use 
\begin_inset Quotes eld
\end_inset

introduction/elimination rules
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

strong normalization
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

complete partial order domains
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

adjoint functors
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

limits
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

co-limits
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

pullbacks
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

pushouts
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

topoi
\begin_inset Quotes erd
\end_inset

, or even the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

, because learning these concepts will not help a functional programmer
 write code.
 Instead, I focus on practically useful material – including some rarely
 mentioned constructions, e.g.
\begin_inset space ~
\end_inset

the 
\begin_inset Quotes eld
\end_inset

filterable functor
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

applicative contrafunctor
\begin_inset Quotes erd
\end_inset

 typeclasses.
\end_layout

\begin_layout Standard
Some formatting conventions used in this book:
\end_layout

\begin_layout Itemize
Text in boldface indicates a new concept or term that is being defined.
 Text in italics is a logical emphasis.
 Example:
\end_layout

\begin_layout Quotation
An 
\series bold
aggregation
\begin_inset Index idx
status open

\begin_layout Plain Layout
aggregation
\end_layout

\end_inset


\series default
 is a function from a list of values to a 
\emph on
single
\emph default
 value.
\end_layout

\begin_layout Itemize
Sample Scala code is written inline using a small monospaced font, such
 as this: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val a = 
\begin_inset Quotes eld
\end_inset

xyz
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

.
 Longer code examples are written in separate code blocks, which may also
 show the output from the Scala interpreter:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val s = (1 to 10).toList
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s.product
\end_layout

\begin_layout Plain Layout

res0: Int = 3628800 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Derivations of laws are written in a two-column notation where the right
 column contains the code and the left column indicates the property or
 law used to derive the expression at right.
 A green underline shows the part of the 
\emph on
previous
\emph default
 expression that we rewrite using the indicated law.
 Example: 
\begin_inset Formula 
\begin{align*}
 & \gunderline{\text{pu}_{M}^{\uparrow\text{Id}}}\bef\text{pu}_{M}\bef\text{ftn}_{M}\\
\text{raising into the identity functor:}\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\\
\text{left identity law for }M:\quad & =\text{pu}_{M}\quad.
\end{align*}

\end_inset

A green underline is sometimes also used at the 
\emph on
last
\emph default
 step of the derivation, to indicate the part of the expression that resulted
 from the most recent rewriting.
\end_layout

\end_body
\end_document
