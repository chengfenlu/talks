
\chapter{Functors and contrafunctors}

\section{Slides}

\subsection{``Container-like'' type constructors}

Visualize \texttt{\textcolor{blue}{\footnotesize{}Seq{[}T{]}}} as
a container with some items of type \texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize\par}

How to formalize this idea as a property of \texttt{\textcolor{blue}{\footnotesize{}Seq}}?

Another example of a container: \texttt{\textcolor{blue}{\footnotesize{}Future{[}T{]}}}{\footnotesize\par}

a value of type \texttt{\textcolor{blue}{\footnotesize{}T}} will be
available later, or may fail to arrive

Let us separate the ``bare container'' functionality from other
functionality

A ``bare container'' will allow us to:

manipulate items held within the container

In FP, to ``manipulate items'' means to \emph{apply functions to
values}

``Container holds items'' = we can apply a function to the items

but the new data items \emph{remain} within the same container!

need \texttt{\textcolor{blue}{\footnotesize{}map{[}A,B{]}:\ Container{[}A{]}
$\Rightarrow$ (A $\Rightarrow$ B) $\Rightarrow$ Container{[}B{]}}}{\footnotesize\par}

A ``bare container'' will \emph{not} allow us to:

make a new container out of a given set of items

read values out of the container

add more items into container, or delete items from container

wait and get notified when new items become available in container

\subsection{\texttt{Option{[}T{]}} as a container I}

In the type notation: $\text{Option}^{A}=1+A$

The \texttt{\textcolor{blue}{\footnotesize{}map}} function is required
to have the type
\[
\text{map}^{A,B}:1+A\Rightarrow\left(A\Rightarrow B\right)\Rightarrow1+B
\]

This function produces a new $\text{Option}^{B}$ value, possibly
containing transformed data

Main questions:

How to avoid ``information loss'' in this function?

Does this \texttt{\textcolor{blue}{\footnotesize{}map}} allow us to
``manipulate values within the container''?


\subsection{\texttt{Option{[}T{]}} as a container II}

Avoiding ``information loss'' means:

\texttt{\textcolor{blue}{\footnotesize{}map{[}A,A{]}(opt)(x$\Rightarrow$x)
== opt}} \textendash{} ``\textbf{identity law}'' for \texttt{\textcolor{blue}{\footnotesize{}map}}{\footnotesize\par}

Actually, we have two implementations of the type: 
\[
\text{map}^{[A,B]}=(1+a^{A})\Rightarrow(f^{A\Rightarrow B})\Rightarrow1+f(a)
\]
and
\[
\text{map}^{[A,B]}=(1+a^{A})\Rightarrow(f^{A\Rightarrow B})\Rightarrow1+0^{B}
\]
The second implementation has ``information loss''!

Short notation for code (type annotations are optional):
\begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{Short notation} & \textbf{Scala code}\tabularnewline
\hline 
\hline 
$a^{A}$ & \texttt{\textcolor{blue}{\footnotesize{}val a: A}}\tabularnewline
\hline 
$f^{:B\Rightarrow C}=...$ & \texttt{\textcolor{blue}{\footnotesize{}def f{[}A{]}: B $\Rightarrow$
C = \{...\}}}\tabularnewline
\hline 
$(a^{A}\boxplus b^{B})\Rightarrow...$ & \texttt{\textcolor{blue}{\footnotesize{}x: Either{[}A, B{]} match
\{...\}}}\tabularnewline
\hline 
$a^{A}+\bbnum 0^{B}$ & \texttt{\textcolor{blue}{\footnotesize{}Left(a):\ Either{[}A, B{]}}}\tabularnewline
\hline 
$1$ & \texttt{\textcolor{blue}{\footnotesize{}()}}, also \texttt{\textcolor{blue}{\footnotesize{}None}}\tabularnewline
\hline 
\end{tabular}
\par\end{center}


\subsection{\texttt{Option{[}T{]}} as a container III}

What it means to ``be able to manipulate values in a container''

Flip the two curried arguments in the type signature of \texttt{\textcolor{blue}{\footnotesize{}map}}:{\footnotesize{}
\[
\text{fmap}^{[A,B]}:\left(A\Rightarrow B\right)\Rightarrow\text{Option}^{A}\Rightarrow\text{Option}^{B}
\]
}{\footnotesize\par}

A function $f$ is ``\textbf{lifted}'' from $A\Rightarrow B$ to
$\text{Option}^{A}\Rightarrow\text{Option}^{B}$ by \texttt{\textcolor{blue}{\footnotesize{}fmap}}:{\footnotesize{}
\[
\text{fmap}(f^{A\Rightarrow B}):\text{Option}^{A}\Rightarrow\text{Option}^{B}
\]
}{\footnotesize\par}

Being able to manipulate values means that functions \emph{behave
normally when lifted}, i.e.\ when applied within the container

The standard properties of function composition are{\footnotesize{}
\begin{align*}
f^{A\Rightarrow B}\bef id^{B\Rightarrow B} & =f^{A\Rightarrow B}\\
id^{A\Rightarrow A}\bef f^{A\Rightarrow B} & =f^{A\Rightarrow B}\\
f^{A\Rightarrow B}\bef(g^{B\Rightarrow C}\bef h^{C\Rightarrow D}) & =(f^{A\Rightarrow B}\bef g^{B\Rightarrow C})\bef h^{C\Rightarrow D}
\end{align*}
}and should hold for the ``lifted'' functions as well!

The ``identity law'' already requires that {\footnotesize{}$\text{fmap}(\text{id}^{A\Rightarrow A})=\text{id}^{\text{Option}^{A}\Rightarrow\text{Option}^{A}}$}{\footnotesize\par}

It remains to require that \texttt{\textcolor{blue}{\footnotesize{}fmap}}
should preserve function composition:{\footnotesize{}
\[
\text{fmap}(f^{A\Rightarrow B}\bef g^{B\Rightarrow C})=\text{fmap}(f^{A\Rightarrow B})\bef\text{fmap}(g^{B\Rightarrow C})
\]
}{\footnotesize\par}


\subsection{Functor: the definition}

An abstraction for the functionality of a ``bare container'' 

A \textbf{functor} is:

a data type with a type parameter, e.g.\ \texttt{\textcolor{blue}{\footnotesize{}MyData{[}T{]}}}{\footnotesize\par}

such that a function \texttt{\textcolor{blue}{\footnotesize{}map}}
or, equivalently, \texttt{\textcolor{blue}{\footnotesize{}fmap}} is
available:{\footnotesize{}
\begin{align*}
\text{map}^{[A,B]}:\  & \text{MyData}^{A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow\text{MyData}^{B}\\
\text{fmap}^{[A,B]}: & \left(A\Rightarrow B\right)\Rightarrow\text{MyData}^{A}\Rightarrow\text{MyData}^{B}
\end{align*}
}{\footnotesize\par}

such that the identity law and the composition law hold

The laws are easier to formulate in terms of \texttt{\textcolor{blue}{\footnotesize{}fmap}}:\texttt{\textcolor{blue}{\footnotesize{}
\begin{align*}
\text{fmap}^{A,A}\,(\text{id}^{A\Rightarrow A}) & =\text{id}^{F^{A}\Rightarrow F^{A}}\\
\text{fmap}(f^{A\Rightarrow B}\bef g^{B\Rightarrow C}) & =\text{fmap}(f^{A\Rightarrow B})\bef\text{fmap}(g^{B\Rightarrow C})
\end{align*}
}}{\footnotesize\par}

Verify the laws for \texttt{\textcolor{blue}{\footnotesize{}Option{[}A{]}}}:
see test code

\texttt{\textcolor{blue}{\footnotesize{}def fmap{[}A,B{]}(f: (A $\Rightarrow$
B)): Option{[}A{]} $\Rightarrow$ Option{[}B{]} = \{}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}  case Some(x) $\Rightarrow$
Some(f(x))}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}  case None $\Rightarrow$
None}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}\}}}{\footnotesize\par}


\subsection{Examples of functors I}

(Almost) everything that has a ``\texttt{map}'' is a functor

Specific functors will have methods for creating them, reading values
out of them, adding / removing items, waiting for items to arrive,
etc.

Common to all functors is the \texttt{\textcolor{blue}{\footnotesize{}map}}
function

Right now we are only concerned about the properties of \texttt{\textcolor{blue}{\footnotesize{}map}}{\footnotesize\par}

Examples of functors in the Scala standard library:

\texttt{\textcolor{blue}{\footnotesize{}Option{[}T{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}Either{[}L, R{]}}} with respect
to \texttt{\textcolor{blue}{\footnotesize{}R}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}Seq{[}T{]}}} and \texttt{\textcolor{blue}{\footnotesize{}Iterator{[}T{]} }}{\footnotesize\par}

various subtypes of \texttt{\textcolor{blue}{\footnotesize{}Seq}}
(\texttt{\textcolor{blue}{\footnotesize{}Range}}, \texttt{\textcolor{blue}{\footnotesize{}List}},
\texttt{\textcolor{blue}{\footnotesize{}Vector}}, \texttt{\textcolor{blue}{\footnotesize{}IndexedSeq}},
etc.)

\texttt{\textcolor{blue}{\footnotesize{}Future{[}T{]}}}, \texttt{\textcolor{blue}{\footnotesize{}Try{[}T{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}Map{[}K, V{]}}} with respect
to \texttt{\textcolor{blue}{\footnotesize{}V}} (using \texttt{\textcolor{blue}{\footnotesize{}mapValues}})

Examples of \emph{not-really-functors} that have a \texttt{\textcolor{blue}{\footnotesize{}map}}:

\texttt{\textcolor{blue}{\footnotesize{}Set{[}T{]}}} \textendash{}
it works only when \texttt{\textcolor{blue}{\footnotesize{}T}} has
a well-behaved ``\texttt{\textcolor{blue}{\footnotesize{}==}}''
operation

\texttt{\textcolor{blue}{\footnotesize{}Map{[}K, V{]}}} with respect
to both \texttt{\textcolor{blue}{\footnotesize{}K}} and \texttt{\textcolor{blue}{\footnotesize{}V}},
because it is a \texttt{\textcolor{blue}{\footnotesize{}Set}} w.r.t.
\texttt{\textcolor{blue}{\footnotesize{}K}}{\footnotesize\par}

See test code


\subsection{Examples of functors II}

Polynomial type constructors as functors

Short notation: $\text{QueryResult}^{A}=\text{String}\times\text{Int}\times A$

\texttt{\textcolor{blue}{\footnotesize{}case class QueryResult{[}A{]}(name: String,
time: Int, data: A)}}{\footnotesize\par}

Short notation: $\text{Vec3}^{A}=A\times A\times A$

\texttt{\textcolor{blue}{\footnotesize{}case class Vec3{[}A{]}(x: A,
y: A, z: A)}}{\footnotesize\par}

Short notation: $\text{QueryResult}^{A}=\text{String}+\text{String}\times\text{Int}\times A$

\texttt{\textcolor{blue}{\footnotesize{}sealed trait QueryResult{[}A{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}case class Error{[}A{]}(message: String)
extends QueryResult{[}A{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}case class Success{[}A{]}(name: String,
time: Int, data: A) }}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}                     extends
QueryResult{[}A{]}}}{\footnotesize\par}

See test code


\subsection{Examples of functors III: non-functors I}

Data types that cannot have ``\texttt{map}'' at all, due to type
problems

Data types that \emph{consume} a value of the parameter type
\[
\text{NotContainer}^{A}=\left(A\Rightarrow\text{Int}\right)\times A
\]
Note: we can implement map for it, but laws do not hold

\texttt{\textcolor{blue}{\footnotesize{}case class NotContainer{[}A{]}(x: A
$\Rightarrow$ Int, y: A)}}{\footnotesize\par}

Disjunction types with non-parametric type values

\texttt{\textcolor{blue}{\footnotesize{}sealed trait ServerAction{[}Res{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}case class GetResult{[}Res{]}(r: Long
$\Rightarrow$ Res) extends ServerAction{[}Res{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}case class StoreId(x: Long,
y: String) extends ServerAction{[}Long{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}case class StoreName(name: String)
extends ServerAction{[}String{]}}}{\footnotesize\par}

The type \texttt{\textcolor{blue}{\footnotesize{}ServerAction{[}Res{]}}}
is called a GADT (``generalized algebraic data type'')

Not sure what the short notation should be for GADTs!


\subsection{Examples of functors III: non-functors II}

These \emph{could} be functors, except for incorrect implementations
of ``\texttt{map}''

We need a well-behaved $\text{fmap}\,(f^{A\Rightarrow B}):\text{Container}^{A}\Rightarrow\text{Container}^{B}$

What could go wrong?

\texttt{\textcolor{blue}{\footnotesize{}fmap(f)}} ignores \texttt{\textcolor{blue}{\footnotesize{}f}}
\textendash{} e.g.\ always returns \texttt{\textcolor{blue}{\footnotesize{}None}}
for \texttt{\textcolor{blue}{\footnotesize{}Option{[}B{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}fmap(f)}} reorders data items
in a container: 
\[
\text{Container}^{A}\equiv A\times A;\qquad\text{fmap}^{A,B}\,(f^{A\Rightarrow B})({\color{blue}x}^{A},{\color{blue}y}^{A})=\left(f({\color{blue}y}),f({\color{blue}x})\right)
\]
e.g.\ swaps some elements in $A\times A\times A$:

\texttt{\textcolor{blue}{\footnotesize{}def fmap{[}A, B{]}(f: A $\Rightarrow$
B): Vec3{[}A{]} $\Rightarrow$ Vec3{[}B{]} =}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}  \{ case Vec3(x, y, z) $\Rightarrow$
Vec3(f(y), f(x), f(z)) \}}}{\footnotesize\par}

Does a special computation if types are equal: if \texttt{\textcolor{blue}{\footnotesize{}A}}
and \texttt{\textcolor{blue}{\footnotesize{}B}} are the same type,
do \texttt{\textcolor{blue}{\footnotesize{}fmap{[}A, A{]}(f) = identity}},
otherwise $f(x)$ is applied

Does a special computation if type is equal to a specific type, e.g.\ if
\texttt{\textcolor{blue}{\footnotesize{}A = B = Int}} then do $f(f(x))$
else $f(x)$

Does a special computation if $f$ is equal to some $f_{0}$, otherwise
use $f(x)$

See test code


\subsection{Recursive polynomial types as functors}

Example: List of even length is a recursive type,
\begin{align*}
LP^{A} & \equiv1+A\times A\times LP^{A}\\
 & =1+A\times A+A\times A\times A\times A+...
\end{align*}

\texttt{\textcolor{blue}{\footnotesize{}sealed trait LP{[}A{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}final case class LPempty{[}A{]}()
extends LP{[}A{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}final case class LPpair{[}A{]}(x: A,
y: A, tail: LP{[}A{]}) extends LP{[}A{]}}}{\footnotesize\par}

We can implement \texttt{\textcolor{blue}{\footnotesize{}fmap}} as
a recursive function:

\texttt{\textcolor{blue}{\footnotesize{}def fmap{[}A, B{]}(f: A $\Rightarrow$
B): LP{[}A{]} $\Rightarrow$ LP{[}B{]} = \{}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}  case LPempty() $\Rightarrow$
LPempty{[}B{]}()}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}  case LPpair(x, y, tail)
$\Rightarrow$ LPpair{[}B{]}(f(x), f(y), fmap(f)(tail))}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}\}}}{\footnotesize\par}

This is the only way to implement \texttt{\textcolor{blue}{\footnotesize{}fmap}}
that satisfies the functor laws!

See test code for checking the functor laws


\subsection{Contrafunctors}

The type  $C^{A}\equiv A\Rightarrow\text{Int}$ is not a functor (impossible
to implement \texttt{\textcolor{blue}{\footnotesize{}map}}), but we
can implement \texttt{\textcolor{blue}{\footnotesize{}contrafmap}}:
\[
\text{contrafmap}^{A,B}:\left({\color{blue}B\Rightarrow A}\right)\Rightarrow C^{A}\Rightarrow C^{B}
\]

The contrafunctor laws are analogous to functor laws:\texttt{\textcolor{blue}{\footnotesize{}
\begin{align*}
\text{contrafmap}^{A,A}(\text{id}^{A\Rightarrow A}) & =\text{id}^{C^{A}\Rightarrow C^{A}}\\
\text{contrafmap}\left(g\bef f\right) & =\text{contrafmap}\left(f\right)\bef\text{contrafmap}\left(g\right)
\end{align*}
}}The ``contra-'' reverses the arrow between $A$ and $B$

The type parameter $A$ is to the left of the function arrow (``consumed'')

``Functors contain data; contrafunctors consume data''

Example of non-contrafunctor:

The type $\text{NotContainer}^{A}=\left(A\Rightarrow\text{Int}\right)\times A$
is neither a functor nor a contrafunctor


\subsection{Covariance, contravariance, and subtyping}

Example of subtyping:

\texttt{\textcolor{blue}{\footnotesize{}sealed trait AtMostTwo}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}final case class Zero() extends
AtMostTwo}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}final case class One(x: Int)
extends AtMostTwo}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}final case class Two(x: Int,
y: Int) extends AtMostTwo}}{\footnotesize\par}

Here \texttt{\textcolor{blue}{\footnotesize{}Zero}}, \texttt{\textcolor{blue}{\footnotesize{}One}},
and \texttt{\textcolor{blue}{\footnotesize{}Two}} are \textbf{subtypes}
of \texttt{\textcolor{blue}{\footnotesize{}AtMostTwo}}{\footnotesize\par}

We can pass \texttt{\textcolor{blue}{\footnotesize{}Two(10, 20)}}
to a function that takes an \texttt{\textcolor{blue}{\footnotesize{}AtMostTwo}}{\footnotesize\par}

This is equivalent to an automatic type conversion \texttt{\textcolor{blue}{\footnotesize{}Two
$\Rightarrow$ AtMostTwo}}{\footnotesize\par}

A container \texttt{\textcolor{blue}{\footnotesize{}C{[}A{]}}} is
\textbf{covariant} if \texttt{\textcolor{blue}{\footnotesize{}C{[}Two{]}}}
is a subtype of \texttt{\textcolor{blue}{\footnotesize{}C{[}AtMostTwo{]}}}{\footnotesize\par}

And then a type conversion function\texttt{\textcolor{blue}{\footnotesize{}
C{[}Two{]} $\Rightarrow$ C{[}AtMostTwo{]}}} exists

More generally, when \texttt{\textcolor{blue}{\footnotesize{}X}} is
a subtype of \texttt{\textcolor{blue}{\footnotesize{}Y}} then we have
\texttt{\textcolor{blue}{\footnotesize{}X $\Rightarrow$ Y}} and we
need \texttt{\textcolor{blue}{\footnotesize{}C{[}X{]} $\Rightarrow$
C{[}Y{]}}}, which is guaranteed if we have a function of type
\[
\left(X\Rightarrow Y\right)\Rightarrow(C^{X}\Rightarrow C^{Y})
\]

Scala supports covariance annotations on types: \texttt{\textcolor{blue}{\footnotesize{}sealed
trait C{[}+T{]}}}{\footnotesize\par}

Functors are covariant, contrafunctors are contravariant

\subsection{Worked examples I}

Decide if a data type is a functor, a contrafunctor, or neither

Implement a \texttt{\textcolor{blue}{\footnotesize{}fmap}} or a \texttt{\textcolor{blue}{\footnotesize{}contrafmap}}
function that satisfies the laws

Define case classes for these types, and implement \texttt{\textcolor{blue}{\footnotesize{}fmap}}:

$\text{Data}^{A}\equiv\text{String}+A\times\text{Int}+A\times A\times A$

$\text{Data}^{A}\equiv1+A\times(\text{Int}\times\text{String}+A)$

$\text{Data}^{A}\equiv\left(\text{String}\Rightarrow\text{Int}\Rightarrow A\right)\times A+\left(\text{Boolean}\Rightarrow\text{Double}\Rightarrow A\right)\times A$

Decide which of these types are functors or contrafunctors, and implement
\texttt{\textcolor{blue}{\footnotesize{}fmap}} or \texttt{\textcolor{blue}{\footnotesize{}contrafmap}}
respectively:

$\text{Data}^{A}\equiv\left(A\Rightarrow\text{Int}\right)+\left(A\Rightarrow A\Rightarrow\text{String}\right)$

$\text{Data}^{A,B}\equiv\left(A+B\right)\times\left(\left(A\Rightarrow\text{Int}\right)\Rightarrow B\right)$

Rewrite this code in the short notation; identify covariant and contravariant
type usages; verify that with covariance annotations:

\texttt{\textcolor{blue}{\footnotesize{}sealed trait Coi{[}A, B{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}case class Pa{[}A, B{]}(b: (A,
B), c: B$\Rightarrow$Int)  extends Coi{[}A, B{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}case class Re{[}A, B{]}(d: A,
e: B, c: Int)    extends Coi{[}A, B{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}case class Ci{[}A, B{]}(f: String$\Rightarrow$A,
g: B$\Rightarrow$A) extends Coi{[}A, B{]}}}{\footnotesize\par}


\subsection{Exercises I}

Define case classes for these types, decide if they are covariant
or contravariant, and implement \texttt{\textcolor{blue}{\footnotesize{}fmap}}
or \texttt{\textcolor{blue}{\footnotesize{}contrafmap}} as needed:

$\text{Data}^{A}\equiv\left(1+A\right)\times\left(1+A\right)\times\text{String}$

$\text{Data}^{A}\equiv\left(A\Rightarrow\text{String}\right)\Rightarrow\left(A\times\left(\text{Int}+A\right)\right)$

$\text{Data}^{A,B}\equiv\left(A\Rightarrow\text{String}\right)\times\left(\left(A+B\right)\Rightarrow\text{Int}\right)$

$\text{Data}^{A}\equiv\left(1+\left(A\Rightarrow\text{String}\right)\right)\Rightarrow\left(1+\left(A\Rightarrow\text{Int}\right)\right)\Rightarrow\text{Int}$

$\text{Data}^{B}\equiv\left(B+\left(\text{Int}\Rightarrow B\right)\right)\times\left(B+\left(\text{String}\Rightarrow B\right)\right)$

Rewrite this code in the short notation; identify covariant and contravariant
type usages; verify that with covariance annotations:

\texttt{\textcolor{blue}{\footnotesize{}sealed trait Result{[}A,B{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}case class P{[}A,B{]}(a: A,
b: B, c: Int)   extends Result{[}A,B{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}case class Q{[}A,B{]}(d: Int$\Rightarrow$A,
e: Int$\Rightarrow$B) extends Result{[}A,B{]}}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}case class R{[}A,B{]}(f: A$\Rightarrow$A,
g: A$\Rightarrow$B)     extends Result{[}A,B{]}}}{\footnotesize\par}


\subsection{The structure of functor types I}

How to build new functors out of old ones

Main question:

Is any data type $Z^{A}$ with $A$ in covariant positions always
a functor? {\footnotesize{}
\[
Z^{A,R}\equiv\left(\left(A\Rightarrow R\right)\Rightarrow R\right)\times A+\left(R\Rightarrow A+\text{Int}\right)+A\times A\times\text{Int}\times\text{Int}
\]
}{\footnotesize\par}

``Elementary'' data types are built from parts:

Constant types $1$, $\text{Int}$, $\text{String}$, etc.

Type parameters $A$, $B$, ..., $Z$, etc.

Previously defined type constructors $F^{A}$, $G^{A}$, etc.

Four operations: $F^{A}+G^{A}$,\  $F^{A}\times G^{A}$,\  $F^{A}\Rightarrow G^{A}$,\ 
$F^{G^{A}}$ (composition)

Each time a type $A$ is moved to the left of $\Rightarrow$, its
covariance is reversed

So $A\Rightarrow Z$ is contravariant in $A$, but $\left(A\Rightarrow Z\right)\Rightarrow Z$
is again covariant

If we exclude the operation $F^{A}\Rightarrow G^{A}$, the result
is always covariant

This yields polynomial type constructors = \textbf{polynomial functors}

To answer the question:

Build \texttt{\textcolor{blue}{\footnotesize{}fmap}} incrementally
as we build up the type expression

Verify that the laws hold at every step


\subsection{The structure of functor types II}

The building blocks

Building blocks: creating functors from scratch

\textbf{Constant} functors $\text{Const}^{C,A}\equiv C$ with $\text{fmap}(f)=id$,
and are at the same time contrafunctors with $\text{contrafmap}(f)=id$

\textbf{Identity} functor $\text{Id}^{A}=A$ with $\text{fmap}(f)=f$
(not a contrafunctor!)

Operations: creating new functors out of previous ones

In each case, we already have the \texttt{\textcolor{blue}{\footnotesize{}fmap}}
implementations for $F^{A}$ and $G^{A}$, and we assume that their
functor laws were already checked 

$F^{A}+G^{A}$ \textendash{} \texttt{\textcolor{blue}{\footnotesize{}fmap}}
is built by pattern-matching and preserving the sides

$F^{A}\times G^{A}$ \textendash{} \texttt{\textcolor{blue}{\footnotesize{}fmap}}
is built by tupling the two \texttt{\textcolor{blue}{\footnotesize{}fmap}}
results, in order

$F^{A}\Rightarrow G^{A}$ \textendash{} \texttt{\textcolor{blue}{\footnotesize{}fmap}}
is built by substituting the function argument

Here $F^{A}$ must be a contrafunctor and $G^{A}$ must be a functor

$F^{G^{A}}$ (\texttt{\textcolor{blue}{\footnotesize{}F{[}G{[}A{]}{]}}}
in code) \textendash{} \texttt{\textcolor{blue}{\footnotesize{}fmap}}
is built by composing the two \texttt{\textcolor{blue}{\footnotesize{}fmap}}s

Type recursion: $F^{A}=R^{A,F^{A}}$, where $R^{A,X}$ is a functor
in $A$ and $X$

\texttt{\textcolor{blue}{\footnotesize{}fmap}} for $F^{A}$ is recursive,
uses the two \texttt{\textcolor{blue}{\footnotesize{}fmap}}s of $R^{A,X}$

Similar constructions hold for contrafunctors, \emph{mutatis mutandis}

Will now check that the functor laws still hold after each operation


\subsection{Worked examples II: Checking the functor laws}

To check that the \texttt{\textcolor{blue}{\footnotesize{}fmap}} laws
hold for $F^{A}+G^{A}$ if they hold for $F^{A}$ and $G^{A}$

From $f:A\Rightarrow B$, get $\text{fmap}_{F}(f):F^{A}\Rightarrow F^{B}$
and $\text{fmap}_{G}(f):G^{A}\Rightarrow G^{B}$

Define $\text{fmap}_{F+G}(f)=(p^{F^{A}}+q^{G^{A}})\Rightarrow\text{fmap}_{F}(f)(p)+\text{fmap}_{G}(f)(q)$

Identity law: $f=id$, so $\text{fmap}_{F}(f)=id$ and $\text{fmap}_{G}(f)=id$

Hence we get $\text{fmap}_{F+G}(id)(p+q)=id(p)+id(q)=p+q$

Composition law: 
\begin{align*}
 & (\text{fmap}_{F+G}(f_{1})\bef\text{fmap}_{F+G}(f_{2}))(p+q)\\
=\  & \text{fmap}_{F+G}(f_{2})\left(\text{fmap}_{F}(f_{1})(p)+\text{fmap}_{G}(f_{1})(q)\right)\\
=\  & (\text{fmap}_{F}(f_{1})\bef\text{fmap}_{F}(f_{2}))(p)+\left(\text{fmap}_{G}(f_{1})\bef\text{fmap}_{G}(f_{2})\right)(q)\\
=\  & \text{fmap}_{F}(f_{1}\bef f_{2})(p)+\text{fmap}_{G}(f_{1}\bef f_{2})(q)\\
=\  & \text{fmap}_{F+G}(f_{1}\bef f_{2})(p+q)
\end{align*}

Note how $\text{fmap}_{F+G}(f)$ works on each side of $\left(p+q\right)$
separately

The laws would not hold if we mixed up some parts of $p$ and $q$


\subsection{Worked examples III: Checking the functor laws}

To show that $F^{A}\Rightarrow G^{A}$ is a functor, assuming that
$F^{A}$ is a contrafunctor and $G^{A}$ is a functor

For a given $f:A\Rightarrow B$, denote for brevity $\gamma_{f}=\text{fmap}_{G}(f):G^{A}\Rightarrow G^{B}$
and $\phi_{f}=\text{contrafmap}_{F}(f):F^{B}\Rightarrow F^{A}$ ,
then define $\text{fmap}_{F\Rightarrow G}(f)(p:F^{A}\Rightarrow G^{A}):\left(F^{B}\Rightarrow G^{B}\right)=q\Rightarrow\gamma_{f}(p(\phi_{f}(q)))$

Identity law: $f=id$, so $\gamma_{f}=id$ and $\phi_{f}=id$

Hence we get $\text{fmap}_{F\Rightarrow G}(id)(p^{F^{A}\Rightarrow G^{A}})=\left(q^{F^{A}}\Rightarrow p(q)\right)=p$

Composition law, assuming $\gamma_{f_{1}}\bef\gamma_{f_{2}}=\gamma_{f_{1}\bef f_{2}}$
and $\phi_{f_{2}}\bef\phi_{f_{1}}=\phi_{f_{1}\bef f_{2}}$: 
\begin{align*}
 & (\text{fmap}_{F\Rightarrow G}(f_{1})\bef\text{fmap}_{F\Rightarrow G}(f_{2}))(p^{F^{A}\Rightarrow G^{A}})\\
=\  & \text{fmap}_{F\Rightarrow G}(f_{2})\left(q\Rightarrow\gamma_{f_{1}}(p(\phi_{f_{1}}(q)))\right)\\
=\  & q\Rightarrow\gamma_{f_{2}}(\gamma_{f_{1}}(p(\phi_{f_{1}}(\phi_{f_{2}}(q)))))\\
=\  & q\Rightarrow\gamma_{f_{1}\bef f_{2}}(p(\phi_{f_{1}\bef f_{2}}(q)))\\
=\  & \text{fmap}_{F\Rightarrow G}(f_{1}\bef f_{2})(p)
\end{align*}

The order is reversed for $\phi$, so this wouldn't work if $F$ were
a functor


\subsection{Exercises II}

Check that the \texttt{\textcolor{blue}{\footnotesize{}fmap}} laws
hold for $F^{A}\times G^{A}$ if they hold for $F^{A}$ and $G^{A}$

Show that $F^{A}\Rightarrow G^{A}$ is, in general, neither a functor
nor a contrafunctor when both $F^{A}$ and $G^{A}$ are functors or
both are contrafunctors (an example of suitable $F^{A}$ and $G^{A}$
will be sufficient)

Show that $F^{A}\Rightarrow G^{A}$ is a contrafunctor if $F^{A}$
is a functor and $G^{A}$ is a contrafunctor, by checking the \texttt{\textcolor{blue}{\footnotesize{}contrafmap}}
laws for $F^{A}\Rightarrow G^{A}$ 


\section{Discussion}

\begin{comment}
this is chapter four all about functors functors are an abstraction
that captures the features of what it means to have container like
types were container like data bunkers are always type constructors
so they're parametrized by type and they mean a container that has
items of values of that type first example would be a sequence so
that is obviously visualized as a container that has zero or more
items of type T so sequence of T written like this but there are other
containers like for example future of T they're very different from
sequence how do we formulate this idea that something is a container
some type constructor and represents a container when they're so different
so sequence is one or more values of this type so you can take one
you can find which one is in the sequence or how many and so on and
here's another one which represents a value of type T that will be
available later or actually may fail to be become available but it's
not available now in any case likely so how do we abstract away a
common feature between these two very different data types it turns
out that the common feature is what I call here the bare functionality
of a container it's just the functionality that describes the idea
of holding in some way an item or perhaps several items of type T
and holding means you can manipulate this data inside the container
that's the only way that we can interpret this if there is data inside
the container but we can never manipulate it in any way then that's
not reasonable to call that a container so what does it mean to manipulate
it means we can apply functions to these values because in functional
programming that's all we do we apply functions and get new values
out of old ones so the idea that the container holds items it means
that we can apply a function to these items and the new items will
remain in the container so we're not extracting items out of it were
just transforming the items that stay within the container and that's
what it means that the container holds them so to make it formal we
write a function that takes a container with items of type a it takes
a function of type a to be and it returns a new container with values
of type B where all the values that were held in the container here
have been transformed through this function into values of type B
but they remain in the same container or in it is a new value of the
container type but they remain within the same kind of container container
at the same shape so for instance if it were a sequence then it will
remain a sequence so we have a sequence of a we can map and we get
a sequence of B each value each data item in the sequence would have
been transformed through this function the resulting data of type
B remain within the sequence and so it's the same shape of the container
that remains and the data is not extracted out of the container it
remains within the container and the same thing happens with the future
type you can do a map on the future and transform through a function
and you get a future of B which means that the value will be available
of Type A in the future and once it is available you'll transform
it through this transformation and you will get a value of type B
also in the future so so this is the common pattern between sequence
and future it's a pattern that allows us to transform data while keeping
that data within the same container so that's what I'll mean here
by the functionality of their container so for instance making a new
container out of a given set of data items is not part of that functionality
or reading values out of the container or adding more items or deleting
items these are also not part of the functionality of the bigger container
so these are specific containers that we will consider later that
can do this but the most basic and common among all containers is
not is not this also not waiting or getting notified when new items
become available like in the future container none of that is the
basic functionality of a container only this so if we have the map
when we have a container we can additionally have other things and
of course any kind of useful container will have other methods and
we'll have other functionality it is unreasonable to just use bare
container you can do anything with it you can't even create it or
read values out of it so in any specific case you will have a bunch
of other methods for any specific container so for example you want
to create a future container it means you need to create some parallel
process that will be running and computing this value of type T while
you're still doing your computation so creating a container of this
type actually involves creating a parallel process or parallel thread
of computation creating a container of this type doesn't involve that
necessarily so these are going to be specific things that I'm not
going to talk about in this tutorial I'm only going to talk about
what is common to all containers which is a bare container functionality
which is the map function so let's consider option as an example and
I will be using the short type notation what because it's easier to
read and to reason about so option is defined as this type is a disjunction
of unit and a value of type a so the map function if option were to
be considered as a container it needs to have a map function would
have this type so it goes from 1 plus a 2 A to B to 1 plus B and this
function needs to produce a new value of type option B which possibly
contains transform data but option could be empty that's the nature
of what the option is it has two versions or two parts of the disjunction
one is the empty and one is the non empty where we have the of type
a so maybe this function will lose will return the empty and lose
all this information that was there in the initial value of the option
so how do we avoid that is it this function how do we define this
function so that we don't lose information and how do we also define
this function so that it actually allows you allows us to manipulate
values so are there some constraints on this function that we need
to be aware of and that's a center point of this tutorial so these
are the main questions that we will be dealing with how to define
this map function in a sensible and reasonable way because that's
part of the idea of the container because the container does not lose
information you transfer information inside but you should don't lose
it while you're transforming losing it would violate the whole idea
of having a container that holds information so the first question
about information loss we will translate that into a formula because
we don't want to just talk about some intuition intuition is important
but we also want to formulate these both requirements there's very
precise formulas as requirements or as we call them laws so here is
how I would formulate the requirement that the map does not lose information
if you give it a transformation so remember the type signature this
function is this we need to give it an initial option and the transformation
so if you give it a transformation which is identity it means you
don't change any data we don't intend to change any data you give
a transformation that doesn't change anything you expect that the
container will not change that the new container that you produce
out of the map it will be exactly the same as the old one well if
that were not true then obviously even doing nothing would lose information
or change things in some unpredictable way and that violates the idea
of manipulating values in the container because manipulating means
you apply a function so if you apply that if an identity function
it means you didn't do anything you did not actually intend to change
anything and so that's reproduce the original value of the option
so this is the law which is called the identity law for map and let's
apply this law to this case so actually if you try to implement this
function there are two ways of implementing it one would be the reasonable
that is if so this is a short notation for code but you have done
this in the Scala exercises in a previous tutorial so I assume you
understand what Scala would be for this I prefer to write short notation
because it's easier to visualize what's going on so the argument is
one plus a so it's either one or a then another argument is the function
f so if we have a left version then we return the left if we have
the right version here then we return f of a so that is the usual
way of implementing math penetrant but the other way would be to always
return the left version the nun or the unit in this disjunction will
never return anything in the right part of the disjunction so so basically
yeah this is I see there's a little syntax error here and there should
be an arrow I will fix that in the slides after this presentation
is over so so basically the second version always loses information
it never takes this a and does anything with it so even if I give
that identity function here I will still lose this a so so that version
has information loss and we don't want that so we will prefer the
first implementation here's a summary of my short code notation which
is that you did you put type annotations as superscript and type parameters
here in brackets and you can put also type annotations at the same
time as type parameters like you're doing scala and if you have an
argument that is a disjunction and you write it like that and then
you use a and B on the right hand side and that implicitly should
generate some match with cases in the right-hand side if you want
the left part of them either for instance then you say a plus 0 so
or you write 0 plus B so you write a 0 explicitly to indicate that
you're returning a disjunction just like in Scala you have to write
left you have to say left explicitly and if you're returning a disjunction
and 1 you're right for a unit value and also for the none value of
the option or any other name the unit you have in your disjunction
now that is something right something that previewer does sorry though
that now the second requirement is that we want to be able to manipulate
values and that requirement is about how you would manipulate using
different function so you by one function and then they apply another
function so what will happen then so now to see what happens and to
formulate that requirement which we haven't yet formulated clearly
it's easier to flip the arguments in the type signature of map and
the type signature is that you have the container as the first argument
and that returns a function whose argument is a to B and that returns
a container so if so these are the two curried arguments and if you
flip them and you have a type signature like this you take a function
from A to B and that returns a function that takes optionally and
returns option B so that is denoted F map so you just flip the argument
order there is no change otherwise to what the function does but it's
easier to reason about this function if you flip the arguments because
then it looks like a function from A to B into a function from optional
a to option B so this looks like lifting a function from A to B to
option eight option B so from one kind of function space to another
kind of function space you're lifting the function so that's much
more visually clear what this function has map does but for coding
in scholar especially it's actually easier to use this order of arguments
because you usually have mapped as a method in a class so you have
a dot map of F and that's also easier to read in code so we have F
dot sorry some kind of option here dot map of this and that returns
that so in this tutorial however we will not use methods on classes
because that's actually more advanced from the point of view of functional
programming and the easier thing is to just write a function with
arguments and so our map function will have this form will have one
argument which is in a container type and another argument that's
a function type and the F map will have the opposite order of these
arguments so this is what we would write F map applied to a function
from A to B returns a function from option eight option B so after
this digression let's formulate what it means to manipulate values
it means that the functions when you lift them into the container
behave still like or normal functions behave and that means when you
compose them they have the ordinary properties and what are these
properties so there are these property than written here you have
a function from A to B you compose it with identity function then
you get the same function you had before and you can compose it on
the left and you still have the same function you have before and
then if you compose functions like this the order of composition F
G H being the same but the order in which you first take this pair
or you first take this pan that doesn't matter so that's called associativity
so there are these laws and they should hold for the lifted functions
as well so that's going to be a bit difficult to understand but actually
it's what we're going to do is we're going to say that oh well we
already have the identity law which was motivated by an information
loss avoidance and that requires that F map of identity is equal to
identity and so when you lift identity you get an identity on the
lifted type of the the container and so it's reasonable then to require
that when you lift a function and you compose it with another function
then the result is going to preserve function composition so that
if you compose two functions and lift them it's the same as if you
first lifted each of them and then composed them so these functions
are composed in the original space and these two functions after F
map are composed in the lifted space in the space of the container
values so if we require this much easier property then these are going
to be automatically satisfied because because these are going to be
just composition in the lifted space and in the container space so
these are therefore going to be the laws now we can make definition
write down a definition water what is a functor so functor is the
term which is used in functional programming recently to denote this
abstraction of the functionality of a bare container the bare container
having a map with laws so definition is that functor first of all
it is a data type that has a type parameter such as something like
this now if you don't have a type traveler you cannot have a container
obviously so or you cannot abstract the functionality of a container
if you don't first abstract the type of values to a type parameter
and you can have a sequence of integers and you can say that's a container
it is but it is not abstracted and you cannot reason about its properties
as an abstract container and so you cannot see what is commonly between
a sequence of integers and some other sequence like a sequence of
boolean's or a sequence of options of some other thing you cannot
see what's common between them unless you abstract the type into a
type parameter and so the abstraction for this functionality requires
you first to do that and to have a type parameter second require is
that a function map should be available for this data type with this
type signature or F map these are equivalent they just differ by order
during the order of curried arguments and these functions must be
such that the laws of identity and the laws of composition must hold
so these laws are written like that in terms of F map is much easier
to write them shorter and also easier to see what these laws do and
you remember why you need them and of course to check them so the
F map applied to the same type a identity and you a gives you an identity
F a to FA and F my applied to a composition of functions gives you
a composition of lifted functions and so now I just want to mention
that the word functor comes from category theory it is not going to
be useful for us to go into category theory right now but there is
different usage of the word factor in programming or in software engineering
which are not the same because what we're doing here which do not
come from category theory so for example even C++ now has something
called a functor and Kokomo has some other thing called a functor
these are not the same and as is just a very specific usage of the
word function that is now being being dominated being the dominant
one in an functional programming so this functor is a concept from
category theory and not something else but for us this is not very
important that it comes from category theory because we are actually
motivating these laws by requirements of practical use so you want
to manipulate data in a container and if you want to do that in a
reasonable way and be able to understand your code after you have
written it several years back then the children there should be surprises
so if you for example identity law just tells you that if you manipulate
data by doing nothing it shouldn't change your container so it would
be very surprising in your code if that were the case and you would
never find the bug until you debug every step painfully and so that's
the kind of thing I want to avoid by imposing these walls and the
second law the composition law also says that basically functions
are applied in the way you expect expect them to be applied and there's
no surprises so you can simplify your code for instance if you discover
that this function G is identity you can omit it from the code and
the code will still be working and that's not the case if this law
is violated so let us go to actual code demonstration - very fine
the law is for the option in the F map implementation for the option
is written here it's a very easy thing that you take a function f
as a parameter and you return a function from option a to option B
so now if you return a function like this an option is a case class
or a sealed trade with case classes or disjunction as I prefer to
call them then a short syntax in Scala is to just write a case partial
function with case so you did not say much more than this it's just
very easy to to write that it's a shorter syntax and then if the optional
a is empty and you return none and if the option is not empty and
they return a non empty option B with the value inside that this transformed
so let's go to the code so this is the code that is written a little
more verbally and there are three versions here well first of all
I do the map not just the F map so the map takes an option I exit
function A to B and returns an option B and so since there's this
syntax I have to say the first argument is this option is the option
a the second argument is f so I didn't check the types control shift
P so option a is being matched and then if it's not empty we return
this it's empty return death now the bad implementation would be we
did the same thing but we always return none so that would be a bad
implementation but doesn't satisfy the laws and the F map is exactly
what was from basically what was written there except for the F being
here just the syntax difference and I also have a fourth implementation
which is F map although which is automatically implemented so I'm
using this the function from the Greek Harvard library which I'm using
here just as a reference check to see whether these methods can be
automatically implemented or not so then we verify the identity law
for all these implementations so this is the way to verify the laws
is to use the Scala check library that allows you to say things like
this for all value of option int this must be true and I just write
here what I want to be true like for example here the map which I
define right there it plot applied to this option and to the identity
function should be able to that option so that is my statement that
identity being lifted is equal to identity but I cannot compare functions
directly in Scala I have to say for all argument opt the function
applied to the argument is equal to the argument that's the only way
I can say that the function is equal to identity the library Scala
check will go through a large number of a randomly chosen values of
this type and it can generate these values automatically the checking
for s map is quite similar except for the order of arguments which
was inverted as compared with that map and F Mikoto exactly the same
as f ma'am now for my bad actually the test would fail if I wrote
the same test for me from my bad it would have failed because my bad
does not give you identity it always Maps your option to none so once
you take here an option that's not none you get and there and also
we verify the composition law which means we say for all X and for
all functions F and G and here I chose some specific types like integers
string and lon all our functions here are completely type parametric
so I can say any types I want but when i test i have to give a specific
type because there will be specific values randomly generated for
these functions and it is impossible to do that unless you specify
type so you have to choose and I choose some random different types
so then here is how I check the composition law the end then is a
standard scala function or method rather that is defined on function
so f and then G means that the same as you you would write this circle
in my slides the composition is a circle it's in Scott will be and
then so first a and then these and sorry first F and then G so if
you apply this to a value of type a then first F will map it to be
and then G will map it to C so then it is easier to to read it that
way so there's this so basically I write down this law has written
here putting ends then instead of the circle if map F and then G I've
not have and then with man G and then I also have to apply the resulting
function to an X and I say that the result should be equal to applying
the other function to the same X that's the only way to check that
functions are equal here this is an equality of functions this lifted
function should be equal to that with the function and in the test
you cannot directly compare functions we have to apply functions to
values and say that for all values the results are the same so that's
what I do and again I have a check for all the implementations including
the bad one for each for which the composition law actually holds
because this this thing always gives you none so whatever you compose
with the result is going to be none at in any case and so the composition
law will trivially hold what the identity law does not does not hold
here are some examples of functors so like I said we are only concerned
about the properties of map here and all these specific examples will
have lots of different other methods so that you can do other things
so for example option T has methods to get values out of it and to
put values in it and so on so basically anything in the Scala standard
library that has a map method is a functor except for certain map
which are almost functors except that for certain and not well behaved
types the laws will not hold let's see how that works so here's a
here's some example so have a I took this idea from from here from
Rob Norris so imagine we have a type bad which calls an integer but
it has the equals function that is not well behaved the eCos function
always returns true for any other thing which would be kind of unreasonable
and useless but what if this was true for some reason what if you
need this behavior then you define a function f in the function G
in a very obvious way you take an integer you put it into the container
so this can be seen as an container itself that contains a single
integer but we're not using that as a container using that as a data
type inside the container so you put an integer in there in the open
this way and you get the integer back in the obvious way so there
are two functions F and G and now let's take a set of integers and
map with the composition of these two functions and so then we write
it like this so you see in scours much easier to use map rather than
F map because of the syntax so then you get this set because F and
then G is identity because you take this F you put an integer inside
and you get that integer back with no changes you're not comparing
anything while you're doing this and so this function is identity
and of course this set does not change when you map it over identity
but if you first map into F and then map into G which you accept expect
to be the same as that then you get wrong answer because when you
first map with your f then it becomes a set of bad one bad to bad
three and then the set try to see if they're equal because a set is
trying to eliminate duplications right because isettas cannot have
duplicated elements but we have made the eCos operation so that it
always returns true and so the set will think that all of them are
the same and it will eliminate all of them except the first one perhaps
and then you map it back to integer and you get a set of one element
so the composition law fails and that's that's bad so basically for
a set of integers it is not even set of integers integers well behaved
the quality of operation but because you go through some bad type
while you're composing functions you are violating the composition
law and the map is similar it has a map values method which is a good
function but it also has a map method which is mapping with respect
to both key and value and it behaves like a set with respect to keys
because it will not allow you to have duplicate key and that's the
same problem as with this set so if you have a map and you have functions
that map you to type with none ill-behaved equals operation then you
will violate the composition law and that code could have difficult
to find bugs will be very difficult to reason about that code so that's
the real value of these laws I would like to have a little more intuition
about functors and type constructors in general and a good way rather
than look at some types defined in the standard library which are
complicated let's look at very simple types that we can define ourselves
and work with ourselves to see to understand how functors work and
what it means to be their container what it means to be a functor
so here I have three examples first example is a type clearly result
Jeremy tries by a the type variable a and it holds a triple of string
integer and a so the short notation for this type is this and the
Scala code would be that I have to put names on each so I'm just writing
down whatever comes to mind what would be appropriate for a query
result and another example would be a vector of three and three dimensions
having coordinates of type a so I have three coordinates of type a
so it could be maybe double or real or complex or something like that
three dimensional vector of type a with coordinates of type a and
the third example would be disjunction tie the clear is out that could
be so the short notation is strain plus strain times integer times
again in Scala code that would be sealed trait with two cases so I'm
just interpreting what it could be so one could be an error with the
message and another would be a success with a value of type a so C
the first element of the disjunction does not actually contain in
the elements of type a and any values of type a let's the second one
does so let's look at the test code to see how we make them into factors
so the first example was the string times integer times a so we need
to define F map and all these examples are all beginning with F map
because it's much easier to write down but the map would be equivalent
we called so to implement F map and what do we do well we need to
take even a function I have take a query result of type a return a
query result of type B well I could have written this as that because
what I need here is I need to return a function with arguments of
type quick query result a so if I need to return a function and my
code needs to start like this this would be the argument of that function
and that would be the result value now the first thing I have to do
that is to match all this query result because it's a the easiest
thing Regus way to extract values from it would be to match and then
I would say case quite a result with three parts and then I returned
query result with the same parts except I apply the function f to
the data so you see I need to transform string x integer times a into
string times integer times B and I have a function from A to B the
only way I can do it is to apply this function to the a and leave
the string and integer and changed and that's the code I have written
here and this is a simplification of syntax but this is not necessary
to write otherwise it's exactly the same code it is a function takes
an argument of this type immediately does a match on that argument
and returns us an equivalent way of writing this code would be like
this so you take this argument and use the copy function on case classes
that copies only so it copies the entire value of the case class and
it only changes one part of it which is data data the new value is
equal to this F of the old of the old QR dot data so in this case
because the code is so simple the case match would be a lot more writing
than this in India in every other way these are equivalent I'm creating
a new value of type query result be and I'm copying all the parts
name and time and I'm only modifying the data part in this way and
I can do this automatically using the current hardliner so that's
the last implementation and I verify identity law and composition
law for all three implementations the second example was the type
constructor that has a Triple A three dimensional vector of A's so
here I do the same thing I do a case match on the vector and now I
have to apply the function f to all three of the elements here so
again I've I've tried the the automatic implementation but actually
there are different ways of implementing this automatically because
you could for example you could interchange x and y here so the type
would still be correct and the automatic implementation only looks
at the type and tries to find out what what code could be of this
type now if I wrote here Y and X instead of x and y the type would
still be correct the function being correct as well we'll see later
the composition law will not hold the identity law or not called no
it's obvious that identity law will not hold because if F is identity
then you are exchanging wine X you're not leaving the vector3 unchanged
but the Kirk Howard library doesn't know that we want to have the
identity law and so it only looks at the type the type will be correct
so then there are six different ways of permuting the order of these
and it finds all six and has no idea what what to choose as a workaround
I say give me all of those implementations and take the first of them
and actually turns out to be the right one so all of type returns
a sequence of values on this table and I check the identity law and
the composition law and all these tests pass and a final example right
now is to commit to make this into a factor and you find that never
depend checking laws so again this is very similar to one we had before
except now we have two cases of a disjunction in order to transform
this into the query result of B we still just need to apply F to this
a and to be and we're done but now there are two cases in the first
case we actually don't have any values of type a we just have a string
and in the other case we have a string and int and the name so we
need to do a case match so here's how will you find it if it's an
error so you see the two cases error in success if it's an error then
we just return error with no change to the message and if it's a success
then we do what we did before we apply F to data and leave other parts
of the case classic unchanged and the curry Howard library can implement
this automatically there's no no uncertainty as to what to do only
one good implementation so that's these three examples in these three
examples what we found is that we can define F map so we try to define
F map guided by types and also guided by laws so sometimes we have
different possibilities for the same type to write code but the laws
only give us one possibility and that's the general situation with
all the type constructors and that we are going to work with laws
and type dictate how to implement map in only one way what are examples
that are not factors where you cannot implement map well one type
of these examples is types that cannot have any map function at all
due to type problems is an example is is this not container just which
is defined as a product of a function from a to end and a so the case
us will be like this function from A to E and and also a value of
type a so why is this not a container well I can try to implement
an app for it but that won't satisfy the one what what I would do
is it would transform the Y and then it would apply it would apply
that function to that a that you had and get an integer and you cannot
produce a function from beta integer but you can produce a function
that's returning your constant integer and so that con because you
have an integer you can compute a constant integer by applying X to
one and so you just return a constant function that always returns
that constant integer now that is not the right implementation for
F map because it doesn't satisfy the laws which I check here so I
check that the try F Maps that I get here does not satisfy identity
another example of a data type that they cannot have a map due to
type problems is this one where we have a disjunction type but its
type values are nonparametric in some strange way so here's what I
mean by that you have a sealed trait with the type parameter called
dress or some kind of action with results let's say and the the case
classes that extend this trait are defined in this curious way so
the first one is normal it has a value and it extends the survey with
the same time parameter race but the second case class doesn't have
a typewriter an external extends server action with a specific title
loan and and also a third case class extends that with specific type
string so it uses type values that are not parametric type values
that are not equal to this parameter so the the way that we have keys
classes for option or either for such parametric disjunction types
is that each case class extends the trait with the same type parameter
as it has and here it's not the case it extends with a fixed type
so these kind of disjunction types are called generalized algebraic
data types and I don't have short notation for them that's very useful
and at this point I'm not sure what that thread notation should be
and how to reason about them in terms of in terms of data containers
because they are not data containers they're very odd type constructors
if you try to think about them as containers they may be very useful
certainly are very useful in a number of situations but as containers
they fail you cannot even implement FF map or map for this because
you do not actually have a value let's say observer action long or
server action integer for this there's no if you want to have a function
that map's long to integer you cannot do a store ID server action
integer is that that's a fixed type so there is no way you can define
the app for this kind of type because of type problems another type
of things that are not factors are types that could be factors but
we didn't implement correctly we need to have a well behaved of map
to have a functor and a number of things could go wrong if we try
to implement F map so one thing could be that F map ignores F it always
returns none for an option so for instance if that is true usually
it would not be satisfying laws or F map reorders data in a continued
for instance here's a container with two values of type a and we define
F map that applies F but also reorders the values in the container
now this or here is this example I was showing in the code now this
would immediately violate that identity you are so that's not good
and we can verify that so I'm gonna have tests with a special method
exists some that I implemented we can verify that identity law is
not is not satisfied another example is that you could have enough
map that checks the types because in Scala you can you can see what
type II or your past using reflection and that's that's a very risky
thing to do because it's easy to make mistakes I'm difficult to write
code that will always work but if you do that you could check that
a and B are the same type or not and if same time then you do one
thing in your F math let's say you return identity ignoring the F
and if you have another not the same type then you do something else
we apply f of X in some way now this would obviously satisfy the identity
law but this would violate the composition law because you could have
functions F and G whose composition his identity and so then you would
check that the type is the same and you would sorry whose composition
is not identity and you would check here that the type is the same
you would return an identity for them and it would not be equal to
the composition of F and G so you would violate the composition law
if you do that or you could do other special computations in in case
that the type is equal to some specific type like integer then you
do something else in the general case or if the function is equal
to some specific function then you do a special thing and otherwise
they do the general case so none of this would give you an F map that's
well behaved that satisfies the laws so an interesting example of
functor is a recursive type defined like this for example so let's
say a list of pairs which I could just define my hand as type LP with
parameter a that satisfies this recursive equation this is a type
equation LP array is equal to 1 plus a times a times of P of a so
if you expand this using the algebraic or arithmetic very hard correspondence
rules the arithmetic identity would be this kind of expansion so then
you can visualize what this type does so it's either empty or it's
two copies of a well-tuned in values of type a or four values of type
a or more so it's kind of list of pairs except it's a list that can
only have even number of elements it's not really a list of pairs
as as I've defined it so here's a definition installer so you have
a co trade copy of a and it has two parts of a disjunction so one
I would write it like this with empty or unit here and the other with
X\&Y of type a and the tail which is this which is again of type LP
of a so that is allowed so this kind of type recursion is allowed
in Scala when you do take when you when you use case classes so now
we can implement a map here you use recursion so that's implement
F map for simplicity you match on LP of a and there are two cases
so either it's empty and the result will be also empty or it's going
to be a pair of XY tail and then you apply F to x apply F to a sorry
F to Y and you apply F to tail now tail is of the same type and so
you need to use the same F map that should be enough map here should
the same F map that you're defining this use the same recursive call
here applying to the tail so that's all right and that works and actually
this is the only way to implement an app that satisfies the funky
laws what would be another way well we could always return empty here
or we could match on this tail further and let's say if if there at
least four of them then we return empty if there is not for we don't
return it or something like this all of that would be wrong all that
would be incorrect factor instance as it's called incorrect implementation
of map so let's look at the test code so here's the implementation
of this recursive type is defined like that so here I don't have this
title obviously because tests pass we can compile if I find maybe
typos so that's now for for this example it's exactly the same code
as before verifying the laws now notice that I'm able to generate
arbitrary values of this recursive type so how does the library do
it just a short digression I'm using a library called college XJ plus
which is a library made by Alex Horne planar Shambo and he allows
me to use case classes in for all so I can do for all {[}Music{]}
value of some case closed or sealed trait now I don't have to write
any code to do that it's automatic so this is some macro and library
that I'm user now another curious thing is that a type such as this
one a function from a to hints is not a funder it cannot implement
map for it but you can implement something called contra map or here
contra F map which is this similar to f map except that I interchange
the order of B and a here so the function goes from B to a but the
lifted function goes from C a to C B so that's the contract it reverses
the arrow between a and B the Contra function laws are very similar
to function laws except for the interchanging of the order of function
here in composition so this is the control direction so composition
G and F and that's composition of F lifted and G lifted an interesting
observation here is that in this type the type parameter is to the
left of the function area so this type parameter a is consumed by
the function in all our examples of functors here this was not the
case the type a was produced or if it was there it was not consumed
here it was consumed in all these examples of function so that was
our example a non-factor and all of these examples they have a that
is produced or it's already there but it is not consumed so that's
an interesting observation but functors contain data that contractors
consume data so contra functor is not a container is not a functor
so it's not a container should be thought of as a container it's something
that consumes data of this type and this is an example that we had
before the non container it is neither a function or a contra factor
so I have here of some test code I tried to implement contra F maps
for this type but actually there aren't any implementations there's
zero implementations possible there's one implementation possible
of the F map but it does not satisfy the law there are no implementations
of this type at all so this type is neither a function or a contra
factor so it can be not cannot be thought of as a container and also
cannot be thought of as something that consumes the data of this type
it's a strange thing maybe maybe useful maybe not but in any case
it's not a factor or not a contractor another so now that we see functors
and conscious factors another thing that comes to mind is the concepts
of covariance and contravariance now the concepts of covariance and
contravariance our relevant to subtyping so what is subtyping an example
would be when you say class extends something trait so in scholar
these are traits and class diseases a bit specific to scholars and
other languages would not be called traits maybe and we just classiest
but this is a subtype so zero is a subtype of at most two so this
is an example I have at most two is a disjunction of zero integers
one integer or two integers and so the 0 1 \& 2 in Scala are types
themselves that are subtypes of at most 2 which means that if you
have a function that takes an at most 2 as an argument you can pass
this value to that function and it will take it so this is how we
have been using these junctions until now so we're using this feature
of Scala that they're implemented as subtypes and subtype means that
you can automatically convert this type into that type whatever you
need that so this function going from two to at most two is identity
function has just relabeled the type because there's nothing to convert
in this case this class is just an instance or a subtype of that so
but logically speaking there are different types so this type is different
from this and so you can think about it as having always an automatic
type conversion of this sort whenever you need it and so this looks
like a function of this type that's always available let's never need
to be written out explicitly but we could write it out explicitly
if we wanted to and we will in in a second so what does it mean that
a type constructor is covariant so it means that if the container
or type constructor applied to the type two is a subtype of the container
of at most two in other words when you lift these types into the container
type they still are subtypes of each other so this two is a subtype
of at most two and then C of two is also a subtype of C at most two
if that is so and C is called covariant and then you have this type
conversion function automatically available whenever you need it so
more generally what is covariance so covariant so C is covariant type
constructors see is covariant in its argument X when whenever if if
whenever if you have xn is a subtype of Y then you have also this
conversion automatically and obviously if you have this kind of function
which is taking this and producing that if you have this kind of function
then you're guaranteed to have this kind of conversion in other words
and this is this is this type signature of f map in other words if
you have a type constructor that has F map and it's guaranteed to
have the right type conversions and to be covariant and so all functors
are covariant and in Scala you can put the little plus next to the
type when you declare the sealed trait to tell a compiler that you
want this explicitly to be known that this is covariant in that argument
and similarly conservatives are contravariant so contravariant means
that this arrow goes into the opposite direction if too is a subtype
of at most to anicon chiffon jerkoff at most two will be a subtype
of a contra founder of two and so because of this very easy argument
with the implicit or automatic type conversion functions we write
them explicitly then we see immediately that functors are automatically
covariant and contravariant variant so if you want to make this explicit
in scala if for any reason you need subtyping which is advanced topic
in functional programming and it's not something I'm going to talk
about a lot right now you can put a plus sign or a minus sign for
contravariant and then the compiler will check that you actually have
covariance or contravariance correct so so this is the correspondence
between functors control factors covariance and contravariance which
is a very interesting thing so in other words we are talking about
centers and country hunters and this is exactly parallel to covariance
and contravariance but usually in object-oriented programming people
talk about so let's go through some more examples with actual coding
where we will do certain things roll first we can now decide if a
data type is a functor a country founder or neither of the Eastern
so to decide that we look we look at the data type write it down in
the short notation and see if there is any type trainer to the left
of the area which is consumed and to the right of the arrow or off
without an error which is produced or which is already there and that
allows us to decide whether it's a functor or country function then
we implement a map or country map that satisfies the laws so we are
implementing first looking at the type just guided by what types need
to be produced and if there is a choice or ambiguity we then see whether
laws are satisfied so let's look at the first example which is this
one so we have this type string plus a times int plus a times a times
a our task is to define case classes for this type and implement map
so this is how we would write our case classes in all these examples
I'm going to call this type data so that all my code is always ready
to cut and paste so in this case we have three pieces of the injunction
or 3s rate disjunction so there are three parts of the disjunction
the first part is just string so we have this second part is a product
of a and int so we have four tuple we have a and we have an int in
the third part is a a a so F map makes a match on data disjunction
if I have a message then I don't change that message you know in any
case I couldn't do anything else at this point I have to return the
message of type B because there is nothing else I could possibly return
if I have a second case class then it means I have one I have one
item of the of type a so then I apply F to that item and I'm done
and the third case I have three items of type a and I apply F on each
of them and I don't change the order so that's how I'm implemented
the second example is this one so now in this example first what I
notice is that I have a type of the for one plus something so in Scala
I already have option type I don't have to myself implement the cases
for that so let me use it so it will be an option of this and that
is a tuple of a and this Junction for this this Junction here I declare
another sealed trait which is a called data two and here this trade
is still parameterize by a it has two cases the message and the value
so so now I have a bit more complication in my code because when I
match on data then that's a case class that has a data constructor
over option so it's a data of option and the option needs to be matched
as well so I can match this in the same case expression and I have
two possibilities data of some of blob data of none know if I have
data of none and clearly all I can do is return data of not there's
nothing else I can do I couldn't possibly return any of those things
so it remains to to do this with a case data of some and the sum is
of a tuple of the of a pair work most more precisely of a and this
data to so there is a pair of value a and data to so then I am going
to return a data of some of some new value a and some new data to
so I'm going to return this and in order to make the code more readable
I'm going to write explicitly what new value a is and what new data
to is so new value a is just a function f of the old value a so in
order to make this more visual I in my head I do this maybe for tutorial
purposes let me write this out this is what I want to do I want to
transform data alien today to be using this function f so I need to
replace a by B exactly at each place that I have a here I replace
it by B and replacing by B means I apply F to that value here so then
all I need to do is I need to case match and whenever I get a value
of a I apply F to it here I have another value of a control shifty
that's it I apply F to it everything else I don't touch so I don't
change these integers this string I don't change the order of anything
I just replace a by B by using the final through using the function
f and change nothing else so this one goes to this one so that's this
line this a goes to this B that's this line integer string goes to
integer string that's this line and this n goes to has B that's that
line so that's all I'm doing and of course the laws will hold them
the third example is a bit more involved in this example I notice
first of all this the structure of the data and must be that first
it's a disjunction of two parts and the parts are quite similar so
each part has this structure that I have string to integer to a here
I have boolean to double to a other than the other and end times a
so that's always a tuple with a except for these types boolean and
double is exactly the same structure so I'm going to parameterize
boolean and so on by X Y and I'm going to define a structure this
and that's going to be data too so it's going to be a case class with
two parts so that or tuple with two parts and I'm going to do X and
y setting them to string int here and the boolean double here so then
I define not a case class but a type I don't have to do it against
plus if I can I already have either as a case class and so that's
actually a little less writing than what I was doing the previous
example where I could also use either or or tuple here but I chose
to do here I chose a tuple then I chose this data to and explicitly
had two cases but I could have used either and tuples and just draw
write all of this as one expression with either in tuples I could
have done that just a little less writing perhaps and certain points
could be more writing so this is not clear how best to arrange this
you have a choice and so let me try it try it this way of course all
these tights are going to be equivalent they're going to be isomorphic
and no matter what I do I can put them inside a case class or not
it's just going to be more wrapping if I put them more into case classes
so let me try without the case class and this level but I do have
a case class for this repeating structure that I found maybe that's
also in Scala that's easier to read because you can have documentation
so to speak as the name of your data type names of your elements they
could tell in the program or what they mean so that it's clear clear
what needs to do what in this case for this example I'm just using
very short names like the data of type anywhere gene just a function
whatever kind so I define the data like this just in either of two
double of two data two structures and that's precisely mirrors what
I have here so that's Scala syntax for the same I also need to define
the function that compares values of this type that is necessary because
as you remember functions cannot be compared directly in Scala and
we will have to compare things in this test if we want to verify laws
so they'll need to compare values of this type for example if something
is an identity function data to going to data two and I want to verify
that and I need to compare the data to the head before applying that
function and after and so that's why I need to have a method of comparing
two values of data of type data a so that is implemented in the same
way using case matches and certain parts should be equal to certain
other parts and if not then I have this special method called fail
that will throw an exception so you can look on that code so here's
how I would implement F map so data of type a is in either so first
of all I match on that and I get two cases left and right now if I'm
in the left case it means I have a data tool of this type string and
be and so like string it into a so I compute a new string and be out
of that and I return the left of that and if I'm in the right and
I compute the new data tool and and return that so now the only non-trivial
part is what to do with this higher order function x2 y2 a so I need
to transform X to Y of a into X to Y to be so how do I do that well
I do that here in line but I could have done it as another Val if
I wanted to all right for example Yugi I could have done that let
me see if that would be perhaps more instructive so what is the type
of new G I need to specify the type otherwise be arrived in Scala
so I need a function from string to int to be so how can I make this
function I have a function G which is of type string katha into a
and I have a function f from A to B so how do I put this new be here
well new G is a function so let me return the function so it takes
X returns a function that takes Y and then I need to produce a B so
how they produce a B and I have an x and y I can put those x and y
into G just drink them into a which will be this so that's the value
of type A when I apply F to it I get a B and that's what I returned
so in this way I can implement the F map for my type so notice this
kind of trick with putting first taking arguments out and then putting
them back in that is necessary whenever you have a type of the sort
which produces a value of your interesting type using some other values
you have to do this kind of code but this code is actually this code
could be generated automatically if I wanted if I wanted to be clever
here and use my curry Howard library I could have done like this and
I need to specify what values I'm allowed to use so I'm allowed to
use FMG so let me do an import so that I have this off type I will
just import everything right so now of type works so I need to say
auf type is a an interface to a lecture a Harvard library that automatically
generates expressions of a given type using other expressions that
are already available so it will find that code basically this code
will be generated automatically there is no other way of generating
this let me let me run this test and I'll see if that actually works
but I expect this to work because there's no other way so this combination
X to Y T or F of G X Y is the only combination that has the right
type and so you'll be able to derive this automatically but of course
it's important to understand how to write this code by hand as well
only then you can correctly use automatic tools but warning is expected
but the strip ass warnings are fine Oh actually it's compiling the
first tests still right they will take a long time it's not compiling
this test the very Harvard library is used in the first one several
times and it's slow it goes through different combinations to find
this expression all right looks like we're compiled and once we compile
you're pretty much guaranteed to work excellent so we have just checked
all these laws work the second series of examples is to decide whether
these are functors or country factors and then it can implement either
F map or contra F map as appropriate the first example is this type
so now if you look at this type here is on the left of the arrow so
that looks like it's consuming an A so it looks like we're having
a contra hunter here certainly not a functor now here are we consuming
an A or are we producing an A now the syntax might be a little confusing
until you get used to it but all these things are to the left of the
arrow so these are the syntax is like this by convention the arrow
associates to the right and so this consumes an A and produces a function
that again consumes an A and produces a strain so this function actually
consumes two different values of a let's type a and so all this consumes
a this also consumes two different values of type in and so we have
a hope of getting a country founder here it's certainly not effective
let's try the country hunter so here I'm going to do some easier that
go the easier route a room but I won't defend I won't define any case
classes I'll just use standard library so I have a single disjunction
and I'll just use either and then I'll just write down these types
more or less like in this formula I also define the data equal function
otherwise these tests won't run because data contains functions so
whenever that is so I need to define it for these tests a function
that will compare for equality so then I define contra F nap so how
do I do that it's a very similar trick as well we did before we just
need to replace arguments here in functions by our own arguments and
that will be it so here's contra F map we have an either our data
type isn't either so in your case match first of all the left is a
function from a to int so now we we need to produce let me just write
down again for convenience what we want to produce is this so we want
to produce a database so if we are in the left and we should produce
this and if we're in the right and we should produce this so if you're
in the left then we produce left of a function that takes some value
let's actually it's a what's always because that's the type it's more
and more clear it's a function that takes B and returns an integer
so we'll take a beat now we need to return an integer so how do we
return you into we can do F of B and we get an A and then we apply
this function a to an integer to that a and we get an integer so that's
how we can do this very similarly we doing the right so there is an
A and a in string now this B actually is the first eight let's called
a one and this let's call it a two just to be more clear so a 1 and
a 2 or 20 what's sorry let's call them so they're of type B so we
are supposed to produce a function from B to B to strength so we produce
the function tends be one takes B 2 and then we produce a string so
we get this applied to an A and again applied to an A so that's all
we do here so f of B 1 is in a f of B 2 is again here not an interesting
question is what order should this be should this be B 2 B 1 or B
1 B 2 well let's see so this we just drink tests actually we didn't
run this test but it's from this test and I think the test would fail
if we do it the wrong way so let me run this test first and then make
a change and then run the test again and the reason is that we shouldn't
interchange the order of arguments salafi give these two arguments
we should not interchange them that would probably violate the identity
law if we did interchanged some of you do the bad thing and run the
test again so as a rule of thumb when we when we build an F map cone
for some data type you just change every instance of a tree instance
of B or vice versa we don't change any order of anything we don't
yeah it fails so there's some value our delta T law yes then did you
all failed to hold so damaged yeah so as a rule of thumb never changes
order anything never interchange things that would violate the laws
the type of deep grip but that would violate the laws and so since
here we're implementing the contra hunter it could be a bit difficult
to decide whether it should be V 2 V 1 or V 1 V 2 what is the order
of these arguments really just run the tests and make your laws testable
and you are sure there's not much choice here they're these choices
when you have different values at the same time of same type or different
arguments of the same type then you might find a stake interchange
them the laws would tell you that this is not so this is not bad and
the Contra composition law remember that was composed of F with G
lifted is equal to a composed of G E and an F so that's contra composition
a second example is this type so it has two parameters a and B so
which should we use as a type Trevor now it's important to realize
that we are free to use either of these two typewriters a functor
is a type constructor with a type triangle but if we have a type constructor
it has many type parameters we need to choose one and say that this
type constructor is a functor with respect to that type parameter
and our F map will modify that type parameter only and not others
and so in this example it shows we can choose for example a you our
typewriter and B is just a fixed type I'm going to f map is not going
to change that let's examine this type so there is this there is this
arrow here and this arrow okay so it looks like a is behind them error
so does it look like a is actually contravariant but wait here's another
here so this entire thing is to the left of an error so this is the
entire thing is consumed so we consume something that consumes a so
that actually makes a covariant again as we will see if you consume
something that consumes a then you can implement F map with respective
a and not the Contra map so it looks like you're not this is a strange
container if it doesn't actually have values of type a but instead
it consumes something that consumes a value of type a but that is
actually so in other words you don't have a value of type a that is
true and not all containers have actual values of type a inside but
one example that would be the future container future is a functor
but it doesn't actually have a value inside not yet in any case it
might have it in the future or might not at all so that's an example
of a container that is a fun turn with respect to a but it does this
funny thing of it consumes a function of consumes a oh so be is in
a covariant position here we have a B inside of this Junction and
here we produce a B so we know that when we produce a B that's covariant
and when so again we could be a type parameter and choose to have
a functor instance or a functor instance is the same as to say we
have an implementation of f map so in this code I will actually define
both F map with respect to a and f map with respect to B so let me
start with B it's a little easier so in order to have an F map with
respect to B I'm going to put the first trailer rename it to Z so
let's rename that to Z then F map will have to be paralyzed by Z and
B and C and we'll map B to C and the result will be mapping from data
ZB into the data ZC so that's I chose the letter Z far from B and
C so that it's clear that Z is not changing B is changing to see after
F map alright so how do we do that so we again need to think so this
is this case class there is no disjunction at the top there is a disjunction
inside so we need to get the data data dot a B will be matched the
result will be that we need to return a new value of type data with
which means we need to produce some new a B and some new D right so
data has a B and it has a D you need to produce new Indian new D so
I structured the code like this to be more clear about that and now
we need to produce a new a B of this type and gnudi of this type so
how do we do that so new a B is just an either of Z C so we just need
to map over the easy either somehow so that's easy to do if we're
on the Left we don't matter because it's an a so that's this or Z
so that's not mapped not changed and the B value is mapped with F
so it's changed it remains to do this so that's the trick we just
saw this is not changing and we have a D which is dated of D which
is of type 0 integer to be so we put an argument out which is 0 integer
and for the apply this D 2 that the result is the value of B apply
F to that value and get the value of C so then we get a function from
G to that see and that's what you probably need this function so like
before this part of code is probably unique it can be generated automatically
so I try to I haven't tried to actually generate all this automatically
with Kurihara stuff you could try to see maybe maybe in this case
there are no ambiguities and you couldn't just generate all this code
automatically in which case we'll just say def F map of all this equals
implement you can just say that yes let's run this list to see if
that is so and I will explain the rest now the F map here is with
respect to a so a is changing so I rename that into X just so that
it's clear we are going to map data xB into data Y B so B is the type
trailer that rent remains constant and we're mapping X to Y through
the function X all right there's some problem ok doesn't work it might
be a bug or there might be some other problems correct Harvard library
is working progress so it works in many cases but not in all cases
I'll make a note of this it's a good idea to have some words and tests
or bug fixes so to implement F map we do a very similar thing we match
on data so sorry we return the data with new a B mu D but now the
types of new a B are different so this is going to be either of Y
B and this is going to be this so the either is dealt with in the
same way as before matching over and pulling B so B is unchanged and
a any value is actually enough type X now so we could bring in this
for clarity into x value there could you name this this is of time
the path type Y so can you move this into my ability oh no this is
a big spoke to you sir now what they do what do we do with this how
do we map x2 ends to be into y2 entity so this is the non trivial
part where we have something data dot d is x2 end to be which consumes
a function that consumes X and we need to produce a function that
consume as a function that produces light how do we do that well we
just write the code directed by type so this is a function so G is
type white urgent data dot d has the type of x2 ends to be so we need
to use data dot d on a function that takes X and produces int so how
do we produce int well the only way to produce an int is to get G
acting on some Y so G of something so that something must be some
Y the only way to get a Y is to apply F to X so this code could be
generated automatically even if that whole thing didn't work I'm pretty
sure this would have worked if I just say off type here I put G and
F and data table D data gene has flat major so I need F G actually
F and data no G myself of type and I copy this type expression over
here and I want to run this test so in any case the tests should pass
with or without this change and this shows how the types that consume
something that consumes a are actually go variant in a their functors
in a it's the same same thing let's see what failed alright so that's
also didn't work so let me undo that drama test again goodish Oregon
compiles the first one the first test that here's a great covered
land anymore very card library is slowing long examples all right
right now we're alright so these are probably bugs or something that
I could fix in the creek or we'd like it but the important thing is
for us to understand how to do this by him and that's what this tutorial
is about the last worked example right now is to to do this you have
a a bunch of scholar can use classes with seal trait you need to identify
which types are used covalently and conveniently and verify that with
covariance annotations yes how we do this so here's the seal trait
so I put already the covariance annotations now the first thing I
would do is to write this in a short notation because this is a lot
of text with names and all that in the short notation so what do I
have the first class as a case class has B and C so that's a times
B is this and then B to hint the second one is a B and int so that's
this product the third one the she is the string to a and B to a so
product of these two and now I just look at this and figure out what
types it has and whether these types are used covariant and contravariant
so I find that a is only used in covariant positions so here I have
an a here I have an a here I produce an A here I produced any so those
are covariant positions to the right of the arrow or define the final
arrow or without a mirror now the B is used here in a covariant position
here in a contravariant position here covariant here contravariant
so that's hopeless so B cannot be B is neither covariant nor contravariant
now there are other types like int so int is used here in the covariant
position here in a covariant position so int would be covariant so
if I wanted to parameterize this by the type over int it would be
a covariant or a functor with respect to that parameter and the string
here is used contravariant lee only in one place so that's that would
be a candidate for contra factor if I needed to parameterize by that
type that would be a Concha factor so let me do that so I changed
integer to I and string to s and then I put minus on s plus an i plus
on a and B is not not too marked because it's neither covariant nor
contravariant and now here's what would happen if I put a plus here
instead of - so let me compile this and run this test if I if I do
that the compiler will tell me that this mirror so it will know that
this s is used here in a contravariant position i intellij doesn't
show me the red and for that but here's the error message' Kovarian
type s occurs on contravariant position and type este or bound effects
so that's the air and that concludes our worked examples for this
part and now there are some exercises of the same kind for you so
after you have done these exercises you have an understanding of how
to work with functor types and we have been checking we have been
checking laws of function by hand every time by writing tests now
this is not very satisfactory because a main question still remains
here is it true that any data type where a is well a type parameter
in covariant position is it true that the data type is a function
with respect to a I could write any kind of stuff like this and it
would take time and effort to check the laws each time I have a type
like this but just visually I see that here a is consumed but the
whole thing is consumed so this is covariant usage of a here is covariant
here's covariant and here's covariant so the entire type is a functor
with respective a that seems obvious I could write an F map function
very easily by just mapping each of these A's to be a to be a to be
this I map to the same integer a to be they sent map to the same integer
this R I'm after the same R I know how to do this we just had examples
of all kinds of different types of this kind types of the sort that
we can implement as factors but do the laws hold and do we need to
write tests every time for this kind of thing in fact so the way we
answer this question is to to realize that these data types are built
from parts they're built like from a Lego set and what are the parts
so these are the constant types like integer or unit you know type
parameters and then there are operations that for example take two
parts and put a plus between them when you get a new type and or you
use the arrow or we use the product so basically these are type expressions
that are produced out of constant types type parameters and these
operations or you can have also other operations like composition
of function like you take one factor and apply it to another like
we did with our examples we took an either and under the either we
had some data types that we defined and so on so that's a composition
of functions or type constructors and we have noticed that every time
that some type is moved to the left of an arrow its covariance is
reversed so this would be contravariant in a and this is again covariant
in a and so this that does this intuition always work or are there
some cases when this is wrong that this is not the right right functor
or the laws don't hold and also note that if we don't use the function
error then everything is going to be always covariant so if we have
a function error then we have to trace which one is covariant but
if there is no error if if a.type was made without using the area
operational types then all positions are covariant and so these are
these are types that are called before polynomial types or polynomial
type constructors and if this intuition is correct and they're always
functors so all polynomial type constructors are functors and to answer
this question we are going to build F map incrementally as we build
up the type expression out of these parts and operations and at every
step when we take for example two parts and put them together we define
what the F map is for the new type constructor and we check the law
left hold the dead step and once we go through all possible steps
which are only for as far as I can see here then we're done we will
prove we have we will have proved by induction that any type constructed
from these operations will be a factor so let's see how that works
so the building blocks for functors are constant factors and identity
factor so what does that mean the constant factor is a type constructor
that takes a type parameter a and always returns the quantity so for
example int I can be considered as a functor that is parameterize
by some a and always has a type int not a very interesting factor
of course but nevertheless a valid function if you take F map which
is always equal to identity so the value of type C is never changed
and interestingly enough this is a contra factor at the same time
with contrib also equal to identity and all the laws hold trivially
because it's always identity so all the compositions are always identities
that's not much to check the identity function is the factor that
takes a type parameter and always returns that side type right now
notice how I started to use terminology let the type the functor takes
a type and returns at like as if factor is a function on types so
that's indeed the case so you can consider factors or type constructors
as functions of types functions that take types and return other types
so that's in Scala it is noted it is very clear that this this is
the case because we use square brackets to denote type application
so this is very similar in exactly almost like having a function f
that is applied to a type which is a function G applied to type a
now is type level function the function that takes types and returns
types so these are type constructors so it is a good way of thinking
about type constructors just functions in the type space so the F
map for the identity function takes the F and returns the same F so
it means that if you want to transform a to B and you just apply the
same F to a and you get to be the the walls hold in a very easy way
obviously if F is identity then this has identity and composition
is composition because we haven't changed anything so f is unchanged
now the operations of creating new factors are the previous ones is
what we're going to be concerned with next so imagine we have some
functors F and G and we already have the F map implementations for
them and we already checked the laws so f and G are functions and
we already check that and now we need to build a functor such as this
one so we need to build a new F map and we need to show that the laws
hold for it and then we will we need to show there further that this
type constructor is a functor and we need we do the same for these
for this for this and also well we can see how that works because
we already have experience in examples implementing F map for various
constructions like this for example this is just built by pattern
matching we preserve the left side to the left and the right side
to the right and here we to pull the two results and again preserve
the order and here we substitute the function argument into F map
remember that trick we have G goes to f of X of whatever G so that's
the kind of trick we need to do here an interesting thing in this
case is that for this construction to work F must be a contractor
and G must be a functor so then the contractor F will be in the contravariant
position and the result of this will be covariant in a in every place
now this wanna do composition of factors when you compose the to F
Maps we just do F map here and you do F map of that and the final
case it's interesting this type recursion so type recursion means
that you define a type F using a recursive equation so you have some
R which is a functor and both a and X must be a factor and then you
write this equation so remember what we had as an example of recursive
polynomial type so we wrote this equation so actually this equation
can be written as L PA equals some function applied to LP a and a
because this is a type construction of the same kind as we are considering
as we are considering here so this can be just paralyzed like this
and then this is a recursive equation because we're using FA inside
here to define itself and we can then define F map for this just like
we did before in that example and the F map function will be recursive
and we'll use the F maps of this factor so that is all the operations
that we need so for contra functors with appropriate changes we will
have exactly the same instructions except that here this should be
a functor that should be a contra function then the result is a contra
functor so what remains is to check that in each case the filter laws
still hold after each operation so let me check this for a few cases
and I will leave other cases as exercises the first case is the disjunction
of two factors so how does that work let me actually go and show you
the code for this disjunction before we look at the short notation
so in this code what I'm doing is I define two factors in some random
way for example F 1 is just to prove a and integer and F 2 is an either
of integer to a and a so see this is a is covariant and covariant
here so I define these two factors I have defined some helper functions
to help me check laws and and so on but just ignore it where these
F map classes that I defined in the tests this is not essential and
essential is that we define the F map of the right type and here I
use implement because it just works and I need to define an equal
function for F 2 so but suppose I'm given F 1 and F 2 so how do i
define a disjunction well first of all I need to define the data type
data okay but again I call this data just to be consistent with all
other examples this is just a name this type so this is an either
of F 1 away and F 2 away so you see in this case we just use it either
and we don't need an extra case class strapless in and I define the
f map so how do i define it I use the two f maps from the previous
factors so these are the classes that I define they have this dot
code method that represents the code of the F map and this is necessary
for type reasons but not necessarily the best way of doing the functor
constructions one will be sufficient for now so I define how do i
define this F map well the data is a disjunction of functor f1 and
frontier f2 so I need to match on this disjunction so I match when
I'm on the Left then I also return the left I'm supposed to return
so I need to return a left part for the left and the right part for
the right so this is the code that needs to be written for that purpose
note that this quote does not use any details about what these functors
are it just uses the F map for them so I have the F map 1 and F map
2 for the factors F 1 F 2 and I just call these F maps on the data
that I have so that's what works when I check the laws of identity
and composition but can I understand why these laws hold they do hold
the tests pass but I want to have understanding and assurance that
this is really correct for all factors not just for particular factors
I have chosen and this is what I would do I would reason about the
code more generally and I would use the short notation for the code
to make it easier so it assumed that F n GA are type constructors
for which we already have the F map with map F and F G and we already
know that the laws hold for them now we define the F map for the factor
F plus G or it would be function f plus G you find it like this so
the data is a disjunction of P and Q and P is of type FA and Q is
of type GA so this is our either from the code and this is the argument
of this function and the result is a disjunction of left and right
corresponding to P and Q so exactly what the code was doing I just
wrote this in the show notation in short notation P is here and so
if P is given that we return this plus zero and if Q is given them
will return zero plus that so that Chris points in the code to returning
left or returning right and that's just a short notation that I'll
use the reason about these laws let us check the laws we have defined
the function f map F plus G let's check that the laws hold for it
now first law is identity law if F is identity then f map F plus G
or identity must be identity and we assume that the law holds also
for already holds for F and G at maps so this is a quick check then
P plus Q is an arbitrary value of type F plus G and then by the formula
we need to apply F map of F to the P which is identity and we need
to apply F map of G to the F map G of F to the Q which is again and
that is again identity so we just have P plus Q so we get we take
P plus Q will return v plus Q and that's obviously identity so identity
law holds for F map F plus G the composition law is a little longer
to check but note as we noted in the code we don't actually use the
structure of the factors F and G we just use the fact that they're
functors and that F maps for them work correctly so the composition
of these two F maps let's decompose first we need to first apply F
1 and then F 2 so when we apply F 1 and we have this this is a definition
of our F map F plus G and then we apply that and then gives us the
two compositions in the left hand and the right and then we can simplify
that you the law for F into this using the law of G into that and
that's exactly the same as if we have applied our F map F plus G to
the composition of functions F 1 and F 2 so I suggest you go through
this computation yourself and check that for any P and Q that you
give here for any or rather not for any pienty for any value of P
plus Q because there's only P or there's only Q in that disjunction
so for any P plus Q you always return exactly this so the law holds
and the law holds precisely because this may f map f what G was defined
to work it was defined here to work separately on P and Q and to return
corresponding parts of the disjunction if we mixed up some house and
some of these parts oil for instance or given P but we return the
right part of the disjunction sometimes that law would not hold at
the law obviously here it depends on having the two parts completely
separate so that concludes the proof that this construction gives
you a factor if the fmg are factors the next example is to show that
if f is a contra function G is a function then the function from G
to F is itself a factor so let me go to the code which I have for
this so I have a some contra factor very simple one and it's F map
is so simple that it can be automatically implemented our defining
quality for it as necessary for the test and then I define this data
as a type I don't want to have an extra case class for extra complexity
and this is just defined like that so exactly the same as the formula
for the type can i define f map so how do i define f map all this
seems to be a lot of code but actually this is just a definition of
types for clarity i have an argument f of this type argument da which
is data in an argument CF 1 B which is a part of data be so data B
is C F 1 of B going to F 2 of B so it's a function that takes CF one
of these an argument so I have to return that function so that's how
I'm returning it and the result must be F 2 of 8 so all this must
be F - ok so how do I make this work I use the sorry F 2 of be nice
to UM be the only way to get of 2 of B is to apply something to have
two away because I cannot just construct f2 of be here from nothing
from scratch no idea what this function is would be so I need to use
the data I'm given so I'm given this FD a and C F 1 B so what's my
plan well first I'm going to map CF on B into CF 1 a and that's a
contra functor map contract map because I have a 2 B so I can map
for the control factor C F 1 B to save one hey so then I have this
I put that into da I get F 2 of a and then I EV map with F F to a
goes to F to B of two of me so that's the whole thing I put the contra
map first contra factor 1 into here apply this to CF I get a CF 1a
I put that as an argument into da I get a tf2a and then I use F map
2 which is 4 F 2 again with the same F on the result and the laws
hold why do they hold let's prove them they hold in general in the
tests we only have specific contracts on certain specific function
and specific types you know we cannot just run tests for generic functor
so let's prove mathematically that this is true it's a very similar
proof to the previous one the details are been different so here will
help if we have some shorter notations definitions so instead of f
map G of F I would just write gamma F instead of contra map F of F
I would read 5x5 so Phi for F and gamma for G and just replacing Latin
letters with Greek ones so this is the code that we had in our skull
example written in this notation the XQ first uses the contra map
of F on Q puts that into P which is this and then uses the map gamma
gamma F on that P so then we check the identity law we just substitute
these expressions so we take an arbitrary P of this type which is
now our new functor to be and then we use we just substitute we get
Q goes to P of Q because gamma is identity Phi is identity so it's
kill going to P of Q right here now Q going to P of Q is the same
as P because this is a function that takes argument and applies P
to that same argument that's the same as what P would do by itself
so this expression is exactly the same as this expression in its effect
so that concludes the proof of the identity law we showed that F map
of identity applied to some P gives you exactly the same P a composition
law is checked like this so we assume that the composition law already
holds for a fine gamma and here we see opposite order of composition
for Phi because it's a control factor so then we apply the definition
and we get first we apply F map F G or F 1 so first we apply this
and that's this gamma F 1 P Phi Q now we'll put that in there apply
again and we have a curious thing that we have gummys together and
Phi's together when you do this computation because here instead of
P you have to put in that definition this Q goes to this so when you
do that the gamma is next to the gamma and the Phi is next to the
phone so now those are compositions of gammas so we can use the composition
law that already holds for gamma and replace this by this and also
for fine note the order so from gamma is this order finds the reversal
and this is therefore exactly the same as what we would have if we
apply this new F map to the composition of functions F 1 and F 2 so
then we have proved the composition law note that the order of the
compositions must be reversed for fine otherwise this thing just won't
work so if I did not have this reversed order here in this position
the proof would not go through so this won't work if F is a factor
F must be a country from K which is what we expected from intuition
without from our intuition whatever is on the left has reversed its
covariance and so if this is a contractor if this were a functor then
being on the left makes this whole thing a contra variant in a and
that's wrong through the function so this is our intuition the intuition
is correct as we have just shown control function behind the error
or to the left of the arrow it becomes covariant and vice-versa here
are some exercises for you to check that this works and to check that
this works for contra functor G and functor F so this is quite similar
but the opposite order and also to show that this is neither a function
or contra function when they're both functors are both country factors
so that's much easier because you just give an example and show that
the types don't match so to conclude this tutorial I would make a
note that this kind of code is certainly not the best way of dealing
with funder constructions so if you want in your code to construct
new factors like this I would suggest taking a look at the libraries
that do this there are two main libraries scholars II and cats so
these libraries include functionality functionality that is quite
similar to what we're doing here they can deal with functors generally
so the the power of functional programming languages such as Scala
and Haskell is that you can write code that takes an arbitrary function
and transforms it in some way so you can not only as we have done
we parameterize code by types but you can also parameterize code by
a type constructor so you can have a function which I did not show
here because it's quite advanced stuff but you can have a function
that is permit rised by these things so it would work for any F 1
and F 2 with certain properties and that's the power of these type
systems which is not present in most programming languages so in Scala
this is a little difficult to write and quite abstract so if you if
you try to write it from scratch so these libraries help and they
can define functors and help you write code with functors so for instance
if you wanted to have code that does something for any factor then
I would suggest you try it yourself but it would be a bit hard explore
these libraries also there there is a library called shapeless which
has some utilities for automatic construction of functors so you see
as you have noticed these operations are quite mechanical so there
is no choice here and all this can be done automatically by by some
preprocessor or or the compiler of Scala so there are libraries that
allow you to write code to automatically implement F map for your
own types with no code that you have to write almost no quality you
have to write because all these operations are dictated by the mathematical
properties of functor there's no choice the curry Howard library can
help in certain cases but it doesn't know that you are constructing
a functor instance it does not check the Loess so if that is if that
is your purpose you should try to explore these libraries that allow
you to automatically construct a functor implementation for your types
and any types of this kind I think should be supported if not make
a PR for them well this concludes the tutorial 
\end{comment}

