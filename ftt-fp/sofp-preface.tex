
\chapter*{Preface}

\addcontentsline{toc}{chapter}{Preface}

The goal of this book is to teach programmers how to reason mathematically
about types and code, in a way that is directly relevant to software
practice.

The material is presented here at medium to advanced level. It requires
a certain amount of mathematical experience and is not suitable for
people unfamiliar with school-level algebra, or for people who are
unwilling to learn new and difficult concepts through prolonged mental
concentration and effort.

The first two chapters are introductory and may be suitable for beginners
in programming. Starting from the middle of Chapter~\ref{chap:3-3-The-formal-logic-curry-howard},
the material becomes unsuitable for beginners. 

The presentation in this book is self-contained. I define and explain
all the required notations, concepts, and Scala language features.
The emphasis is on clarity and understandability of all examples,
mathematical notions, derivations, and code. I use some \emph{non-standard}
notations (Appendix~\ref{chap:Appendix-Notations}) and terminology
(Appendix~\ref{chap:Appendix-Glossary-of-terms}) to achieve a clearer
presentation of the material, especially for readers not familiar
with today's research literature in the theory of programming languages.

The main intent of this book is to explain the mathematical principles
that guide the practice of functional programming \textendash{} that
is, help people to write code. Therefore, all mathematical developments
in this book are motivated and justified by practical programming
issues, and are accompanied by code examples that illustrate their
usage. For example, the equational laws for standard typeclasses (functor,
applicative, monad, etc.) are first motivated heuristically before
deriving a set of mathematical equations and formulating the laws
in more abstract terms. Each new concept or technique is explained
via solved examples and drilled via provided exercises. Answers to
exercises are not provided, but it is verified that the exercises
are doable and free of errors. More difficult examples and exercises
are marked by an asterisk ({*}).

A software engineer needs to know only a little of mathematical theory
\textendash{} the parts that answer questions arising in the practice
of functional programming. So I keep the theoretical material to the
minimum; \emph{ars longa, vita brevis est}. I do not pursue mathematical
generalizations beyond practical relevance or immediate pedagogical
usefulness. This limits the scope of required mathematical knowledge
to bare rudiments of category theory, type theory, and formal logic.
For instance, I do not use ``introduction/elimination rules'', ``strong
normalization'', ``complete partial order domains'', ``adjoint
functors'', ``limits'', ``co-limits'', ``pullbacks'', ``pushouts'',
``topoi'', or even the word ``algebra'', because learning these
concepts will not help a functional programmer write code. Instead,
I focus on practically useful material \textendash{} including some
rarely mentioned constructions, e.g.~the ``filterable functor''
and ``applicative contrafunctor'' typeclasses.

Some formatting conventions used in this book:
\begin{itemize}
\item Text in boldface indicates a new concept or term that is being defined.
Text in italics is a logical emphasis. Example:
\end{itemize}
\begin{quotation}
An \textbf{aggregation\index{aggregation}} is a function from a list
of values to a \emph{single} value.
\end{quotation}
\begin{itemize}
\item Sample Scala code is written inline using a small monospaced font,
such as this: \lstinline!val a = "xyz"!. Longer code examples are
written in separate code blocks, which may also show the output from
the Scala interpreter:
\end{itemize}
\begin{lstlisting}
val s = (1 to 10).toList

scala> s.product
res0: Int = 3628800 
\end{lstlisting}

\begin{itemize}
\item Derivations of laws are written in a two-column notation where the
right column contains the code and the left column indicates the property
or law used to derive the expression at right. A green underline shows
the part of the \emph{previous} expression that we rewrite using the
indicated law. Example: 
\begin{align*}
 & \gunderline{\text{pu}_{M}^{\uparrow\text{Id}}}\bef\text{pu}_{M}\bef\text{ftn}_{M}\\
\text{raising into the identity functor:}\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{left identity law for }M:}\quad & =\text{pu}_{M}\quad.
\end{align*}
A green underline is sometimes also used at the \emph{last} step of
the derivation, to indicate the part of the expression that resulted
from the most recent rewriting.
\end{itemize}

