#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.0pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

\usepackage{CJKutf8} % For occasional Chinese characters. Also, add "russian" to documentclass.
\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.44in
\paperheight 9.68in
\leftmargin 2cm
\topmargin 1.1cm
\rightmargin 1.5cm
\bottommargin 1.75cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Success,Failure,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\start_of_appendix
Notations
\begin_inset CommandInset label
LatexCommand label
name "chap:Appendix-Notations"

\end_inset


\end_layout

\begin_layout Standard
I chose certain notations in this book to be different from the notations
 currently used in the functional programming community.
 The proposed notation seems to be well adapted to reasoning about types
 and code, and especially for designing data types and proving the equational
 laws of typeclasses.
\end_layout

\begin_layout Section
Summary table
\end_layout

\begin_layout Description
\begin_inset Formula $F^{A}$
\end_inset

 type constructor 
\begin_inset Formula $F$
\end_inset

 with type argument 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $x^{:A}$
\end_inset

 value 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\bbnum 1,\,1$
\end_inset

 the unit type and its value; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\bbnum 0$
\end_inset

 the void type; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $A+B$
\end_inset

 a disjunctive type; in Scala, this type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 a value of a disjunctive type 
\begin_inset Formula $A+B$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $A\times B$
\end_inset

 a product (tuple) type; in Scala, this type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $a^{:A}\times b^{:B}$
\end_inset

 value of a tuple type 
\begin_inset Formula $A\times B$
\end_inset

; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $A\Rightarrow B$
\end_inset

 the function type, mapping from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $x^{:A}\Rightarrow f$
\end_inset

 a nameless function (as a value); in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x:A => f }
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\text{id}$
\end_inset

 the identity function
\end_layout

\begin_layout Description
\begin_inset Formula $\triangleq$
\end_inset

 
\begin_inset Quotes eld
\end_inset

equal by definition
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\cong$
\end_inset

 for types, a natural isomorphism between types; for values, 
\begin_inset Quotes eld
\end_inset

equivalent
\begin_inset Quotes erd
\end_inset

 values according to an established isomorphism
\end_layout

\begin_layout Description
\begin_inset Formula $A^{:F^{B}}$
\end_inset

 type annotation, used for defining unfunctors (GADTs)
\end_layout

\begin_layout Description
\begin_inset Formula $\wedge$
\end_inset

 logical conjunction; 
\begin_inset Formula $\alpha\wedge\beta$
\end_inset

 is 
\begin_inset Quotes eld
\end_inset

both 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 are true
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\vee$
\end_inset

 logical disjunction; 
\begin_inset Formula $\alpha\vee\beta$
\end_inset

 is 
\begin_inset Quotes eld
\end_inset

either 
\begin_inset Formula $\alpha$
\end_inset

 or 
\begin_inset Formula $\beta$
\end_inset

 or both are true
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\Rightarrow$
\end_inset

 logical implication; 
\begin_inset Formula $\alpha\Rightarrow\beta$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $\alpha$
\end_inset

 is true then 
\begin_inset Formula $\beta$
\end_inset

 is true
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 the standard method 
\begin_inset Formula $\text{fmap}$
\end_inset

 pertaining to a functor 
\begin_inset Formula $F$
\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $\text{pu}_{F}$
\end_inset

 the standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 of a monad 
\begin_inset Formula $F$
\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $F^{\bullet}$
\end_inset

 the type constructor 
\begin_inset Formula $F$
\end_inset

 understood as a type-level function; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $F^{\bullet}\leadsto G^{\bullet}$
\end_inset

 or 
\begin_inset Formula $F^{A}\leadsto G^{A}$
\end_inset

 a natural transformation between functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $\forall A.P^{A}$
\end_inset

 a universally quantified type expression 
\end_layout

\begin_layout Description
\begin_inset Formula $\exists A.P^{A}$
\end_inset

 an existentially quantified type expression 
\end_layout

\begin_layout Description
\begin_inset Formula $\bef$
\end_inset

 the forward composition of functions: 
\begin_inset Formula $f\bef g$
\end_inset

 is 
\begin_inset Formula $x\Rightarrow g(f(x))$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\circ$
\end_inset

 the backward composition of functions: 
\begin_inset Formula $f\circ g$
\end_inset

 is 
\begin_inset Formula $x\Rightarrow f(g(x))$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\circ$
\end_inset

 the backward composition of type constructors: 
\begin_inset Formula $F\circ G$
\end_inset

 is 
\begin_inset Formula $F^{G^{\bullet}}$
\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $\triangleright$
\end_inset

 use a value as the argument of a function: 
\begin_inset Formula $x\triangleright f$
\end_inset

 is 
\begin_inset Formula $f(x)$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 a function 
\begin_inset Formula $f$
\end_inset

 raised to a functor 
\begin_inset Formula $G$
\end_inset

; same as 
\begin_inset Formula $\text{fmap}_{G}f$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $f^{\uparrow G\uparrow H}$
\end_inset

 a function raised first to 
\begin_inset Formula $G$
\end_inset

 and then to 
\begin_inset Formula $H$
\end_inset

; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h.map(_.map(f))
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $f^{\downarrow H}$
\end_inset

 a function 
\begin_inset Formula $f$
\end_inset

 raised to a contrafunctor 
\end_layout

\begin_layout Description
\begin_inset Formula $\diamond_{M}$
\end_inset

 the Kleisli product operation for the monad 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\oplus$
\end_inset

 the binary operation of a monoid; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x |+| y
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\Delta$
\end_inset

 the 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 function of type 
\begin_inset Formula $\forall A.\,A\Rightarrow A\times A$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\nabla_{1},\nabla_{2},...$
\end_inset

 the projections from a tuple to its first, second, ..., parts
\end_layout

\begin_layout Description
\begin_inset Formula $\boxtimes$
\end_inset

 pair product of functions, 
\begin_inset Formula $(f\boxtimes g)(a\times b)=f(a)\times g(b)$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\left[a,b,c\right]$
\end_inset

 an ordered sequence of values; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(a, b, c)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\begin{array}{||cc|}
\text{id} & \bbnum0\\
\bbnum0 & a\Rightarrow a\times a
\end{array}$
\end_inset

 a function that works with disjunctive types
\end_layout

\begin_layout Section
Detailed explanations
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}$
\end_inset

 means a type constructor 
\begin_inset Formula $F$
\end_inset

 with a type parameter 
\begin_inset Formula $A$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

.
 Type constructors with multiple type parameters are denoted by 
\begin_inset Formula $F^{A,B,C}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{:A}$
\end_inset

 means a value 
\begin_inset Formula $x$
\end_inset

 that has type 
\begin_inset Formula $A$
\end_inset

; this is a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
type annotation
\end_layout

\end_inset

type annotation
\series default
.
 In Scala, a type annotation is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
 The colon symbol, 
\begin_inset Formula $:$
\end_inset

, in the superscript shows that 
\begin_inset Formula $A$
\end_inset

 is not a type argument (as it would be in a type constructor, 
\begin_inset Formula $F^{A}$
\end_inset

).
 The notation 
\begin_inset Formula $x:A$
\end_inset

 can be used as well, but 
\begin_inset Formula $x^{:A}$
\end_inset

 is easier to read when 
\begin_inset Formula $x$
\end_inset

 is inside a larger code expression.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\bbnum1$
\end_inset

 means the unit type
\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type
\end_layout

\end_inset

, and 
\begin_inset Formula $1$
\end_inset

 means the value of the unit type.
 In Scala, the unit type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, and its value is denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 Example of using the unit type is 
\begin_inset Formula $\bbnum1+A$
\end_inset

, which in Scala corresponds to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\bbnum0$
\end_inset

 means the void
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 type (the type with no values).
 In Scala, this is the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 Example of using the void type is to denote the empty part of a disjunction.
 For example, in the disjunction 
\begin_inset Formula $\bbnum1+A$
\end_inset

 the non-empty part is 
\begin_inset Formula $\bbnum0+A$
\end_inset

, which in Scala corresponds to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A]
\end_layout

\end_inset

.
 The empty part 
\begin_inset Formula $\bbnum1+\bbnum0$
\end_inset

 corresponds to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 Similarly, 
\begin_inset Formula $A+\bbnum0$
\end_inset

 denotes the left part of the type 
\begin_inset Formula $A+B$
\end_inset

 (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A]
\end_layout

\end_inset

), while 
\begin_inset Formula $\bbnum0+B$
\end_inset

 denotes its right part (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right[A]
\end_layout

\end_inset

).
 Values of disjunctive types are denoted similarly.
 For instance, 
\begin_inset Formula $x^{:A}+\bbnum0^{:B}$
\end_inset

 denotes a value of the left part of the type 
\begin_inset Formula $A+B$
\end_inset

; in Scala, this value is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A,B](x)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $A+B$
\end_inset

 means the disjunctive type made from types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 (or, a disjunction of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

).
 In Scala, this is the type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{:A}+\bbnum0^{:B}$
\end_inset

 denotes a value of a disjunctive type 
\begin_inset Formula $A+B$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 is the value of type 
\begin_inset Formula $A$
\end_inset

, which is the chosen case, and 
\begin_inset Formula $\bbnum0$
\end_inset

 stands for other possible cases.
 For example, 
\begin_inset Formula $x^{:A}+\bbnum0^{B}$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A,B](x)
\end_layout

\end_inset

 in Scala.
 Type annotations 
\begin_inset Formula $^{:A}$
\end_inset

 and 
\begin_inset Formula $^{:B}$
\end_inset

 may be omitted if the types are unambiguous from the context.
\end_layout

\begin_layout Standard
\begin_inset Formula $A\times B$
\end_inset

 means the product type made from types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 In Scala, this is the tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $a^{:A}\times b^{:B}$
\end_inset

 means a value of a tuple type 
\begin_inset Formula $A\times B$
\end_inset

; in Scala, this is the tuple value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

.
 Type annotations 
\begin_inset Formula $^{:A}$
\end_inset

 and 
\begin_inset Formula $^{:B}$
\end_inset

 may be omitted if the types are unambiguous from the context.
\end_layout

\begin_layout Standard
\begin_inset Formula $A\Rightarrow B$
\end_inset

 means a function type from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

.
 In Scala, this is the function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{:A}\Rightarrow y$
\end_inset

 means a nameless function with argument 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $A$
\end_inset

 and function body 
\begin_inset Formula $y$
\end_inset

.
 (Usually, the body 
\begin_inset Formula $y$
\end_inset

 will be an expression that uses 
\begin_inset Formula $x$
\end_inset

.) Type annotation 
\begin_inset Formula $^{:A}$
\end_inset

 may be omitted if the type is unambiguous from the context.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{id}$
\end_inset

 means the identity function.
 The type of its argument should be either specified as 
\begin_inset Formula $\text{id}^{A}$
\end_inset

 or 
\begin_inset Formula $\text{id}^{:A\Rightarrow A}$
\end_inset

, or else should be unambiguous from the context.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\triangleq$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

equal by definition
\begin_inset Quotes erd
\end_inset

.
 Examples:
\end_layout

\begin_layout Itemize
\begin_inset Formula $f\triangleq(x^{:\text{Int}}\Rightarrow x+10)$
\end_inset

 is a definition of a function 
\begin_inset Formula $f$
\end_inset

.
 In Scala, this is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val f = { x: Int => x + 10 }
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $F^{A}\triangleq\bbnum1+A$
\end_inset

 is a definition of a type constructor 
\begin_inset Formula $F$
\end_inset

.
 In Scala, this is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[A] = Option[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\cong$
\end_inset

 for types means a natural isomorphism between types.
 For example, 
\begin_inset Formula $A+A\times B\cong A\times\left(\bbnum1+B\right)$
\end_inset

.
 The same symbol 
\begin_inset Formula $\cong$
\end_inset

 for 
\emph on
values
\emph default
 means 
\begin_inset Quotes eld
\end_inset

equivalent
\begin_inset Quotes erd
\end_inset

 according to an equivalence relation that needs to be established in the
 text.
 For example, if we have established the equivalence that allows nested
 tuples to be reordered whenever needed, we can write 
\begin_inset Formula $\left(a\times b\right)\times c\cong a\times\left(b\times c\right)$
\end_inset

, meaning that these values are mapped to each other by the established
 isomorphism.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $A^{:F^{B}}$
\end_inset

 in type expressions means that the type constructor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 assigns the type 
\begin_inset Formula $F^{B}$
\end_inset

 to the type expression 
\begin_inset Formula $A$
\end_inset

.
 This notation is used for defining unfunctors (GADTs).
 For example, the Scala code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

case class F1() extends F[Int]
\end_layout

\begin_layout Plain Layout

case class F2[A](a: A) extends F[(A, String)]
\end_layout

\end_inset

defines an unfunctor
\begin_inset Index idx
status open

\begin_layout Plain Layout
unfunctor
\end_layout

\end_inset

, which I denote as 
\begin_inset Formula $F^{A}\triangleq\bbnum1^{:F^{\text{Int}}}+A^{:F^{A\times\text{String}}}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 means the standard method 
\begin_inset Formula $\text{fmap}$
\end_inset

 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 typeclass, implemented for the functor 
\begin_inset Formula $F$
\end_inset

.
 In Scala, this may be written as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor[F].fmap
\end_layout

\end_inset


\family default
.
 Since each functor 
\begin_inset Formula $F$
\end_inset

 has its own specific implementation of 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

, the subscript 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

 is not a type parameter of 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

.
 The method 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 actually has 
\emph on
two
\emph default
 type parameters, which can be written out as 
\begin_inset Formula $\text{fmap}_{F}^{A,B}$
\end_inset

.
 Then the type signature of 
\begin_inset Formula $\text{fmap}$
\end_inset

 is written in full as 
\begin_inset Formula $\text{fmap}_{F}^{A,B}:\left(A\Rightarrow B\right)\Rightarrow F^{A}\Rightarrow F^{B}$
\end_inset

.
 For clarity, we may sometimes write explicitly the type parameters 
\begin_inset Formula $A,B$
\end_inset

 in the expression 
\begin_inset Formula $\text{fmap}_{F}^{A,B}$
\end_inset

, but in most cases these type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 can be omitted without loss of clarity.
 As another example, a monad's standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 is denoted by 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

, where the subscript refers to the monad 
\begin_inset Formula $F$
\end_inset

.
 This function has type signature 
\begin_inset Formula $A\Rightarrow F^{A}$
\end_inset

 that contains a type parameter 
\begin_inset Formula $A$
\end_inset

.
 In the short notation, the presence of the type parameter 
\begin_inset Formula $A$
\end_inset

 can be denoted by 
\begin_inset Formula $\text{pu}_{F}^{A}$
\end_inset

.
 If we are using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method with a complicated type, e.g.
 
\begin_inset Formula $\bbnum1+P^{A}$
\end_inset

, instead of the type parameter 
\begin_inset Formula $A$
\end_inset

, we might want to write this type parameter for clarity and write 
\begin_inset Formula $\text{pu}_{F}^{\bbnum1+P^{A}}$
\end_inset

.
 The type signature of that function is then 
\begin_inset Formula 
\[
\text{pu}_{F}^{1+P^{A}}:\bbnum1+P^{A}\Rightarrow F^{\bbnum1+P^{A}}\quad.
\]

\end_inset

But in most cases we will not need to write the type parameter.
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{\bullet}$
\end_inset

 means the type constructor 
\begin_inset Formula $F$
\end_inset

 understood as a type-level function, – that is, with a type argument unspecifie
d.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

.
 The bullet symbol, 
\begin_inset Formula $\bullet$
\end_inset

, is used as a placeholder for the missing type parameter.
 I also simply write 
\begin_inset Formula $F$
\end_inset

 when no type argument is needed, and it means the same as 
\begin_inset Formula $F^{\bullet}$
\end_inset

.
 (For example, 
\begin_inset Quotes eld
\end_inset

a functor 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

a functor 
\begin_inset Formula $F^{\bullet}$
\end_inset


\begin_inset Quotes erd
\end_inset

 mean the same thing.) However, it is useful for clarity to be able to indicate
 the place where the type argument would appear.
 For instance, functor composition is clearly denoted as 
\begin_inset Formula $F^{G^{\bullet}}$
\end_inset

; in Scala, this is 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[G[?]]
\end_layout

\end_inset


\family default
 when using the 
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset

 plugin.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/typelevel/kind-projector"
target "https://github.com/typelevel/kind-projector"
literal "false"

\end_inset


\end_layout

\end_inset

 As another example, 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 denotes a monad transformer for the base monad 
\begin_inset Formula $L$
\end_inset

 and the foreign monad 
\begin_inset Formula $M$
\end_inset

.
 The foreign monad 
\begin_inset Formula $M$
\end_inset

 is a type parameter in 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

, and so is the missing type parameter denoted by the placeholder symbol
 
\begin_inset Formula $\bullet$
\end_inset

.
 (However, the base monad 
\begin_inset Formula $L$
\end_inset

 is not a type parameter in 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 because the construction of the monad transformer depends sensitively on
 the internal details of 
\begin_inset Formula $L$
\end_inset

.)
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{\bullet}\leadsto G^{\bullet}$
\end_inset

 or 
\begin_inset Formula $F^{A}\leadsto G^{A}$
\end_inset

 means a natural transformation between two functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

.
 In some Scala libraries, this is denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F ~> G
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\forall A.P^{A}$
\end_inset

 is a universally quantified type expression, in which 
\begin_inset Formula $A$
\end_inset

 is a bound type parameter.
\end_layout

\begin_layout Standard
\begin_inset Formula $\exists A.P^{A}$
\end_inset

 is an existentially quantified type expression, in which 
\begin_inset Formula $A$
\end_inset

 is a bound type parameter.
\end_layout

\begin_layout Standard
\begin_inset Formula $\bef$
\end_inset

 means the forward composition
\begin_inset Index idx
status open

\begin_layout Plain Layout
forward composition
\end_layout

\end_inset

 of functions: 
\begin_inset Formula $f\bef g$
\end_inset

 (reads 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $f$
\end_inset

 before 
\begin_inset Formula $g$
\end_inset


\begin_inset Quotes erd
\end_inset

) is the function defined as 
\begin_inset Formula $x\Rightarrow g(f(x))$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\circ$
\end_inset

 means the backward composition
\begin_inset Index idx
status open

\begin_layout Plain Layout
backward composition
\end_layout

\end_inset

 of functions: 
\begin_inset Formula $f\circ g$
\end_inset

 (reads 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $f$
\end_inset

 after 
\begin_inset Formula $g$
\end_inset


\begin_inset Quotes erd
\end_inset

) is the function defined as 
\begin_inset Formula $x\Rightarrow f(g(x))$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\circ$
\end_inset

 with type constructors means their (backward) composition, for example
 
\begin_inset Formula $F\circ G$
\end_inset

 denotes the type constructor 
\begin_inset Formula $F^{G^{\bullet}}$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[G[A]]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $x\triangleright f$
\end_inset

 means that 
\begin_inset Formula $x$
\end_inset

 is inserted as the argument into the function 
\begin_inset Formula $f$
\end_inset

.
 This 
\series bold
forwarding notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
forwarding notation
\end_layout

\end_inset


\series default
, 
\begin_inset Formula $x\triangleright f$
\end_inset

, means the same expression as 
\begin_inset Formula $f(x)$
\end_inset

 or 
\begin_inset Formula $f\,x$
\end_inset

.
 In Scala, the expression 
\begin_inset Formula $x\triangleright f$
\end_inset

 is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.pipe(f)
\end_layout

\end_inset

 or, if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is a method, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.f
\end_layout

\end_inset

.
 This syntax is used with many standard methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.size
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toSeq
\end_layout

\end_inset

.
 Because the function 
\begin_inset Formula $f$
\end_inset

 is to the 
\emph on
right
\emph default
 of 
\begin_inset Formula $x$
\end_inset

 in this notation, forward compositions of functions such as 
\begin_inset Formula $x\triangleright f\triangleright g$
\end_inset

 are naturally grouped to the left, similarly to how this is done in Scala
 code, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.toSeq.sorted
\end_layout

\end_inset

.
 The operation 
\begin_inset Formula $\triangleright$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

pipe
\begin_inset Quotes erd
\end_inset

) groups weaker than the forward composition (
\begin_inset Formula $\bef$
\end_inset

), and so we have 
\begin_inset Formula $x\triangleright f\bef g=x\triangleright f\triangleright g$
\end_inset

 in this notation.
 Reasoning about code in the forwarding notation uses the identities
\begin_inset Formula 
\begin{align*}
x\triangleright f=f(x),\quad\quad & \left(x\triangleright f\right)\triangleright g=x\triangleright f\triangleright g\quad,\\
x\triangleright f\bef g=x\triangleright\left(f\bef g\right),\quad\quad & x\triangleright f\triangleright g=x\triangleright f\bef g\quad.
\end{align*}

\end_inset

Some examples of reasoning in the forwarding notation:
\begin_inset Formula 
\begin{align*}
 & \left(a\Rightarrow a\triangleright f\right)=\left(a\Rightarrow f(a)\right)=f\quad,\\
 & f\triangleright\left(y\Rightarrow a\triangleright y\right)=a\triangleright f=f(a)\quad,\\
 & f(y(x))=x\triangleright y\triangleright f\neq x\triangleright\left(y\triangleright f\right)=f(y)(x)\quad.
\end{align*}

\end_inset

The correspondence between the forwarding notation and the backward composition:
\begin_inset Formula 
\begin{align*}
 & f\bef g=g\circ f\quad,\\
 & x\triangleright(f\bef g)=x\triangleright f\bef g=x\triangleright f\triangleright g=g(f(x))=(g\circ f)(x)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 means a function 
\begin_inset Formula $f$
\end_inset

 lifted to a functor 
\begin_inset Formula $G$
\end_inset

.
 For a function 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

, the application of 
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 to a value 
\begin_inset Formula $g^{:G^{A}}$
\end_inset

 is written as 
\begin_inset Formula $f^{\uparrow G}(g)$
\end_inset

 or as 
\begin_inset Formula $g\triangleright f^{\uparrow G}$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g.map(f)
\end_layout

\end_inset

.
 Nested lifting (i.e.
\begin_inset space ~
\end_inset

lifting to the functor composition 
\begin_inset Formula $H\circ G$
\end_inset

) can be written as 
\begin_inset Formula $f^{\uparrow G\uparrow H}$
\end_inset

, which means 
\begin_inset Formula $\left(f^{\uparrow G}\right)^{\uparrow H}$
\end_inset

 and produces a function of type 
\begin_inset Formula $H^{G^{A}}\Rightarrow H^{G^{B}}$
\end_inset

.
 Applying a nested lifting to a value 
\begin_inset Formula $h$
\end_inset

 of type 
\begin_inset Formula $H^{G^{A}}$
\end_inset

 is written as 
\begin_inset Formula $f^{\uparrow G\uparrow H}h$
\end_inset

 or 
\begin_inset Formula $h\triangleright f^{\uparrow G\uparrow H}$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h.map(_.map(f))
\end_layout

\end_inset

.
 The functor composition law is written as
\begin_inset Formula 
\[
p^{\uparrow G}\bef q^{\uparrow G}=\left(p\bef q\right)^{\uparrow G}\quad.
\]

\end_inset

Note the similarity between Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(p).map(q)
\end_layout

\end_inset

 and the notation 
\begin_inset Formula $x\triangleright p^{\uparrow G}\triangleright q^{\uparrow G}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $f^{\downarrow H}$
\end_inset

 means a function 
\begin_inset Formula $f$
\end_inset

 lifted to a contrafunctor 
\begin_inset Formula $H$
\end_inset

.
 For a function 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

, the application of 
\begin_inset Formula $f^{\downarrow H}$
\end_inset

 to a value 
\begin_inset Formula $h:H^{B}$
\end_inset

 is written as 
\begin_inset Formula $f^{\downarrow H}h$
\end_inset

 or 
\begin_inset Formula $h\triangleright f^{\downarrow H}$
\end_inset

, and yields a value of type 
\begin_inset Formula $H^{A}$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h.contramap(f)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\diamond_{M}$
\end_inset

 means the Kleisli product operation for a given monad 
\begin_inset Formula $M$
\end_inset

.
 This is a binary operation working on two Kleisli functions of types 
\begin_inset Formula $A\Rightarrow M^{B}$
\end_inset

 and 
\begin_inset Formula $B\Rightarrow M^{C}$
\end_inset

 and yields a new function of type 
\begin_inset Formula $A\Rightarrow M^{C}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\oplus$
\end_inset

 means the binary operation of a monoid, for example 
\begin_inset Formula $x\oplus y$
\end_inset

.
 The specific monoid type should be defined for this expression to make
 sense.
 For example, in Scala the monoidal operation is usually denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x |+| y
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\Delta$
\end_inset

 means the standard 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 function of type 
\begin_inset Formula $\forall A.\,A\Rightarrow A\times A$
\end_inset

.
 There is only one implementation of this type signature,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def delta[A](a: A): (A, A) = (a, a)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\nabla_{1},\nabla_{2},...$
\end_inset

 denote the standard projection functions from a tuple to its first, second,
 ..., parts.
 In Scala, 
\begin_inset Formula $\nabla_{1}$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_._1
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\boxtimes$
\end_inset

 means the 
\begin_inset Quotes eld
\end_inset

pair product
\begin_inset Quotes erd
\end_inset

 of functions, where the result is a pair of the values of the two functions:
 
\begin_inset Formula $(f\boxtimes g)(a\times b)=f(a)\times g(b)$
\end_inset

.
 In Scala, this operation can be defined by
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def boxtimes[A,B,P,Q](f: A => P, g: B => Q): ((A, B)) => (P, Q) = {
\end_layout

\begin_layout Plain Layout

  case (a, b) => (f(a), g(b))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The operations 
\begin_inset Formula $\Delta$
\end_inset

, 
\begin_inset Formula $\nabla_{i}$
\end_inset

 (where 
\begin_inset Formula $i=1,2,...$
\end_inset

), and 
\begin_inset Formula $\boxtimes$
\end_inset

 allow us to express any function operating on tuples.
 Useful properties for reasoning about code of such functions: 
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \Delta\bef\nabla_{i}=\text{id}\quad,\\
\text{duplication law}:\quad & f\bef\Delta=\Delta\bef(f\boxtimes f)\quad,\\
\text{projection law}:\quad & (f\boxtimes g)\bef\nabla_{1}=\nabla_{1}\bef f\quad,\\
\text{projection law}:\quad & (f\boxtimes g)\bef\nabla_{2}=\nabla_{2}\bef g\quad,\\
\text{composition law}:\quad & (f\boxtimes g)\bef(p\boxtimes q)=(f\bef p)\boxtimes(g\bef q)\quad,
\end{align*}

\end_inset

as well as the naturality laws for 
\begin_inset Formula $\Delta$
\end_inset

 and 
\begin_inset Formula $\nabla_{i}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & f^{\uparrow F}\bef\Delta=\Delta\bef f^{\uparrow(F\times F)}=\Delta\bef(f^{\uparrow F}\boxtimes f^{\uparrow F})\quad,\\
 & (f^{\uparrow F}\boxtimes f^{\uparrow G})\bef\nabla_{1}=f^{\uparrow(F\times G)}\bef\nabla_{1}=\nabla_{1}\bef f^{\uparrow F}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left[a,b,c\right]$
\end_inset

 means an ordered sequence of values, such as a list or an array.
 In Scala, this can be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(a, b, c)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vector(a, b, c)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array(a, b, c)
\end_layout

\end_inset

, or another collection type.
\end_layout

\begin_layout Standard
\begin_inset Formula $f^{:Z+A\Rightarrow Z+A\times A}\triangleq\begin{array}{||cc|}
\text{id} & \bbnum0\\
\bbnum0 & a\Rightarrow a\times a
\end{array}$
\end_inset

 is an example of the 
\begin_inset Quotes eld
\end_inset

short matrix notation
\begin_inset Quotes erd
\end_inset

 for a function that inputs a disjunctive type and outputs another disjunctive
 type.
 In Scala, the function 
\begin_inset Formula $f$
\end_inset

 is implemented as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[Z, A]: Either[Z, A] => Either[Z, (A, A)] = {
\end_layout

\begin_layout Plain Layout

  case Left(z)   => Left(z) // Identity function on z.
\end_layout

\begin_layout Plain Layout

  case Right(a)  => Right((a, a)) // Delta on a.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The rows of the matrix indicate the different 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

s in the function's code, corresponding to the different parts of the input
 disjunctive type.
 If the input type is not disjunctive, there will be only one row.
 The columns of the matrix indicate the parts of the output disjunctive
 type.
 If the the output type is not disjunctive, there will be only one column.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

long matrix notation
\begin_inset Quotes erd
\end_inset

 writes out all parts of the disjunctive types in a separate 
\begin_inset Quotes eld
\end_inset

type row
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

type column
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\begin{equation}
f\triangleq\begin{array}{|c||cc|}
 & Z & A\times A\\
\hline Z & \text{id} & \bbnum0\\
A & \bbnum0 & a\Rightarrow a\times a
\end{array}\quad.
\end{equation}

\end_inset

This notation clearly indicates the input and the output types of the function,
 and may be useful at the initial stages of reasoning about the code.
 The vertical double line separates input types from the function code.
 The 
\begin_inset Quotes eld
\end_inset

type column
\begin_inset Quotes erd
\end_inset

 shows the parts of the input disjunction type 
\begin_inset Formula $Z+A$
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

type row
\begin_inset Quotes erd
\end_inset

 shows the parts of the output disjunction type 
\begin_inset Formula $Z+A\times A$
\end_inset

.
\end_layout

\begin_layout Standard
The matrix notation is adapted to 
\emph on
forward
\emph default
 function compositions.
 Assume that 
\begin_inset Formula $A$
\end_inset

 is a monoid type, and consider the composition of the function 
\begin_inset Formula $f$
\end_inset

 shown above and the function 
\begin_inset Formula $g$
\end_inset

 defined by the Scala code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def g[Z, A: Monoid]: Either[Z, (A, A)] => A = {
\end_layout

\begin_layout Plain Layout

  case Left(_)          => Monoid[A].empty
\end_layout

\begin_layout Plain Layout

  case Right((a1, a2))  => a1 |+| a2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the long and the short matrix notations, the function 
\begin_inset Formula $g$
\end_inset

 is written as
\begin_inset Formula 
\[
g\triangleq\begin{array}{|c||c|}
 & A\\
\hline Z & \_\Rightarrow e^{:A}\\
A\times A & a_{1}\times a_{2}\Rightarrow a_{1}\oplus a_{2}
\end{array}\quad,\quad\quad g\triangleq\begin{array}{||c|}
\_\Rightarrow e^{:A}\\
a_{1}\times a_{2}\Rightarrow a_{1}\oplus a_{2}
\end{array}\quad.
\]

\end_inset

The forward composition 
\begin_inset Formula $f\bef g$
\end_inset

 is computed by forward-composing the matrix elements with the rules of
 the ordinary matrix multplication, where any terms containing 
\begin_inset Formula $\bbnum0$
\end_inset

 are omitted:
\begin_inset Formula 
\begin{align*}
f\bef g & =\begin{array}{||cc|}
\text{id} & \bbnum0\\
\bbnum0 & a\Rightarrow a\times a
\end{array}\bef\begin{array}{||c|}
\_\Rightarrow e^{:A}\\
a_{1}\times a_{2}\Rightarrow a_{1}\oplus a_{2}
\end{array}\\
 & =\begin{array}{||c|}
\text{id}\bef(\_\Rightarrow e^{:A})\\
\left(a\Rightarrow a\times a\right)\bef\left(a_{1}\times a_{2}\Rightarrow a_{1}\oplus a_{2}\right)
\end{array}=\begin{array}{||c|}
\_\Rightarrow e^{:A}\\
a\Rightarrow a\oplus a
\end{array}\quad.
\end{align*}

\end_inset

Applying a function to a value of a disjunctive type such as 
\begin_inset Formula $x:Z+A$
\end_inset

 is computed by writing 
\begin_inset Formula $x$
\end_inset

 as a single-row matrix, for example
\begin_inset Formula 
\[
x=z^{:Z}+\bbnum0^{:A}=\begin{array}{||cc|}
z^{:Z} & \bbnum0\end{array}\quad,
\]

\end_inset

and the computation 
\begin_inset Formula $x\triangleright f\bef g$
\end_inset

 again follows the rules of matrix multiplication:
\begin_inset Formula 
\[
x\triangleright f\bef g=\begin{array}{||cc|}
z^{:Z} & \bbnum0\end{array}\triangleright\begin{array}{||c|}
\_\Rightarrow e^{:A}\\
a\Rightarrow a\oplus a
\end{array}=z\triangleright(\_\Rightarrow e^{:A})=e^{:A}\quad.
\]

\end_inset

Since the standard rules of matrix multiplication are associative, the propertie
s of the 
\begin_inset Formula $\triangleright$
\end_inset

-notation such as 
\begin_inset Formula $x\triangleright(f\bef g)=(x\triangleright f)\triangleright g$
\end_inset

 are guaranteed to hold.
\end_layout

\begin_layout Chapter
Glossary of terms
\begin_inset CommandInset label
LatexCommand label
name "chap:Appendix-Glossary-of-terms"

\end_inset


\end_layout

\begin_layout Standard
I chose certain terms in this book to be different from the terms currently
 used in the functional programming community.
 My proposed terminology is designed to help readers understand and remember
 the concepts behind the terms.
 
\end_layout

\begin_layout Description
Nameless
\begin_inset space ~
\end_inset

function 
\begin_inset Index idx
status open

\begin_layout Plain Layout
nameless function
\end_layout

\end_inset

An expression of function type, representing a function.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x: Int) => x * 2
\end_layout

\end_inset

.
 Also known as function expression, function literal, anonymous function,
 closure, lambda-function, lambda-expression, or simply a 
\begin_inset Quotes eld
\end_inset

lambda
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
contrafunctor
\end_layout

\end_inset

Contrafunctor A type constructor having the properties of a contravariant
 functor with respect to a type parameter.
 Instead of saying 
\begin_inset Quotes eld
\end_inset

contravariant functor
\begin_inset Quotes erd
\end_inset

, I use the shorter name 
\begin_inset Quotes eld
\end_inset

contrafunctor
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
profunctor
\end_layout

\end_inset

Profunctor A type constructor whose type parameter occurs in both covariant
 and contravariant positions.
\end_layout

\begin_layout Description
Product
\begin_inset space ~
\end_inset

type 
\begin_inset Index idx
status open

\begin_layout Plain Layout
product type
\end_layout

\end_inset

A type representing several values given at once.
 In Scala, product types are the tuple types, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, String)
\end_layout

\end_inset

, and case classes.
 Also known as 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
tuple type
\end_layout

\end_inset

tuple
\series default
 type, 
\series bold
struct
\series default
 (in C and C++), and 
\series bold
record
\series default
.
\end_layout

\begin_layout Description
Disjunctive
\begin_inset space ~
\end_inset

type 
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type
\end_layout

\end_inset

A type representing one of several distinct possibilities.
 In Scala, this is usually implemented as a sealed trait extended by several
 case classes.
 The standard Scala disjunction types are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

.
 Also known as 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
sum type
\end_layout

\end_inset

sum 
\series default
type, 
\series bold
tagged union
\begin_inset Index idx
status open

\begin_layout Plain Layout
tagged union type
\end_layout

\end_inset


\series default
 type, 
\series bold
co-product
\begin_inset Index idx
status open

\begin_layout Plain Layout
co-product type
\end_layout

\end_inset


\series default
 type, and variant type (in Object Pascal and in OCaml).
 The shortest name is 
\begin_inset Quotes eld
\end_inset

sum type,
\begin_inset Quotes erd
\end_inset

 but the English word 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

 is more ambiguous to the ear than 
\begin_inset Quotes eld
\end_inset

disjunction
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Description
Polynomial
\begin_inset space ~
\end_inset

functor 
\begin_inset Index idx
status open

\begin_layout Plain Layout
polynomial functor
\end_layout

\end_inset

A type constructor built using disjunctions (sums), products (tuples), type
 parameters and fixed types.
 For example, in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[A] = Either[(Int, A), A]
\end_layout

\end_inset

 is a polynomial functor with respect to the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 is a fixed type (not a type parameter).
 Polynomial functors are also called 
\series bold
algebraic data types
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
algebraic!data type
\end_layout

\end_inset

.
 A polynomial type constructor is always a functor with respect to any of
 its type parameters, hence I use the shorter name 
\begin_inset Quotes eld
\end_inset

polynomial functor
\begin_inset Quotes erd
\end_inset

 instead of 
\begin_inset Quotes eld
\end_inset

polynomial type constructor
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
unfunctor
\end_layout

\end_inset

Unfunctor A type constructor that cannot possibly be a functor, nor a contrafunc
tor, nor a profunctor.
 An example is a type constructor with explicitly indexed type parameters,
 such as 
\begin_inset Formula $F^{A}\triangleq\left(A\times A\right)^{:F^{\text{Int}}}+\left(\text{Int}\times A\right)^{:F^{\bbnum1}}$
\end_inset

.
 The Scala code for this type constructor is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

final case class F1[A](x: A, y: A) extends F[Int]
\end_layout

\begin_layout Plain Layout

final case class F2[A](s: Int, t: A) extends F[Unit]
\end_layout

\end_inset

Also called a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
GADT (generalized algebraic data type)
\end_layout

\end_inset

GADT
\series default
 (generalized algebraic data type).
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor block
\end_layout

\end_inset

Functor
\begin_inset space ~
\end_inset

block A short syntax for composing several 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 operations applied to a functor-typed value.
 The type constructor corresponding to that value must therefore be fixed
 throughout the entire functor block.
 (The type constructor 
\emph on
must
\emph default
 be a functor and may additionally be filterable and/or monadic.) For example,
 in Scala the code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for { x <- List(1,2,3); y <- List(10, x); if y > 2 }
\end_layout

\begin_layout Plain Layout

  yield 2 * y
\end_layout

\end_inset

is equivalent to the code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List(1, 2, 3).flatMap(x => List(10, x))
\end_layout

\begin_layout Plain Layout

  .filter(y => y > 1).map(y => 2 * y)
\end_layout

\end_inset

and computes the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(20, 20, 20, 6)
\end_layout

\end_inset

.
 This is a functor block that 
\begin_inset Quotes eld
\end_inset

raises
\begin_inset Quotes erd
\end_inset

 computations to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor.
 Similar syntax exists in a number of languages and is called a 
\series bold

\begin_inset Quotes eld
\end_inset

for-comprehension
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
for-comprehension
\end_layout

\end_inset


\series default
 or a 
\begin_inset Quotes eld
\end_inset

list comprehension
\begin_inset Quotes erd
\end_inset

 in Python, 
\series bold

\begin_inset Quotes eld
\end_inset

do-notation
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
do-notation (Haskell)
\end_layout

\end_inset


\series default
 in Haskell, and 
\series bold

\begin_inset Quotes eld
\end_inset

computation expressions
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
computation expressions (F#)
\end_layout

\end_inset


\series default
 in F#.
 I use the name 
\begin_inset Quotes eld
\end_inset

functor block
\begin_inset Quotes erd
\end_inset

 in this book because it is shorter and more descriptive.
 (The type constructor used in a functor block needs to be, at least, a
 functor but does not have to be a monad.)
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
method
\end_layout

\end_inset

Method This word is used in two ways: 1) A method
\begin_inset Formula $_{1}$
\end_inset

 is a Scala function defined as a member of a typeclass.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 is a method defined in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

 typeclass.
 2) A method
\begin_inset Formula $_{2}$
\end_inset

 is a Scala function defined as a member of a data type declared as a Java-compa
tible 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

.
 Trait methods
\begin_inset Formula $_{2}$
\end_inset

 are necessary in Scala when implementing functions whose arguments have
 type parameters (because Scala function values defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 cannot have type parameters).
 So, many typeclasses such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, whose methods
\begin_inset Formula $_{1}$
\end_inset

 require type parameters, will use Scala 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traits
\end_layout

\end_inset

 with methods
\begin_inset Formula $_{2}$
\end_inset

 for their implementation.
 The same applies to type constructions with quantified types, such as the
 Church encoding.
 
\end_layout

\begin_layout Description
Kleisli
\begin_inset space ~
\end_inset

function 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kleisli function
\end_layout

\end_inset

Also called a Kleisli morphism
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kleisli morphism
\end_layout

\end_inset

 or a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kleisli arrow
\end_layout

\end_inset

Kleisli arrow.
 A function with type signature 
\begin_inset Formula $A\Rightarrow M^{B}$
\end_inset

 for some fixed monad 
\begin_inset Formula $M$
\end_inset

.
 More verbosely, 
\begin_inset Quotes eld
\end_inset

a morphism from the Kleisli category corresponding to the monad 
\begin_inset Formula $M$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The standard monadic method 
\begin_inset Formula $\text{pure}_{M}:A\Rightarrow M^{A}$
\end_inset

 has the type signature of a Kleisli function.
 The Kleisli product operation, 
\begin_inset Formula $\diamond_{M}$
\end_inset

, is a binary operation that combines two Kleisli functions (of types 
\begin_inset Formula $A\Rightarrow M^{B}$
\end_inset

 and 
\begin_inset Formula $B\Rightarrow M^{C}$
\end_inset

) into a new Kleisli function (of type 
\begin_inset Formula $A\Rightarrow M^{C}$
\end_inset

).
\end_layout

\begin_layout Description
Exponential-polynomial
\begin_inset space ~
\end_inset

type 
\begin_inset Index idx
status open

\begin_layout Plain Layout
exponential-polynomial type
\end_layout

\end_inset

A type constructor built using disjunctions (sums), products, and function
 types, as well as type parameters or fixed types.
 For brevity, this book calls them 
\begin_inset Quotes eld
\end_inset

exp-poly
\begin_inset Quotes erd
\end_inset

 types.
 For example, in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[A] = Either[(A, A), Int => A]
\end_layout

\end_inset

 is an exp-poly type constructor.
 Such type constructors can be functors, contrafunctors, or profunctors.
\end_layout

\begin_layout Description
Short
\begin_inset space ~
\end_inset

type
\begin_inset space ~
\end_inset

notation 
\begin_inset Index idx
status open

\begin_layout Plain Layout
short type notation
\end_layout

\end_inset

A mathematical notation for type expressions developed in this book for
 the purpose of quicker reasoning about types in functional programs.
 Disjunction types are denoted by 
\begin_inset Formula $+$
\end_inset

, product types by 
\begin_inset Formula $\times$
\end_inset

, and function types by 
\begin_inset Formula $\Rightarrow$
\end_inset

.
 The unit type is denoted by 
\begin_inset Formula $\bbnum1$
\end_inset

, and the void type by 
\begin_inset Formula $\bbnum0$
\end_inset

.
 The function arrow 
\begin_inset Formula $\Rightarrow$
\end_inset

 groups weaker than 
\begin_inset Formula $+$
\end_inset

, which is in turn weaker than 
\begin_inset Formula $\times$
\end_inset

.
 This means
\begin_inset Formula 
\[
Z+A\Rightarrow Z+A\times A\quad\text{is the same as}\quad\left(Z+A\right)\Rightarrow\left(Z+\left(A\times A\right)\right)\quad.
\]

\end_inset

 Type parameters are denoted by superscripts.
 As an example of using these conventions, the Scala definition
\family typewriter

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A] = Either[(A, A => Option[Int]), String => List[A]]
\end_layout

\end_inset


\family default
is written in the short type notation as 
\begin_inset Formula 
\[
F^{A}\triangleq A\times\left(A\Rightarrow\bbnum1+\text{Int}\right)+\left(\text{String}\Rightarrow\text{List}^{A}\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Section
On the current misuse of the term 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
In this book, I do not use the terms 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Index idx
status open

\begin_layout Plain Layout
algebra
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Index idx
status open

\begin_layout Plain Layout
algebraic
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, because these terms are too ambiguous.
 In the current practice, the functional programming community is using
 the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 in at least 
\emph on
four
\emph default
 incompatible ways.
\end_layout

\begin_layout Paragraph
Definition 0.
\end_layout

\begin_layout Standard
In mathematics, an “algebra” is a vector space with multiplication and certain
 standard properties.
 For example, we need 
\begin_inset Formula $1*x=x$
\end_inset

, the addition must be commutative, the multiplication must be distributive
 over addition, and so on.
 The set of all 
\begin_inset Formula $10\times10$
\end_inset

 matrices with real coefficients is an “algebra” in this sense.
 These matrices form a 
\begin_inset Formula $100$
\end_inset

-dimensional vector space, and they can be multiplied and added.
 This definition of 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 is not actually used in functional programming.
\end_layout

\begin_layout Paragraph
Definition 1.
\end_layout

\begin_layout Standard
An 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 is a function with type signature 
\begin_inset Formula $F^{A}\Rightarrow A$
\end_inset

, where 
\begin_inset Formula $F^{A}$
\end_inset

 is some fixed functor.
 This definition comes from category theory, where such types are called
 
\series bold

\begin_inset Formula $F$
\end_inset

-algebras
\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $F$
\end_inset

-algebra
\end_layout

\end_inset


\series default
.
 There is no direct connection between this 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 and Definition
\begin_inset space ~
\end_inset

0, except when the functor 
\begin_inset Formula $F$
\end_inset

 is defined by 
\begin_inset Formula $F^{A}\triangleq A\times A$
\end_inset

, and then a function of type 
\begin_inset Formula $A\times A\Rightarrow A$
\end_inset

 may be interpreted as a 
\begin_inset Quotes eld
\end_inset

multiplication
\begin_inset Quotes erd
\end_inset

 operation (but, in any case, 
\begin_inset Formula $A$
\end_inset

 is a type and not a vector space, and there are no distributivity or commutativ
ity laws).
 I prefer to call such functions 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

-algebras
\begin_inset Quotes erd
\end_inset

, emphasizing that they characterize and depend on a chosen functor 
\begin_inset Formula $F$
\end_inset

.
 However, 
\begin_inset Formula $F$
\end_inset

-algebras are not mentioned in this book: knowing how to reason about their
 theoretical properties does not give much help in practical programming.
\end_layout

\begin_layout Paragraph
Definition 2.
\end_layout

\begin_layout Standard
Polynomial functors are often called “algebraic data types”.
 However, they are not “algebraic” in the sense of Definitions
\begin_inset space ~
\end_inset

0 or 1.
 For example, consider the “algebraic data type” 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Option[A], Int]
\end_layout

\end_inset

, which is 
\begin_inset Formula $F^{A}\triangleq1+A+\text{Int}$
\end_inset

 in the short type notation.
 The set of all values of the type 
\begin_inset Formula $F^{A}$
\end_inset

 does not admit the addition and multiplication operations required by the
 mathematical definition of 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

.
 The type 
\begin_inset Formula $F^{A}$
\end_inset

 may admit some binary or unary operations (e.g.
\begin_inset space ~
\end_inset

that of a monoid), but these operations will not be commutative or distributive.
 Also, there cannot be a function with type 
\begin_inset Formula $F^{A}\Rightarrow A$
\end_inset

, as required for Definition
\begin_inset space ~
\end_inset

1.
 It seems that the usage of the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 here is to refer to 
\begin_inset Quotes eld
\end_inset

school-level algebra
\begin_inset Quotes erd
\end_inset

 with polynomials; these data types are built from sums and products of
 types.
 In this book, I call such types 
\begin_inset Quotes eld
\end_inset

polynomial
\begin_inset Quotes erd
\end_inset

.
 However, if the data type contains a function type, e.g.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Int => A]
\end_layout

\end_inset

, the type is no longer polynomial.
 So I use the more precise terms “polynomial type” and “exponential-polynomial
 type”.
\end_layout

\begin_layout Paragraph
Definition 3.
\end_layout

\begin_layout Standard
People talk about the “algebra” of properties of functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, referring to the fact that these functions must satisfy certain equational
 laws (e.g.
\begin_inset space ~
\end_inset

the composition, naturality, or associativity laws).
 But these laws do not form an 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 in the sense of Definition
\begin_inset space ~
\end_inset

0, nor do the functions such as map or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 themselves (there are no binary operations on them).
 Neither do they form an 
\begin_inset Formula $F$
\end_inset

-algebra in the sense of Definition
\begin_inset space ~
\end_inset

1.
 The laws for 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset


\family default
 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 are in no way related to “algebraic data types” of Definition
\begin_inset space ~
\end_inset

2.
 So here the word “algebra” is used in a way that is unrelated to the three
 previous definitions.
 It does not actually seem helpful to say the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

 when talking about equational laws.
 These laws are 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

 in a trivial sense – they are written as equations containing compositions
 of functions and applications of functions to arguments.
 In mathematics, it makes sense to talk about 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

 equations as different from 
\begin_inset Quotes eld
\end_inset

differential
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

integral
\begin_inset Quotes erd
\end_inset

 equations.
 In functional programming, all equational laws are of the same kind: some
 code on the left-hand side must be equal to some code on the right-hand
 side of the equation.
 Since functional programming does not have 
\begin_inset Quotes eld
\end_inset

non-algebraic
\begin_inset Quotes erd
\end_inset

 laws, calling its laws 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

 does not clarify anything.
 I call them 
\begin_inset Quotes eld
\end_inset

equational laws
\begin_inset Quotes erd
\end_inset

 or just 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

 in this book.
\end_layout

\begin_layout Paragraph
Definition 4.
\end_layout

\begin_layout Standard
In the Church encoding of a free monad (nowadays known as the 
\begin_inset Quotes eld
\end_inset

final tagless
\begin_inset Quotes erd
\end_inset

 encoding), the term 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 refers to the function 
\begin_inset Formula $S^{E^{\bullet}}\leadsto E^{\bullet}$
\end_inset

, which is a sub-expression of the Church encoding 
\begin_inset Formula $\forall E^{\bullet}.\,(S^{E^{\bullet}}\leadsto E^{\bullet})\Rightarrow E^{A}$
\end_inset

 that uses the 
\emph on
type constructor
\emph default
 parameter 
\begin_inset Formula $E$
\end_inset

.
 This definition is related only to Definition
\begin_inset space ~
\end_inset

1 if we consider 
\begin_inset Formula $S^{E}\leadsto E$
\end_inset

 as an 
\begin_inset Formula $S$
\end_inset

-algebra in the category of 
\emph on
functors
\emph default
.
 The fact that 
\begin_inset Formula $S^{E^{\bullet}}\leadsto E^{\bullet}$
\end_inset

 is an 
\begin_inset Formula $S$
\end_inset

-algebra in the category of functors does not provide any additional insight
 or help for practical work with the Church encoding of a free monad.
\end_layout

\begin_layout Standard
In some online tutorials, the type constructor 
\begin_inset Formula $S$
\end_inset

 itself is called an 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

.
 The type constructor 
\begin_inset Formula $S$
\end_inset

 is used to parameterize the effects described by the Church-encoded free
 monad, so I call it the 
\begin_inset Quotes eld
\end_inset

effect constructor
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
So, it seems that the current usage of the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 in functional programming is both inconsistent and unhelpful to practitioners.
 In this book, I reserve the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 to denote the branch of mathematics, as in 
\begin_inset Quotes eld
\end_inset

school-level algebra
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

graduate-level algebra
\begin_inset Quotes erd
\end_inset

.
 Instead of 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 as in Definitions
\begin_inset space ~
\end_inset

1 to 4, I talk about 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

-algebras
\begin_inset Quotes erd
\end_inset

 with a specific functor 
\begin_inset Formula $F$
\end_inset

; 
\begin_inset Quotes eld
\end_inset

polynomial types
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

polynomial functors
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

exponential-polynomial functors
\begin_inset Quotes erd
\end_inset

 etc.; 
\begin_inset Quotes eld
\end_inset

equational laws
\begin_inset Quotes erd
\end_inset

; and an 
\begin_inset Quotes eld
\end_inset

effect constructor
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $S$
\end_inset

.
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Scala syntax and features
\end_layout

\begin_layout Plain Layout
Function syntax
\end_layout

\begin_layout Plain Layout
Functions have arguments, body, and type.
 The function type lists the type of all arguments and the type of the result
 value.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int, y: Int): Int => Int = { z => x + y + z }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Functions may be used with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
infix syntax
\end_layout

\end_inset

infix syntax as well.
 For this syntax to work, the function must be defined 
\series bold
as a Scala method
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
method
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala method
\end_layout

\end_inset

, that is, using 
\family typewriter
def
\family default
 within the declaration of 
\family typewriter
x
\family default
's class, or as an extension method.
 The infix syntax cannot work with functions defined using 
\family typewriter
val
\family default
.
 For clarity, I call Scala functions 
\series bold
infix methods
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
infix method
\end_layout

\end_inset

 when defined and used in this way.
\end_layout

\begin_layout Plain Layout
The syntax 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset


\family default
 means 
\begin_inset Quotes eld
\end_inset

a list of integer values.
\begin_inset Quotes erd
\end_inset

 In the type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

, the 
\begin_inset Quotes eld
\end_inset


\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset


\family default

\begin_inset Quotes erd
\end_inset

 is called the 
\series bold
type parameter
\begin_inset Index idx
status open

\begin_layout Plain Layout
type parameter
\end_layout

\end_inset


\series default
 and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\family default
 is called the 
\series bold
type constructor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type constructor
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
A list can contain values of any type; for example, 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[List[Int]]]
\end_layout

\end_inset


\family default
 means a list of lists of lists of integers.
 So, a type constructor can be seen as a function from types to types.
 A type constructor takes a type parameter as an argument, and produces
 a new type as a result.
\end_layout

\begin_layout Plain Layout
Functions of several arguments vs.
\begin_inset space ~
\end_inset

tuples
\end_layout

\begin_layout Plain Layout
In Scala, there is a difference between a function whose argument is a tuple,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1(p: (Int, String)): Int = ???
\end_layout

\end_inset

and a function with several arguments,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2(x: Int, s: String): Int = ???
\end_layout

\end_inset

This difference is 
\begin_inset Quotes eld
\end_inset

cosmetic
\begin_inset Quotes erd
\end_inset

 because these functions are equivalent from the computational point of
 view.
 However, Scala syntax for these functions is different.
\end_layout

\begin_layout Plain Layout
Scala collections
\end_layout

\begin_layout Plain Layout
The Scala standard library defines collections of several kinds, the main
 ones being sequences, sets, and dictionaries.
 These collections have many map/reduce-style methods defined on them.
\end_layout

\begin_layout Plain Layout
Sequences are 
\begin_inset Quotes eld
\end_inset

subclasses
\begin_inset Quotes erd
\end_inset

 of the class 
\family typewriter
Seq
\family default
.
 The standard library will sometimes choose automatically a suitable subclass
 of 
\family typewriter
Seq
\family default
, such as 
\family typewriter
List
\family default
, 
\family typewriter
IndexedSeq
\family default
, 
\family typewriter
Vector
\family default
, 
\family typewriter
Range
\family default
, etc.; for example:
\end_layout

\begin_layout LyX-Code
scala> 1 to 5
\end_layout

\begin_layout LyX-Code
scala> (1 to 5).map(x => x*x)
\end_layout

\begin_layout LyX-Code
scala> (1 to 5).toList
\end_layout

\begin_layout LyX-Code
scala> 1 until 5
\end_layout

\begin_layout LyX-Code
scala> (1 until 5).toList
\end_layout

\begin_layout Plain Layout
For our purposes, all these 
\begin_inset Quotes eld
\end_inset

sequence-like
\begin_inset Quotes erd
\end_inset

 types are equivalent.
\end_layout

\begin_layout Plain Layout
Sets are values of class 
\family typewriter
Set
\family default
, and dictionaries are values of class 
\family typewriter
Map
\family default
.
\end_layout

\begin_layout LyX-Code
scala> Set(1, 2, 3).filter(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 x % 2 == 0)
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
The Curry-Howard correspondence
\begin_inset CommandInset label
LatexCommand label
name "app:The-Curry-Howard-correspondence"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset href
LatexCommand href
name "Gentzen-Vorobiev-Hudelmaier algorithm"
target "http://apt13.unibe.ch/slides/Dyckhoff.pdf"
literal "false"

\end_inset

 and its generalizations
\end_layout

\begin_layout Standard
See also the 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"
literal "false"

\end_inset

 project
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Slides
\end_layout

\begin_layout Standard
Type constructions in functional programming
\end_layout

\begin_layout Standard
The common ground between OCaml, Haskell, Scala, Rust, and other languages
\end_layout

\begin_layout Standard
Type constructions common in FP languages:
\end_layout

\begin_layout Standard
Tuple (
\begin_inset Quotes eld
\end_inset

product
\begin_inset Quotes erd
\end_inset

) type: 
\begin_inset Formula $\text{Int}\times\text{String}$
\end_inset


\end_layout

\begin_layout Standard
Function type: 
\begin_inset Formula $\text{Int}\Rightarrow\text{String}$
\end_inset


\end_layout

\begin_layout Standard
Disjunction (
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

) type: 
\begin_inset Formula $\text{Int}+\text{String}$
\end_inset


\end_layout

\begin_layout Standard
Unit type (
\begin_inset Quotes eld
\end_inset

empty tuple
\begin_inset Quotes erd
\end_inset

): 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Standard
Type parameters: 
\begin_inset Formula $\text{List}^{T}$
\end_inset


\end_layout

\begin_layout Standard
Up to differences in syntax, the FP languages share all these features
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Type constructions: Scala syntax
\end_layout

\begin_layout Standard
Tuple type: 
\family typewriter
\size footnotesize
\color blue
(Int, String)
\end_layout

\begin_layout Standard
Create: 
\family typewriter
\size footnotesize
\color blue
val pair:
\begin_inset space \space{}
\end_inset

(Int, String) = (123, "abc")
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Use: 
\family typewriter
\size footnotesize
\color blue
val y:
\begin_inset space \space{}
\end_inset

String = pair._2
\end_layout

\begin_layout Standard
Function type: 
\family typewriter
\size footnotesize
\color blue
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\end_layout

\begin_layout Standard
Create: 
\family typewriter
\size footnotesize
\color blue
def f:
\begin_inset space \space{}
\end_inset

(Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String) = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 "Value is " + x.toString
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Use: 
\family typewriter
\size footnotesize
\color blue
val y:
\begin_inset space \space{}
\end_inset

String = f(123)
\end_layout

\begin_layout Standard
Disjunction type: 
\family typewriter
\size footnotesize
\color blue
Either[Int, String]
\family default
\size default
\color inherit
 defined in standard library
\end_layout

\begin_layout Standard
Create:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size footnotesize
\color blue

\begin_inset space \space{}
\end_inset

val x:
\begin_inset space \space{}
\end_inset

Either[Int, String] = Left(123)
\begin_inset Newline newline
\end_inset

 val y:
\begin_inset space \space{}
\end_inset

Either[Int, String] = Right("abc")
\end_layout

\begin_layout Standard
Use: 
\family typewriter
\size footnotesize
\color blue
val z:
\begin_inset space \space{}
\end_inset

Boolean = x match {
\begin_inset Newline newline
\end_inset

 case Left(i) 
\begin_inset Formula $\Rightarrow$
\end_inset

 i > 0
\begin_inset Newline newline
\end_inset

 case Right(_) 
\begin_inset Formula $\Rightarrow$
\end_inset

 false
\begin_inset Newline newline
\end_inset

}
\end_layout

\begin_layout Standard
Unit type: 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\begin_layout Standard
Create: 
\family typewriter
\size footnotesize
\color blue
val x:
\begin_inset space \space{}
\end_inset

Unit = ()
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Type constructions: OCaml syntax
\end_layout

\begin_layout Standard
Tuple type: 
\family typewriter
\size footnotesize
\color blue
int * string
\end_layout

\begin_layout Standard
Create: 
\family typewriter
\size footnotesize
\color blue
let pair:
\begin_inset space \space{}
\end_inset

int * string = (123, "abc")
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Use: 
\family typewriter
\size footnotesize
\color blue
let y:
\begin_inset space \space{}
\end_inset

string = snd pair
\end_layout

\begin_layout Standard
Function type: 
\family typewriter
\size footnotesize
\color blue
int -> string
\end_layout

\begin_layout Standard
Create: 
\family typewriter
\size footnotesize
\color blue
let f:
\begin_inset space \space{}
\end_inset

int -> string =
\begin_inset Newline newline
\end_inset

 fun x -> Printf.sprintf "Value is %d" x
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Use: 
\family typewriter
\size footnotesize
\color blue
let y:
\begin_inset space \space{}
\end_inset

string = f 123
\end_layout

\begin_layout Standard
Disjunction type: 
\family typewriter
\size footnotesize
\color blue
type e = Left of int | Right of string
\end_layout

\begin_layout Standard
Create:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size footnotesize
\color blue

\begin_inset space \space{}
\end_inset

let x:
\begin_inset space \space{}
\end_inset

e = Left 123
\begin_inset Newline newline
\end_inset

 let y:
\begin_inset space \space{}
\end_inset

e = Right "abc"
\end_layout

\begin_layout Standard
Use: 
\family typewriter
\size footnotesize
\color blue
let z:
\begin_inset space \space{}
\end_inset

bool = match x with
\begin_inset Newline newline
\end_inset

 Left i -> i > 0
\begin_inset Newline newline
\end_inset

 Right _ -> false
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Unit type: 
\family typewriter
\size footnotesize
\color blue
unit
\end_layout

\begin_layout Standard
Create: 
\family typewriter
\size footnotesize
\color blue
let x:
\begin_inset space \space{}
\end_inset

unit = ()
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Type constructions: Haskell syntax
\end_layout

\begin_layout Standard
Tuple type: 
\family typewriter
\size footnotesize
\color blue
(Int, String)
\end_layout

\begin_layout Standard
Create: 
\family typewriter
\size footnotesize
\color blue
pair = (123, "abc")
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Use: 
\family typewriter
\size footnotesize
\color blue
(_, y) = pair
\end_layout

\begin_layout Standard
Function type: 
\family typewriter
\size footnotesize
\color blue
Int -> String
\end_layout

\begin_layout Standard
Create: 
\family typewriter
\size footnotesize
\color blue
f = 
\backslash
x -> "Value is " ++ show x
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Use: 
\family typewriter
\size footnotesize
\color blue
y = f 123
\end_layout

\begin_layout Standard
Disjunction type: 
\family typewriter
\size footnotesize
\color blue
data E = Left Int | Right String
\end_layout

\begin_layout Standard
Create:
\begin_inset Newline newline
\end_inset


\begin_inset space \space{}
\end_inset

 
\family typewriter
\size footnotesize
\color blue
x = Left 123
\begin_inset Newline newline
\end_inset

 y = Right "abc"
\end_layout

\begin_layout Standard
Use: 
\family typewriter
\size footnotesize
\color blue
z = case x of
\begin_inset Newline newline
\end_inset

 Left i -> i > 0
\begin_inset Newline newline
\end_inset

 Right _ -> false
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Unit type: 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\begin_layout Standard
Create: 
\family typewriter
\size footnotesize
\color blue
x = ()
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
From types to propositions
\end_layout

\begin_layout Standard
The code 
\family typewriter
\size footnotesize
\color blue
val x:
\begin_inset space \space{}
\end_inset

T =
\family default
\size default
\color inherit
 ...
 shows that 
\emph on
we can compute a value
\emph default
 of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 as part of our program expression
\end_layout

\begin_layout Standard
Let's denote this 
\emph on
proposition
\emph default
 by 
\begin_inset Formula ${\cal CH}(T)$
\end_inset

 – 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathcal{C}$
\end_inset

ode 
\begin_inset Formula $\mathcal{H}$
\end_inset

as a value of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Correspondence between types and propositions, for a given program:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Short notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(T)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(A, B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
and
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\wedge B$
\end_inset

; 
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Either[A, B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
or
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\vee B$
\end_inset

; 
\begin_inset Formula $A+B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
implies
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Type parameter 
\family typewriter
\size footnotesize
\color blue
[T]
\family default
\size default
\color inherit
 in a function type means 
\begin_inset Formula $\forall T$
\end_inset


\end_layout

\begin_layout Standard
Example: 
\family typewriter
\size footnotesize
\color blue
def dupl[A]:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A, A)
\family default
\size default
\color inherit
.
 The type of this function, 
\begin_inset Formula $A\Rightarrow A\times A$
\end_inset

, corresponds to the theorem 
\begin_inset Formula $\forall A:A\Rightarrow A\wedge A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Translating language constructions into the logic I
\end_layout

\begin_layout Standard
How to represent logical relationships between 
\begin_inset Formula ${\cal CH}(...)$
\end_inset

 propositions?
\end_layout

\begin_layout Standard
Code expressions create
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
,
\end_layout

\end_inset


\emph on
logical relationships
\emph default
 between propositions 
\begin_inset Formula ${\cal CH}(...)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Logical relationships
\begin_inset Quotes erd
\end_inset

 = what will be true if something given is true
\end_layout

\begin_layout Standard
In formal logic, this statement is written in the syntax
\begin_inset Formula 
\[
X,Y,...,Z\vdash T
\]

\end_inset

and is called a 
\series bold
sequent
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent
\end_layout

\end_inset

 having the premises 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

 and the goal 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
A sequent in formal logic can be proved if proof task;
\end_layout

\begin_layout Standard
The elementary proof task is represented by a 
\series bold
sequent
\end_layout

\begin_layout Standard
Notation: 
\begin_inset Formula $A,B,C\vdash G$
\end_inset

; the 
\series bold
premises
\series default
 are 
\begin_inset Formula $A,B,C$
\end_inset

 and the 
\series bold
goal
\series default
 is G
\end_layout

\begin_layout Standard
Proofs are achieved via axioms and derivation rules
\end_layout

\begin_layout Standard
Axioms: such and such sequents are already true
\end_layout

\begin_layout Standard
Derivation rules: this sequent is true if such and such sequents are true
\end_layout

\begin_layout Standard
To make connection with logic, represent code fragments as 
\series bold
sequents
\end_layout

\begin_layout Standard

\color blue
\begin_inset Formula $A,B\vdash C$
\end_inset


\color inherit
 represents an 
\emph on
expression
\emph default
 of type 
\family typewriter
\size footnotesize
\color blue
C
\family default
\size default
\color inherit
 that uses 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

A
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
y:
\begin_inset space \space{}
\end_inset

B
\end_layout

\begin_layout Standard
Examples in Scala:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
(x:
\begin_inset space \space{}
\end_inset

Int).toString + "abc"
\family default
\size default
\color inherit
 is an expression of type 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 that uses an 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

Int
\family default
\size default
\color inherit
 and is represented by the sequent 
\begin_inset Formula $\text{Int}\vdash\text{String}$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
(x:
\begin_inset space \space{}
\end_inset

Int) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x.toString + "abc"
\family default
\size default
\color inherit
 is an expression of type 
\family typewriter
\size footnotesize
\color blue
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\family default
\size default
\color inherit
 and is represented by the sequent 
\begin_inset Formula $\emptyset\vdash\text{Int}\Rightarrow\text{String}$
\end_inset


\end_layout

\begin_layout Standard
Sequents only describe the 
\emph on
types
\emph default
 of expressions and their parts
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Translating language constructions into the logic II
\end_layout

\begin_layout Standard
What are the derivation rules for the logic of types?
\end_layout

\begin_layout Standard
Write all the constructions in FP languages as sequents
\end_layout

\begin_layout Standard
This will give all the derivation rules for the logic of types
\end_layout

\begin_layout Standard
Each type construction has an expression for creating it and an expression
 for using it
\end_layout

\begin_layout Standard
Tuple type 
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\begin_layout Standard
Create: 
\begin_inset Formula $A,B\vdash A\times B$
\end_inset

 
\end_layout

\begin_layout Standard
Use: 
\begin_inset Formula $A\times B\vdash A$
\end_inset

 and also 
\begin_inset Formula $A\times B\vdash B$
\end_inset


\end_layout

\begin_layout Standard
Function type 
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\begin_layout Standard
Create: if we have 
\begin_inset Formula $A\vdash B$
\end_inset

 then we will have 
\begin_inset Formula $\emptyset\vdash A\Rightarrow B$
\end_inset

 
\end_layout

\begin_layout Standard
Use: 
\begin_inset Formula $A\Rightarrow B,A\vdash B$
\end_inset


\end_layout

\begin_layout Standard
Disjunction type 
\begin_inset Formula $A+B$
\end_inset


\end_layout

\begin_layout Standard
Create: 
\begin_inset Formula $A\vdash A+B$
\end_inset

 and also 
\begin_inset Formula $B\vdash A+B$
\end_inset


\end_layout

\begin_layout Standard
Use: 
\begin_inset Formula $A+B,A\Rightarrow C,B\Rightarrow C\vdash C$
\end_inset


\end_layout

\begin_layout Standard
Unit type 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Standard
Create: 
\begin_inset Formula $\emptyset\vdash1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Translating language constructions into the logic III
\end_layout

\begin_layout Standard
Additional rules for the logic of types
\end_layout

\begin_layout Standard
In addition to constructions that use types, we have 
\begin_inset Quotes eld
\end_inset

trivial
\begin_inset Quotes erd
\end_inset

 constructions:
\end_layout

\begin_layout Standard
a single, unmodified value of type 
\begin_inset Formula $A$
\end_inset

 is a valid expression of type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Standard
For any 
\begin_inset Formula $A$
\end_inset

 we have the sequent 
\begin_inset Formula $A\vdash A$
\end_inset


\end_layout

\begin_layout Standard
if a value can be computed using some given data, it can also be computed
 if given
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
,
\end_layout

\end_inset


\emph on
additional
\emph default
 data
\end_layout

\begin_layout Standard
If we have 
\begin_inset Formula $A,...,C\vdash G$
\end_inset

 then also 
\begin_inset Formula $A,...,C,D\vdash G$
\end_inset

 for any 
\begin_inset Formula $D$
\end_inset


\end_layout

\begin_layout Standard
For brevity, we denote by 
\begin_inset Formula $\Gamma$
\end_inset

 a sequence of arbitrary premises
\end_layout

\begin_layout Standard
the order in which data is given does not matter, we can still compute all
 the same things given the same premises in different order
\end_layout

\begin_layout Standard
If we have 
\begin_inset Formula $\Gamma,A,B\vdash G$
\end_inset

 then we also have 
\begin_inset Formula $\Gamma,B,A\vdash G$
\end_inset


\end_layout

\begin_layout Standard
Syntax conventions:
\end_layout

\begin_layout Standard
the implication operation associates 
\emph on
to the right
\end_layout

\begin_layout Standard
\begin_inset Formula $A\Rightarrow B\Rightarrow C$
\end_inset

 means 
\begin_inset Formula $A\Rightarrow\left(B\Rightarrow C\right)$
\end_inset


\end_layout

\begin_layout Standard
precedence order: implication, disjunction, conjunction
\end_layout

\begin_layout Standard
\begin_inset Formula $A+B\times C\Rightarrow D$
\end_inset

 means 
\begin_inset Formula $\left(A+\left(B\times C\right)\right)\Rightarrow D$
\end_inset


\end_layout

\begin_layout Standard
Quantifiers: implicitly, all our type variables are universally quantified
\end_layout

\begin_layout Standard
When we write 
\begin_inset Formula $A\Rightarrow B\Rightarrow A$
\end_inset

, we mean 
\begin_inset Formula $\forall A:\forall B:A\Rightarrow B\Rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
The logic of types I
\end_layout

\begin_layout Standard
Now we have all the axioms and the derivation rules of the logic of types.
\end_layout

\begin_layout Standard
What theorems can we derive in this logic?
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $A\Rightarrow B\Rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
Start with an axiom 
\begin_inset Formula $A\vdash A$
\end_inset

; add an unused extra premise 
\begin_inset Formula $B$
\end_inset

: 
\begin_inset Formula $A,B\vdash A$
\end_inset


\end_layout

\begin_layout Standard
Use the 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule with 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $A$
\end_inset

, get 
\begin_inset Formula $A\vdash B\Rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
Use the 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule with 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B\Rightarrow A$
\end_inset

, get the final sequent 
\begin_inset Formula $\emptyset\vdash A\Rightarrow B\Rightarrow A$
\end_inset

 showing that 
\begin_inset Formula $A\Rightarrow B\Rightarrow A$
\end_inset

 is a 
\series bold
theorem
\series default
 since it is derived from no premises
\end_layout

\begin_layout Standard
What code does this describe?
\end_layout

\begin_layout Standard
The axiom 
\begin_inset Formula $A\vdash A$
\end_inset

 represents the expression 
\begin_inset Formula $x^{A}$
\end_inset

 where 
\begin_inset Formula $x$
\end_inset

 is of type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Standard
The unused premise 
\begin_inset Formula $B$
\end_inset

 corresponds to unused variable 
\begin_inset Formula $y^{B}$
\end_inset

 of type 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule gives the function 
\begin_inset Formula $y^{B}\Rightarrow x^{A}$
\end_inset


\end_layout

\begin_layout Standard
The second 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule gives 
\begin_inset Formula $x^{A}\Rightarrow\left(y^{B}\Rightarrow x\right)$
\end_inset


\end_layout

\begin_layout Standard
Scala code: 
\family typewriter
\size footnotesize
\color blue
def f[A, B]:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B 
\begin_inset Formula $\Rightarrow$
\end_inset

 A = (x:
\begin_inset space \space{}
\end_inset

A) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (y:
\begin_inset space \space{}
\end_inset

B) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x
\end_layout

\begin_layout Standard
Any code expression's type can be translated into a sequent
\end_layout

\begin_layout Standard
A proof of a theorem directly guides us in writing code for that type
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Correspondence between programs and proofs
\end_layout

\begin_layout Standard
By construction, any theorem can be implemented in code
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def identity[A](x:
\begin_inset space \space{}
\end_inset

A):
\begin_inset space \space{}
\end_inset

A = x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def toUnit[A](x:
\begin_inset space \space{}
\end_inset

A): Unit = ()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def inLeft[A,B](x:A):
\begin_inset space \space{}
\end_inset

Either[A,B] = Left(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\times B\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def first[A,B](p:
\begin_inset space \space{}
\end_inset

(A,B)):
\begin_inset space \space{}
\end_inset

A = p._1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow B\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def const[A,B](x:
\begin_inset space \space{}
\end_inset

A):
\begin_inset space \space{}
\end_inset

B
\begin_inset Formula $\Rightarrow$
\end_inset

A = (y:B)
\begin_inset Formula $\Rightarrow$
\end_inset

x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Also, non-theorems 
\emph on
cannot be implemented
\emph default
 in code 
\end_layout

\begin_layout Standard
Examples of non-theorems:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $\forall A:1\Rightarrow A$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:A+B\Rightarrow A$
\end_inset

; 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall A\forall B:A\Rightarrow A\times B$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:(A\Rightarrow B)\Rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
Given a type's formula, can we implement it in code? Not obvious.
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $\forall A\forall B:((((A\Rightarrow B)\Rightarrow A)\Rightarrow A)\Rightarrow B)\Rightarrow B$
\end_inset


\end_layout

\begin_layout Standard
Can we write a function with this type? Can we prove this formula?
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
The logic of types II
\end_layout

\begin_layout Standard
What kind of logic is this? What do mathematicians call this logic?
\end_layout

\begin_layout Standard
This is called 
\begin_inset Quotes eld
\end_inset

intuitionistic propositional logic
\begin_inset Quotes erd
\end_inset

, IPL (also 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
This is a 
\begin_inset Quotes eld
\end_inset

nonclassical
\begin_inset Quotes erd
\end_inset

 logic because it is different from Boolean logic
\end_layout

\begin_layout Standard
Disjunction works very differently from Boolean logic
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $A\Rightarrow B+C\vdash(A\Rightarrow B)+(A\Rightarrow C)$
\end_inset

 does not hold in IPL
\end_layout

\begin_layout Standard
This is counter-intuitive!
\end_layout

\begin_layout Standard
We cannot implement a function with this type:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
def q[A,B,C](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Either[B, C]): Either[A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B, A 
\begin_inset Formula $\Rightarrow$
\end_inset

 C]
\end_layout

\begin_layout Standard
Disjunction is 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

: need to supply one of the parts
\end_layout

\begin_layout Standard
But 
\family typewriter
\size footnotesize
\color blue
Either[A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B, A 
\begin_inset Formula $\Rightarrow$
\end_inset

 C]
\family default
\size default
\color inherit
 is not a function of 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Implication works somewhat differently
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $\left(\left(A\Rightarrow B\right)\Rightarrow A\right)\Rightarrow A$
\end_inset

 holds in Boolean logic but not in IPL
\end_layout

\begin_layout Standard
Cannot compute an 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

A
\family default
\size default
\color inherit
 because of insufficient data
\end_layout

\begin_layout Standard
Conjunction works the same as in Boolean logic
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula 
\[
A\Rightarrow B\times C\vdash\left(A\Rightarrow B\right)\times\left(A\Rightarrow C\right)
\]

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
The logic of types III
\end_layout

\begin_layout Standard
How to determine whether a given IPL formula is a theorem?
\end_layout

\begin_layout Standard
The IPL cannot have a truth table with a fixed number of truth values
\end_layout

\begin_layout Standard
This was shown by G
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
"
\end_layout

\end_inset

odel in 1932 (see 
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia page"
target "https://en.wikipedia.org/wiki/Many-valued_logic"
literal "false"

\end_inset

)
\end_layout

\begin_layout Standard
The IPL has a decision procedure (algorithm) that either finds a proof for
 a given IPL formula, or determines that there is no proof
\end_layout

\begin_layout Standard
There may be several inequivalent proofs of an IPL theorem
\end_layout

\begin_layout Standard
Each proof can be 
\emph on
automatically translated
\emph default
 into code
\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"
literal "false"

\end_inset

 library implements an IPL prover as a Scala macro, and generates Scala
 code from types
\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset href
LatexCommand href
name "djinn-ghc"
target "https://hackage.haskell.org/package/djinn-ghc"
literal "false"

\end_inset

 compiler plugin and the 
\begin_inset CommandInset href
LatexCommand href
name "JustDoIt plugin"
target "https://github.com/nomeata/ghc-justdoit"
literal "false"

\end_inset

 implement an IPL prover in Haskell, and generate Haskell code from types
\end_layout

\begin_layout Standard
All these IPL provers use the same basic algorithm called LJT 
\end_layout

\begin_layout Standard
and all cite the same paper 
\size footnotesize

\begin_inset CommandInset href
LatexCommand href
name "[Dyckhoff 1992]"
target "https://rd.host.cs.st-andrews.ac.uk/publications/jsl57.pdf"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
because most other papers on this subject are incomprehensible to non-specialist
s, or describe algorithms that are too complicated
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search I: looking for an algorithm
\end_layout

\begin_layout Standard
Why our initial presentation of IPL does not give a proof search algorithm
\end_layout

\begin_layout Standard
The FP type constructions give nine axioms and three derivation rules:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Itemize
\begin_inset Formula $\Gamma,A,B\vdash A\times B$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\times B\vdash A$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\times B\vdash B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\Rightarrow B,A\vdash B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\vdash A+B$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,B\vdash A+B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A+B,A\Rightarrow C,B\Rightarrow C\vdash C$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma\vdash1$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\vdash A$
\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma,A\vdash B}{\Gamma\vdash A\Rightarrow B}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma\vdash G}{\Gamma,D\vdash G}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma,A,B\vdash G}{\Gamma,B,A\vdash G}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Can we use these rules to obtain a finite and complete search tree? No.
\end_layout

\begin_layout Standard
Try proving 
\begin_inset Formula $A,B+C\vdash A\times B+C$
\end_inset

: cannot find matching rules
\end_layout

\begin_layout Standard
Need a better formulation of the logic
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search II: Gentzen's calculus LJ (1935)
\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

complete and sound calculus
\begin_inset Quotes erd
\end_inset

 is a set of axioms and derivation rules that will yield all (and only!)
 theorems of the logic
\begin_inset Formula 
\begin{align*}
\text{(}X\text{ is atomic)\,}\frac{}{\Gamma,{\color{blue}X}\vdash X}\:Id & \qquad\frac{}{\Gamma\vdash{\color{blue}\top}}\,\top\\
\frac{\Gamma,A\Rightarrow B\vdash A\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A\Rightarrow B}\vdash C}\:L\Rightarrow & \qquad\frac{\Gamma,A\vdash B}{\Gamma\vdash{\color{blue}A\Rightarrow B}}\,R\Rightarrow\\
\frac{\Gamma,A\vdash C\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A+B}\vdash C}\:L+ & \qquad\frac{\Gamma\vdash A_{i}}{\Gamma\vdash{\color{blue}A_{1}+A_{2}}}\,R+_{i}\\
\frac{\Gamma,A_{i}\vdash C}{\Gamma,{\color{blue}A_{1}\times A_{2}}\vdash C}\:L\times_{i} & \qquad\frac{\Gamma\vdash A\quad\;\Gamma\vdash B}{\Gamma\vdash{\color{blue}A\times B}}\,R\times
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Two axioms and eight derivation rules
\end_layout

\begin_layout Standard
Each derivation rule says: The sequent at bottom will be proved if proofs
 are given for sequent(s) at top
\end_layout

\begin_layout Standard
Use these rules 
\begin_inset Quotes eld
\end_inset

bottom-up
\begin_inset Quotes erd
\end_inset

 to perform a proof search
\end_layout

\begin_layout Standard
Sequents are nodes and proofs are edges in the proof search tree
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search example I
\end_layout

\begin_layout Standard
Example: to prove 
\begin_inset Formula $\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q$
\end_inset


\end_layout

\begin_layout Standard
Root sequent 
\begin_inset Formula $S_{0}:\emptyset\vdash\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{0}$
\end_inset

 with rule 
\begin_inset Formula $R\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{1}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash Q$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{1}$
\end_inset

 with rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{2}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash R\Rightarrow R$
\end_inset

 and 
\begin_inset Formula $S_{3}:Q\vdash Q$
\end_inset


\end_layout

\begin_layout Standard
Sequent 
\begin_inset Formula $S_{3}$
\end_inset

 follows from the 
\begin_inset Formula $Id$
\end_inset

 axiom; it remains to prove 
\begin_inset Formula $S_{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{2}$
\end_inset

 with rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{4}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash R\Rightarrow R$
\end_inset

 and 
\begin_inset Formula $S_{5}:Q\vdash R\Rightarrow R$
\end_inset


\end_layout

\begin_layout Standard
We are stuck here because 
\begin_inset Formula $S_{4}=S_{2}$
\end_inset

 (we are in a loop)
\end_layout

\begin_layout Standard
We can prove 
\begin_inset Formula $S_{5}$
\end_inset

, but that will not help
\end_layout

\begin_layout Standard
So we backtrack (erase 
\begin_inset Formula $S_{4}$
\end_inset

, 
\begin_inset Formula $S_{5}$
\end_inset

) and apply another rule to 
\begin_inset Formula $S_{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{2}$
\end_inset

 with rule 
\begin_inset Formula $R\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{6}:\left(R\Rightarrow R\right)\Rightarrow Q;R\vdash R$
\end_inset


\end_layout

\begin_layout Standard
Sequent 
\begin_inset Formula $S_{6}$
\end_inset

 follows from the 
\begin_inset Formula $Id$
\end_inset

 axiom
\end_layout

\begin_layout Standard
Therefore we have proved 
\begin_inset Formula $S_{0}$
\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q$
\end_inset

 is derived from no premises, it is a theorem
\end_layout

\begin_layout Standard
\begin_inset Formula $Q.E.D.$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search III: The calculus LJT
\end_layout

\begin_layout Standard
Vorobieff-Hudelmaier-Dyckhoff, 1950-1990
\end_layout

\begin_layout Standard
The Gentzen calculus LJ will loop if rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 is applied 
\begin_inset Formula $\geq2$
\end_inset

 times
\end_layout

\begin_layout Standard
The calculus LJT keeps all rules of LJ except rule 
\begin_inset Formula $L\Rightarrow$
\end_inset


\end_layout

\begin_layout Standard
Replace rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 by pattern-matching on 
\begin_inset Formula $A$
\end_inset

 in the premise 
\begin_inset Formula $A\Rightarrow B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{(}X\text{ is atomic)\,}\frac{\Gamma,X,B\vdash D}{\Gamma,X,{\color{blue}X\Rightarrow B}\vdash D}\:L\Rightarrow_{1}\\
\frac{\Gamma,A\Rightarrow B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\times B)\Rightarrow C}\vdash D}\:L\Rightarrow_{2}\\
\frac{\Gamma,A\Rightarrow C,B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A+B)\Rightarrow C}\vdash D}\:L\Rightarrow_{3}\\
\frac{\Gamma,B\Rightarrow C\vdash A\Rightarrow B\quad\quad\Gamma,C\vdash D}{\Gamma,{\color{blue}(A\Rightarrow B)\Rightarrow C}\vdash D}\:L\Rightarrow_{4}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
When using LJT rules, the proof tree has no loops and terminates
\end_layout

\begin_layout Standard
See 
\begin_inset CommandInset href
LatexCommand href
name "this paper"
target "http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2618"
literal "false"

\end_inset

 for an explicit decreasing measure on the proof tree
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search IV: The calculus LJT
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset


\emph on
It is obvious that it is obvious
\emph default

\begin_inset Quotes erd
\end_inset

 – a mathematician after thinking for a half-hour
\end_layout

\begin_layout Standard
Rule 
\begin_inset Formula $L\Rightarrow_{4}$
\end_inset

 is based on the key theorem: 
\size footnotesize

\begin_inset Formula 
\[
\left(\left(A\Rightarrow B\right)\Rightarrow C\right)\Rightarrow\left(A\Rightarrow B\right)\,\Longleftrightarrow\,\left(B\Rightarrow C\right)\Rightarrow\left(A\Rightarrow B\right)
\]

\end_inset


\end_layout

\begin_layout Standard
The key theorem for rule 
\begin_inset Formula $L\Rightarrow_{4}$
\end_inset

 is attributed to Vorobieff (1958):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Vorobieff-lemma.png
	display false
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\align center

\size footnotesize
[R.
 Dyckhoff, 
\emph on
Contraction-Free Sequent Calculi for Intuitionistic Logic
\emph default
, 1992]
\end_layout

\begin_layout Standard
A stepping stone to this theorem:
\size footnotesize

\begin_inset Formula 
\[
\left(\left(A\Rightarrow B\right)\Rightarrow C\right)\Rightarrow B\Rightarrow C
\]

\end_inset


\size default
Proof (
\emph on
obviously
\emph default
 trivial): 
\begin_inset Formula $f^{\left(A\Rightarrow B\right)\Rightarrow C}\Rightarrow b^{B}\Rightarrow f\:(x^{A}\Rightarrow b)$
\end_inset


\end_layout

\begin_layout Standard

\emph on
Details are left as exercise for the reader
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search V: From deduction rules to code
\end_layout

\begin_layout Standard
The new rules are equivalent to the old rules, therefore...
\end_layout

\begin_layout Standard
Proof of a sequent 
\begin_inset Formula $A,B,C\vdash G$
\end_inset

 
\begin_inset Formula $\Leftrightarrow$
\end_inset

 code/expression 
\begin_inset Formula $t(a,b,c):G$
\end_inset


\end_layout

\begin_layout Standard
Also can be seen as a function 
\begin_inset Formula $t$
\end_inset

 from 
\begin_inset Formula $A,B,C$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Standard
Sequent in a proof follows from an axiom or from a transforming rule
\end_layout

\begin_layout Standard
The two axioms are fixed expressions, 
\begin_inset Formula $x^{A}\Rightarrow x$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Standard
Each rule has a 
\emph on
proof transformer
\emph default
 function: 
\begin_inset Formula $\text{PT}_{R\Rightarrow}$
\end_inset

 , 
\begin_inset Formula $\text{PT}_{L+}$
\end_inset

 , etc.
\end_layout

\begin_layout Standard
Examples of proof transformer functions:
\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\vdash C\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A+B}\vdash C}\:L+\\
PT_{L+}(t_{1}^{A\Rightarrow C},t_{2}^{B\Rightarrow C})=x^{A+B}\Rightarrow & \ x\ \text{match}\begin{cases}
a^{A}\Rightarrow t_{1}(a)\\
b^{B}\Rightarrow t_{2}(b)
\end{cases}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\Rightarrow B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\times B)\Rightarrow C}\vdash D}\:L\Rightarrow_{2}\\
PT_{L\Rightarrow_{2}}(f^{\left(A\Rightarrow B\Rightarrow C\right)\Rightarrow D})=g^{A\times B\Rightarrow C}\Rightarrow & f\,(x^{A}\Rightarrow y^{B}\Rightarrow g(x,y))
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Verify that we can indeed produce PTs for every rule of LJT
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search example II: deriving code
\end_layout

\begin_layout Standard
Once a proof tree is found, start from leaves and apply PTs
\end_layout

\begin_layout Standard
For each sequent 
\begin_inset Formula $S_{i}$
\end_inset

, this will derive a 
\series bold
proof expression
\series default
 
\begin_inset Formula $t_{i}$
\end_inset


\end_layout

\begin_layout Standard
Example: to prove 
\begin_inset Formula $S_{0}$
\end_inset

, start from 
\begin_inset Formula $S_{6}$
\end_inset

 backwards:
\size footnotesize

\begin_inset Formula 
\begin{align*}
S_{6}:\left(R\Rightarrow R\right)\Rightarrow Q;R\vdash R\quad(\text{axiom }Id)\quad & t_{6}(rrq,r)=r\\
S_{2}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash\left(R\Rightarrow R\right)\quad\text{PT}_{R\Rightarrow}(t_{6})\quad & t_{2}(rrq)=\left(r\Rightarrow t_{6}(rrq,r)\right)\\
S_{3}:Q\vdash Q\quad(\text{axiom }Id)\quad & t_{3}(q)=q\\
S_{1}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash Q\quad\text{PT}_{L\Rightarrow}(t_{2},t_{3})\quad & t_{1}(rrq)=t_{3}(rrq(t_{2}(rrq)))\\
S_{0}:\emptyset\vdash\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q\quad\text{PT}_{R\Rightarrow}(t_{1})\quad & t_{0}=\left(rrq\Rightarrow t_{1}(rrq)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The proof expression for 
\begin_inset Formula $S_{0}$
\end_inset

 is then obtained as
\begin_inset Formula 
\begin{align*}
t_{0} & =rrq\Rightarrow t_{3}\left(rrq\left(t_{2}\left(rrq\right)\right)\right)=rrq\Rightarrow rrq(r\Rightarrow t_{6}\left(rrq,r\right)\\
 & =rrq\Rightarrow rrq\left(r\Rightarrow r\right)
\end{align*}

\end_inset

Simplified final code having the required type: 
\begin_inset Formula 
\[
t_{0}:\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q=\left(rrq\Rightarrow rrq\left(r\Rightarrow r\right)\right)
\]

\end_inset


\end_layout

\begin_layout Section
Intuitionistic propositional logic (IPL)
\end_layout

\begin_layout Standard
The intuitionistic propositional logic (sometimes also called the 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

 propositional logic) describes how programs in functional programming languages
 may be able to compute values of different types.
\end_layout

\begin_layout Standard
The main formal difference between IPL and the classical (Boolean) logic
 is that IPL does not include the axiom of excluded middle (
\begin_inset Quotes eld
\end_inset


\emph on
tertium non datur
\emph default

\begin_inset Quotes erd
\end_inset

), which is 
\begin_inset Formula 
\[
\forall A:(A\text{\emph{ or}}\left(\text{\emph{not}}\left(A\right)\right))\text{ is true}\quad.
\]

\end_inset

However, given just this information, it is not easy to understand the consequen
ces of 
\emph on
not having
\emph default
 this axiom, or to figure out which statements are true in the IPL.
 
\end_layout

\begin_layout Standard
The reason this axiom is not included in IPL is that IPL propositions such
 as 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 correspond to the 
\emph on
practical possibility
\emph default
 of values of type 
\begin_inset Formula $A$
\end_inset

 
\emph on
to be computed
\emph default
 by a program.
 For the proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 to be true in IPL, a program needs to actually compute a value of type
 
\begin_inset Formula $A$
\end_inset

.
 It is not sufficient merely to show that the non-existence of such a value
 would be somehow contradictory.
 But in classical logic, the axiom of excluded middle says that either 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 or 
\begin_inset Formula $\text{\emph{not}}\left({\cal CH}(A)\right)$
\end_inset

 is true.
 So showing that 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{\emph{not}}\left({\cal CH}(A)\right)$
\end_inset


\begin_inset Quotes erd
\end_inset

 is contradictory is sufficient for proving 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

, without ever computing any values of type 
\begin_inset Formula $A$
\end_inset

.
 For this reason, classical (Boolean) logic does not adequately describe
 the logic of types in functional programming, i.e.
\begin_inset space ~
\end_inset

it does not correctly predict the types of values that can be computed by
 functional programs.
\end_layout

\begin_layout Section
Example: The logic of types is not Boolean
\end_layout

\begin_layout Standard
Here is an explicit example of obtaining an incorrect result when using
 classical logic to reason about values computed by functional programs.
 Consider the formula
\begin_inset Formula 
\begin{equation}
\left(A\Rightarrow B+C\right)\Rightarrow\left(A\Rightarrow B\right)+\left(A\Rightarrow C\right)\label{eq:abc-example-classical-logic}
\end{equation}

\end_inset

or, putting in all the parentheses for clarity,
\begin_inset Formula 
\[
\left(A\Rightarrow\left(B+C\right)\right)\Rightarrow\left(\left(A\Rightarrow B\right)+\left(A\Rightarrow C\right)\right)\quad.
\]

\end_inset

This formula is a true theorem in classical logic.
 To prove this, we only need to show that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is always equal to 
\emph on
true
\emph default
 (i.e.
\begin_inset space ~
\end_inset

Boolean value 
\begin_inset Formula $1$
\end_inset

) for any Boolean values of the variables 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

.
 Consider that the only way an implication 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 could be 
\emph on
false
\emph default
 (that is, equal to 
\begin_inset Formula $0$
\end_inset

) in Boolean logic is when 
\begin_inset Formula $A=1$
\end_inset

 and 
\begin_inset Formula $B=0$
\end_inset

.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be false only if 
\begin_inset Formula $\left(A\Rightarrow B+C\right)=1$
\end_inset

 and 
\begin_inset Formula $\left(A\Rightarrow B\right)+\left(A\Rightarrow C\right)=0$
\end_inset

.
 The disjunction can be false only when both parts are false; so we must
 have 
\begin_inset Formula $\left(A\Rightarrow B\right)=0$
\end_inset

 and 
\begin_inset Formula $\left(A\Rightarrow C\right)=0$
\end_inset

.
 This is only possible if 
\begin_inset Formula $A=1$
\end_inset

 and 
\begin_inset Formula $B=C=0$
\end_inset

.
 But, with these value assignments, we find 
\begin_inset Formula $\left(A\Rightarrow B+C\right)=0$
\end_inset

 rather than 
\begin_inset Formula $1$
\end_inset

.
 So, we cannot ever make Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) equal to 
\begin_inset Formula $0$
\end_inset

 as a Boolean formula.
 This shows Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to be a 
\begin_inset Quotes eld
\end_inset

classically valid
\begin_inset Quotes erd
\end_inset

 formula, i.e.
\begin_inset space ~
\end_inset

a theorem that holds in classical Boolean logic.
\end_layout

\begin_layout Standard
If we use the Curry-Howard correspondence and apply Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to propositions such as 
\begin_inset Formula ${\cal CH}\left(A\right)$
\end_inset

, 
\begin_inset Formula ${\cal CH}\left(B\right)$
\end_inset

, 
\begin_inset Formula ${\cal CH}\left(C\right)$
\end_inset

, we obtain the statement that a program should be able to compute a value
 of type 
\begin_inset Formula $\left(A\Rightarrow B\right)+\left(A\Rightarrow C\right)$
\end_inset

 given a value of type 
\begin_inset Formula $A\Rightarrow B+C$
\end_inset

.
 In Scala, such a program would be written as a function with the following
 type signature,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def bad[A, B, C](g: A => Either[B, C]): Either[A=>B, A=>C] = ???
\end_layout

\end_inset

However, it is impossible to implement this function in Scala as a total
 function.
\end_layout

\begin_layout Standard
To help build an intuition for the impossibility of implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

, consider that the only available data is a function 
\begin_inset Formula $g:A\Rightarrow B+C$
\end_inset

, which may return values of type 
\begin_inset Formula $B$
\end_inset

 or 
\begin_inset Formula $C$
\end_inset

 depending on the input value of type 
\begin_inset Formula $A$
\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

 must return either a function of type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 or a function of type 
\begin_inset Formula $A\Rightarrow C$
\end_inset

.
 Can we create a function of type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

? Given a value of type 
\begin_inset Formula $A$
\end_inset

, we need to compute a value of type 
\begin_inset Formula $B$
\end_inset

.
 Since the type 
\begin_inset Formula $B$
\end_inset

 is completely arbitrary (it is a type parameter), we cannot produce a value
 of type 
\begin_inset Formula $B$
\end_inset

 from scratch.
 The only potential source of values of type 
\begin_inset Formula $B$
\end_inset

 is the input function 
\begin_inset Formula $g$
\end_inset

.
 However, 
\begin_inset Formula $g$
\end_inset

 may produce values of type 
\begin_inset Formula $C$
\end_inset

 for some values of type 
\begin_inset Formula $A$
\end_inset

.
 So, in general, we cannot build a function of type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 out of the function 
\begin_inset Formula $g$
\end_inset

.
 Similarly, we find that we cannot build a function of type 
\begin_inset Formula $A\Rightarrow C$
\end_inset

 out of 
\begin_inset Formula $g$
\end_inset

.
 
\end_layout

\begin_layout Standard
The decision about whether to return 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 or 
\begin_inset Formula $A\Rightarrow C$
\end_inset

 must be somehow made in the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

.
 The only input data is the function 
\begin_inset Formula $g$
\end_inset

 that takes an argument of type 
\begin_inset Formula $A$
\end_inset

.
 We could imagine calling 
\begin_inset Formula $g$
\end_inset

 on various arguments of type 
\begin_inset Formula $A$
\end_inset

 and to see whether 
\begin_inset Formula $g$
\end_inset

 returns a 
\begin_inset Formula $B$
\end_inset

 or a 
\begin_inset Formula $C$
\end_inset

.
 However, the type 
\begin_inset Formula $A$
\end_inset

 is unknown, so the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

 cannot produce any values of that type and call 
\begin_inset Formula $g$
\end_inset

.
 So the decision about whether to return 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 or 
\begin_inset Formula $A\Rightarrow C$
\end_inset

 must be made regardless of the function 
\begin_inset Formula $g$
\end_inset

.
 Whichever we choose to return, 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 or 
\begin_inset Formula $A\Rightarrow C$
\end_inset

, we will not be able to return a result value of the required type.
\end_layout

\begin_layout Standard
We could try to switch between 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 and 
\begin_inset Formula $A\Rightarrow C$
\end_inset

 depending on a given value of type 
\begin_inset Formula $A$
\end_inset

.
 This, however, corresponds to a different type signature: 
\begin_inset Formula 
\[
\left(A\Rightarrow B+C\right)\Rightarrow A\Rightarrow\left(A\Rightarrow B\right)+\left(A\Rightarrow C\right)\quad.
\]

\end_inset

This type signature 
\emph on
can
\emph default
 be implemented, for instance, by this Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A, B, C](g: A => Either[B, C]): A => Either[A=>B, A=>C] = { a =>
\end_layout

\begin_layout Plain Layout

  g(a) match {
\end_layout

\begin_layout Plain Layout

    case Left(b) => Left(_ => b)
\end_layout

\begin_layout Plain Layout

    case Right(c) => Right(_ => c)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

But this is not the type signature that describes Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) via the Curry-Howard correspondence.
\end_layout

\begin_layout Standard
In the IPL, it turns out that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is not a valid theorem, i.e.
\begin_inset space ~
\end_inset

it is impossible to find a proof of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) using the axioms and the derivation rules of the IPL.
 To 
\emph on
prove
\emph default
 that there is no proof, one needs to use methods of proof theory that are
 beyond the scope of this book.
 A good introduction to the required technique is the book 
\begin_inset Quotes eld
\end_inset


\emph on
Proof and Disproof in Formal Logic
\emph default

\begin_inset Quotes erd
\end_inset

 by R.
\begin_inset space ~
\end_inset

Bornat.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "R. Bornat, \"Proof and Disproof in Formal Logic\", Oxford, 2005 - link to Amazon.com"
target "https://www.amazon.com/Proof-Disproof-Formal-Logic-Introduction/dp/0198530277"
literal "false"

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
This example illustrates that it is precisely the valid theorems in the
 IPL, and not the valid theorems in the Boolean logic, that correspond to
 implementable functional programs.
\end_layout

\begin_layout Section
Using truth values in Boolean logic and in IPL
\end_layout

\begin_layout Standard
Another significant difference between IPL and the Boolean logic is that
 propositions in IPL cannot be assigned a fixed set of 
\begin_inset Quotes eld
\end_inset

truth values
\begin_inset Quotes erd
\end_inset

.
 This was proved by Gödel in 1935.
 It means that a proposition in IPL cannot be decided by writing out a truth
 table, even if we allow more than two truth values.
\end_layout

\begin_layout Chapter
Category theory
\end_layout

\begin_layout Standard
Examples of categories
\end_layout

\begin_layout Enumerate
Objects: types 
\begin_inset Formula $\text{Int}$
\end_inset

, 
\begin_inset Formula $\text{String}$
\end_inset

, ...; morphisms (arrows) are functions 
\begin_inset Formula $\text{Int}\rightarrow\text{String}$
\end_inset

 etc.
 – this is the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 category corresponding to a given programming language
\end_layout

\begin_layout Enumerate
Objects: types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, ...; morphisms are pairs of functions 
\begin_inset Formula $\left(A\rightarrow B\right),\left(B\rightarrow A\right)$
\end_inset


\end_layout

\begin_layout Enumerate
* Objects: types 
\begin_inset Formula $\text{List}^{A}$
\end_inset

, 
\begin_inset Formula $\text{List}^{B}$
\end_inset

, ...; morphisms are functions of type 
\begin_inset Formula $\text{List}^{A}\rightarrow\text{List}^{B}$
\end_inset


\end_layout

\begin_layout Enumerate
Objects: types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, ...; morphisms are functions of type 
\begin_inset Formula $\text{List}^{A}\rightarrow\text{List}^{B}$
\end_inset


\end_layout

\begin_layout Enumerate
Objects: types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, ...; morphisms are functions of type 
\begin_inset Formula $A\rightarrow\text{List}^{B}$
\end_inset


\end_layout

\begin_layout Enumerate
* Objects: types 
\begin_inset Formula $\text{List}^{A}$
\end_inset

, 
\begin_inset Formula $\text{List}^{B}$
\end_inset

, ...; morphisms are functions 
\begin_inset Formula $A\rightarrow B$
\end_inset


\end_layout

\begin_layout Enumerate
Objects: types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, ...; morphisms are 
\begin_inset Formula $\text{List}^{A\rightarrow B}$
\end_inset


\end_layout

\begin_layout Enumerate
Objects: types 
\begin_inset Formula $A,$
\end_inset

 
\begin_inset Formula $B$
\end_inset

, ...; morphisms are functions 
\begin_inset Formula $B\rightarrow A$
\end_inset


\end_layout

\begin_layout Enumerate
* Objects: things 
\begin_inset Formula $A,$
\end_inset

 
\begin_inset Formula $B$
\end_inset

, ...; morphisms are pairs 
\begin_inset Formula $\left(A,B\right)$
\end_inset

 of things – this is the same as a preorder
\end_layout

\begin_layout Standard
Examples marked with * are for illustration only, they are probably not
 very useful
\end_layout

\begin_layout Chapter
A humorous disclaimer
\end_layout

\begin_layout Standard

\emph on
The following text is quoted in part from an anonymous source (
\begin_inset Quotes eld
\end_inset

Project Guten Tag
\begin_inset Quotes erd
\end_inset

) dating back at least to 1997.
 The original text is no longer available on the Internet.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\noun on
Warranto Limitensis; Disclamatantus Damagensis
\end_layout

\begin_layout Standard
Solus exceptus 
\begin_inset Quotes eld
\end_inset

Rectum Replacator Refundiens
\begin_inset Quotes erd
\end_inset

 describitus ecci,
\end_layout

\begin_layout Enumerate
Projectus (etque nunquam partum quis hic etext remitibus cum 
\noun on
Project Guten Tag
\noun default
-tm identificator) disclamabat omni liabilitus tuus damagensis, pecuniensisque,
 includibantus pecunia legalitus, et 
\end_layout

\begin_layout Enumerate

\noun on
Remedia Negligentitia Non Habet Tuus, Warrantus Destructi
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

bus Contractus Nullibus Ni Liabilitus Sumus, Inclutatibus Non Limitatus
 Destructio Directibus, Consequentius, Punitio, O Incidentus, Non Sunt Si
 Nos Notificat Vobis
\noun default
.
 
\end_layout

\begin_layout Standard
Sit discubriatus defectus en etextum sic entram diariam noventam recibidio,
 pecuniam tuum refundatorium receptorus posset, sic scribatis vendor.
 Sit veniabat medium physicalis, vobis idem reternat et replacator possit
 copius.
 Sit venitabat electronicabilis, sic viri datus chansus segundibus.
 
\end_layout

\begin_layout Standard

\noun on
Hic Etext Venid 
\begin_inset Quotes eld
\end_inset

Como-asi
\begin_inset Quotes erd
\end_inset

.
 Nihil Warranti Nunquam Classum, Expressito Ni Implicato, Le Macchen Como
 Si Etexto Bene Sit O Il Medio Bene Sit, Inclutat Et Non Limitat Warranti
 Mercatensis, Appropriatensis Purposem.
 
\end_layout

\begin_layout Standard
Statuen varias non permitatent disclamabaris ni warranti implicatoren ni
 exclusioni limitatio damagaren consequentialis, ecco lo qua disclamatori
 exclusato
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

rique non vobis applicant, et potat optia alia legali.
\end_layout

\begin_layout Chapter
GNU Free Documentation License
\begin_inset CommandInset label
LatexCommand label
name "sec:GFDL"

\end_inset

 
\end_layout

\begin_layout Standard

\size tiny
Version 1.2, November 2002
\end_layout

\begin_layout Standard

\size tiny
Copyright (c) 2000,2001,2002 Free Software Foundation, Inc.
 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
\end_layout

\begin_layout Standard

\size tiny
Everyone is permitted to copy and distribute verbatim copies of this license
 document, but changing it is not allowed.
\end_layout

\begin_layout Standard

\size tiny
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
setcounter{subsection}{-1}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*

\size tiny
Preamble
\end_layout

\begin_layout Standard

\size tiny
The purpose of this License is to make a manual, textbook, or other functional
 and useful document free in the sense of freedom: to assure everyone the
 effective freedom to copy and redistribute it, with or without modifying
 it, either commercially or noncommercially.
 Secondarily, this License preserves for the author and publisher a way
 to get credit for their work, while not being considered responsible for
 modifications made by others.
\end_layout

\begin_layout Standard

\size tiny
This License is a kind of “copyleft
\begin_inset Quotes erd
\end_inset

, which means that derivative works of the document must themselves be free
 in the same sense.
 It complements the GNU General Public License, which is a copyleft license
 designed for free software.
\end_layout

\begin_layout Standard

\size tiny
We have designed this License in order to use it for manuals for free software,
 because free software needs free documentation: a free program should come
 with manuals providing the same freedoms that the software does.
 But this License is not limited to software manuals; it can be used for
 any textual work, regardless of subject matter or whether it is published
 as a printed book.
 We recommend this License principally for works whose purpose is instruction
 or reference.
\end_layout

\begin_layout Subsection
Applicability and definitions
\begin_inset CommandInset label
LatexCommand label
name "subsec:1Applicability-and-definitions"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
This License applies to any manual or other work, in any medium, that contains
 a notice placed by the copyright holder saying it can be distributed under
 the terms of this License.
 Such a notice grants a world-wide, royalty-free license, unlimited in duration,
 to use that work under the conditions stated herein.
 The “Document'', below, refers to any such manual or work.
 Any member of the public is a licensee, and is addressed as “you''.
 You accept the license if you copy, modify or distribute the work in a
 way requiring permission under copyright law.
\end_layout

\begin_layout Standard

\size tiny
A “Modified Version
\begin_inset Quotes erd
\end_inset

 of the Document means any work containing the Document or a portion of
 it, either copied verbatim, or with modifications and/or translated into
 another language.
\end_layout

\begin_layout Standard

\size tiny
A “Secondary Section
\begin_inset Quotes erd
\end_inset

 is a named appendix or a front-matter section of the Document that deals
 exclusively with the relationship of the publishers or authors of the Document
 to the Document's overall subject (or to related matters) and contains
 nothing that could fall directly within that overall subject.
 (Thus, if the Document is in part a textbook of mathematics, a Secondary
 Section may not explain any mathematics.) The relationship could be a matter
 of historical connection with the subject or with related matters, or of
 legal, commercial, philosophical, ethical or political position regarding
 them.
\end_layout

\begin_layout Standard

\size tiny
The “Invariant Sections'' are certain Secondary Sections whose titles are
 designated, as being those of Invariant Sections, in the notice that says
 that the Document is released under this License.
 If a section does not fit the above definition of Secondary then it is
 not allowed to be designated as Invariant.
 The Document may contain zero Invariant Sections.
 If the Document does not identify any Invariant Sections then there are
 none.
\end_layout

\begin_layout Standard

\size tiny
The “Cover Texts'' are certain short passages of text that are listed, as
 Front-Cover Texts or Back-Cover Texts, in the notice that says that the
 Document is released under this License.
 A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be
 at most 25 words.
\end_layout

\begin_layout Standard

\size tiny
A “Transparent'' copy of the Document means a machine-readable copy, represented
 in a format whose specification is available to the general public, that
 is suitable for revising the document straightforwardly with generic text
 editors or (for images composed of pixels) generic paint programs or (for
 drawings) some widely available drawing editor, and that is suitable for
 input to text formatters or for automatic translation to a variety of formats
 suitable for input to text formatters.
 A copy made in an otherwise Transparent file format whose markup, or absence
 of markup, has been arranged to thwart or discourage subsequent modification
 by readers is not Transparent.
 An image format is not Transparent if used for any substantial amount of
 text.
 A copy that is not “Transparent'' is called “Opaque
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard

\size tiny
Examples of suitable formats for Transparent copies include plain ASCII
 without markup, Texinfo input format, \SpecialChar LaTeX
 input format, SGML or XML using
 a publicly available DTD, and standard-conforming simple HTML, PostScript
 or PDF designed for human modification.
 Examples of transparent image formats include PNG, XCF and JPG.
 Opaque formats include proprietary formats that can be read and edited
 only by proprietary word processors, SGML or XML for which the DTD and/or
 processing tools are not generally available, and the machine-generated
 HTML, PostScript or PDF produced by some word processors for output purposes
 only.
\end_layout

\begin_layout Standard

\size tiny
The 
\begin_inset Quotes eld
\end_inset

Title Page
\begin_inset Quotes erd
\end_inset

 means, for a printed book, the title page itself, plus such following pages
 as are needed to hold, legibly, the material this License requires to appear
 in the title page.
 For works in formats which do not have any title page as such, “Title Page”
 means the text near the most prominent appearance of the work's title,
 preceding the beginning of the body of the text.
\end_layout

\begin_layout Standard

\size tiny
A section 
\begin_inset Quotes eld
\end_inset

Entitled XYZ
\begin_inset Quotes erd
\end_inset

 means a named subunit of the Document whose title either is precisely XYZ
 or contains XYZ in parentheses following text that translates XYZ in another
 language.
 (Here XYZ stands for a specific section name mentioned below, such as “Acknowle
dgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the
 Title” of such a section when you modify the Document means that it remains
 a section “Entitled XYZ” according to this definition.
\end_layout

\begin_layout Standard

\size tiny
The Document may include Warranty Disclaimers next to the notice which states
 that this License applies to the Document.
 These Warranty Disclaimers are considered to be included by reference in
 this License, but only as regards disclaiming warranties: any other implication
 that these Warranty Disclaimers may have is void and has no effect on the
 meaning of this License.
\end_layout

\begin_layout Subsection
Verbatim copying
\begin_inset CommandInset label
LatexCommand label
name "subsec:2Verbatim-copying"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
You may copy and distribute the Document in any medium, either commercially
 or noncommercially, provided that this License, the copyright notices,
 and the license notice saying this License applies to the Document are
 reproduced in all copies, and that you add no other conditions whatsoever
 to those of this License.
 You may not use technical measures to obstruct or control the reading or
 further copying of the copies you make or distribute.
 However, you may accept compensation in exchange for copies.
 If you distribute a large enough number of copies you must also follow
 the conditions in section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:3Copying-in-quantity"

\end_inset

.
\end_layout

\begin_layout Standard

\size tiny
You may also lend copies, under the same conditions stated above, and you
 may publicly display copies.
\end_layout

\begin_layout Subsection
Copying in quantity
\begin_inset CommandInset label
LatexCommand label
name "subsec:3Copying-in-quantity"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
If you publish printed copies (or copies in media that commonly have printed
 covers) of the Document, numbering more than 100, and the Document's license
 notice requires Cover Texts, you must enclose the copies in covers that
 carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on
 the front cover, and Back-Cover Texts on the back cover.
 Both covers must also clearly and legibly identify you as the publisher
 of these copies.
 The front cover must present the full title with all words of the title
 equally prominent and visible.
 You may add other material on the covers in addition.
 Copying with changes limited to the covers, as long as they preserve the
 title of the Document and satisfy these conditions, can be treated as verbatim
 copying in other respects.
\end_layout

\begin_layout Standard

\size tiny
If the required texts for either cover are too voluminous to fit legibly,
 you should put the first ones listed (as many as fit reasonably) on the
 actual cover, and continue the rest onto adjacent pages.
\end_layout

\begin_layout Standard

\size tiny
If you publish or distribute Opaque copies of the Document numbering more
 than 100, you must either include a machine-readable Transparent copy along
 with each Opaque copy, or state in or with each Opaque copy a computer-network
 location from which the general network-using public has access to download
 using public-standard network protocols a complete Transparent copy of
 the Document, free of added material.
 If you use the latter option, you must take reasonably prudent steps, when
 you begin distribution of Opaque copies in quantity, to ensure that this
 Transparent copy will remain thus accessible at the stated location until
 at least one year after the last time you distribute an Opaque copy (directly
 or through your agents or retailers) of that edition to the public.
\end_layout

\begin_layout Standard

\size tiny
It is requested, but not required, that you contact the authors of the Document
 well before redistributing any large number of copies, to give them a chance
 to provide you with an updated version of the Document.
\end_layout

\begin_layout Subsection
Modifications
\begin_inset CommandInset label
LatexCommand label
name "subsec:4Modifications"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
You may copy and distribute a Modified Version of the Document under the
 conditions of sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:2Verbatim-copying"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:3Copying-in-quantity"

\end_inset

 above, provided that you release the Modified Version under precisely this
 License, with the Modified Version filling the role of the Document, thus
 licensing distribution and modification of the Modified Version to whoever
 possesses a copy of it.
 In addition, you must do these things in the Modified Version:
\end_layout

\begin_layout Standard

\size tiny
A.
 Use in the Title Page (and on the covers, if any) a title distinct from
 that of the Document, and from those of previous versions (which should,
 if there were any, be listed in the History section of the Document).
 You may use the same title as a previous version if the original publisher
 of that version gives permission.
\end_layout

\begin_layout Standard

\size tiny
B.
 List on the Title Page, as authors, one or more persons or entities responsible
 for authorship of the modifications in the Modified Version, together with
 at least five of the principal authors of the Document (all of its principal
 authors, if it has fewer than five), unless they release you from this
 requirement.
\end_layout

\begin_layout Standard

\size tiny
C.
 State on the Title page the name of the publisher of the Modified Version,
 as the publisher.
\end_layout

\begin_layout Standard

\size tiny
D.
 Preserve all the copyright notices of the Document.
\end_layout

\begin_layout Standard

\size tiny
E.
 Add an appropriate copyright notice for your modifications adjacent to
 the other copyright notices.
\end_layout

\begin_layout Standard

\size tiny
F.
 Include, immediately after the copyright notices, a license notice giving
 the public permission to use the Modified Version under the terms of this
 License, in the form shown in the Addendum below.
\end_layout

\begin_layout Standard

\size tiny
G.
 Preserve in that license notice the full lists of Invariant Sections and
 required Cover Texts given in the Document's license notice.
\end_layout

\begin_layout Standard

\size tiny
H.
 Include an unaltered copy of this License.
\end_layout

\begin_layout Standard

\size tiny
I.
 Preserve the section Entitled 
\begin_inset Quotes eld
\end_inset

History
\begin_inset Quotes erd
\end_inset

, Preserve its Title, and add to it an item stating at least the title,
 year, new authors, and publisher of the Modified Version as given on the
 Title Page.
 If there is no section Entitled “History” in the Document, create one stating
 the title, year, authors, and publisher of the Document as given on its
 Title Page, then add an item describing the Modified Version as stated
 in the previous sentence.
\end_layout

\begin_layout Standard

\size tiny
J.
 Preserve the network location, if any, given in the Document for public
 access to a Transparent copy of the Document, and likewise the network
 locations given in the Document for previous versions it was based on.
 These may be placed in the 
\begin_inset Quotes eld
\end_inset

History
\begin_inset Quotes erd
\end_inset

 section.
 You may omit a network location for a work that was published at least
 four years before the Document itself, or if the original publisher of
 the version it refers to gives permission.
\end_layout

\begin_layout Standard

\size tiny
K.
 For any section Entitled 
\begin_inset Quotes eld
\end_inset

Acknowledgements
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Dedications
\begin_inset Quotes erd
\end_inset

, Preserve the Title of the section, and preserve in the section all the
 substance and tone of each of the contributor acknowledgements and/or dedicatio
ns given therein.
\end_layout

\begin_layout Standard

\size tiny
L.
 Preserve all the Invariant Sections of the Document, unaltered in their
 text and in their titles.
 Section numbers or the equivalent are not considered part of the section
 titles.
\end_layout

\begin_layout Standard

\size tiny
M.
 Delete any section Entitled 
\begin_inset Quotes eld
\end_inset

Endorsements
\begin_inset Quotes erd
\end_inset

.
 Such a section may not be included in the Modified Version.
\end_layout

\begin_layout Standard

\size tiny
N.
 Do not retitle any existing section to be Entitled 
\begin_inset Quotes eld
\end_inset

Endorsements
\begin_inset Quotes erd
\end_inset

 or to conflict in title with any Invariant Section.
\end_layout

\begin_layout Standard

\size tiny
O.
 Preserve any Warranty Disclaimers.
\end_layout

\begin_layout Standard

\size tiny
If the Modified Version includes new front-matter sections or appendices
 that qualify as Secondary Sections and contain no material copied from
 the Document, you may at your option designate some or all of these sections
 as invariant.
 To do this, add their titles to the list of Invariant Sections in the Modified
 Version's license notice.
 These titles must be distinct from any other section titles.
\end_layout

\begin_layout Standard

\size tiny
You may add a section Entitled 
\begin_inset Quotes eld
\end_inset

Endorsements
\begin_inset Quotes erd
\end_inset

, provided it contains nothing but endorsements of your Modified Version
 by various parties – for example, statements of peer review or that the
 text has been approved by an organization as the authoritative definition
 of a standard.
\end_layout

\begin_layout Standard

\size tiny
You may add a passage of up to five words as a Front-Cover Text, and a passage
 of up to 25 words as a Back-Cover Text, to the end of the list of Cover
 Texts in the Modified Version.
 Only one passage of Front-Cover Text and one of Back-Cover Text may be
 added by (or through arrangements made by) any one entity.
 If the Document already includes a cover text for the same cover, previously
 added by you or by arrangement made by the same entity you are acting on
 behalf of, you may not add another; but you may replace the old one, on
 explicit permission from the previous publisher that added the old one.
\end_layout

\begin_layout Standard

\size tiny
The author(s) and publisher(s) of the Document do not by this License give
 permission to use their names for publicity for or to assert or imply endorseme
nt of any Modified Version.
\end_layout

\begin_layout Subsection*

\size tiny
Combining documents
\end_layout

\begin_layout Standard

\size tiny
You may combine the Document with other documents released under this License,
 under the terms defined in section 4 above for modified versions, provided
 that you include in the combination all of the Invariant Sections of all
 of the original documents, unmodified, and list them all as Invariant Sections
 of your combined work in its license notice, and that you preserve all
 their Warranty Disclaimers.
\end_layout

\begin_layout Standard

\size tiny
The combined work need only contain one copy of this License, and multiple
 identical Invariant Sections may be replaced with a single copy.
 If there are multiple Invariant Sections with the same name but different
 contents, make the title of each such section unique by adding at the end
 of it, in parentheses, the name of the original author or publisher of
 that section if known, or else a unique number.
 Make the same adjustment to the section titles in the list of Invariant
 Sections in the license notice of the combined work.
\end_layout

\begin_layout Standard

\size tiny
In the combination, you must combine any sections Entitled “History” in
 the various original documents, forming one section Entitled “History”;
 likewise combine any sections Entitled “Acknowledgements”, and any sections
 Entitled “Dedications”.
 You must delete all sections Entitled “Endorsements.”
\end_layout

\begin_layout Subsection*

\size tiny
Collections of documents
\end_layout

\begin_layout Standard

\size tiny
You may make a collection consisting of the Document and other documents
 released under this License, and replace the individual copies of this
 License in the various documents with a single copy that is included in
 the collection, provided that you follow the rules of this License for
 verbatim copying of each of the documents in all other respects.
\end_layout

\begin_layout Standard

\size tiny
You may extract a single document from such a collection, and distribute
 it individually under this License, provided you insert a copy of this
 License into the extracted document, and follow this License in all other
 respects regarding verbatim copying of that document.
\end_layout

\begin_layout Subsection*

\size tiny
Aggregation with independent works
\end_layout

\begin_layout Standard

\size tiny
A compilation of the Document or its derivatives with other separate and
 independent documents or works, in or on a volume of a storage or distribution
 medium, is called an “aggregate” if the copyright resulting from the compilatio
n is not used to limit the legal rights of the compilation's users beyond
 what the individual works permit.
 When the Document is included an aggregate, this License does not apply
 to the other works in the aggregate which are not themselves derivative
 works of the Document.
\end_layout

\begin_layout Standard

\size tiny
If the Cover Text requirement of section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:3Copying-in-quantity"

\end_inset

 is applicable to these copies of the Document, then if the Document is
 less than one half of the entire aggregate, the Document's Cover Texts
 may be placed on covers that bracket the Document within the aggregate,
 or the electronic equivalent of covers if the Document is in electronic
 form.
 Otherwise they must appear on printed covers that bracket the whole aggregate.
\end_layout

\begin_layout Subsection*

\size tiny
Translation
\end_layout

\begin_layout Standard

\size tiny
Translation is considered a kind of modification, so you may distribute
 translations of the Document under the terms of section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:4Modifications"

\end_inset

.
 Replacing Invariant Sections with translations requires special permission
 from their copyright holders, but you may include translations of some
 or all Invariant Sections in addition to the original versions of these
 Invariant Sections.
 You may include a translation of this License, and all the license notices
 in the Document, and any Warrany Disclaimers, provided that you also include
 the original English version of this License and the original versions
 of those notices and disclaimers.
 In case of a disagreement between the translation and the original version
 of this License or a notice or disclaimer, the original version will prevail.
\end_layout

\begin_layout Standard

\size tiny
If a section in the Document is Entitled “Acknowledgements”, “Dedications”,
 or “History”, the requirement (section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:4Modifications"

\end_inset

) to Preserve its Title (section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:1Applicability-and-definitions"

\end_inset

) will typically require changing the actual title.
\end_layout

\begin_layout Subsection*

\size tiny
Termination
\end_layout

\begin_layout Standard

\size tiny
You may not copy, modify, sublicense, or distribute the Document except
 as expressly provided for under this License.
 Any other attempt to copy, modify, sublicense or distribute the Document
 is void, and will automatically terminate your rights under this License.
 However, parties who have received copies, or rights, from you under this
 License will not have their licenses terminated so long as such parties
 remain in full compliance.
\end_layout

\begin_layout Subsection*

\size tiny
Future revisions of this license
\end_layout

\begin_layout Standard

\size tiny
The Free Software Foundation may publish new, revised versions of the GNU
 Free Documentation License from time to time.
 Such new versions will be similar in spirit to the present version, but
 may differ in detail to address new problems or concerns.
 See 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
url{http://www.gnu.org/copyleft/}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard

\size tiny
Each version of the License is given a distinguishing version number.
 If the Document specifies that a particular numbered version of this License
 “or any later version” applies to it, you have the option of following
 the terms and conditions either of that specified version or of any later
 version that has been published (not as a draft) by the Free Software Foundatio
n.
 If the Document does not specify a version number of this License, you
 may choose any version ever published (not as a draft) by the Free Software
 Foundation.
\end_layout

\begin_layout Subsection*

\size tiny
\noun on
Addendum
\noun default
: How to use this License for your documents
\end_layout

\begin_layout Standard

\size tiny
To use this License in a document you have written, include a copy of the
 License in the document and put the following copyright and license notices
 just after the title page:
\end_layout

\begin_layout Standard

\size tiny
Copyright (c) <year> <your name>.
 Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.2 or any later
 version published by the Free Software Foundation; with no Invariant Sections,
 no Front-Cover Texts, and no Back-Cover Texts.
 A copy of the license is included in the section entitled “GNU Free Documentati
on License”.
\end_layout

\begin_layout Standard

\size tiny
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
 replace the “with...Texts.” line with this:
\end_layout

\begin_layout Standard

\size tiny
with the Invariant Sections being <list their titles>, with the Front-Cover
 Texts being <list>, and with the Back-Cover Texts being <list>.
\end_layout

\begin_layout Standard

\size tiny
If you have Invariant Sections without Cover Texts, or some other combination
 of the three, merge those two alternatives to suit the situation.
\end_layout

\begin_layout Standard

\size tiny
If your document contains nontrivial examples of program code, we recommend
 releasing these examples in parallel under your choice of free software
 license, such as the GNU General Public License, to permit their use in
 free software.
\end_layout

\begin_layout Subsection*

\size tiny
Copyright 
\end_layout

\begin_layout Standard

\size tiny
Copyright (c) 2000, 2001, 2002 Free Software Foundation, Inc.
 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
\end_layout

\begin_layout Standard

\size tiny
Everyone is permitted to copy and distribute verbatim copies of this license
 document, but changing it is not allowed.
\end_layout

\end_body
\end_document
