
\chapter{Mathematical formulas as code. I. Nameless functions\label{chap:1-Values,-types,-expressions,}}

\section{Translating mathematics into code}

\subsection{First examples}

We begin by writing Scala code for some computational tasks.

\paragraph{Factorial of 10}

Find the product of integers from $1$ to $10$ (the \textbf{factorial\index{factorial function}}
of 10).

First, we write a mathematical formula for the result:
\[
\prod_{k=1}^{10}k\quad.
\]
We can then write Scala code in a way that resembles this formula:
\begin{lstlisting}
scala> (1 to 10).product
res0: Int = 3628800
\end{lstlisting}

The Scala interpreter indicates that the result is the value $3628800$
of type \lstinline!Int!. To define a name for this value, we use
the ``\lstinline!val!'' syntax:
\begin{lstlisting}
scala> val fac10 = (1 to 10).product
fac10: Int = 3628800

scala> fac10 == 3628800
res1: Boolean = true
\end{lstlisting}

The code \texttt{}\lstinline!(1 to 10).product! is an \textbf{expression}\index{expression},
which means that (1) the code can be evaluated (e.g.~using the Scala
interpreter) and yields a value, and (2) the code can be inserted
as a part of a larger expression. For example, we could write
\begin{lstlisting}
scala> 100 + (1 to 10).product + 100
res0: Int = 3629000
\end{lstlisting}


\paragraph{Factorial as a function}

Define a function that takes an integer $n$ and computes the factorial
of $n$.

A mathematical formula for this function can be written as
\[
f\left(n\right)=\prod_{k=1}^{n}k\quad.
\]
The corresponding Scala code is
\begin{lstlisting}
def f(n:Int) = (1 to n).product
\end{lstlisting}

In Scala's \texttt{}\lstinline!def! syntax, we need to specify the
type of a function's argument; in this case, we write \lstinline!n:Int!.
In the usual mathematical notation, types of arguments are either
not written at all, or written separately from the formula:
\[
f(n)=\prod_{k=1}^{n}k,\quad\forall n\in\mathbb{N}\quad.
\]
This indicates that $n$ must be from the set of non-negative integers
(denoted by $\mathbb{N}$ in mathematics). This is similar to specifying
the type \texttt{}\lstinline!Int! in the Scala code. So, the argument's
type in the code specifies the \emph{domain} of a function.

Having defined the function \lstinline!f!, we can now apply it to
an integer argument: 
\begin{lstlisting}
scala> f(10)
res6: Int = 3628800
\end{lstlisting}
It is an error to apply \lstinline!f! to a non-integer value, e.g.\ to
a string:
\begin{lstlisting}
scala> f("abc")
<console>:13: error: type mismatch;
 found   : String("abc")
 required: Int
       f("abc")
         ^ 
\end{lstlisting}


\subsection{Nameless functions\label{subsec:Nameless-functions}}

The formula and the code, as written above, both involve \emph{naming}
the function as ``$f$''. Sometimes a function does not really need
a name, \textendash{} for instance, if the function is used only once.
I denote ``nameless'' mathematical functions like this: 
\[
x\Rightarrow\left(\text{some formula}\right)\quad.
\]
Then the mathematical notation for the nameless factorial function
is
\[
n\Rightarrow\prod_{k=1}^{n}k\quad.
\]
This reads as ``a function that maps $n$ to the product of all $k$
where $k$ goes from $1$ to $n$''. The Scala expression implementing
this mathematical formula is
\begin{lstlisting}
(n: Int) => (1 to n).product
\end{lstlisting}
This expression shows Scala's syntax for a \textbf{nameless}\index{nameless function}
function. Here, 
\begin{lstlisting}
n: Int
\end{lstlisting}
is the function's \textbf{argument}, while
\begin{lstlisting}
(1 to n).product
\end{lstlisting}
is the function's \textbf{body}. The arrow symbol \lstinline!=>!
separates the argument from the body.\footnote{In Scala, the two ASCII characters \lstinline!=>! and the single
Unicode character $\Rightarrow$ have the same meaning. I use the
symbol $\Rightarrow$ (pronounced ``maps to'') in this book. However,
when doing calculations \emph{by hand}, I tend to write $\rightarrow$
instead of $\Rightarrow$ since it is faster. Several programming
languages, such as OCaml and Haskell, use the symbols \lstinline!->!
or the Unicode equivalent, $\rightarrow$, for the function arrow.} 

Functions in Scala (whether named or nameless) are treated as values\index{function value},
which means that we can also define a Scala value as
\begin{lstlisting}
scala> val fac = (n: Int) => (1 to n).product
fac: Int => Int = <function1>
\end{lstlisting}
We see that the value \lstinline!fac! has the type \lstinline!Int => Int!,
which means that the function takes an integer (\lstinline!Int!)
argument and returns an integer result value. What is the value of
the function \lstinline!fac! \emph{itself}? As we have just seen,
the Scala interpreter prints \lstinline!<function1>! as the ``value''
of \lstinline!fac!. An alternative Scala interpreter\footnote{\texttt{\href{https://ammonite.io/}{https://ammonite.io/}}}
called \texttt{ammonite} prints something like this,
\begin{lstlisting}
scala@ val fac = (n: Int) => (1 to n).product
fac: Int => Int = ammonite.$sess.cmd0$$$Lambda$1675/2107543287@1e44b638
\end{lstlisting}
This seems to indicate some identifying number, or perhaps a memory
location.

I usually imagine that a ``function value'' represents a block\emph{
}of compiled machine code,  \textendash{}  code that will actually
run and evaluate the function's body when the function is applied
to its argument.

Once defined, a function can be applied to an argument like this:
\begin{lstlisting}
scala> fac(10)
res1: Int = 3628800
\end{lstlisting}

However, functions can be used without naming them. We can directly
apply a nameless factorial function to an integer argument \lstinline!10!
instead of writing \lstinline!fac(10)!:
\begin{lstlisting}
scala> ((n: Int) => (1 to n).product)(10)
res2: Int = 3628800
\end{lstlisting}
One would not often write code like this because there is no advantage
in creating a nameless function and then applying it right away to
an argument. This is so because we can evaluate the expression
\begin{lstlisting}
((n: Int) => (1 to n).product)(10)
\end{lstlisting}
by substituting \lstinline!10! instead of \lstinline!n! in the function
body, which gives us
\begin{lstlisting}
(1 to 10).product
\end{lstlisting}

If a nameless function uses the argument several times, for example
\begin{lstlisting}
((n: Int) => n*n*n + n*n)(12345)
\end{lstlisting}
it is still better to substitute the argument and to eliminate the
nameless function. We could have written
\begin{lstlisting}
12345*12345*12345 + 12345*12345
\end{lstlisting}
but, of course, we want to avoid repeating the value \lstinline!12345!.
To achieve that, we may define \texttt{}\lstinline!n! as a value
in an \textbf{expression block\index{expression block}} like this:
\begin{lstlisting}
scala> { val n = 12345; n*n*n + n*n }
res3: Int = 322687002
\end{lstlisting}
Defined in this way, the value \lstinline!n! is visible only within
the expression block. Outside the block, another value named \lstinline!n!
could be defined independently of this \lstinline!n!. For this reason,
the definition of \lstinline!n! is called a \textbf{locally}\index{local scope}
\textbf{scoped} definition.

Nameless functions are most useful when they are themselves arguments
of other functions, as we will see next.

\paragraph{Example: prime numbers}

Let us define a function that takes an integer argument $n$ and determines
whether $n$ is a prime number.

A simple mathematical formula for this function can be written as
\begin{equation}
\text{is\_prime}\left(n\right)=\forall k\in\left[2,n-1\right]\ :\ n\neq0\text{ mod }k\quad.\label{eq:is_prime_def}
\end{equation}
This formula has two clearly separated parts: first, a range of integers
from $2$ to $n-1$, and second, a requirement that all these integers
should satisfy a given condition, $n\neq0\text{ mod }k$. Formula~(\ref{eq:is_prime_def})
is translated into Scala code as
\begin{lstlisting}
def is_prime(n: Int) = (2 to n-1).forall(k => n % k != 0)
\end{lstlisting}
In this code, the two parts of the mathematical formula are implemented
in a way that is closely similar to the mathematical notation, except
for the arrow after $k$.

We can now apply the function \lstinline!is_prime! to some integer
values:
\begin{lstlisting}
scala> is_prime(12)
res3: Boolean = false

scala> is_prime(13)
res4: Boolean = true
\end{lstlisting}
As we can see from the output above, the function \lstinline!is_prime!
returns a value of type \lstinline!Boolean!. Therefore, the function
\lstinline!is_prime! has type \lstinline!Int => Boolean!.

A function that returns a \lstinline!Boolean! value is called a \textbf{predicate}\index{predicate}.

In Scala, it is optional \textendash{} but strongly recommended \textendash{}
to specify the return type of named functions. The required syntax
looks like this,
\begin{lstlisting}
def is_prime(n: Int): Boolean =
  (2 to n-1).forall(k => n % k != 0)
\end{lstlisting}

However, we do not need to specify the type \texttt{}\lstinline!Int!
for the argument \texttt{}\lstinline!k! of the nameless function
\lstinline*k => n % k != 0*. This is because the Scala compiler knows
that \texttt{}\lstinline!k! is going to iterate over the \emph{integer}
elements of the range \lstinline!(2 to n-1)!, which effectively forces
\texttt{}\lstinline!k! to be of type \lstinline!Int!.

\subsection{Nameless functions and bound variables}

The code for \texttt{}\lstinline!is_prime! differs from the mathematical
formula\ (\ref{eq:is_prime_def}) in two ways.

One difference is that the interval $\left[2,n-1\right]$ is in front
of \lstinline!forall!. To understand this, look at the ways Scala
allows programmers to define syntax.

The Scala syntax such as \texttt{}\lstinline!(2 to n-1).forall(k => ...)!
means to apply a function called \texttt{}\lstinline!forall! to
\emph{two} arguments: the first argument is the range \texttt{}\lstinline!(2 to n-1)!\texttt{,}
and the second argument is the nameless function \lstinline!(k => ...)!.
In Scala, the \textbf{infix} syntax\index{infix syntax} \lstinline!x.f(z)!,
or equivalently \lstinline!x f z!, means that a function \texttt{}\lstinline!f!
is applied to its \emph{two} arguments, \texttt{}\lstinline!x! and
\lstinline!z!. In the ordinary mathematical notation, this would
be $f(x,z)$. Infix notation is often easier to read and is also widely
used in mathematics, for instance when we write $x+y$ rather than
something like $plus(x,y)$.

A single-argument function could be also defined with infix notation,
and then the syntax is \lstinline!x.f!, as in the expression \texttt{}\lstinline!(1 to n).product!
we have seen before.

The infix methods \texttt{}\lstinline!.product! and \texttt{}\lstinline!.forall!
are already provided in the Scala standard library, so it is natural
to use them. If we want to avoid the infix syntax, we could define
a function \texttt{}\lstinline!for_all! with two arguments and write
code like this,

\begin{lstlisting}
for_all(2 to n-1, k => n % k != 0)
\end{lstlisting}
This would have brought the syntax somewhat closer to the formula\ (\ref{eq:is_prime_def}). 

However, there still remains the second difference: The symbol $k$
is used as an \emph{argument} of a nameless function \texttt{}\lstinline*(k => n % k != 0)*
in the Scala code,  \textendash{}  while the mathematical notation,
such as 
\[
\forall k\in\left[2,n-1\right]\ :\ n\neq0\text{ mod }k\quad,
\]
does not seem to involve any nameless functions. Instead, the mathematical
formula defines the symbol $k$ that ``goes over the range $\left[2,n-1\right]$,''
as one might say. The symbol $k$ is then used for writing the predicate
$n\neq0\mod k$. 

However, let us investigate the role of the symbol $k$ more closely. 

The symbol $k$ is a mathematical variable that is actually defined
\emph{only inside} the expression ``$\forall k:...$'' and makes
no sense outside that expression. This becomes clear by looking at
Eq.\ (\ref{eq:is_prime_def}): The variable $k$ is not present in
the left-hand side and could not possibly be used there. The name
``$k$'' is defined only in the right-hand side, where it is first
mentioned as the arbitrary element $k\in\left[2,n-1\right]$ and then
used in the sub-expression ``$...\text{ mod }k$''.

So, the mathematical notation
\[
\forall k\in\left[2,n-1\right]\ :\ n\neq0\text{ mod }k
\]
gives two pieces of information: first, we are examining all values
from the given range; second, we chose the name $k$ for the values
from the given range, and for each of those $k$ we need to evaluate
the expression $n\neq0\text{ mod }k$, which is a certain given \emph{function}
\emph{of} $k$ that returns a \lstinline!Boolean! value. Translating
the mathematical notation into code, it is therefore natural to use
a nameless function of $k$,
\[
k\Rightarrow n\neq0\text{ mod }k\quad,
\]
and to write Scala code that applies this nameless function to each
element of the range $\left[2,n-1\right]$ and then requires that
all result values be \lstinline!true!:

\begin{lstlisting}
(2 to n-1).forall(k => n % k != 0)
\end{lstlisting}

Just as the mathematical notation defines the variable $k$ only in
the right-hand side of Eq.\ (\ref{eq:is_prime_def}), the argument
\lstinline!k! of the nameless Scala function \lstinline*k => n % k != 0*
is defined only within that function's body and cannot be used in
any code outside the expression \lstinline*n % k != 0*.

Variables that are defined only inside an expression and are invisible
outside are called \textbf{bound variables}\index{bound variable},
or ``variables bound in an expression''. Variables that are used
in an expression but are defined outside it are called \textbf{free
variables}\index{free variable}, or ``variables occurring free in
an expression''. These concepts apply equally well to mathematical
formulas and to Scala code. For example, in the mathematical expression
$k\Rightarrow n\neq0\text{ mod }k$ (which is a nameless function),
the variable $k$ is bound (it is defined only within that expression)
but the variable $n$ is free (it is defined outside that expression).

The main difference between free and bound variables is that bound
variables can be \emph{locally renamed} at will, unlike free variables.
To see this, consider that we could rename $k$ to $z$ and write
instead of Eq.\ (\ref{eq:is_prime_def}) an equivalent definition
\[
\text{is\_prime}\left(n\right)=\forall z\in\left[2,n-1\right]\ :\ n\neq0\text{ mod }z\quad,
\]
or in Scala code, 
\begin{lstlisting}
(2 to n-1).forall(z => n % z != 0)
\end{lstlisting}
In the nameless function \lstinline*k => n % k != 0*, the argument
\lstinline!k! may be renamed to \lstinline!z! or to anything else,
without changing the value of the entire program. No code outside
this expression needs to be changed after renaming \lstinline!k!
to \lstinline!z!. But the value \lstinline!n! is defined outside
and thus cannot be renamed locally (i.e.~only within the sub-expression).
If, for any reason, we wanted to rename \lstinline!n! in the sub-expression
\lstinline*k => n % k != 0*, we would also need to change every place
in the code that defines and uses \lstinline!n! \emph{outside} that
expression, or else the program would become incorrect.

Mathematical formulas use bound variables in various constructions
such as $\forall k:p(k)$, $\exists k:p(k)$, $\sum_{k=a}^{b}f(k)$,
$\int_{0}^{1}k^{2}dk$, $\lim_{n\rightarrow\infty}f(n)$, and $\text{argmax}_{k}f\left(k\right)$.
When translating mathematical expressions into code, we need to recognize
the presence of bound variables, which the mathematical notation does
not make quite so explicit. For each bound variable, we need to create
a nameless function whose argument is that variable, e.g.\ $k\Rightarrow p(k)$
or $k\Rightarrow f(k)$ for the examples just shown. Only then will
our code correctly reproduce the behavior of bound variables in mathematical
expressions.

As an example, the mathematical formula 
\[
\forall k\in\left[1,n\right]:p\left(k\right)\quad,
\]
has a bound variable $k$ and is translated into Scala code as

\begin{lstlisting}
(1 to n).forall(k => p(k))
\end{lstlisting}
At this point we can apply the following simplification trick to this
code. The nameless function $k\Rightarrow p(k)$ does exactly the
same thing as the (named) function $p$: It takes an argument, which
we may call $k$, and returns $p(k)$. So, we can simplify the Scala
code above to

\begin{lstlisting}
(1 to n).forall(p)
\end{lstlisting}

The simplification of $x\Rightarrow f(x)$ to just $f$ is always
possible for functions $f$ of a single argument.\footnote{Certain features of Scala allow programmers to write code that looks
like \lstinline!f(x)! but actually involves additional implicit or
default arguments of the function \lstinline!f!, or an implicit conversion
for its argument \lstinline!x!. In those cases, replacing the code
\lstinline!x => f(x)! by just \lstinline!f! may fail to compile
in Scala. But these complications do not arise when working with simple
functions.}

\section{Aggregating data from sequences}

Consider the task of finding how many even numbers there are in a
given list $L$ of integers. For example, the list $\left[5,6,7,8,9\right]$
contains \emph{two} even numbers: $6$ and $8$.

A mathematical formula for this task can be written like this,
\begin{align*}
\text{count\_even}\left(L\right) & =\sum_{k\in L}\text{is\_even}\left(k\right)\quad,\\
\text{is\_even}\left(k\right) & =\begin{cases}
1 & \text{if }k=0\text{ mod }2\\
0 & \text{otherwise}
\end{cases}\quad.
\end{align*}
Here we defined a helper function \texttt{}\lstinline!is_even! in
order to write more easily a formula for \lstinline!count_even!.
In mathematics, complicated formulas are often split into simpler
parts by defining helper expressions. 

We can write the Scala code similarly. We first define the helper
function \lstinline!is_even!; the Scala code can be written in the
style quite similar to the mathematical formula:

\begin{lstlisting}
def is_even(k: Int): Int = (k % 2) match {
  case 0 => 1 // First, check if it is zero.
  case _ => 0 // The underscore matches everything else.
}
\end{lstlisting}

For such a simple computation, we could also write shorter code using
a nameless function,

\begin{lstlisting}
val is_even = (k: Int) => if (k % 2 == 0) 1 else 0
\end{lstlisting}

Given this function, we now need to translate into Scala code the
expression $\sum_{k\in L}\text{is\_even}\left(k\right)$. We can represent
the list $L$ using the data type \lstinline!List[Int]! from the
Scala standard library.

To compute $\sum_{k\in L}\text{is\_even}\left(k\right)$, we must
apply the function \texttt{}\lstinline!is_even! to each element
of the list $L$, which will produce a list of some (integer) results,
and then we will need to add all those results together. It is convenient
to perform these two steps separately. This can be done with the functions
\texttt{}\lstinline!.map! and \lstinline!.sum!, defined in the
Scala standard library as infix methods for the data type \lstinline!List!.

The method \texttt{}\lstinline!.sum! is similar to \lstinline!.product!
and is defined for any \lstinline!List! of numerical types (\lstinline!Int!,
\lstinline!Float!, \lstinline!Double!, etc.). It computes the sum
of all numbers in the list:
\begin{lstlisting}
scala> List(1, 2, 3).sum
res0: Int = 6
\end{lstlisting}

The method \texttt{}\lstinline!.map! needs more explanation. This
method takes a \emph{function} as its second argument, applies that
function to each element of the list, and puts all the results into
a \emph{new }list, which is then returned as the result value:

\begin{lstlisting}
scala> List(1, 2, 3).map(x => x*x + 100*x)
res1: List[Int] = List(101, 204, 309)
\end{lstlisting}

In this example, the argument of \lstinline!.map! is the nameless
function $x\Rightarrow x^{2}+100x$. This function is repeatedly applied
by \texttt{}\lstinline!.map! to transform each of the values from
a given list, creating a new list as a result.

It is equally possible to define the transforming function separately,
give it a name, and then pass it as the argument to \lstinline!.map!:
\begin{lstlisting}
scala> def func1(x: Int): Int = x*x + 100*x
func1: (x: Int)Int 

scala> List(1, 2, 3).map(func1)
res2: List[Int] = List(101, 204, 309)
\end{lstlisting}
Usually, short and simple functions are defined inline, while longer
functions are given a name and defined separately.

An infix method, such as \lstinline!.map!, can be also used with
a ``dotless'' syntax:
\begin{lstlisting}
scala> List(1, 2, 3) map func1
res3: List[Int] = List(101, 204, 309)
\end{lstlisting}

If the transforming function \lstinline!func1! is used only once,
and especially for a simple operation such as $x\Rightarrow x^{2}+100x$,
it is easier to work with a nameless function.

We can now combine the methods \texttt{}\lstinline!.map! and \texttt{}\lstinline!.sum!
to define \lstinline!count_even!:

\begin{lstlisting}
def count_even(s: List[Int]) = s.map(is_even).sum
\end{lstlisting}

This code can be also written using a nameless function instead of
\lstinline!is_even!:

\begin{lstlisting}
def count_even(s: List[Int]): Int =
   s
    .map { k => if (k % 2 == 0) 1 else 0 }
    .sum
\end{lstlisting}

It is customary in Scala to use infix methods when chaining several
operations. For instance \lstinline!s.map(...).sum! means first apply
\lstinline!s.map(...)!, which returns a \emph{new} list, and then
apply \texttt{}\lstinline!.sum! to that list. To make the code more
readable, I put each of the chained methods on a new line. 

To test this code, let us run it in the Scala interpreter. In order
to let the interpreter work correctly with code entered line by line,
the dot character needs to be at the end of the line. The interpreter
will automatically insert the visual continuation characters. (In
a compiled code, the dots can be at the beginning of the lines since
the compiler reads the entire code at once.)
\begin{lstlisting}
scala> def count_even(s: List[Int]): Int =
     |    s .
     |     map { k => if (k % 2 == 0) 1 else 0 } .
     |     sum
count_even: (s: List[Int])Int

scala> count_even(List(1,2,3,4,5))
res0: Int = 2

scala> count_even( List(1,2,3,4,5).map(x => x * 2) )
res1: Int = 5
\end{lstlisting}
Note that the Scala interpreter prints the types differently for functions
defined using \lstinline!def!. It prints \lstinline!(s: List[Int])Int!
for the function type that one would normally write as \lstinline!List[Int] => Int!.

\section{Filtering and truncating sequences}

In addition to the methods \lstinline!.sum!, \lstinline!.product!,
\lstinline!.map!, \texttt{}\lstinline!.forall! that we have already
seen, the Scala standard library defines many other useful methods.
We will now take a look at using the methods \lstinline!.max!, \lstinline!.min!,
\lstinline!.exists!, \lstinline!.size!, \lstinline!.filter!, and
\lstinline!.takeWhile!. 

The methods \lstinline!.max!, \lstinline!.min!, and \texttt{}\lstinline!.size!
are self-explanatory:
\begin{lstlisting}
scala> List(10, 20, 30).max
res2: Int = 30

scala> List(10, 20, 30).min
res3: Int = 10

scala> List(10, 20, 30).size
res4: Int = 3
\end{lstlisting}

The methods \lstinline!.forall!, \lstinline!.exists!, \lstinline!.filter!,
and \texttt{}\lstinline!.takeWhile! require a predicate as an argument.
The \texttt{}\lstinline!.forall! method returns \texttt{}\lstinline!true!
iff the predicate is true on all values in the list; the \texttt{}\lstinline!.exists!
method returns \texttt{}\lstinline!true! iff the predicate holds
(returns \lstinline!true!) for at least one value in the list. These
methods can be written as mathematical formulas like this:
\begin{align*}
\text{forall}\left(S,p\right) & =\forall k\in S:p(k)=\text{true}\\
\text{exists}\left(S,p\right) & =\exists k\in S:p(k)=\text{true}
\end{align*}
However, there is no mathematical notation for operations such as
``removing elements from a list'', so we will focus on the Scala
syntax for these functions.

The \lstinline!.filter! method returns a \emph{new list} that contains
only the values for which the predicate returns \texttt{}\lstinline!true!:

\begin{lstlisting}
scala> List(1, 2, 3, 4, 5).filter(k => k % 3 != 0)
res5: List[Int] = List(1, 2, 4, 5)
\end{lstlisting}

The \texttt{}\lstinline!.takeWhile! method truncates a given list,
returning a \emph{new list} with the initial portion of values from
the original list for which predicate keeps being \lstinline!true!:
\begin{lstlisting}
scala> List(1, 2, 3, 4, 5).takeWhile(k => k % 3 != 0)
res6: List[Int] = List(1, 2)
\end{lstlisting}

In all these cases, the predicate's argument \lstinline!k! must be
of the same type as the elements in the list. In the examples shown
above, the elements are integers (i.e.\ the lists have type \lstinline!List[Int]!),
therefore \texttt{}\lstinline!k! must be of type \lstinline!Int!.

The methods \lstinline!.max!, \lstinline!.min!, \lstinline!.sum!,
and \texttt{}\lstinline!.product! are defined on lists of \emph{numeric
types}, such as \lstinline!Int!, \lstinline!Double!, and \lstinline!Long!.
The other methods are defined on lists of all types.

Using these methods, we can solve many problems that involve transforming
and aggregating data stored in lists (as well as in arrays, sets,
or other similar data structures). A \textbf{transformation\index{transformation}}
is a function from a list of values to another list of values; examples
of transformation functions are \texttt{}\lstinline!.filter! and
\lstinline!.map!. An \textbf{aggregation\index{aggregation}} is
a function from a list of values to a \emph{single} value; examples
of aggregation functions are \texttt{}\lstinline!.max! and \lstinline!.sum!.

Writing programs by chaining together various functions of transformation
and aggregation is known as programming in the \textbf{map/reduce}\index{map/reduce style}
\textbf{style}.

\section{Solved examples\index{solved examples}}

\subsection{Aggregation }

\subsubsection{Example \label{subsec:ch1-aggr-Example-1}\ref{subsec:ch1-aggr-Example-1}}

Improve the code for \lstinline!is_prime! by limiting the search
to $k^{2}\leq n$:
\[
\text{is\_prime}\left(n\right)=\forall k\in\left[2,n-1\right]\text{ such that }k^{2}\leq n\ :\ n\neq0\text{ mod }k\quad.
\]


\subparagraph{Solution:}

Use \lstinline!.takeWhile! to truncate the initial list when $k^{2}\leq n$
becomes false:
\begin{lstlisting}
def is_prime(n: Int): Boolean =
  (2 to n-1)
    .takeWhile(k => k*k + 1 < n)
    .forall(k => n % k != 0)
\end{lstlisting}


\subsubsection{Example \label{subsec:ch1-aggr-Example-2}\ref{subsec:ch1-aggr-Example-2}}

Compute $\prod_{k\in\left[1,10\right]}\left|\sin\left(k+2\right)\right|$.

\subparagraph{Solution:}

~
\begin{lstlisting}
(1 to 10)
  .map(k => math.abs(math.sin(k + 2)))
  .product
\end{lstlisting}


\subsubsection{Example \label{subsec:ch1-aggr-Example-3}\ref{subsec:ch1-aggr-Example-3}}

Compute $\sum_{k\in[1,10];~\cos k>0}\sqrt{\cos k}$.

\subparagraph{Solution:}

~

\begin{lstlisting}
(1 to 10)
  .filter(k => math.cos(k) > 0)
  .map(k => math.sqrt(math.cos(k)))
  .sum
\end{lstlisting}
It is safe to compute $\sqrt{\cos k}$, because we have first filtered
the list by keeping only values $k$ for which $\cos k>0$:
\begin{lstlisting}
scala> (1 to 10).toList.
  filter(k => math.cos(k) > 0).map(x => math.cos(x))
res0: List[Double] = List(0.5403023058681398, 0.28366218546322625, 0.9601702866503661, 0.7539022543433046)
\end{lstlisting}


\subsubsection{Example \label{subsec:ch1-aggr-Example-4}\ref{subsec:ch1-aggr-Example-4}}

Compute the average of a non-empty list of type \lstinline!List[Double]!,
\[
\text{average}\left(s\right)=\frac{1}{n}\sum_{i=0}^{n-1}s_{i}\quad.
\]


\subparagraph{Solution:}

We need to divide the sum by the length of the list:
\begin{lstlisting}
scala> def average(s: List[Double]): Double = s.sum / s.size
average: (s: List[Double])Double

scala> average(List(1.0, 2.0, 3.0))
res0: Double = 2.0
\end{lstlisting}


\subsubsection{Example \label{subsec:ch1-aggr-Example-5-Wallis-product}\ref{subsec:ch1-aggr-Example-5-Wallis-product}}

Given $n$, compute \href{https://en.wikipedia.org/wiki/Wallis_product}{the Wallis product}
truncated up to $\frac{2n}{2n+1}$: 
\[
\text{wallis}\left(n\right)=\frac{2}{1}\frac{2}{3}\frac{4}{3}\frac{4}{5}\frac{6}{5}\frac{6}{7}...\frac{2n}{2n+1}\quad.
\]


\subparagraph{Solution:}

We will define the helper function \lstinline!wallis_frac(i)! that
computes the $i^{\text{th}}$ fraction. The method \texttt{}\lstinline!.toDouble!
converts integers to \texttt{}\lstinline!Double! numbers.
\begin{lstlisting}
def wallis_frac(i: Int): Double =
   (2*i).toDouble / (2*i - 1)*(2*i)/(2*i + 1)

def wallis(n: Int) = (1 to n).map(wallis_frac).product

scala> math.cos(wallis(10000)) // Should be close to 0.
res0: Double = 3.9267453954401036E-5

scala> math.cos(wallis(100000)) // Should be even closer to 0.
res1: Double = 3.926966362362075E-6
\end{lstlisting}
The limit of the Wallis product is $\frac{\pi}{2}$, so the cosine
of \lstinline!wallis(n)! tends to zero in the limit of large $n$.

\subsubsection{Example \label{subsec:ch1-aggr-Example-6}\ref{subsec:ch1-aggr-Example-6}}

Another known series related to $\pi$ is
\[
\sum_{k=1}^{\infty}\frac{1}{k^{2}}=\frac{\pi^{2}}{6}\quad.
\]
Define a function of $n$ that computes a partial sum of this series
until $k=n$. Compute the result for a large value of $n$ and compare
with the limit value.

\subparagraph{Solution:}

~

\begin{lstlisting}
def euler_series(n: Int): Double = 
  (1 to n).map(k => 1.0/k/k).sum

scala> euler_series(100000)
res0: Double = 1.6449240668982423

scala> val pi = 4*math.atan(1)
pi: Double = 3.141592653589793

scala> pi*pi/6
res1: Double = 1.6449340668482264 
\end{lstlisting}


\subsubsection{Example \label{subsec:ch1-aggr-Example-7}\ref{subsec:ch1-aggr-Example-7}}

Check numerically the infinite product formula
\[
\prod_{k=1}^{\infty}\left(1-\frac{x^{2}}{k^{2}}\right)=\frac{\sin\pi x}{\pi x}\quad.
\]


\subparagraph{Solution:}

We will compute this product up to $k=n$ for $x=0.1$ and a large
value of $n$, say $n=10^{5}$, and compare with the right-hand side:
\begin{lstlisting}
def sine_product(n: Int, x: Double): Double =
  (1 to n).map(k => 1.0 - x*x/k/k).product

scala> sine_product(n = 100000, x = 0.1) // Arguments may be named, for clarity.
res0: Double = 0.9836317414461351

scala> math.sin(pi*0.1)/pi/0.1
res1: Double = 0.9836316430834658
\end{lstlisting}


\subsubsection{Example \label{subsec:ch1-aggr-Example-8}\ref{subsec:ch1-aggr-Example-8}}

Define a function $p$ that takes a list of integers and a function
\lstinline!f: Int => Int!, and returns the largest value of $f(x)$
among all $x$ in the list.

\subparagraph{Solution:}

~

\begin{lstlisting}
def p(s: List[Int], f: Int => Int): Int = s.map(f).max
\end{lstlisting}
Here is an example test for this function:
\begin{lstlisting}
scala> p(List(2, 3, 4, 5), x => 60 / x)
res0: Int = 30
\end{lstlisting}


\subsection{Transformation}

\subsubsection{Example \label{subsec:ch1-Example-1}\ref{subsec:ch1-Example-1}}

Given a list of lists, \lstinline!s: List[List[Int]]!, select the
inner lists of size at least $3$. The result must be again of type
\lstinline!List[List[Int]]!. 

\subparagraph{Solution:}

To ``select the inner lists'' means to compute a \emph{new} list
containing only the desired inner lists. We use \texttt{}\lstinline!.filter!
on the outer list \lstinline!s!. The predicate for the filter is
a function that takes an inner list and returns \texttt{}\lstinline!true!
if the size of that list is at least $3$. Write the predicate as
a nameless function, \lstinline!t => t.size >= 3!:
\begin{lstlisting}
def f(s: List[List[Int]]): List[List[Int]] =
  s.filter(t => t.size >= 3)

scala> f(List( List(1,2), List(1,2,3), List(1,2,3,4) ))
res0: List[List[Int]] = List(List(1, 2, 3), List(1, 2, 3, 4)) 
\end{lstlisting}
The predicate in the argument of \texttt{}\lstinline!.filter! is
a nameless function \texttt{}\lstinline!t => t.size >= 3! whose
argument \texttt{}\lstinline!t! is of type \lstinline!List[Int]!.
The Scala compiler deduces the type of \lstinline!t! from the code;
no other type would work with the way we use \lstinline!.filter!
on a \emph{list of lists} of integers.

\subsubsection{Example \label{subsec:ch1-Example-2}\ref{subsec:ch1-Example-2}}

Find all integers $k\in\left[1,10\right]$ such that there are at
least three different integers $j$, where $1\leq j\leq k$, each
$j$ satisfying the condition $j^{2}>2k$.

\subparagraph{Solution:}

~

\begin{lstlisting}
scala> (1 to 10).toList.filter(k => (1 to k).
     |  filter(j => j*j > 2*k).size >= 3)
res0: List[Int] = List(6, 7, 8, 9, 10) 
\end{lstlisting}
The argument of the outer \lstinline!.filter! is a nameless function
that itself uses another \lstinline!.filter!. The inner expression
\begin{lstlisting}
(1 to k).filter(j => j*j > 2*k).size >= 3
\end{lstlisting}
computes the list of $j$'s that satisfy the condition $j^{2}>2k$,
and then compares the size of that list with $3$ and so imposes the
requirement that there should be at least $3$ values of $j$. We
can see how the Scala code closely follows the mathematical formulation
of the problem.

\section{Summary}

The following table translates mathematical formulas into code.
\begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{Mathematical notation} & \textbf{Scala code}\tabularnewline
\hline 
\hline 
$x\Rightarrow\sqrt{x^{2}+1}$ & \texttt{x $\Rightarrow$ math.sqrt(x{*}x + 1)}\tabularnewline
\hline 
list $\left[1,~2,~...,~n\right]$ & \texttt{(1 to n)}\tabularnewline
\hline 
list $\left[f(1),~...,~f(n)\right]$ & \texttt{(1 to n).map(k $\Rightarrow$ f(k))}\tabularnewline
\hline 
$\sum_{k=1}^{n}k^{2}$ & \texttt{(1 to n).map(k $\Rightarrow$ k{*}k).sum}\tabularnewline
\hline 
$\prod_{k=1}^{n}f(k)$ & \texttt{(1 to n).map(f).product}\tabularnewline
\hline 
$\forall k\text{ such that }1\leq k\leq n:p(k)~\text{holds}$ & \texttt{(1 to n).forall(k $\Rightarrow$ p(k))}\tabularnewline
\hline 
$\exists k,\:1\leq k\leq n\text{ such that }p(k)~\text{holds}$ & \texttt{(1 to n).exists(k $\Rightarrow$ p(k))}\tabularnewline
\hline 
${\displaystyle \sum_{k\in S\text{ such that }p(k)\text{ holds}}}f(k)$ & \texttt{s.filter(p).map(f).sum}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

What problems can one solve with this knowledge?
\begin{itemize}
\item Compute mathematical expressions involving sums, products, and quantifiers,
based on integer ranges, such as $\sum_{k=1}^{n}f(k)$ etc.
\item Transform and aggregate data from lists using \lstinline!.map!, \lstinline!.filter!,\textbf{
}\lstinline!.sum!, and other methods from the Scala standard library.
\end{itemize}
What are examples of problems that are not solvable with these tools?
\begin{itemize}
\item Example 1: Compute the smallest $n\geq1$ such that 
\[
f(f(f(...f(0)...)>1000\quad,
\]
where the given function $f$ is applied $n$ times.
\item Example 2: Given a list $s$ of numbers, compute the list $r$ of
running averages: 
\[
r_{n}=\frac{1}{n}\sum_{k=0}^{n-1}s_{k}\quad.
\]
\item Example 3: Perform binary search over a sorted list of integers.
\end{itemize}
These computations involve \emph{mathematical induction}\index{mathematical induction},
which we have not yet learned to translate into code in the general
case.

Library functions we have seen so far, such as \texttt{}\lstinline!.map!
and \lstinline!.filter!, implement a restricted class of iterative
operations on lists: namely, operations that process each element
of a given list independently and accumulate results. For instance,
when computing \lstinline!s.map(f)!, the number of function applications
is given by the size of the initial list. However, Example\ 1 requires
applying a function $f$ repeatedly until a given condition holds
\textendash{} that is, repeating for an \emph{initially unknown} number
of times. So it is impossible to write an expression containing \lstinline!.map!,
\lstinline!.filter!, \lstinline!.takeWhile!, etc., that solves Example\ 1.
We could write the solution of Example\ 1 as a formula by using mathematical
induction, but we have not yet seen how to implement that in Scala
code. 

Similarly, Example\ 2 defines a new list $r$ from $s$ by induction,
\[
r_{0}=s_{0}\quad;\quad\quad r_{i}=s_{i}+r_{i-1},\forall i>0\quad.
\]
However, operations such as \texttt{}\lstinline!.map! and \texttt{}\lstinline!.filter!
cannot compute $r_{i}$ depending on the value of $r_{i-1}$.

Example\ 3 defines the search result by induction: the list is split
in half, and search is performed by inductive hypothesis in the half
that contains the required value. This computation requires an initially
unknown number of steps.

Chapter\ \ref{chap:2-Mathematical-induction} explains how to solve
these problems by translating mathematical induction into code using
recursion.

\section{Exercises\label{sec:Chapter-1-Exercises}\index{exercises}}

\subsection{Aggregation}

\subsubsection{Exercise \label{subsec:ch1-aggr-Exercise-1}\ref{subsec:ch1-aggr-Exercise-1}}

\href{http://turner.faculty.swau.edu/mathematics/materialslibrary/pi/machin.html}{Machin's formula}
converges to $\pi$ faster than Example~\ref{subsec:ch1-aggr-Example-5-Wallis-product}:
\begin{align*}
\frac{\pi}{4} & =4\arctan\frac{1}{5}-\arctan\frac{1}{239}\quad,\\
\arctan\frac{1}{n} & =\frac{1}{n}-\frac{1}{3}\frac{1}{n^{3}}+\frac{1}{5}\frac{1}{n^{5}}-...=\sum_{k=1}^{\infty}\frac{\left(-1\right)^{k}}{2k+1}n^{-2k-1}\quad.
\end{align*}
Implement a function that computes the series for $\arctan\frac{1}{n}$
up to a given number of terms, and compute an approximation of $\pi$
using this formula. Show that about $12$ terms of the series are
already sufficient for a full-precision \lstinline!Double! approximation
of $\pi$.%
\begin{comment}
Code: def at(n: Double, l: Int) = (1 to l).map(k => 1.0{*}(k \% 2
{*} 2 - 1) / (2{*}k-1) / math.pow(n, 2{*}k-1) ).sum ; def p(l: Int)
= 16{*}at(5, l) - 4{*}at(239, l); p(12)
\end{comment}


\subsubsection{Exercise \label{subsec:ch1-aggr-Exercise-2}\ref{subsec:ch1-aggr-Exercise-2}}

Using the function \lstinline!is_prime!, check numerically the \href{https://en.wikipedia.org/wiki/Proof_of_the_Euler_product_formula_for_the_Riemann_zeta_function}{Euler product formula}
for the Riemann zeta function $\zeta(4)$; \href{https://ocw.mit.edu/courses/mathematics/18-104-seminar-in-analysis-applications-to-number-theory-fall-2006/projects/chan.pdf}{it is known that}
$\zeta(4)=\frac{\pi^{4}}{90}$:%
\begin{comment}
Code: def is\_prime(n: Int) = (2 to n-1).takeWhile(k => k{*}k <= n).forall(k
=> n \% k != 0); def ep(n: Int): Double = (2 to n).filter(is\_prime).map(k
=> 1.0 / (1.0 - 1.0 / k/k/k/k)).product; ep(100); pi{*}pi{*}pi{*}pi/90;
\end{comment}
\[
\prod_{k\geq2;~k\text{ is prime}}\frac{1}{1-p^{-4}}=\frac{\pi^{4}}{90}\quad.
\]
{} 

\subsection{Transformation}

\subsubsection{Exercise \label{subsec:ch1-transf-Exercise-1}\ref{subsec:ch1-transf-Exercise-1}}

Define a function \texttt{}\lstinline!add_20! of type \texttt{}\lstinline!List[List[Int]] => List[List[Int]]!
that adds $20$ to every element of every inner list. A sample test:
\begin{lstlisting}
scala> add_20( List( List(1), List(2, 3) ) )
res0: List[List[Int]] = List(List(21), List(22, 23))
\end{lstlisting}


\subsubsection{Exercise \label{subsec:ch1-transf-Exercise-2}\ref{subsec:ch1-transf-Exercise-2}}

An integer $n$ is called a ``$3$-factor'' if it is divisible by
only three different integers $j$ such that $2\leq j<n$. Compute
the set of all ``$3$-factor'' integers $n$ among $n\in[1,...,1000]$
.

\subsubsection{Exercise \label{subsec:ch1-transf-Exercise-3}\ref{subsec:ch1-transf-Exercise-3}}

Given a function \lstinline!f: Int => Boolean!, an integer $n$ is
called a ``$3$-$f$'' if there are only three different integers
$j\in[1,...,n]$ such that $f(j)$ returns \lstinline!true!. Define
a function that takes $f$ as an argument and returns a sequence of
all ``$3$-$f$'' integers among $n\in[1,...,1000]$. What is the
type of that function? Implement Exercise~\ref{subsec:ch1-transf-Exercise-2}
using that function.

\subsubsection{Exercise \label{subsec:ch1-transf-Exercise-4}\ref{subsec:ch1-transf-Exercise-4}}

Define a function \lstinline!see100! of type \texttt{}\lstinline!List[List[Int]] => List[List[Int]]!
that selects only those inner lists whose largest value is at least
$100$. Test with:
\begin{lstlisting}
scala> see100( List( List(0, 1, 100), List(60, 80), List(1000) ) )
res0: List[List[Int]] = List(List(0, 1, 100), List(1000))
\end{lstlisting}


\subsubsection{Exercise \label{subsec:ch1-transf-Exercise-5}\ref{subsec:ch1-transf-Exercise-5}}

Define a function of type \texttt{}\lstinline!List[Double] => List[Double]!
that ``normalizes'' the list: finds the element having the largest
absolute value and, if that value is nonzero, divides all elements
by that factor and returns a new list; otherwise returns the original
list.

\section{Discussion}

\subsection{Functional programming as a paradigm}

Functional programming\index{functional programming} (FP) is a \textbf{paradigm}\index{paradigm}
of programming, \textendash{} that is, an approach that guides programmers
to write code in specific ways, for a wide range of programming tasks.

The main principle of FP is to write code \emph{as a mathematical
expression or formula}. This approach allows programmers to derive
code through logical reasoning rather than through guessing, \textendash{}
similarly to how books on mathematics reason about mathematical formulas
and derive results systematically, without guessing or ``debugging.''
Similarly to mathematicians and scientists who reason about formulas,
functional programmers can \emph{reason about code} systematically
and logically, based on rigorous principles. This is possible only
because code is written as a mathematical formula.

Mathematical intuition is backed by the vast experience accumulated
while working with data over thousands of years of human history.
It took centuries to invent flexible and powerful notation such as
$\forall k\in S:p(k)$ and to develop the corresponding rules of reasoning.
Functional programmers are fortunate to have at their disposal such
a superior reasoning tool.

As we have seen, the Scala code for certain computational tasks corresponds
quite closely to mathematical formulas. (Scala conventions and syntax,
of course, require programmers to spell out certain things that the
mathematical notation leaves out.) Just as in mathematics, large code
expressions may be split into parts in a suitable way, so that the
parts can be easily reused, flexibly composed together, and written
independently from each other. The FP community has developed a toolkit
of functions (such as \lstinline!.map!, \texttt{}\lstinline!.filter!,
etc.) that proved especially useful in real-life programming, although
many of them are not standard in mathematical literature.

Mastering FP involves practicing to reason about programs as formulas,
building up the specific kind of applied mathematical intuition, familiarizing
oneself with concepts adapted to programming needs, and learning how
to translate the mathematics into code in various cases. The FP community
has discovered a number of specific design patterns, founded on mathematical
principles but driven by practical necessities of programming rather
than by the needs of academic mathematics. This book explains the
required mathematical principles in detail, developing them through
intuition and practical coding tasks.

\subsection{Functional programming languages}

It is possible to apply the FP paradigm while writing code in any
programming language. However, some languages lack certain features
that make FP techniques much easier to use in practice. For example,
in a language such as Python or Ruby, one can productively use only
a limited number of FP idioms, such as the map/reduce operations.
More advanced FP constructions are impractical in these languages
because the required code becomes too hard to read, and mistakes are
too easy to make, which negates the advantage of easier reasoning
about functional programs.

Some programming languages, such as Haskell and OCaml, were designed
specifically for advanced use in the FP paradigm. Other languages,
such as ML, F\#, Scala, Swift, Elm, and PureScript, have different
design goals but still support enough FP features to be considered
FP languages. I will be using Scala in this book, but exactly the
same constructions could be implemented in other FP languages in a
similar way. At the level of detail needed in this book, the differences
between languages such as ML, OCaml, Haskell, F\#, Scala, Swift, Elm,
or PureScript will not play a significant role.

\subsection{The mathematical meaning of variables}

The usage of variables in functional programming closely corresponds
to how mathematical literature uses variables. In mathematics, \textbf{variables\index{variable}}
are used first of all as \emph{arguments} of functions; e.g. the formula
\[
f(x)=x^{2}+x
\]
contains the variable $x$ and defines a function $f$ that takes
$x$ as its argument (to be definite, let us assume that $x$ is an
integer) and computes the value $x^{2}+x$. The body of the function
is the expression $x^{2}+x$. 

Mathematics has the convention that a variable, such as $x$, does
not change its value within a formula. Indeed, there is no mathematical
notation even to talk about ``changing'' the value of $x$ \emph{inside}
the formula $x^{2}+x$. It would be quite confusing if a mathematics
textbook said ``before adding the last $x$ in the formula $x^{2}+x$,
we change that $x$ by adding $4$ to it''. If the ``last $x$''
in $x^{2}+x$ needs to have a $4$ added to it, a mathematics textbook
will just write the formula $x^{2}+x+4$.

Arguments of nameless functions are also immutable. Consider, for
example,
\[
f(n)=\sum_{k=0}^{n}k^{2}+k\quad.
\]
Here, $n$ is the argument of the function $f$, while $k$ is the
argument of the nameless function $k\Rightarrow k^{2}+k$. Neither
$n$ nor $k$ can be ``modified'' in any sense within the expressions
where they are used. The symbols $k$ and $n$ stand for some integer
values, and these values are immutable. Indeed, it is meaningless
to say that we ``modified the integer $4$''. In the same way, we
cannot modify $k$.

So, a variable in mathematics remains constant \emph{within} \emph{the
expression} where it is defined; in that expression, a variable is
essentially a \emph{named constant} value. Of course, a function $f$
can be applied to different values $x$, to compute a different result
$f(x)$ each time. However, a given value of $x$ will remain unmodified
within the body of the function $f$ while $f(x)$ is being computed.

Functional programming adopts this convention from mathematics: variables
are immutable named constants. (Scala also has \emph{mutable} variables,
but we will not need to consider them in this book.)

In Scala, function arguments are immutable within the function body:
\begin{lstlisting}
def f(x: Int) = x * x + x // Can't modify x here.
\end{lstlisting}

The \emph{type} of each mathematical variable (such as integer, string,
etc.) is also fixed in advance. In mathematics, each variable is a
value from a specific set, known in advance (the set of all integers,
the set of all strings, etc.). Mathematical formulas such as $x^{2}+x$
do not express any ``checking'' that $x$ is indeed an integer and
not, say, a string, before starting to evaluate $x^{2}+x$.

Functional programming adopts the same view: Each argument of each
function must have a \textbf{type\index{type}}, which represents
\emph{the set of possible allowed values} for that function argument.
The programming language's compiler will automatically check the types
of all arguments \emph{before} the program runs. A program that calls
functions on arguments of incorrect types will not compile.

The second usage of \textbf{variables\index{variable}} in mathematics
is to denote expressions that will be reused. For example, one writes:
let $z=\frac{x-y}{x+y}$ and now compute $\cos z+\cos2z+\cos3z$.
Again, the variable $z$ remains immutable, and its type remains fixed.

In Scala, this construction (defining an expression to be reused later)
is written with the ``\lstinline!val!'' syntax. Each variable defined
using ``\lstinline!val!'' is a named constant, and its type and
value are fixed at the time of definition. Type annotations for ``\lstinline!val!''s
are optional in Scala: for instance we could write 
\begin{lstlisting}
val x: Int = 123
\end{lstlisting}
or we could omit the type annotation \lstinline!:Int! and write more
concisely
\begin{lstlisting}
val x = 123
\end{lstlisting}
because it is clear that this \texttt{}\lstinline!x! is an integer.
However, when types are complicated, it helps to write them out. If
we do so, the compiler will check that the types match correctly and
give an error message whenever wrong types are used:
\begin{lstlisting}
scala> val x: Int = "123" // A String instead of an Int.
<console>:11: error: type mismatch;
 found   : String("123")
 required: Int
        val x: Int = "123" // A String instead of an Int.                     
                     ^ 
\end{lstlisting}


\subsection{Iteration without loops}

Another distinctive feature of the FP paradigm is the absence of explicit
loops.

Iterative computations are ubiquitous in mathematics; as an example,
consider the formula for the standard deviation estimated from a sample,
\[
\sqrt{\frac{1}{n-1}\sum_{i=1}^{n}\sum_{j=1}^{n}s_{i}s_{j}-\frac{1}{n\left(n-1\right)}\left(\sum_{i=1}^{n}s_{i}\right)^{2}}\quad.
\]
To compute these expressions, we need to iterate over values of $i$
and $j$. And yet, no mathematics textbook uses ``loops'' or says
``now repeat this formula ten times''. Indeed, it would be pointless
to evaluate a formula such as $x^{2}+x$ ten times, or to ``repeat''
an equation such as
\[
\left(x-1\right)(x^{2}+x+1)=x^{3}-1\quad.
\]
Instead of loops, mathematicians write \emph{expressions} such as
$\sum_{i=1}^{n}s_{i}$, where symbols such as $\sum_{i=1}^{n}$ or
$\prod_{i=1}^{n}$ denote iterative computations. Such computations
are defined using mathematical induction\index{mathematical induction}.
The functional programming paradigm has developed rich tools for translating
mathematical induction into code. In this chapter, we have seen methods
such as \lstinline!.map!, \lstinline!.filter!, and \lstinline!.sum!,
which implement certain kinds of iterative computations. These and
other operations can be combined in very flexible ways, which allows
programmers to write iterative code \emph{without loops}.

The programmer can avoid writing loops because the iteration is delegated
to the library functions \lstinline!.map!, \lstinline!.filter!,
\lstinline!.sum!, and so on. It is the job of the library and the
compiler to translate these functions into machine code. The machine
code most likely \emph{will} contain loops; but the functional programmer
does not need to see that code or to reason about it.

\subsection{Nameless functions in mathematical notation\label{subsec:Nameless-functions-in-mathematical-notation}}

Functions in mathematics are mappings from one set to another. A function
does not necessarily \emph{need} a name; the mapping just needs to
be defined. However, nameless functions have not been widely used
in the conventional mathematical notation. It turns out that nameless
functions are quite important in functional programming because, in
particular, they allow programmers to write code more concisely and
use a straightforward, consistent syntax.

Nameless functions have the property that their bound variables are
invisible outside their scope. This property is directly reflected
by the prevailing mathematical conventions. Compare the formulas
\[
f\left(x\right)=\int_{0}^{x}\frac{dx}{1+x}\quad;\quad f\left(x\right)=\int_{0}^{x}\frac{dz}{1+z}\quad.
\]
The mathematical convention is that these formulas define the same
function $f$, and that one may rename the integration variable at
will.

In programming, the only situation when a variable ``may be renamed
at will'' is when the variable represents an argument of a function.
It follows that the notations $\frac{dx}{1+x}$ and $\frac{dz}{1+z}$
correspond to a nameless function whose argument was renamed from
$x$ to $z$. In FP notation, this nameless function would be denoted
as $z\Rightarrow\frac{1}{1+z}$, and the integral rewritten as code
such as
\[
\text{integration}\left(0,x,g\right)\text{ where }g=\left(z\Rightarrow\frac{1}{1+z}\right)\quad.
\]
Now consider the traditional mathematical notations for summation,
e.g.
\[
\sum_{k=0}^{x}\frac{1}{1+k}\quad.
\]
In sums, the bound variable $k$ is introduced under the $\sum$ symbol;
but in integrals, the bound variable follows the special symbol ``$d$''.
This notational inconsistency could be removed if we were to use nameless
functions explicitly, for example:
\begin{align*}
\sum_{0}^{x} & \left(k\Rightarrow\frac{1}{1+k}\right)\text{ instead of }\sum_{k=0}^{x}\frac{1}{1+k}\quad,\\
\int_{0}^{x} & \left(z\Rightarrow\frac{1}{1+z}\right)\text{ instead of }\int_{0}^{x}\frac{dz}{1+z}\quad.
\end{align*}
In this notation, the new summation symbol $\sum_{0}^{x}$ does not
mention the name \textquotedblleft $k$\textquotedblright{} but takes
a function as an argument. Similarly, the new integration symbol $\int_{0}^{x}$
does not mention ``$z$'' and does not use the special symbol ``$d$''
but now takes a function as an argument. Written in this way, the
operations of summation and integration become \emph{functions} that
take a function as argument. The above summation may be written in
a consistent and straightforward manner as a function:
\[
\text{summation}\left(0,x,f\right)\text{ where }f=\left(y\Rightarrow\frac{1}{1+y}\right)\quad.
\]

We could implement \texttt{}\lstinline!summation(a,b,g)! as
\begin{lstlisting}
def summation(a: Int, b: Int, g: Int => Double) = (a to b).map(g).sum

scala> summation(1, 10, x => math.sqrt(x))
res0: Double = 22.4682781862041
\end{lstlisting}

Numerical integration requires longer code, since the formulas are
more complicated. For instance, \href{https://en.wikipedia.org/wiki/Simpson\%27s_rule}{Simpson's rule}
can be written as
\begin{align*}
\text{integration}\left(a,b,g\right) & =\frac{\delta}{3}\left(g(a)+g(b)+4s_{1}+2s_{2}\right)\quad,\\
\text{where }~~~n & =2\left\lfloor \frac{b-a}{\varepsilon}\right\rfloor ,\quad\delta_{x}=\frac{b-a}{n}\quad,\\
s_{1} & =\sum_{i=1,3,...,n-1}g(a+i\delta_{x})\quad,\\
s_{2} & =\sum_{i=2,4,...,n-2}g(a+i\delta_{x})\quad.
\end{align*}
 A straightforward translation of this formula into Scala is
\begin{lstlisting}
def integration(a: Double, b: Double, g: Double => Double, eps: Double) = {
  // First, we define some helper values and functions that replace
  // the definitions "where n = ..." in the mathematical formula.
   val n: Int = (math.round((b-a)/eps/2)*2).toInt
   val delta_x = (b - a) / n
   val g_i = (i: Int) => g(a + i*delta_x)
   val s1 = (1 to (n-1) by 2).map(g_i).sum
   val s2 = (2 to (n-2) by 2).map(g_i).sum
   // Now we write the expression for the final result.
   delta_x / 3 * (g(a) + g(b) + 4*s1 + 2*s2)
}

scala> integration(0, 2, x => x*x*x, 0.001) // Exact answer is 4
res0: Double = 4.000000000000003

scala> integration(0, 7, x => x*x*x*x*x*x, 0.001) // Exact answer is 117649
res1: Double = 117649.00000000023 
\end{lstlisting}

The entire code is one large \emph{expression}, with a few sub-expressions
defined for convenience as a few helper values and helper functions.
In other words, this code is written in the FP paradigm.

\subsection{Named and nameless expressions and their uses}

It is a significant advantage if a programming language supports unnamed
(or ``nameless'') expressions. To see this, consider a familiar
situation where we take the absence of names for granted.

In most programming languages today, we can directly write arithmetical
expressions such as \texttt{}\lstinline!(x+123)*y/(2+x)!. Here,
\texttt{}\lstinline!x! and \texttt{}\lstinline!y! are variables
with names. Note, however, that the entire expression does not need
to have a name. Parts of that expression (such as \texttt{}\lstinline!x+123!
or \lstinline!2+x!) also do not need to have separate names. It would
be quite inconvenient if we \emph{needed} to assign a name separately
to each sub-expression. The code for \lstinline!(x+123)*y/(2+x)!
could then look like this:
\begin{lstlisting}[language=Python]
r1 = 123
r2 = x + r1
r3 = r2 * y
r4 = 2
r5 = r4 + x
r6 = r3 / r5
return r6
\end{lstlisting}

This style of programming resembles assembly languages\index{assembly language},
where \emph{every} sub-expression \textendash{} that is, every step
of every calculation, \textendash{} must be named separately (and,
in the assembly languages, assigned a memory address or a CPU register).

So, programmers become more productive when their programming language
supports nameless expressions.

This is also common practice in mathematics; names are assigned when
needed, but most expressions remain nameless.

It is similarly quite useful if data structures can be declared without
a name. For instance, a \textbf{dictionary}\index{dictionary} (also
called a ``hashmap\index{hashmap}'') is declared in Scala as
\begin{lstlisting}
Map("a" -> 1, "b" -> 2, "c" -> 3)
\end{lstlisting}
This is a nameless expression representing a dictionary. Without this
construction, programmers have to write cumbersome, repetitive code
that creates an initially empty dictionary and then fills it step
by step with values:
\begin{lstlisting}[language=Java]
// Scala code for creating a dictionary:
val myMap = Map("a" -> 1, "b" -> 2, "c" -> 3)
// Java code:
// Map<String, Int> myMap = new HashMap<String, Integer>() {{
//   put("a", 1);
//   put("b", 2);
//   put("c", 3);
// }}; // The shortest Java code for creating the same dictionary.
\end{lstlisting}

Nameless functions are useful for the same reason as nameless data
values: they allow us to build larger programs from simpler parts
in a uniform way.

\subsection{Nameless functions: historical perspective}

Nameless functions were first used in 1936 in a theoretical programming
language called ``$\lambda$-calculus\index{lambda-calculus@$\lambda$-calculus}''.
In that language,\footnote{Although called a ``calculus,'' it is in reality a (drastically
simplified) programming language. It has nothing to do with ``calculus''
as known in mathematics, such as differential or integral calculus.
Also, the letter $\lambda$ has no particular significance; it plays
a purely syntactic role in the $\lambda$-calculus. Practitioners
of functional programming usually do not need to study any $\lambda$-calculus.
All practically relevant knowledge related to $\lambda$-calculus
is explained in Chapter~\ref{chap:Higher-order-functions} of this
book.} all functions are nameless and have a single argument. The letter
$\lambda$ is a syntax separator denoting function arguments in nameless
functions. For example, the nameless function $x\Rightarrow x+1$
could be written as $\lambda x.add~x~1$ in $\lambda$-calculus, if
it had a function $add$ for adding integers (which it does not).

In most programming languages that were in use until around 1990,
all functions required names. But by 2015, most languages added support
for nameless functions, because programming in the map/reduce style
(which invites frequent use of nameless functions) turned out to be
immensely useful. Table\ \ref{lambda-functions-table} shows the
year when nameless functions were introduced in each language.

\begin{table}
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{Language } & \textbf{Year} & \textbf{Code for }$k^{:\text{Int}}\Rightarrow k+k$\tabularnewline
\hline 
\hline 
$\lambda$-calculus & 1936 & $\lambda k.~add~k~k$\tabularnewline
\hline 
typed $\lambda$-calculus & 1940 & $\lambda k:int.~add~k~k$\tabularnewline
\hline 
LISP & 1958 & \texttt{\footnotesize{}(lambda (k) (+ k k))}\tabularnewline
\hline 
Standard ML & 1973 & \texttt{\footnotesize{}fn (k:int) => k + k}\tabularnewline
\hline 
Scheme & 1975 & \texttt{\footnotesize{}(lambda (k) (+ k k))}\tabularnewline
\hline 
OCaml & 1985 & \texttt{\footnotesize{}fun (k:int) -> k + k}\tabularnewline
\hline 
Haskell  & 1990 & \texttt{\footnotesize{}\textbackslash{} k -> (k::Int) + k}\tabularnewline
\hline 
Oz & 1991 & \texttt{\footnotesize{}fun \{\$ K\} K + K}\tabularnewline
\hline 
R  & 1993 & \texttt{\footnotesize{}function(k) k + k}\tabularnewline
\hline 
Python 1.0 & 1994 & \texttt{\footnotesize{}lambda k: k + k}\tabularnewline
\hline 
JavaScript  & 1995 & \texttt{\footnotesize{}function(k) \{ return k + k; \}}\tabularnewline
\hline 
Mercury  & 1995 & \texttt{\footnotesize{}func(K) = K + K}\tabularnewline
\hline 
Ruby  & 1995 & \texttt{\footnotesize{}lambda \{ |k| k + k \}}\tabularnewline
\hline 
Lua 3.1 & 1998 & \texttt{\footnotesize{}function(k) return k + k end}\tabularnewline
\hline 
Scala  & 2003 & \texttt{\footnotesize{}(k:Int) => k + k}\tabularnewline
\hline 
F\# & 2005 & \texttt{\footnotesize{}fun (k:int) -> k + k}\tabularnewline
\hline 
C\# 3.0 & 2007 & \texttt{\footnotesize{}delegate(int k) \{ return k + k; \}}\tabularnewline
\hline 
C++ 11 & 2011 & \texttt{\footnotesize{}{[}{]} (int k) \{ return k + k; \}}\tabularnewline
\hline 
Go & 2012 & \texttt{\footnotesize{}func(k int) \{ return k + k \}}\tabularnewline
\hline 
Kotlin & 2012 & \texttt{\footnotesize{}\{ k:Int -> k + k \}}\tabularnewline
\hline 
Swift  & 2014 & \texttt{\footnotesize{}\{ (k:int) -> int in return k + k \}}\tabularnewline
\hline 
Java 8 & 2014 & \texttt{\footnotesize{}(int k) -> k + k}\tabularnewline
\hline 
Rust & 2015 & \texttt{\footnotesize{}|k:i32| k + k}\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{Nameless functions in various programming languages.}
\label{lambda-functions-table}
\end{table}

What I call a ``nameless function'' is also called anonymous function,
function expression, function literal, closure, lambda function, lambda
expression, or just a ``lambda''. I use the term ``nameless function\index{nameless functions}''
in this book because it is the most descriptive and unambiguous both
in speech and in writing.
