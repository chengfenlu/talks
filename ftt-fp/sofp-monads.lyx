#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% Better formatting of tables.
%\usepackage{booktabs}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.0pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.
\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt,utf8
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7in
\paperheight 9in
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Success,Failure,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Computations in functor blocks II.
 Semimonads and monads
\end_layout

\begin_layout Section
Slides, part 1
\end_layout

\begin_layout Subsection
Computations within a functor context: Semimonads
\end_layout

\begin_layout Standard
Intuitions behind adding more 
\begin_inset Quotes eld
\end_inset

generator arrows
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Example of nested iterations: 
\size footnotesize

\begin_inset Formula 
\[
\sum_{i=1}^{n}\sum_{j=1}^{n}\sum_{k=1}^{n}f(i,j,k)
\]

\end_inset


\end_layout

\begin_layout Standard
Using Scala's 
\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
yield
\family default
\size default
\color inherit
 syntax (
\begin_inset Quotes eld
\end_inset

functor block
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
(for { i 
\begin_inset Formula $\leftarrow$
\end_inset

 1 to n
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    j 
\begin_inset Formula $\leftarrow$
\end_inset

 1 to n
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    k 
\begin_inset Formula $\leftarrow$
\end_inset

 1 to n
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  } yield f(i, j, k)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
).sum
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
(1 to n).flatMap { i 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   (1 to n).flatMap { j 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     (1 to n).map { k 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
       f(i, j, k)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  }}}.sum
\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 replaces the last left arrow, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 replaces other left arrows
\end_layout

\begin_layout Standard
When the functor is 
\emph on
also
\emph default
 filterable, we can use 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
if
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 as well
\end_layout

\begin_layout Standard
Standard library defines 
\family typewriter
\size footnotesize
\color blue
flatMap()
\family default
\size default
\color inherit
 as replacement of 
\family typewriter
\size footnotesize
\color blue
map() 
\begin_inset Formula $\circ$
\end_inset

 flatten
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
(1 to n).map(j 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...).flatten
\family default
\size default
\color inherit
 is 
\family typewriter
\size footnotesize
\color blue
(1 to n).flatMap(j 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Functors having 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 are 
\begin_inset Quotes eld
\end_inset

flattenable
\begin_inset Quotes erd
\end_inset

 or 
\series bold
semimonads
\end_layout

\begin_layout Standard
Most of them also have method 
\family typewriter
\size footnotesize
\color blue
pure:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\Rightarrow$
\end_inset

 F[A]
\family default
\size default
\color inherit
 and so are 
\series bold
monads
\end_layout

\begin_layout Standard
The method 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 is not relevant in the functor block
\end_layout

\begin_layout Standard
We will not need 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 in this part of the tutorial; focus on semimonads
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
How 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 works with lists
\end_layout

\begin_layout Standard
consider 
\family typewriter
\size footnotesize
\color blue
List(x1, x2, x3).flatMap(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 f(x))
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
assume that 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
f: X 
\begin_inset Formula $\Rightarrow$
\end_inset

 List[Y]
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
f(x1) = List(y0, y1)
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
f(x2) = List(y2)
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
f(x3) = List(y3, y4, y5, y6)
\end_layout

\begin_layout Standard
then the result is 
\family typewriter
\size footnotesize
\color blue
List(y0, y1, y2, y3, y4, y5, y6)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
if we first do 
\family typewriter
\size footnotesize
\color blue
.map(f)
\family default
\size default
\color inherit
 then 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
List(x1, x2, x3).map(f).flatten =
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  List(List(y0, y1), List(y2), List(y3, y4, y5, y6)).flatten =
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  List(y0, y1, y2, y3, y4, y5, y6)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
What is 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 doing with the data in a collection?
\end_layout

\begin_layout Standard
Consider this schematic code, using 
\family typewriter
\size footnotesize
\color blue
Seq
\family default
\size default
\color inherit
 as the container type:
\family typewriter
\size footnotesize
\color blue
 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val result = for {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  i 
\begin_inset Formula $\leftarrow$
\end_inset

 1 to m
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  j 
\begin_inset Formula $\leftarrow$
\end_inset

 1 to n
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  x = f(i, j)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  k 
\begin_inset Formula $\leftarrow$
\end_inset

 1 to p
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  y = g(i, j, k)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} yield h(x,y)
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val result = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  (1 to m).flatMap { i 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    (1 to n).flatMap { j 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
      val x = f(i, j)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
      (1 to p).map { k 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
        val y = g(i, j, k)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
        h(x,y)  } } } }
\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Computations are repeated for all 
\begin_inset Formula $i$
\end_inset

, for all 
\begin_inset Formula $j$
\end_inset

, etc., from each collection
\end_layout

\begin_layout Standard
All 
\begin_inset Quotes eld
\end_inset

generator lines
\begin_inset Quotes erd
\end_inset

 must use the same container type
\end_layout

\begin_layout Standard
Each generator line finally computes a container of 
\emph on
that
\emph default
 type
\end_layout

\begin_layout Standard
The total number of resulting data items is 
\begin_inset Formula $\leq m*n*p$
\end_inset


\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout Standard
All the resulting data items must fit within 
\emph on
the same
\emph default
 container type!
\end_layout

\begin_layout Standard

\size footnotesize
The set of 
\emph on
container capacity counts
\emph default
 must be closed under multiplication
\end_layout

\begin_layout Standard
What container types have this property?
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Seq,
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
NonEmptyList
\family default
\size default
\color inherit
 – can hold 
\emph on
any
\emph default
 number of elements 
\begin_inset Formula $\geq$
\end_inset

 min.
\begin_inset space \space{}
\end_inset

count
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Option
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Try
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Future
\family default
\size default
\color inherit
 – can hold 
\begin_inset Formula $0$
\end_inset

 or 
\begin_inset Formula $1$
\end_inset

 elements (
\begin_inset Quotes eld
\end_inset

pass/fail
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Tree-like
\begin_inset Quotes erd
\end_inset

 containers, e.g.
\begin_inset space \space{}
\end_inset

can hold only 
\begin_inset Formula $3$
\end_inset

, 
\begin_inset Formula $6$
\end_inset

, 
\begin_inset Formula $9$
\end_inset

, 
\begin_inset Formula $12$
\end_inset

, ...
\begin_inset space \space{}
\end_inset

elements
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Non-standard
\begin_inset Quotes erd
\end_inset

 containers: 
\begin_inset Formula $F^{A}\equiv\text{String}\Rightarrow A$
\end_inset

; 
\begin_inset Formula $F^{A}\equiv\left(A\Rightarrow\text{Int}\right)\Rightarrow\text{Int}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Worked examples I: List-like monads
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Seq
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
NonEmptyList
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Iterator
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Stream
\end_layout

\begin_layout Standard
Typical tasks for 
\begin_inset Quotes eld
\end_inset

list-like
\begin_inset Quotes erd
\end_inset

 monads:
\end_layout

\begin_layout Standard
Create a list of all combinations or all permutations of a sequence
\end_layout

\begin_layout Standard
Traverse a 
\begin_inset Quotes eld
\end_inset

solution tree
\begin_inset Quotes erd
\end_inset

 with DFS and filter out incorrect solutions
\end_layout

\begin_layout Standard
Can use eager (
\family typewriter
\size footnotesize
\color blue
Seq
\family default
\size default
\color inherit
) or lazy (
\family typewriter
\size footnotesize
\color blue
Iterator
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Stream
\family default
\size default
\color inherit
) evaluation strategies
\end_layout

\begin_layout Standard
Usually, list-like containers have many additional methods
\end_layout

\begin_layout Standard
append, prepend, concat, fill, fold, scan, etc.
\end_layout

\begin_layout Standard
Worked examples: see code
\end_layout

\begin_layout Standard
All permutations of 
\family typewriter
\size footnotesize
\color blue
Seq("a", "b", "c")
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
All subsets of 
\family typewriter
\size footnotesize
\color blue
Set("a", "b", "c")
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
All subsequences of length 3 out of a given sequence
\end_layout

\begin_layout Standard
Generalize examples 1-3 to support arbitrary length 
\begin_inset Formula $n$
\end_inset

 instead of 3
\end_layout

\begin_layout Standard
All solutions of the 
\begin_inset Quotes eld
\end_inset

8 queens
\begin_inset Quotes erd
\end_inset

 problem
\end_layout

\begin_layout Standard
Generalize example 5 to solve 
\begin_inset Formula $n$
\end_inset

-queens problem
\end_layout

\begin_layout Standard
Transform Boolean formulas between CNF and DNF 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Intuitions for pass/fail monads
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Option
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Try
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Future
\end_layout

\begin_layout Standard
Container 
\begin_inset Formula $F^{A}$
\end_inset

 can hold 
\begin_inset Formula $n=1$
\end_inset

 or 
\begin_inset Formula $n=0$
\end_inset

 values of type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Standard
Such containers will have methods to create 
\begin_inset Quotes eld
\end_inset

pass
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

fail
\begin_inset Quotes erd
\end_inset

 values
\end_layout

\begin_layout Standard
Schematic example of a functor block program using the 
\family typewriter
\size footnotesize
\color blue
Try
\family default
\size default
\color inherit
 functor:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
val result: Try[A] = for { 
\family roman
\color darkgray
// computations in the 
\family default
Try
\family roman
 functor
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  x 
\begin_inset Formula $\leftarrow$
\end_inset

 Try(...) 
\family roman
\color darkgray
// first computation; may fail
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  y = f(x) 
\family roman
\color darkgray
// no possibility of failure in this line
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  if p(y) 
\family roman
\color darkgray
// the entire expression will fail if this is false
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  z 
\begin_inset Formula $\leftarrow$
\end_inset

 Try(g(x, y))
\family roman
\color darkgray
 // may fail here
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  r 
\begin_inset Formula $\leftarrow$
\end_inset

 Try(...)
\family roman
\color darkgray
 // may fail here as well
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
} yield r 
\family roman
\color darkgray
//  
\family default
r
\family roman
 is of type 
\family default
A
\family roman
, so 
\family default
result
\family roman
 is of type 
\family default
Try[A]
\end_layout

\begin_layout Standard
Computations may yield a result (
\begin_inset Formula $n=1$
\end_inset

), or may fail (
\begin_inset Formula $n=0$
\end_inset

)
\end_layout

\begin_layout Standard
The functor block chains several such computations 
\emph on
sequentially
\end_layout

\begin_layout Standard
Computations are sequential even if using the 
\family typewriter
\size footnotesize
\color blue
Future
\family default
\size default
\color inherit
 functor!
\end_layout

\begin_layout Standard
Once any computation fails, the entire functor block fails (
\begin_inset Formula $0*n=0$
\end_inset

)
\end_layout

\begin_layout Standard
Only if 
\emph on
all
\emph default
 computations succeed, the functor block returns 
\emph on
one
\emph default
 value
\end_layout

\begin_layout Standard
Filtering can also make the entire functor block fail
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Flat
\begin_inset Quotes erd
\end_inset

 functor block replaces a chain of nested 
\family typewriter
\size footnotesize
\color blue
if/else
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
match/case
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Worked examples II: Pass/fail monads
\end_layout

\begin_layout Standard
Type constructors:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Option[A]
\family default
\size default
\color inherit
 
\begin_inset Formula $\equiv1+A$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Either[Z, A]
\family default
\size default
\color inherit
 
\begin_inset Formula $\equiv Z+A$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Try[A]
\family default
\size default
\color inherit
 
\begin_inset Formula $\equiv$
\end_inset


\family typewriter
\size footnotesize
\color blue
 Either[Throwable, A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Typical tasks for pass/fail monads:
\end_layout

\begin_layout Standard
Perform a linear sequence of computations that may fail
\end_layout

\begin_layout Standard
Avoid crashing on failure, instead return an 
\emph on
error value
\end_layout

\begin_layout Standard
Worked examples: see code
\end_layout

\begin_layout Standard
Read values of Java properties, checking that they all exist
\end_layout

\begin_layout Standard
Obtain values from 
\family typewriter
\size footnotesize
\color blue
Future
\family default
\size default
\color inherit
 computations in sequence
\end_layout

\begin_layout Standard
Make arithmetic safe by returning error messages in 
\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Pass/fail chain: sequencing computations that may throw an exception
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Intuitions for tree-like monads
\end_layout

\begin_layout Standard
Examples of tree-like recursive type constructors:
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A+F^{A}\times F^{A}$
\end_inset

 (binary tree)
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A+S^{F^{A}}$
\end_inset

 (
\begin_inset Formula $S$
\end_inset

-shaped tree, where 
\begin_inset Formula $S$
\end_inset

 is a functor)
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A\times A+F^{A}\times F^{A}$
\end_inset

 (binary tree with binary leaves)
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv S^{A}+S^{F^{A}}$
\end_inset

 (
\begin_inset Formula $S$
\end_inset

-shaped tree with 
\begin_inset Formula $S$
\end_inset

-shaped leaves)
\end_layout

\begin_layout Standard
Implementing 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 for these type constructors is recursive
\end_layout

\begin_layout Standard
See example code
\end_layout

\begin_layout Standard
Note: trees with 
\begin_inset Formula $S$
\end_inset

-shaped leaves are 
\emph on
semi
\emph default
-monads but not monads
\end_layout

\begin_layout Standard
Example of a 
\emph on
non-monadic
\emph default
 tree-like functor:
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A+A\times A+A\times A\times A\times A+...$
\end_inset

 (powers of 2)
\end_layout

\begin_layout Standard
Recursive definition: 
\begin_inset Formula $F^{A}=A+F^{A\times A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Worked examples III: Tree-like monads
\end_layout

\begin_layout Standard
How 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 works for a binary tree:
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://tex.stackexchange.com/questions/5447/how-can-i-draw-simple-trees-in-latex
\end_layout

\end_inset

 assume 
\family typewriter
\size footnotesize
\color blue
f:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Tree[B]
\family default
\size default
\color inherit
 and
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
tree1
\family default
\size default
\color inherit
 = 
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[  [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] 
\end_layout

\end_inset

 ; 
\begin_inset Formula $f(a_{1})=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[  [ $b_0$ ] [ $b_1$ ] ] 
\end_layout

\end_inset

; 
\begin_inset Formula $f(a_{2})=b_{2}$
\end_inset

; 
\begin_inset Formula $f(a_{3})=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[  [ $b_3$ ] [ $b_4$ ] ] 
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
then 
\family typewriter
\size footnotesize
\color blue
tree1.flatMap(f)
\family default
\size default
\color inherit
 =
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[  [ [ $b_0$ ] [ $b_1$ ] ] [ [ $b_2$ ] [ [ $b_3$ ] [ $b_4$ ] ] ] ] 
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
grafting subtrees plays the role of 
\begin_inset Quotes eld
\end_inset

flattening
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Typical tasks for tree-like monads:
\end_layout

\begin_layout Standard
Traverse a tree, graft subtrees at leaves
\end_layout

\begin_layout Standard
Substitute subexpressions in a syntax tree
\end_layout

\begin_layout Standard
Worked examples: see code
\end_layout

\begin_layout Standard
Implement a tree of 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 properties with arbitrary branching
\end_layout

\begin_layout Standard
Implement variable substitution for a simple arithmetic language
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Worked examples IV: Single-value monads
\end_layout

\begin_layout Standard
Pretend that container holds exactly 
\begin_inset Formula $1$
\end_inset

 value, together with a 
\begin_inset Quotes eld
\end_inset

context
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Usually, methods exist to insert a value and to work with the 
\begin_inset Quotes eld
\end_inset

context
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Typical tasks for single-value monads:
\end_layout

\begin_layout Standard
Managing extra information about computations along the way
\end_layout

\begin_layout Standard
Chaining computations with a nonstandard evaluation strategy
\end_layout

\begin_layout Standard
Examples: see code
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Writer
\family default
\size default
\color inherit
: Perform computations and log information about each step
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{Writer}^{A}\equiv A\times W$
\end_inset

 where 
\begin_inset Formula $W$
\end_inset

 is a monoid or a semigroup
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Reader
\family default
\size default
\color inherit
: Read-only context, or dependency injection
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{Reader}^{A}\equiv E\Rightarrow A$
\end_inset

 where 
\begin_inset Formula $E$
\end_inset

 represents the 
\begin_inset Quotes eld
\end_inset

environment
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Eval
\family default
\size default
\color inherit
: Perform a sequence of lazy or memoized computations
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{Eval}^{A}\equiv A+\left(1\Rightarrow A\right)$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Cont
\family default
\size default
\color inherit
: A chain of asynchronous operations
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{Cont}^{A}\equiv\left(A\Rightarrow R\right)\Rightarrow R$
\end_inset

 where 
\begin_inset Formula $R$
\end_inset

 is the fixed 
\begin_inset Quotes eld
\end_inset

result
\begin_inset Quotes erd
\end_inset

 type
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
State
\family default
\size default
\color inherit
: A sequence of steps that update state while returning results
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{State}^{A}\equiv S\Rightarrow A\times S$
\end_inset

 where 
\begin_inset Formula $S$
\end_inset

 is the fixed 
\begin_inset Quotes eld
\end_inset

state
\begin_inset Quotes erd
\end_inset

 value type
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Deriving the types of single-value monads
\end_layout

\begin_layout Standard
Motivation for the choice of the type constructors 
\begin_inset Formula $\text{Writer}^{A}$
\end_inset

, 
\begin_inset Formula $\text{Reader}^{A}$
\end_inset

, 
\begin_inset Formula $\text{State}^{A}$
\end_inset

, 
\begin_inset Formula $\text{Cont}^{A}$
\end_inset


\end_layout

\begin_layout Standard
We want previous values to be transformed via 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 to next values
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Writer
\family default
\size default
\color inherit
: a computation 
\begin_inset Formula $\left(A\Rightarrow B\right)$
\end_inset

 and some info (
\begin_inset Formula $W$
\end_inset

) about it
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{A}\Rightarrow f(x):B$
\end_inset

 and 
\begin_inset Formula $x^{A}\Rightarrow g(x):W$
\end_inset

; the type is 
\begin_inset Formula $\left(A\Rightarrow B\right)\times\left(A\Rightarrow W\right)$
\end_inset


\end_layout

\begin_layout Standard
this function should have type 
\begin_inset Formula $A\Rightarrow\text{Writer}^{B}$
\end_inset

, hence 
\begin_inset Formula $\text{Writer}^{B}\equiv B\times W$
\end_inset

 
\end_layout

\begin_layout Standard
use the 
\begin_inset Quotes eld
\end_inset

arithmetic
\begin_inset Quotes erd
\end_inset

 Curry-Howard to transform types: 
\begin_inset Formula $b^{a}w^{a}=(bw)^{a}$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Reader
\family default
\size default
\color inherit
: Read-only context, or 
\begin_inset Quotes eld
\end_inset

environment
\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset Formula $E$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $x^{A}\Rightarrow f(r,x):B$
\end_inset

 where 
\begin_inset Formula $r^{E}$
\end_inset

 is fixed; the type is 
\begin_inset Formula $A\times E\Rightarrow B$
\end_inset


\end_layout

\begin_layout Standard
this function should have type 
\begin_inset Formula $A\Rightarrow\text{Reader}^{B}$
\end_inset

, hence 
\begin_inset Formula $\text{Reader}^{B}\equiv E\Rightarrow B$
\end_inset


\end_layout

\begin_layout Standard
we used the 
\begin_inset Quotes eld
\end_inset

arithmetic
\begin_inset Quotes erd
\end_inset

 Curry-Howard to transform 
\begin_inset Formula $b^{ae}=(b^{e})^{a}$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Cont
\family default
\size default
\color inherit
: A computation that registers an asynchronous callback
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{A}\Rightarrow f(cb):1$
\end_inset

 where 
\begin_inset Formula $cb:B\Rightarrow1$
\end_inset

 (usually, callbacks return 
\family typewriter
\size footnotesize
\color blue
Unit
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Standard
the type is
\size footnotesize
 
\begin_inset Formula $A\Rightarrow\left(B\Rightarrow1\right)\Rightarrow1$
\end_inset


\size default
; this function should have type 
\size footnotesize

\begin_inset Formula $A\Rightarrow\text{Cont}^{B}$
\end_inset


\size default
, hence
\size footnotesize
 
\begin_inset Formula $\text{Cont}^{B}\equiv\left(B\Rightarrow1\right)\Rightarrow1$
\end_inset


\end_layout

\begin_layout Standard
generalize to 
\size footnotesize

\begin_inset Formula $\text{Cont}^{A}\equiv\left(A\Rightarrow R\right)\Rightarrow R$
\end_inset

 
\size default
where 
\begin_inset Formula $R$
\end_inset

 is a fixed 
\begin_inset Quotes eld
\end_inset

result
\begin_inset Quotes erd
\end_inset

 type
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
State
\family default
\size default
\color inherit
: A computation can update state (
\begin_inset Formula $S$
\end_inset

) while producing a result
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{A}\Rightarrow f(x,s)$
\end_inset

 and 
\begin_inset Formula $s^{S}:=g(x,s)$
\end_inset

; the type is
\size footnotesize
 
\begin_inset Formula $\left(A\times S\Rightarrow B\right)\times\left(A\times S\Rightarrow S\right)$
\end_inset


\end_layout

\begin_layout Standard
this will be 
\begin_inset Formula $A\Rightarrow\text{State}^{B}$
\end_inset

 if 
\size footnotesize

\begin_inset Formula $\text{State}^{B}\equiv\left(S\Rightarrow B\right)\times\left(S\Rightarrow S\right)\equiv S\Rightarrow B\times S$
\end_inset

 
\end_layout

\begin_layout Standard
we used the 
\begin_inset Quotes eld
\end_inset

arithmetic
\begin_inset Quotes erd
\end_inset

 Curry-Howard: 
\begin_inset Formula $b^{as}s^{as}=(b^{s}s^{s})^{a}=\left(\left(bs\right)^{s}\right)^{a}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Exercises I
\end_layout

\begin_layout Standard
For a given 
\family typewriter
\size footnotesize
\color blue
Set[Int]
\family default
\size default
\color inherit
, compute all subsets 
\begin_inset Formula $\left(w,x,y,z\right)$
\end_inset

 of size 4 such that 
\begin_inset Formula $w<x<y<z$
\end_inset

 and 
\begin_inset Formula $w+z=x+y$
\end_inset


\end_layout

\begin_layout Standard
Given 3 sequences 
\begin_inset Formula $xs$
\end_inset

, 
\begin_inset Formula $ys$
\end_inset

, 
\begin_inset Formula $zs$
\end_inset

 of type 
\family typewriter
\size footnotesize
\color blue
Seq[Int]
\family default
\size default
\color inherit
, compute all 
\begin_inset Formula $\left(x,y,z\right)$
\end_inset

 such that 
\begin_inset Formula $x\in xs$
\end_inset

, 
\begin_inset Formula $y\in ys$
\end_inset

, 
\begin_inset Formula $z\in zs$
\end_inset

 and 
\begin_inset Formula $x<y<z$
\end_inset

 and 
\begin_inset Formula $x+y+z<10$
\end_inset


\end_layout

\begin_layout Standard
Solve the 
\begin_inset Formula $n$
\end_inset

-queens problem on an 
\begin_inset Formula $3\times3\times3$
\end_inset

 cube
\end_layout

\begin_layout Standard
Write a tiny library for arithmetic using 
\family typewriter
\size footnotesize
\color blue
Future
\family default
\size default
\color inherit
's; use it to compute 
\begin_inset Formula $1+2+...+100$
\end_inset

 via 
\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
yield
\family default
\size default
\color inherit
 and verify the result.
 E.g.
\begin_inset space \space{}
\end_inset

implement: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
const: Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Future[Int]
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
add(x: Int): Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Future[Int]
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
isEqual(x: Int): Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Future[Boolean] 
\end_layout

\begin_layout Standard
Read a file into a string and write it to another file using Java 
\family typewriter
\size footnotesize
\color blue
Files
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Paths
\family default
\size default
\color inherit
 API
\family typewriter
\size footnotesize
\color blue
.
 
\family default
\size default
\color inherit
Use 
\family typewriter
\size footnotesize
\color blue
Try
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
yield
\family default
\size default
\color inherit
 to make this safe.
\end_layout

\begin_layout Standard
Given a semigroup 
\begin_inset Formula $W$
\end_inset

, make a semimonad out of 
\begin_inset Formula $F^{A}\equiv E\Rightarrow A\times W$
\end_inset

 
\end_layout

\begin_layout Standard
Implement a semimonad instance for the (recursive) type constructor 
\begin_inset Formula $F^{A}=A+A\times A+F^{A}+F^{A}\times F^{A}$
\end_inset


\end_layout

\begin_layout Standard
Find the largest prime number below 1000 via a simple 
\begin_inset CommandInset href
LatexCommand href
name "Sieve of Eratosthenes"
target "https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"
literal "false"

\end_inset

; use the 
\family typewriter
\size footnotesize
\color blue
State[S, Int]
\family default
\size default
\color inherit
 monad with 
\family typewriter
\size footnotesize
\color blue
S = Array[Boolean]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Section
Slides, part 2
\end_layout

\begin_layout Subsection
Semimonad laws I: The intuitions
\end_layout

\begin_layout Standard
What properties of functor block programs do we expect to have?
\end_layout

\begin_layout Standard
In 
\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\leftarrow$
\end_inset

 c
\family default
\size default
\color inherit
, the value of 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 will 
\emph on
go over items
\emph default
 held in container 
\family typewriter
\size footnotesize
\color blue
c
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Manipulating items in container is followed by a generator:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\leftarrow$
\end_inset

 cont1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
y = f(x)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
z 
\begin_inset Formula $\leftarrow$
\end_inset

 cont2(y)
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
y 
\begin_inset Formula $\leftarrow$
\end_inset

 cont1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
      .map(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 f(x))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
z 
\begin_inset Formula $\leftarrow$
\end_inset

 cont2(y)
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
cont1.flatMap(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 cont2(f(x))) = cont1.map(f).flatMap(y 
\begin_inset Formula $\Rightarrow$
\end_inset

 cont2(y))
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Manipulating items in container is preceded by a generator:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\leftarrow$
\end_inset

 cont1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
y 
\begin_inset Formula $\leftarrow$
\end_inset

 cont2(x)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
z = f(y)
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\leftarrow$
\end_inset

 cont1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
z 
\begin_inset Formula $\leftarrow$
\end_inset

 cont2(x)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
       .map(f)
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset VSpace defskip
\end_inset

cont1.flatMap(cont2).map(f)
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
= cont1.flatMap(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 cont2(x).map(f))
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Within a generator, 
\family typewriter
\size footnotesize
\color blue
for {...} yield
\family default
\size default
\color inherit
 can be inlined:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\leftarrow$
\end_inset

 cont
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
y 
\begin_inset Formula $\leftarrow$
\end_inset

 p(x)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
z 
\begin_inset Formula $\leftarrow$
\end_inset

 cont2(y)
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
yy 
\begin_inset Formula $\leftarrow$
\end_inset

 for { x 
\begin_inset Formula $\leftarrow$
\end_inset

 cont
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
            y 
\begin_inset Formula $\leftarrow$
\end_inset

 p(x) } yield y
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
z 
\begin_inset Formula $\leftarrow$
\end_inset

 cont2(yy)
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset VSpace defskip
\end_inset

cont.flatMap(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 p(x).flatMap(cont2)) = cont.flatMap(p).flatMap(cont2)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Semimonad laws II: The laws for 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
For brevity, write 
\size footnotesize

\begin_inset Formula $\text{flm}$
\end_inset


\size default
 instead of 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
A 
\series bold
semimonad
\series default
 
\begin_inset Formula $S^{A}$
\end_inset

 has 
\size footnotesize

\begin_inset Formula $\text{flm}^{\left[A,B\right]}:\left(A\Rightarrow S^{B}\right)\Rightarrow S^{A}\Rightarrow S^{B}$
\end_inset


\size default
 with 3 laws:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{flm}\,(f^{A\Rightarrow B}\bef g^{B\Rightarrow S^{C}})=\text{fmap}\,f\bef\text{flm}\,g$
\end_inset


\size default
 
\size footnotesize
(naturality in 
\begin_inset Formula $A$
\end_inset

)
\size default
 
\size footnotesize

\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & S^{B}\ar[rd]\sp(0.5){\ \text{flm}\,g^{B\Rightarrow S^{C}}}\\
S^{A}\ar[ru]\sp(0.5){\text{fmap}\,f^{A\Rightarrow B}\ }\ar[rr]\sb(0.5){\text{flm}\,(f^{A\Rightarrow B}\bef\,g^{B\Rightarrow S^{C}})\,} &  & S^{C}
}
\]

\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{flm}\,\big(f^{A\Rightarrow S^{B}}\bef\text{fmap}\,g^{B\Rightarrow C}\big)=\text{flm}\,f\bef\text{fmap}\,g$
\end_inset


\size default
 
\size footnotesize
(naturality in 
\begin_inset Formula $B$
\end_inset

)
\size default
 
\size footnotesize

\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & S^{B}\ar[rd]\sp(0.5){\ \text{fmap}\,g^{B\Rightarrow C}}\\
S^{A}\ar[ru]\sp(0.5){\text{flm}\,f^{A\Rightarrow S^{B}}\ }\ar[rr]\sb(0.5){\text{flm}\,(f^{A\Rightarrow S^{B}}\bef\,\text{fmap}\,g^{B\Rightarrow C})\,} &  & S^{C}
}
\]

\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{flm}\,\big(f^{A\Rightarrow S^{B}}\bef\text{flm}\,g^{B\Rightarrow S^{C}}\big)=\text{flm}\,f\bef\text{flm}\,g$
\end_inset


\size default
 
\size footnotesize
(associativity)
\size default
 
\size footnotesize

\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & S^{B}\ar[rd]\sp(0.5){\ \text{flm}\,g^{B\Rightarrow S^{C}}}\\
S^{A}\ar[ru]\sp(0.5){\text{flm}\,f^{A\Rightarrow S^{B}}\ }\ar[rr]\sb(0.5){\text{flm}\,\big(f^{A\Rightarrow S^{B}}\bef\,\text{flm}\,g^{B\Rightarrow S^{C}}\big)\,} &  & S^{C}
}
\]

\end_inset


\end_layout

\begin_layout Standard
Is there a shorter and clearer formulation of these laws?
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Semimonad laws III: The laws for 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
The methods 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 (denoted by 
\size footnotesize

\begin_inset Formula $\text{ftn}$
\end_inset


\size default
) and 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 are equivalent:
\family typewriter
\size footnotesize
\color blue
 
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula 
\begin{align*}
\text{ftn}^{\left[A\right]}:S^{S^{A}}\Rightarrow S^{A} & \equiv\text{flm}^{\left[S^{A},A\right]}(m^{S^{A}}\Rightarrow m)\\
\text{flm}\,\big(f^{A\Rightarrow S^{B}}\big) & \equiv\text{fmap}\,f\bef\text{ftn}
\end{align*}

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & S^{S^{B}}\ar[rd]\sp(0.5){\ \text{ftn}\ }\\
S^{A}\ar[ru]\sp(0.5){\text{fmap}\,f^{A\Rightarrow S^{B}}\ }\ar[rr]\sb(0.5){\text{flm}\,\big(f^{A\Rightarrow S^{B}}\big)\,} &  & S^{B}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Standard
It turns out that 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 has only 2 laws:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{fmap}\big(\text{fmap}\,f^{A\Rightarrow B}\big)\bef\text{ftn}^{\left[B\right]}=\text{ftn}^{\left[A\right]}\bef\text{fmap}\,f$
\end_inset


\size default
 
\size footnotesize
(naturality)
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{5pc} & S^{S^{B}}\ar[rd]\sp(0.5){\ \text{ftn}^{\left[B\right]}}\\
S^{S^{A}}\ar[ru]\sp(0.5){\text{fmap}\,\big(\text{fmap}\,f^{A\Rightarrow B}\big)\ \ }\ar[rd]\sb(0.5){\text{ftn}^{\left[A\right]}\,} &  & S^{B}\\
 & S^{A}\ar[ru]\sb(0.5){\text{fmap}\,f^{A\Rightarrow B}}
}
\]

\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{fmap}\,(\text{ftn}^{\left[A\right]})\bef\text{ftn}^{\left[A\right]}=\text{ftn}^{[S^{A}]}\bef\text{ftn}^{\left[A\right]}$
\end_inset


\size default
 
\size footnotesize
(associativity) 
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{5pc} & S^{S^{A}}\ar[rd]\sp(0.5){\ \text{ftn}^{\left[A\right]}}\\
S^{S^{S^{A}}}\ar[ru]\sp(0.5){\text{fmap}\,(\text{ftn}^{\left[A\right]})\ }\ar[rd]\sb(0.5){\text{ftn}^{[S^{A}]}\,} &  & S^{A}\\
 & S^{S^{A}}\ar[ru]\sb(0.5){\text{ftn}^{\left[A\right]}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Equivalence of a natural transformation and a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Equivalence of 
\size footnotesize

\begin_inset Formula $\text{flm}$
\end_inset


\size default
 and 
\size footnotesize

\begin_inset Formula $\text{ftn}$
\end_inset


\size default
: 
\size footnotesize

\begin_inset Formula $\text{ftn}=\text{flm}\left(\text{id}\right)$
\end_inset

; 
\begin_inset Formula $\text{flm}\,f=\text{fmap}\,f\bef\text{ftn}$
\end_inset


\size default
 
\end_layout

\begin_layout Standard
We saw this before: 
\size footnotesize

\begin_inset Formula $\text{deflate}=\text{fmapOpt}\left(\text{id}\right)$
\end_inset


\size default
; 
\size footnotesize

\begin_inset Formula $\text{fmapOpt}\,f=\text{fmap}\:f\bef\text{deflate}$
\end_inset


\size default
 
\end_layout

\begin_layout Standard
Is there a general pattern where two such functions are equivalent?
\end_layout

\begin_layout Standard
Let 
\size footnotesize

\begin_inset Formula $\text{tr}:F^{G^{A}}\Rightarrow F^{A}$
\end_inset

 
\size default
be a natural transformation (
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are functors)
\end_layout

\begin_layout Standard
Define 
\size footnotesize

\begin_inset Formula $\text{ftr}:\left(A\Rightarrow G^{B}\right)\Rightarrow F^{A}\Rightarrow F^{B}$
\end_inset


\size default
 by 
\size footnotesize

\begin_inset Formula $\text{ftr}\,f=\text{fmap}\,f\bef\text{tr}$
\end_inset


\size default
 
\end_layout

\begin_layout Standard
It follows that 
\size footnotesize

\begin_inset Formula $\text{tr}=\text{ftr}\left(\text{id}\right)$
\end_inset


\size default
, and we have equivalence between 
\size footnotesize

\begin_inset Formula $\text{tr}$
\end_inset


\size default
 and 
\size footnotesize

\begin_inset Formula $\text{ftr}$
\end_inset


\size default
:
\family typewriter
\size footnotesize
\color blue
 
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula 
\begin{align*}
\text{tr}:F^{G^{A}}\Rightarrow F^{A} & =\text{ftr}(m^{G^{A}}\Rightarrow m)\\
\text{ftr}\,\big(f^{A\Rightarrow G^{B}}\big) & =\text{fmap}\,f\bef\text{tr}
\end{align*}

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{G^{B}}\ar[rd]\sp(0.5){\ \text{tr}\ }\\
F^{A}\ar[ru]\sp(0.5){\text{fmap}\,f^{A\Rightarrow G^{B}}\ }\ar[rr]\sb(0.5){\text{ftr}\,\big(f^{A\Rightarrow G^{B}}\big)\,} &  & F^{B}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Standard
An automatic law for 
\size footnotesize

\begin_inset Formula $\text{ftr}$
\end_inset


\size default
 (
\begin_inset Quotes eld
\end_inset

naturality in 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

) follows from the definition: 
\size footnotesize

\begin_inset Formula $\text{fmap}\,g\bef\text{ftr}\,f=\text{fmap}\,g\bef\text{fmap}\,f\bef\text{tr}=\text{fmap}\left(g\bef f\right)\bef\text{tr}=\text{ftr}\left(g\bef f\right)$
\end_inset


\size default
 
\end_layout

\begin_layout Standard
This is why 
\size footnotesize

\begin_inset Formula $\text{tr}$
\end_inset


\size default
 always has 
\emph on
one law fewer
\emph default
 than 
\size footnotesize

\begin_inset Formula $\text{ftr}$
\end_inset


\end_layout

\begin_layout Standard
To demonstrate equivalence in the direction 
\size footnotesize

\begin_inset Formula $\text{ftr}\rightarrow\text{tr}$
\end_inset


\size default
: Start with an arbitrary 
\size footnotesize

\begin_inset Formula $\text{ftr}$
\end_inset


\size default
 satisfying 
\begin_inset Quotes eld
\end_inset

naturality in 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

, then obtain 
\size footnotesize

\begin_inset Formula $\text{tr}=\text{ftr}\left(\text{id}\right)$
\end_inset


\size default
 from it, then verify 
\size footnotesize

\begin_inset Formula $\text{ftr}\,f=\text{fmap}\,f\bef\text{tr}$
\end_inset


\size default
 with that 
\size footnotesize

\begin_inset Formula $\text{tr}$
\end_inset


\size default
; 
\size footnotesize

\begin_inset Formula $\text{fmap}\,f\bef\text{ftr}\left(\text{id}\right)=\text{ftr}\left(f\bef id\right)=\text{ftr}\,f$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Semimonad laws IV: Deriving the laws for 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Denote for brevity 
\begin_inset Formula $q^{\uparrow}\equiv\text{fmap}\,q$
\end_inset

 for any function 
\begin_inset Formula $q$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $q^{A\Rightarrow B}$
\end_inset

 to 
\begin_inset Formula $S$
\end_inset

)
\end_layout

\begin_layout Standard
Express 
\begin_inset Formula $\text{flm}\,f=f^{\uparrow}\bef\text{ftn}$
\end_inset

 and substitute that into 
\begin_inset Formula $\text{flm}$
\end_inset

's 3 laws:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{flm}\left(f\bef g\right)=f^{\uparrow}\bef\text{flm}\,g$
\end_inset


\size default
 gives 
\size footnotesize

\begin_inset Formula $\left(f\bef g\right)^{\uparrow}\bef\text{ftn}=f^{\uparrow}\bef g^{\uparrow}\bef\text{ftn}$
\end_inset


\size default

\begin_inset Newline newline
\end_inset

– this law holds automatically due to functor composition law
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{flm}\left(f\bef g^{\uparrow}\right)=\text{flm}\,f\bef g^{\uparrow}$
\end_inset


\size default
 gives 
\size footnotesize

\begin_inset Formula $\left(f\bef g^{\uparrow}\right)^{\uparrow}\bef\text{ftn}=f^{\uparrow}\bef\text{ftn}\bef g^{\uparrow}$
\end_inset


\size default
;
\begin_inset Newline newline
\end_inset

using the functor composition law, we reduce this to
\begin_inset Newline newline
\end_inset


\size footnotesize

\begin_inset Formula $g^{\uparrow\uparrow}\bef\text{ftn}=\text{ftn}\bef g^{\uparrow}$
\end_inset


\size default
 – this is the naturality law
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{flm}\left(f\bef\text{flm}\,g\right)=\text{flm}\,f\bef\text{flm}\,g$
\end_inset

 
\size default
with functor composition law gives
\size footnotesize
 
\begin_inset Formula $f^{\uparrow}\bef g^{\uparrow\uparrow}\bef\text{ftn}^{\uparrow}\bef\text{ftn}=f^{\uparrow}\bef\text{ftn}\bef g^{\uparrow}\bef\text{ftn}$
\end_inset

;
\size default
 using 
\size footnotesize

\begin_inset Formula $\text{ftn}$
\end_inset


\size default
's naturality and omitting the common factor
\size footnotesize
 
\begin_inset Formula $f^{\uparrow}\bef g^{\uparrow\uparrow}$
\end_inset


\size default
, we get
\size footnotesize
 
\begin_inset Formula $\text{ftn}^{\uparrow}\bef\text{ftn}=\text{ftn}\bef\text{ftn}$
\end_inset


\size default
 – associativity law
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 has the simplest type signature 
\emph on
and
\emph default
 the fewest laws
\end_layout

\begin_layout Standard
It is usually easy to check naturality!
\end_layout

\begin_layout Standard

\series bold
Parametricity theorem
\series default
: Any 
\emph on
pure, fully parametric
\emph default
 code for a function of type 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 will implement a natural transformation
\end_layout

\begin_layout Standard
Checking 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
's associativity needs 
\emph on
a lot
\emph default
 more work!
\end_layout

\begin_layout Standard
The 
\family typewriter
\size footnotesize
\color blue
cats
\family default
\size default
\color inherit
 library has a 
\family typewriter
\size footnotesize
\color blue
FlatMap
\family default
\size default
\color inherit
 type class, defining 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 via 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Checking the associativity law for standard monads
\end_layout

\begin_layout Standard
Implement 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 for these functors and check the laws (see code):
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Option
\family default
\size default
\color inherit
 monad: 
\begin_inset Formula $F^{A}\equiv1+A$
\end_inset

; 
\begin_inset Formula $\text{ftn}:1+\left(1+A\right)\Rightarrow1+A$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
 monad: 
\begin_inset Formula $F^{A}\equiv Z+A$
\end_inset

; 
\begin_inset Formula $\text{ftn}:Z+\left(Z+A\right)\Rightarrow Z+A$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
List
\family default
\size default
\color inherit
 monad: 
\begin_inset Formula $F^{A}\equiv\text{List}^{A}$
\end_inset

; 
\begin_inset Formula $\text{ftn}:\text{List}^{\text{List}^{A}}\Rightarrow\text{List}^{A}$
\end_inset


\end_layout

\begin_layout Standard
Writer monad: 
\begin_inset Formula $F^{A}\equiv A\times W$
\end_inset

; 
\begin_inset Formula $\text{ftn}:\left(A\times W\right)\times W\Rightarrow A\times W$
\end_inset


\end_layout

\begin_layout Standard
Reader monad: 
\begin_inset Formula $F^{A}\equiv R\Rightarrow A$
\end_inset

; 
\begin_inset Formula $\text{ftn}:\left(R\Rightarrow\left(R\Rightarrow A\right)\right)\Rightarrow R\Rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
State: 
\begin_inset Formula $F^{A}\equiv S\Rightarrow A\times S$
\end_inset

; 
\begin_inset Formula $\text{ftn}:\left(S\Rightarrow\left(S\Rightarrow A\times S\right)\times S\right)\Rightarrow S\Rightarrow A\times S$
\end_inset


\end_layout

\begin_layout Standard
Continuation monad: 
\begin_inset Formula $F^{A}\equiv\left(A\Rightarrow R\right)\Rightarrow R$
\end_inset

; 
\begin_inset Formula $\text{ftn}:\left(\left(\left(\left(A\Rightarrow R\right)\Rightarrow R\right)\Rightarrow R\right)\Rightarrow R\right)\Rightarrow\left(A\Rightarrow R\right)\Rightarrow R$
\end_inset


\end_layout

\begin_layout Standard
Code implementing these 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 functions is 
\emph on
fully parametric
\emph default
 in 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Standard
Naturality of these functions follows from parametricity theorem
\end_layout

\begin_layout Standard
Associativity needs to be checked for each monad!
\end_layout

\begin_layout Standard
Example of a useful semimonad that is 
\emph on
not
\emph default
 a full monad:
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A\times V\times W$
\end_inset

; 
\begin_inset Formula $\text{ftn}\left(\left(a\times v_{1}\times w_{1}\right)\times v_{2}\times w_{2}\right)=a\times v_{1}\times w_{2}$
\end_inset


\end_layout

\begin_layout Standard
Examples of 
\emph on
non-associative
\emph default
 (i.e.
\begin_inset space \space{}
\end_inset

wrong) implementations of 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A\times W\times W$
\end_inset

; 
\begin_inset Formula $\text{ftn}\left(\left(a\times v_{1}\times v_{2}\right)\times w_{1}\times w_{2}\right)=a\times w_{2}\times w_{1}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv\text{List}^{A}$
\end_inset

, but 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 concatenates the nested lists in reverse order
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Motivation for monads
\end_layout

\begin_layout Standard
Monads represent values with a 
\begin_inset Quotes eld
\end_inset

special computational context
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Specific monads will have methods to create various contexts
\end_layout

\begin_layout Standard
Monadic composition will 
\begin_inset Quotes eld
\end_inset

combine
\begin_inset Quotes erd
\end_inset

 the contexts associatively
\end_layout

\begin_layout Standard
It is generally useful to have an 
\begin_inset Quotes eld
\end_inset

empty context
\begin_inset Quotes erd
\end_inset

 available:
\begin_inset Formula 
\[
\text{pure}:A\Rightarrow M^{A}
\]

\end_inset


\end_layout

\begin_layout Standard
Adding the empty context to another context should be a no-op
\end_layout

\begin_layout Standard
Empty context is followed by a generator:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
y 
\begin_inset Formula $\leftarrow$
\end_inset

 pure(x)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
z 
\begin_inset Formula $\leftarrow$
\end_inset

 cont(y)
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
y = x
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
z 
\begin_inset Formula $\leftarrow$
\end_inset

 cont(y)
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
pure(x).flatMap(y 
\begin_inset Formula $\Rightarrow$
\end_inset

 cont(y)) = cont(x)
\family default
\size default
\color inherit

\begin_inset Formula $\quad\quad\text{pure}\bef\text{flm}\,f=f$
\end_inset

 
\color gray
– left identity
\end_layout

\begin_layout Standard
Empty context is preceded by a generator:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\leftarrow$
\end_inset

 cont
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
y 
\begin_inset Formula $\leftarrow$
\end_inset

 pure(x)
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\leftarrow$
\end_inset

 cont
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
y = x
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset VSpace defskip
\end_inset

cont.flatMap(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 pure(x))
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
= cont
\family default
\size default
\color inherit
 
\begin_inset Formula $\quad\quad\quad\text{flm}\left(\text{pure}\right)=\text{id}$
\end_inset

 
\color gray
– right identity
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
The monad laws formulated in terms of 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Naturality law for 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
: 
\begin_inset Formula $f\bef\text{pure}=\text{pure}\bef\text{fmap}\,f$
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{5pc} & B\ar[rd]\sp(0.5){\ \text{pure}^{\left[B\right]}}\\
A\ar[ru]\sp(0.5){f^{A\Rightarrow B}\ }\ar[rd]\sb(0.5){\text{pure}^{[A]}\,} &  & S^{B}\\
 & S^{A}\ar[ru]\sb(0.5){\text{fmap}\,f^{A\Rightarrow B}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
Left identity: 
\begin_inset Formula $\text{pure}\bef\text{flm}\,f=\text{pure}\bef\text{fmap}\,f\bef\text{ftn}=f\bef\text{pure}\bef\text{ftn}=f$
\end_inset

 requires that 
\begin_inset Formula $\text{pure}\bef\text{ftn}=\text{id}$
\end_inset

 (both sides applied to 
\begin_inset Formula $S^{A}$
\end_inset

)
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & S^{S^{A}}\ar[rd]\sp(0.5){\ \text{ftn}^{[A]}\ }\\
S^{A}\ar[ru]\sp(0.5){\text{pure}^{[S^{A}]}\ }\ar[rr]\sb(0.5){\text{id}} &  & S^{A}
}
\]

\end_inset


\end_layout

\begin_layout Standard
Right identity: 
\begin_inset Formula $\text{flm}\left(\text{pure}\right)=\text{fmap}\left(\text{pure}\right)\bef\text{ftn}=\text{id}^{S^{A}\Rightarrow S^{A}}$
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & S^{S^{A}}\ar[rd]\sp(0.5){\ \text{ftn}^{[A]}\ }\\
S^{A}\ar[ru]\sp(0.5){\text{fmap}(\text{pure}^{[A]})\quad}\ar[rr]\sb(0.5){\text{id}} &  & S^{A}
}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Formulating laws via Kleisli functions
\end_layout

\begin_layout Standard
Recall: we formulated the laws of filterables via 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
type signature of 
\begin_inset Formula $\text{fmapOpt}:\left(A\Rightarrow1+B\right)\Rightarrow S^{A}\Rightarrow S^{B}$
\end_inset


\end_layout

\begin_layout Standard
and then we had to compose functions of types 
\begin_inset Formula $A\Rightarrow1+B$
\end_inset

 via 
\begin_inset Formula $\diamond_{\text{Opt}}$
\end_inset


\end_layout

\begin_layout Standard
Here we have
\size small
 
\begin_inset Formula $\text{flm}:\left(A\Rightarrow S^{B}\right)\Rightarrow S^{A}\Rightarrow S^{B}$
\end_inset


\size default
 instead of 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Can we compose 
\series bold
Kleisli functions
\series default
 with 
\begin_inset Quotes eld
\end_inset

twisted
\begin_inset Quotes erd
\end_inset

 type, 
\begin_inset Formula $A\Rightarrow S^{B}$
\end_inset

?
\end_layout

\begin_layout Standard
Use 
\begin_inset Formula $\text{flm}$
\end_inset

 to define 
\series bold
Kleisli composition
\series default
: 
\begin_inset Formula $f^{A\Rightarrow S^{B}}\diamond g^{B\Rightarrow S^{C}}\equiv f\bef\text{flm}\,g$
\end_inset


\end_layout

\begin_layout Standard
Define 
\series bold
Kleisli identity
\series default
 
\begin_inset Formula $\text{id}_{\diamond}$
\end_inset

 of type 
\begin_inset Formula $A\Rightarrow S^{A}$
\end_inset

 as 
\begin_inset Formula $\text{id}_{\diamond}\equiv\text{pure}$
\end_inset


\end_layout

\begin_layout Standard
Composition law: 
\begin_inset Formula $\text{flm}\left(f\diamond g\right)=\text{flm}\,f\bef\text{flm}\,g$
\end_inset

 (same as for 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Standard
Shows that 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 is a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset Formula $A\Rightarrow S^{B}$
\end_inset

 to 
\begin_inset Formula $S^{A}\Rightarrow S^{B}$
\end_inset


\end_layout

\begin_layout Standard
These laws are similar to functor 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 laws...
\end_layout

\begin_layout Standard
except that 
\begin_inset Formula $\diamond$
\end_inset

 is used for composing Kleisli functions
\end_layout

\begin_layout Standard
What are the properties of 
\begin_inset Formula $\diamond$
\end_inset

?
\end_layout

\begin_layout Standard
Exactly similar to the properties of function composition 
\begin_inset Formula $f\bef g$
\end_inset


\end_layout

\begin_layout Standard
Reformulate 
\begin_inset Formula $\text{flm}$
\end_inset

's laws in terms of the 
\begin_inset Formula $\diamond$
\end_inset

 operation:
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{flm}$
\end_inset

's left and right identity laws: 
\begin_inset Formula $\text{pure}\diamond f=f$
\end_inset

 and 
\begin_inset Formula $f\diamond\text{pure}=f$
\end_inset


\end_layout

\begin_layout Standard
Associativity law: 
\begin_inset Formula $\left(f\diamond g\right)\diamond h=f\diamond\left(g\diamond h\right)$
\end_inset


\end_layout

\begin_layout Standard
Follows from the 
\begin_inset Formula $\text{flm}$
\end_inset

 law: 
\begin_inset Formula $f\bef\text{flm}\left(g\bef\text{flm}h\right)=f\bef\text{flm}\,g\bef\text{flm}\,h$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* Motivation for categories and functors
\end_layout

\begin_layout Standard
Compare different 
\begin_inset Quotes eld
\end_inset

liftings
\begin_inset Quotes erd
\end_inset

 seen so far, and generalize
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Category
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type 
\series default

\begin_inset Formula $A\rightsquigarrow B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Identity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Composition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
plain functions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{id}:A\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f^{A\Rightarrow B}\bef g^{B\Rightarrow C}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lifted to 
\begin_inset Formula $F$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F^{A}\Rightarrow F^{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{id}:F^{A}\Rightarrow F^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f^{F^{A}\Rightarrow F^{B}}\bef g^{F^{B}\Rightarrow F^{C}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kleisli over 
\begin_inset Formula $F$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\Rightarrow F^{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{pure}:A\Rightarrow F^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f^{A\Rightarrow F^{B}}\diamond g^{B\Rightarrow F^{C}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Category theory generalizes this situation
\end_layout

\begin_layout Standard

\series bold
Category
\series default
: a certain class of 
\begin_inset Quotes eld
\end_inset

twisted functions
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $A\rightsquigarrow B$
\end_inset

 called 
\series bold
morphisms
\end_layout

\begin_layout Standard
For any two morphisms 
\begin_inset Formula $f^{A\rightsquigarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{B\rightsquigarrow C}$
\end_inset

 the 
\series bold
composition
\series default
 morphism 
\begin_inset Formula $f\diamond g$
\end_inset

 of type 
\begin_inset Formula $A\rightsquigarrow C$
\end_inset

 must exist
\end_layout

\begin_layout Standard
For each type 
\begin_inset Formula $A$
\end_inset

, the 
\series bold
identity
\series default
 morphism 
\begin_inset Formula $\text{id}_{\diamond}$
\end_inset

 of type 
\begin_inset Formula $A\rightsquigarrow A$
\end_inset

 must exist
\end_layout

\begin_layout Standard
Composition respects identity: 
\begin_inset Formula $\text{id}_{\diamond}\diamond f=f$
\end_inset

 and 
\begin_inset Formula $f\diamond\text{id}_{\diamond}=f$
\end_inset


\end_layout

\begin_layout Standard
Composition is associative: 
\begin_inset Formula $\left(f\diamond g\right)\diamond h=f\diamond\left(g\diamond h\right)$
\end_inset


\end_layout

\begin_layout Standard
General 
\series bold
functor
\series default
: a map from one category to another
\end_layout

\begin_layout Standard
A functor must 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 each morphism from one category to the other
\end_layout

\begin_layout Standard
Functor laws: 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 must preserve identity and composition
\end_layout

\begin_layout Standard
What we call 
\begin_inset Quotes eld
\end_inset

functor
\begin_inset Quotes erd
\end_inset

 is called 
\series bold
endofunctor
\series default
 in category theory
\end_layout

\begin_layout Standard
An endofunctor's 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 goes from plain functions to 
\begin_inset Formula $F$
\end_inset

-lifted functions
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* From Kleisli back to 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
The Kleisli functions, 
\begin_inset Formula $A\rightsquigarrow B\equiv A\Rightarrow S^{B}$
\end_inset

, form a category iff 
\begin_inset Formula $S$
\end_inset

 is a monad 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 are computationally equivalent to Kleisli composition:
\end_layout

\begin_layout Standard
Define 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 through Kleisli:
\size small
 
\begin_inset Formula $\text{flm}\,f^{A\Rightarrow S^{B}}\equiv\text{id}^{S^{A}\Rightarrow S^{A}}\diamond f$
\end_inset


\end_layout

\begin_layout Standard
Require two additional laws that connect 
\begin_inset Formula $\diamond$
\end_inset

, 
\begin_inset Formula $\text{fmap}$
\end_inset

, and 
\begin_inset Formula $\bef$
\end_inset

:
\end_layout

\begin_layout Standard
Left naturality: 
\size small

\begin_inset Formula $f^{A\Rightarrow B}\bef g^{B\Rightarrow S^{C}}=\left(f\bef\text{pure}\right)\diamond g$
\end_inset


\end_layout

\begin_layout Standard
Right naturality: 
\size small

\begin_inset Formula $f^{A\Rightarrow S^{B}}\bef\text{fmap}\,g^{B\Rightarrow C}=f\diamond\left(g\bef\text{pure}\right)$
\end_inset


\end_layout

\begin_layout Standard
So, can define 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 through Kleisli: 
\begin_inset Formula $\text{fmap}\,g^{A\Rightarrow B}\equiv\text{id}^{S^{A}\Rightarrow S^{A}}\diamond\left(g\bef\text{pure}\right)$
\end_inset


\end_layout

\begin_layout Standard
The laws for 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 then follow from category axioms for Kleisli:
\end_layout

\begin_layout Standard
Left and right identity laws follow from 
\begin_inset Formula $\text{id}\diamond\text{pure}=\text{id}$
\end_inset

 and 
\begin_inset Formula $\text{pure}\diamond f=f$
\end_inset

 
\end_layout

\begin_layout Standard
Associativity for 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 follows from 
\begin_inset Formula $\left(\text{id}\diamond f\right)\diamond g=\text{id}\diamond\left(f\diamond g\right)$
\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset Quotes eld
\end_inset

left naturality
\begin_inset Quotes erd
\end_inset

, get: 
\begin_inset Formula $\left(f\bef g\right)\diamond h=\left(f\bef pure\right)\diamond g\diamond h=f\bef\left(g\diamond h\right)$
\end_inset


\end_layout

\begin_layout Standard
Naturality for 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
: 
\begin_inset Formula $\text{pure}\bef\text{fmap}\,f=\text{pure}\diamond\left(f\bef\text{pure}\right)=f\bef\text{pure}$
\end_inset


\end_layout

\begin_layout Standard
Define 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
: 
\begin_inset Formula $\text{ftn}=\text{id}^{S^{S^{A}}\Rightarrow S^{S^{A}}}\diamond\text{id}^{S^{A}\Rightarrow S^{A}}$
\end_inset


\end_layout

\begin_layout Standard
Naturality for 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
: 
\begin_inset Formula $\text{ftn}\bef\text{fmap}\,f=\text{id}\diamond\text{id}\diamond\left(f\bef\text{pure}\right)=\text{id}\diamond\text{fmap}\,f$
\end_inset

 and 
\begin_inset Formula $\text{fmap}\left(\text{fmap}\,f\right)\bef\text{ftn}=\text{id}\diamond\left(\left(\text{fmap}\,f\right)\bef\text{pure}\right)\bef\text{id}\diamond\text{id}=\text{id}\diamond\text{fmap}\,f$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Structure of semigroups and monoids
\end_layout

\begin_layout Standard
Semimonad contexts are combined associatively, as in a semigroup
\end_layout

\begin_layout Standard
A full monad includes an 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 context, i.e.
\begin_inset space \space{}
\end_inset

the identity element
\end_layout

\begin_layout Standard
Semigroup with an identity element is a monoid
\end_layout

\begin_layout Standard
Some constructions of semigroups and monoids (see code):
\end_layout

\begin_layout Standard
Any type 
\begin_inset Formula $Z$
\end_inset

 is a semigroup with operation 
\begin_inset Formula $z_{1}\bef z_{2}=z_{1}$
\end_inset

 (or 
\begin_inset Formula $z_{2}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $1+S$
\end_inset

 is a monoid if 
\begin_inset Formula $S$
\end_inset

 is (at least) a semigroup (or 
\begin_inset Formula $S\equiv0$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{List}^{A}$
\end_inset

 is a monoid (for any type 
\begin_inset Formula $A$
\end_inset

), also 
\begin_inset Formula $\text{Seq}^{A}$
\end_inset

 etc.
\end_layout

\begin_layout Standard
The function type 
\begin_inset Formula $A\Rightarrow A$
\end_inset

 is a monoid (for any type 
\begin_inset Formula $A$
\end_inset

)
\end_layout

\begin_layout Standard
The operation 
\begin_inset Formula $f\bef g$
\end_inset

 can be either 
\begin_inset Formula $f\bef g$
\end_inset

 or 
\begin_inset Formula $g\bef f$
\end_inset


\end_layout

\begin_layout Standard
Any totally ordered type is a monoid, with 
\begin_inset Formula $\bef$
\end_inset

 defined as 
\begin_inset Formula $\max$
\end_inset

 or 
\begin_inset Formula $\min$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{1}\times S_{2}$
\end_inset

 is a semigroup (monoid) if 
\begin_inset Formula $S_{1}$
\end_inset

, 
\begin_inset Formula $S_{2}$
\end_inset

 are semigroups (monoids)
\end_layout

\begin_layout Standard
\begin_inset Formula $S_{1}+S_{2}$
\end_inset

 is a semigroup (monoid) if 
\begin_inset Formula $S_{1}$
\end_inset

, 
\begin_inset Formula $S_{2}$
\end_inset

 are semigroups (monoids)
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
M[S]
\family default
\size default
\color inherit
 is a monoid if 
\family typewriter
\size footnotesize
\color blue
M[_]
\family default
\size default
\color inherit
 is a monad and 
\family typewriter
\size footnotesize
\color blue
S
\family default
\size default
\color inherit
 is a monoid
\end_layout

\begin_layout Standard
\begin_inset Formula $S\times P$
\end_inset

 is a semigroup if 
\begin_inset Formula $S$
\end_inset

 is a semigroup that has an 
\series bold
action on
\series default
 
\begin_inset Formula $P$
\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

action
\begin_inset Quotes erd
\end_inset

 is 
\begin_inset Formula $\alpha:S\Rightarrow P\Rightarrow P$
\end_inset

 such that 
\begin_inset Formula $\alpha(s_{2})\bef\alpha(s_{1})=\alpha(s_{1}\bef s_{2})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S\times P$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

twisted product.
\begin_inset Quotes erd
\end_inset

 Examples: 
\begin_inset Formula $\left(A\Rightarrow A\right)\times A$
\end_inset

; 
\begin_inset Formula $\text{Bool}\times\left(1+A\right)$
\end_inset


\end_layout

\begin_layout Standard
Other examples of monoids: 
\begin_inset Formula $\text{Int}$
\end_inset

 (many), 
\begin_inset Formula $\text{String}$
\end_inset

, 
\begin_inset Formula $\text{Set}^{A}$
\end_inset

, Akka's 
\family typewriter
\size footnotesize
\color blue
Route
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Structure of (semi)monads
\end_layout

\begin_layout Standard
How to recognize a (semi)monad by its type? Open question!
\end_layout

\begin_layout Standard
Intuition from 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
: reshuffle data in 
\begin_inset Formula $F^{F^{A}}$
\end_inset

 to fit into 
\begin_inset Formula $F^{A}$
\end_inset


\end_layout

\begin_layout Standard
Some constructions of exponential-polynomial (semi)monads:
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv Z$
\end_inset

 (constant functor) for a fixed type 
\begin_inset Formula $Z$
\end_inset


\end_layout

\begin_layout Standard
For a full monad, need to choose 
\begin_inset Formula $Z=1$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A\times G^{A}$
\end_inset

 for any functor 
\begin_inset Formula $G^{A}$
\end_inset

 (a full monad only if 
\begin_inset Formula $G^{A}$
\end_inset

 is a monad)
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{A}\times H^{A}$
\end_inset

 for any (semi)monads 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Standard
but 
\begin_inset Formula $G^{A}+H^{A}$
\end_inset

 is generally 
\emph on
not
\emph default
 a semimonad
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv R\Rightarrow G^{A}$
\end_inset

 is a (semi)monad for any (semi)monad 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A+G^{A}$
\end_inset

 is a monad for a monad 
\begin_inset Formula $G^{A}$
\end_inset

 (
\series bold
free pointed
\series default
 over 
\begin_inset Formula $G$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{Z+A\times W}$
\end_inset

 is a monad if 
\begin_inset Formula $G$
\end_inset

 is a monad and 
\begin_inset Formula $W$
\end_inset

 a monoid
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A+G^{F^{A}}$
\end_inset

 (recursive) for any functor 
\begin_inset Formula $G^{A}$
\end_inset

 (
\series bold
free monad
\series default
 over 
\begin_inset Formula $G$
\end_inset

)
\end_layout

\begin_layout Standard

\emph on
Semimonad-only
\emph default
 constructions:
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{A}+G^{F^{A}}$
\end_inset

 (recursive) for any functor 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv H^{A}\Rightarrow A\times G^{A}$
\end_inset

 for any contrafunctor 
\begin_inset Formula $H^{A}$
\end_inset

 and functor 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Standard
Obtain a full monad only when 
\begin_inset Formula $G^{A}\equiv1$
\end_inset

, i.e.
\begin_inset space \space{}
\end_inset


\begin_inset Formula $F^{A}\equiv H^{A}\Rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Exercises II
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace*{-0.2cm}
\end_layout

\end_inset

Show that 
\family typewriter
\size footnotesize
\color blue
M[S]
\family default
\size default
\color inherit
 is a monoid if 
\family typewriter
\size footnotesize
\color blue
M[_]
\family default
\size default
\color inherit
 is a monad and 
\family typewriter
\size footnotesize
\color blue
S
\family default
\size default
\color inherit
 is a monoid.
\end_layout

\begin_layout Standard
A framework implements a 
\begin_inset Quotes eld
\end_inset

route
\begin_inset Quotes erd
\end_inset

 type 
\begin_inset Formula $R$
\end_inset

 as 
\begin_inset Formula $R\equiv Q\Rightarrow\left(E+S\right)$
\end_inset

, where 
\begin_inset Formula $Q$
\end_inset

 is a query, 
\begin_inset Formula $E$
\end_inset

 is an error response, and 
\begin_inset Formula $S$
\end_inset

 is a success response.
 A server is defined as a 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

 of several routes.
 For a given query 
\begin_inset Formula $Q$
\end_inset

, the response is the first route (if it exists) that yields a success.
 Implement the route 
\begin_inset Quotes eld
\end_inset

summation
\begin_inset Quotes erd
\end_inset

 operation and show that it makes 
\begin_inset Formula $R$
\end_inset

 into a semigroup.
 What would be necessary to make 
\begin_inset Formula $R$
\end_inset

 into a monoid?
\end_layout

\begin_layout Standard
Verify the associativity law for the semimonad 
\begin_inset Formula $F^{A}\equiv Z+\text{Bool}\times A$
\end_inset

.
\end_layout

\begin_layout Standard
Show that the functor 
\begin_inset Formula $F^{A}\equiv\text{Boolean}\times M^{A}$
\end_inset

 (where 
\begin_inset Formula $M^{A}$
\end_inset

 is an arbitrary monad) can be made into a semimonad but not into a monad.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $W$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 are arbitrary fixed types, which of the functors can be made into a semimonad:
 
\begin_inset Formula $F^{A}\equiv W\times\left(R\Rightarrow A\right)$
\end_inset

, 
\begin_inset Formula $G^{A}=R\Rightarrow\left(W\times A\right)$
\end_inset

?
\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $F^{A}\equiv\left(P\Rightarrow A\right)+\left(Q\Rightarrow A\right)$
\end_inset

 is not a semimonad (cannot define 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
) when 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are arbitrary, different types.
\end_layout

\begin_layout Standard
Implement the 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 methods for 
\begin_inset Formula $D^{A}\equiv1+A\times A$
\end_inset

 (
\family typewriter
\size footnotesize
\color blue
type D[A] = Option[(A, A)]
\family default
\size default
\color inherit
) in at least two significantly different ways, and show that the monad
 laws always fail to hold.
 (
\begin_inset Formula $D^{A}$
\end_inset

 is not a monad!)
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Exercises II (continued)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
addtocounter{enumi}{7}
\backslash
vspace*{-0.5cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A programmer implemented the 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 method for 
\size footnotesize

\begin_inset Formula $F^{A}\equiv A\times\left(A\Rightarrow Z\right)$
\end_inset

 
\size default
as
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
def fmap[A,B](f: A
\begin_inset Formula $\Rightarrow$
\end_inset

B): ((A, A
\begin_inset Formula $\Rightarrow$
\end_inset

Z)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (B, B
\begin_inset Formula $\Rightarrow$
\end_inset

Z) =
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  { case (a, az) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (f(a), (_: B) 
\begin_inset Formula $\Rightarrow$
\end_inset

 az(a)) }
\end_layout

\begin_layout Standard
Show that this implementation fails to satisfy the functor laws.
\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $P^{A}\equiv Z+W\times A$
\end_inset

 is a (full) monad if 
\begin_inset Formula $W$
\end_inset

 is a monoid.
\end_layout

\begin_layout Standard
Verify that the full monad laws hold for construction 4.
\end_layout

\begin_layout Standard
Implement 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 for 
\begin_inset Formula $F^{A}\equiv A+\left(R\Rightarrow A\right)$
\end_inset

, where 
\begin_inset Formula $R$
\end_inset

 is a fixed type, and show that all the monad laws hold.
\end_layout

\begin_layout Standard
For construction 5, show that an identity law would fail if 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 were defined as 
\family typewriter
\size footnotesize
\color blue
a 
\begin_inset Formula $\Rightarrow$
\end_inset

 Right(Monad[G].pure(a))
\family default
\size default
\color inherit
 instead of as 
\family typewriter
\size footnotesize
\color blue
Left(a)
\family default
\size default
\color inherit
.
\end_layout

\begin_layout Standard
Implement the monad methods for 
\begin_inset Formula $F^{A}\equiv\left(Z\Rightarrow1+A\right)\times\text{List}^{A}$
\end_inset

 using the known monad constructions (no need to check the laws).
\end_layout

\begin_layout Standard
Implement the semimonad construction 2 by discarding the first effect (not
 the second), and show that the associativity law is still satisfied.
\end_layout

\begin_layout Standard
For semimonad construction 8, show that the associativity law holds.
\end_layout

\begin_layout Standard
Verify the identity laws for the State and Continuation monads.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Addendum: Miscellaneous remarks on monads
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset

A non-empty list 
\begin_inset Formula $F^{A}\equiv A\times\text{List}^{A}$
\end_inset

 is a semigroup but not a monoid.
\end_layout

\begin_layout Standard
Any polynomial functor 
\begin_inset Formula $F^{A}\equiv p(A)$
\end_inset

 can be made into a monad when 
\begin_inset Formula $p(x)$
\end_inset

 is a polynomial of the form 
\begin_inset Formula $p(x)=x^{n_{1}}+x^{n_{2}}+...+x^{n_{k}}$
\end_inset

 for some positive integers 
\begin_inset Formula $n_{1}$
\end_inset

, ..., 
\begin_inset Formula $n_{k}$
\end_inset

.
 Indeed, any 
\begin_inset Formula $F^{A}$
\end_inset

 of this form may be built from the identity monad via constructions 3 and
 5.
 To illustrate this, denote 
\begin_inset Formula $E_{1}\equiv1$
\end_inset

, 
\begin_inset Formula $E_{n+1}\equiv1+E_{n}$
\end_inset

.
 Monoid construction 2 makes 
\begin_inset Formula $E_{n}$
\end_inset

 into monoids.
 Then the monads 
\begin_inset Formula $E_{n}\Rightarrow A$
\end_inset

 (reader) and 
\begin_inset Formula $E_{n}\times A$
\end_inset

 (writer) are equivalent to polynomial monads 
\begin_inset Formula $A\times...\times A$
\end_inset

 and 
\begin_inset Formula $A+...+A$
\end_inset

.
\end_layout

\begin_layout Standard
Contrafunctors cannot be monads or semimonads: if 
\begin_inset Formula $H^{A}$
\end_inset

 is a contrafunctor then 
\begin_inset Formula $H^{H^{A}}$
\end_inset

 is a functor, so a natural transformation between 
\begin_inset Formula $H^{H^{A}}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset

 (in either direction) is impossible.
\end_layout

\begin_layout Standard
An example of combining natural transformations: Given functors 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

 and natural transformations 
\begin_inset Formula $C^{A}\Rightarrow F^{A}$
\end_inset

 and 
\begin_inset Formula $C^{A}\Rightarrow G^{A}$
\end_inset

 and taking the product, we get a natural transformation 
\begin_inset Formula $C^{A}\Rightarrow F^{A}\times G^{A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M^{A}$
\end_inset

 is a monad then 
\begin_inset Formula $M^{M^{A}}$
\end_inset

 is not automatically a monad (need counterexample?).
\end_layout

\begin_layout Standard
Two monadic values 
\begin_inset Formula $m_{1},m_{2}:M^{A}$
\end_inset

 can be merged by ignoring the payload of one of them and merging the effects;
 and we can merge the effects in any chosen order: for { x 
\begin_inset Formula $\leftarrow$
\end_inset

 m
\begin_inset Formula $_{1}$
\end_inset

; _ 
\begin_inset Formula $\leftarrow$
\end_inset

 m
\begin_inset Formula $_{2}$
\end_inset

 } yield x or for { _ 
\begin_inset Formula $\leftarrow$
\end_inset

 m
\begin_inset Formula $_{1}$
\end_inset

; x 
\begin_inset Formula $\leftarrow$
\end_inset

 m
\begin_inset Formula $_{2}$
\end_inset

 } yield x 
\end_layout

\begin_layout Standard
A curious example: The functor 
\begin_inset Formula $Q^{A}\equiv\left(A\Rightarrow Z\right)\Rightarrow1+A$
\end_inset

 is not a monad (and not even a lawful applicative) but 
\begin_inset Formula $M^{A}\equiv\left(A\Rightarrow1+1\right)\Rightarrow1+A$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

search monad
\begin_inset Quotes erd
\end_inset

.
 More generally, a 
\begin_inset Quotes eld
\end_inset

selector monad
\begin_inset Quotes erd
\end_inset

 is 
\begin_inset Formula $\left(A\Rightarrow P^{1}\right)\Rightarrow P^{A}$
\end_inset

 for any functor 
\begin_inset Formula $P^{A}$
\end_inset

.
\end_layout

\begin_layout Section
Practical use
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
in this part of the tutorial I will talk about Mona's and semi Mona's this
 continues a consideration of how we can do computations in a functor context
 or in Scala this is the functional block for the for yield block in this
 part I will concentrate on practical issues the first example we will use
 is this computation in this computation we need nested iterations in the
 factor block nested iterations are expressed with several left arrows or
 they're called generator arrows so the program for this computation can
 look like this from the left I show it in the filter block syntax on each
 line as you see the generator line gives you an iteration I goes over this
 sequence from 1 to M J also goes over the same sequence and K those over
 the same sequence and they all go independently so I for each I and J goes
 over all these and for each I and J K goes over all of this and in the
 yield expression we compute this function f that we're supposed to compute
 here and the result of this sub expression up to this parenthesis is a
 large list of all values of F for each choice of I J and K and then we
 take a sum of this large list so that computes the sum in this expression
 if you replace the left arrows as the Scala compiler does through map and
 flatmap and you will see that the map replaces the last left arrow and
 flatmap replaces all other flap left arrows or generator errors and so
 line for line translation of this code could look like this so instead
 of this syntax we have this instead of this we have this and so on and
 you see how this works so the last expression is just a simple map because
 we just need to compute the value F for each of these case but this result
 is a list and soldered argument a flat map is a function that takes J and
 returns a list the result of the flat map is again a list which is this
 one up to this brace and this is the body of this function taking I as
 the argument and returning this list so again the argument of flat map
 as a function from a value to a list so this syntax is available for the
 sequence factor because sequence has flat map defined in addition to map
 if that function has a filter defined where the function method is called
 with filter as we have seen in the previous tutorial then we can use the
 if lines in the function block as well in this tutorial we will occasionally
 see the if lines but we'll concentrate on what happens when you have several
 left arrows it is named flat map because it is actually equivalent to us
 first doing a map and then doing a flattened how would that work well in
 this this code were the function in the brackets or in the parentheses
 here takes J and returns a list the result of that would be a list of Lists
 and when you flatten that you get a simple list and that is the same as
 doing a flat map so factors that have flat map or and flatten defining
 them I call them platinum or semi monads this is my own terminology flattened
 able and semi mu nuts is my terminology there is no accepted name for these
 factors you must have heard of monent now monads are more than just founders
 at her flat map or flattened monads also needed an additional method called
 pure which has this type signature however this method cannot be used in
 the function block directly so it does not correspond to a specific constructio
n of a functor block of course let me correct myself it can be used in the
 function block as any other method but it has to be used here on the right-hand
 side because here this an arbitrary Scala code here so you can use any
 methods you want but it is not special to the function block it does not
 have a special meaning and also we will not need this method much in fact
 it is not not very often used other methods are more important than pure
 and so mathematically and adding the meta pure makes an interesting mathematica
l structure but for the practical use that I'm going to talk about this
 is not very important so full monitor monads are factors that have flatmap
 and pure with appropriate laws which I will talk about in another part
 of this tutorials semi monads are those that just have flat map and they
 may or may not have pure in many cases they will also have some natural
 definition of pure but in some cases they won't so let's concentrate therefore
 one semi Mona's monads that don't have pure necessarily let's look at more
 a visual example of how a flat map works with lists so consider this expression
 how we would compute that expression so let's assume that the function
 f takes a value of x and returns a list of some values of type y now if
 you have specific values x1 x2 x3 here then the result of applying F to
 them might be a different list each time it could be even a list of different
 lengths with different values inside so let's imagine this is the result
 of applying f2 x1 x2 and x3 so the flat map will put all of these values
 together in one list we first do melt and then we do flatten and what happens
 is that the map will replace each of these x ones with its corresponding
 list x1 x2 x3 will be replaced by these three lists so that would be a
 list of lists of Y and you flatten that and you get a simple or flat list
 let's develop some more intuition about what happens with data in a factory
 or in a collection or in a container when we use flatmap or when we use
 several generator errors in the factor block so here is a schematic example
 of some code that tells you that I goes over this collection or container
 or sequence in this case J goes over here then we compute some X as a function
 of I J now at this point we have computed a whole sequence of X's for each
 I and J different experts then we for each of those X's we still have another
 it nested iteration and then we compute some Y as a function of I J and
 K and actually at this point we have computed a large list of Y's of perhaps
 different values of Y different for each I J and K and then we compute
 another function H of x and y so this entire result will be a long list
 of values of this H computed for each high J and K a different value of
 H so this code is a translation into non hunkler block syntax so you see
 line 4 line same thing 1 to M 1 to M I I 1 to N 1 to N J J so this is here
 x equals this here we need to say well in the function block we don't say
 well that's the only syntactic difference so 1 2 P 1 2 P ok ok so here
 we having this line by line translation this code computes exactly the
 same value of the result which is going to be a list of so one thing we
 notice is that every line that is a generative line that is every line
 it has a left arrow must have the same type of container on the right hand
 side so this is a list or sequence in general in this case this is going
 to be subclasses of sequence some vector or something like that each generator
 line needs to have the same type we could not for example here use sequence
 and here use some completely different containers such as let's say tree
 or some point that we couldn't do this must be the same type and this is
 so because flatmap is defined like this flat map requires that this sequence
 type is the same as the sequence type returned by this function which is
 all of that so all of that should be a sequence of the same type as this
 and so for this reason each container or sequencer or collection on the
 right hand side of a generator arrow must have the same type same container
 type another thing we know is that each generator line actually starts
 an expression so if you look at this generator line for example DJ the
 translation of this actually is this J goes to that so this entire thing
 is a an expression that evaluates to to a list to a sequence which is again
 a container of the same type so you can think about this syntax as nested
 computation where each line starts in new computation yielding finally
 the value of the same type let's now look also at the number of resulting
 data items now I goes from 1 to N J goes from 1 to N K goes from 1 to P
 so in this case clearly we have M times n times P different elements in
 the resulting list here so this will be M times n times P values in the
 result if we had some other code here for example if this were not from
 1 to n always but the length of this sequence were somehow a function of
 this value 1 I let's say now we would probably have the different number
 of data items depending on the data or we could have fewer data items because
 we could have an if line which would filter out some of the data so we'll
 have less than M times n times P but in any case we could have up to M
 times n times P resulting data items in their container so the container
 type that we need for this kind of computation is at least such that it
 can hold m times n times P items if it can hold em items for n items for
 p- so if we ask the question what kind of containers can have flatmap in
 other words what kind of containers will fit this style of computation
 the answer is at least this type of containers must be such that if the
 container can hold em items of data and it can hold end items of data it
 must also be able to hold at least m times n items of data so the capacity
 of the container must be closed under multiplication always the set of
 all possible capacities or capacity counts of the container must be closed
 under multiplication this is an interesting property with container types
 have this property so for instance a sequence or a non-empty list these
 containers can hold any number of items in the case of non-empty lists
 any number of items that's at least one so that set is a set of all integers
 at at least some minimum that set is certainly closed under multiplication
 and also well it's not just multiplication must be closed under this it
 must be if it has m elements and it has n elements it should be able to
 hold all less than M times n elements any number of pretty much elements
 less than that so obviously sequence and non-empty lists are such containers
 with this property another important example of such containers is the
 container that can hold only 0 or 1 elements for example option is such
 a container option can hold one data port it could be empty either is another
 container data item have some error message thing try is another such container
 it could have a date I could have an exception future is another such container
 it holds the data item that is going to be available in the future or it
 could fail also the computer so these I call the pass fail containers these
 could hold at most one data item and clearly the set of capacities for
 this container is a set of 2 L two numbers 0 and 1 and this set is closed
 under multiplication another example of a container that would have this
 property is a tree light container that must have for instance three six
 nine twelve and so on elements that are always multiples of three let's
 say yeah so it's bit branches in such a way that it can always hold can
 only hold the number of items that's multiplied that smell a multiple of
 three and obviously this kind of set is closed under multiplication finally
 there are several containers that I will also talk about which are which
 I call non-standard examples of such containers are these so these are
 functors because here a is a covariant position here also a is in a covariant
 position because it's behind two arrows two functionaries so these are
 factors but they are not really containers with data in an ordinary sense
 there's no way in which you can say they hold five or eleven items of data
 or something like this they hold data in some non-standard way and we will
 talk about the usage of these containers and give examples but these also
 in certain cases certain function types like these also can have flat map
 defined on them in a reasonable way so let's look at examples now the first
 set of examples are what I call a list like monads so by the way all these
 examples here are monads are not just semi Munez but we will just look
 at the flat map and so we will not use the fact that there are full moon
 ads so for us it's not really important to make that distinction right
 now we only focus on flat map so what are the typical tasks that list like
 monads before typical is make a list of combinations or permutations to
 go over these filter out what you want and get a list of results that's
 a typical computation of this kind another situation is that if you have
 some problem that has many possible solutions you organize these solutions
 in a solution tree and you traverse this tree with say a recursive depth
 first search and then you again filter out solutions that are incorrect
 and you get your resulting solutions now the containers that have this
 property it may be eager sequence so eager means all elements of the sequence
 are computed upfront before you can use the sequence for they can be lazy
 which also iterator is one example is a sequence whose elements are not
 all computed upfront you can already start using the iterator and as you
 need it will compute new elements so that's called lazy computation stream
 is another the data type in the Scala standard library that computes lazy
 value so it does not compute upfront all the values in the stream computes
 them when you need to do so once you have confused them they are stored
 in memory but until then they are not so these are eager and lazy evaluation
 strategies but the way your write code is very similar you just have flat
 map defined on iterator you have flat map defined on stream and so you
 can just use them usually list like containers have a lot of additional
 methods defined in them it's a very rich data structure so they're monads
 they have pure metal defining them I just remind you that the pure method
 has this type so it just takes one data item and creates a container that
 has this one little item inside so clearly you can put one item in the
 list or an iterator on the stream and so on comes clear but many additional
 methods are used such as appending lists pretending elements to list concatenat
ing lists fill so you make a list that has certain pre computed elements
 fold scan those are methods are you are all defined on this list like Mona's
 so actually program code mostly uses methods like these and not pure so
 it is not very important for programming for the practice of programming
 to have the method viewer defined list like Mona and actually it's the
 same for most moments the method pure is quite secondary in its importance
 for practical programming so let's look at some example so I have prepared
 working code in the repository so let's take a look so here is the first
 example how we compute things in the function block what we want is to
 compute a [Music] multiplication table so the results should be a sequence
 of strings such as these so these strings need to be computed in this order
 so notice that the multiplication table is only half of the matrix its
 we never compute for example three times two we already have two times
 three and sufficient and so to organize this kind of computation we write
 this so I goes from 1 to 5 but J goes from I to 5 so this is an example
 of the collection on in the right hand side of the generator line and the
 collection is a function of the value that we defined in the previous line
 so this collection is a function of I so this is a example of having a
 different list you know each time for each I will be a different list and
 that's fine this is just as easy to do that using the function lock with
 mu naught so what do we yield in other words for each I and for each J
 what do we compute or we compute the product of I and J and then we print
 this line I times J equals product so that will produce a string and the
 whole result will be a sequence of these strings so we have a flat sequence
 so to speak remember this heuristic or a mnemonic choice of word of the
 name flat map so we we have many nested iterations here when the result
 is a flat sequence so this test verifies that the result is this multiplication
 table here is how we can do the same using a filter so here we do not make
 this second sequence depending on their both same but then we filter out
 by the condition that J must be not less than I so then we we can compute
 product here that's completely equivalent in terms of results and we yield
 this listener perhaps slightly different and maybe easier to understand
 way of doing the same thing so it still computes the same multiplication
 table as we had here I already ran all these tests they all pass so you
 I encourage you to download this and run as well and play with it to save
 time I will not run tests but they all pass another important thing here
 is to notice that if one of the generator arrows returns you an empty sequence
 then remember this size of the result is a product of sizes of these sequences
 and the sequences of length zero and so the resulting sequence will be
 of length zero it will be empty so just having one of these generators
 produce an empty sequence will kill the entire computation it will make
 an empty sequence out of the entire computation regardless of what you
 do here before or after it will just completely collapse everything into
 an empty sequence that is also an important property of the magnetic computatio
n so let's now go through our worked examples in that slide the first example
 is to compute all permutations of the sequence of three strings a B and
 C so how do we compute that let's just write code like this so first we
 define the sequence excess or excess now obviously we need to iterate over
 it in some way to get the permutation so let's do that so let's say X goes
 over all this now once X let's say is a we need to go over the result over
 the remaining elements so let's compute the remaining elements here so
 diff is the library function that computes the difference between two sequences
 or it removes elements from the second elements that are in the second
 sequence are removed from the first sequence when you do div and so the
 remain will be BC for instance if X is a then we go over the remain and
 we find and next remain so remain tube which is now all the rest and Z
 goes over remain two so now we know that it's a sequence of three elements
 so we know that remain two is going to have just one element left so that's
 what we want and the result is we yield the sequence of XYZ and so this
 is going to be computed for each choice of XY and Z so the result will
 be a sequence of sequences so let's check that control shift right so that's
 a sequence of sequence of string that's the result we check on this test
 that the permutations are correctly computed the standard library in Scala
 already has the permutations function just that the permutations function
 returns an iterator not a sequence so we converted to see in order to run
 this test if we didn't convert it to sequence and we couldn't compare our
 sequence of sequences against an iterator the iterator doesn't have the
 values computed yet cannot compare something that already has all the values
 computed and something that doesn't we need to run that to them to compute
 all the values so that's what the two sequence does for me it's very careful
 the second example is to compute all subsets of this set now subsets of
 the set is not the same at all as permutations of a sequence for instance
 empty set would be a subset or a set of B alone would be a subset or a
 set of B and C would be a subset but there is no difference between the
 set of B and C and a set of C and B so all subsets is very different from
 all permutations let's see how we can do that so let's think about it so
 first the subsets could be empty so we need to allow empty set the subsets
 can be also non empty so let's allow that as well so we we say X a would
 be of type set of string and so X a would go over either an empty set or
 a set of a so in this generator line the right-hand side is a collection
 or our in this case it is a set and the set contains two elements an empty
 set of strings and a set of single-a so exhale be either empty set or set
 of a xB would be similarly either an empty set or set of B XC will be in
 either in the second set of C and then we will concatenate all these sets
 now when we concatenate sets equal sets would collapse into one and so
 the result would be empty set will be present once then we'll be set of
 a together maybe with empty or together a set of B so in this way we have
 eight combinations that we need so either each of the X a xB XC goes over
 to possible values and so the result is 8 X or two times two times two
 different sets so indeed we have a standard library function subsets that
 returns an iterator we convert that iterator to set and the result is correct
 so it's all subsets of this next example is to compute all sub sequences
 of length 3 out of a given sequence so sub sequences are not necessarily
 elements or they're next to each other in sequence but they must be in
 the water so let's look how we can do this so here's an example we have
 a sequence from 1 to 5 and the sub sequences of length 3 out of this are
 listed here so it's one two three one two four one two five one three four
 and so on so how do we compute such a sub sequence well we start reasoning
 by what kind of generator lines we should write and what kind of filtering
 we should do that's the way that this kind of code is written we use the
 library function tails which is a useful function saves us work what does
 it do it takes a sequence and it computes a sequence of first initial one
 then the tail of the sequence have a tail of the tail and the tail of that
 and so on until we get an empty sequence so XS is going to be a sequence
 of these ranges we filter out the new and then we know then it's that it's
 not empty actually we filter out not the new we filter out the case when
 this entire tails is empty because it could happen what if we're given
 an empty sequence here then this entire tails sequence will be empty so
 we filter out non-empty we take the head and that's the first sequence
 here and then we take the tail of that which so the tail of excess is these
 and that's our remain one so now we go over the sequences in these and
 in the tail of XS so if let's say first of all would be DS again we filter
 out as its it must be non-empty take the head and then take the tail of
 that and this what this does is that in the next iteration we would have
 x1 here why being here for example and so that's how we find all the possible
 sub sequences so we can take this this and this and taking heads of those
 would give us 1 3 4 4 1 3 5 and so on so this is the way we induce the
 sub sequences this is a bit manual there's a lot of boilerplate code but
 this is a code that kind of is obvious obviously correct we take details
 then other tails and so on and it works as expected so you see we have
 used if we have used non generator lines or the computation lines which
 are map these are flat map this is a filter so we use all the features
 of the list as we should we should always use all the features if they
 are helpful so this code computes the sequences we expect the next task
 is to generalize all these examples to support arbitrary length instead
 of three so here we had hard-coded length in hard-coded length 3 now we
 want to generalize and this is of course a little more challenging but
 notice in all these code examples we had really hard-coded the fact that
 we are looking at length 3 let's see how we can generalize this it's not
 a lot of work it's just needs to be a little more clever so let's look
 at the first example the first example is permutations well obviously we
 still do the same thing as before let's take our code for permutations
 see what we do so we we do X going through the sequence then we compute
 the remain the remaining subsequence or part of the sequence by removing
 the X we just chose so the result is a smaller subsequence and let's just
 use the same function to compute the permutations of that recursively so
 that's the idea here so we take X going to it over over all the XS compute
 the remain and then the Y's is going to go over all the permutations of
 remain and that is a recursive call to the same function so Y is going
 to be a sequence of elements because the function returns a sequence of
 sequence so since on the right hand side of the generating line we here
 have a sequence of sequences the left-hand side will become a sequence
 now notice the generator light has to be the same container type sequence
 doesn't have to be the same element type so in the first generator line
 the container type is sequence the element type is a and here the container
 type is sequence the element type is sequence of a so that's fine as long
 as the outer container type stays the same now this variable is going to
 be sequence of a so we need to append X which is the first element which
 shows and the permutations of the other elements so the result is that
 we yield at this sequence and the total result is going to be Kwan's of
 these sequences for all X's and for all permutations on the remainder and
 that's what we need except you have to add this check at the very beginning
 because we will eventually call the permutations on an empty sequence here
 and we need to not break when we when we have that so that's how it works
 and now we can have any length and it works so let's see how example 2
 is generalized we look at the code and example 2 we see we need to basically
 repeat this n times we repeated this line three times here but now we need
 to repeat this n times instead of three times so how do we do that we use
 recursion of course so the first line we can continue and as before then
 we do the remain which is also the - here is the operation defined on set
 that removes elements from a set well it's not it doesn't really modify
 this set it's just compute a new set that has one element viewer possibly
 then we do the recursive call of subsets on the remain and gives us a bunch
 of sets so for each of those sets we have a wide age and we concatenate
 the sets so it's very similar thank very similar idea so we we do one step
 that we did before and then we call the cursor away on the remainder and
 that works for any length of the set example 3 is a bit more ago but that's
 exactly the same procedure in example three we had this kind of code repeated
 three times ex going to seek on something tails if non-empty get the head
 and compute the remained take the tails if not everything at the head compute
 tail yet tails of non empty so that is going to be repeated so we're going
 to write this once and then do the recursive call so that's how this works
 in generalizing our example three so again we need to check for empty sequences
 and that's a little involved I won't go into details here encourage you
 to look at it yourself the main computation is here notice I have to put
 parentheses around the four because I needed to seek on it and you cannot
 just do it to seek after this brace that is not right syntax this brace
 is part of the yield expression and so if you wanted to seek on the entire
 it's for yield block you have to put parentheses around it alright so this
 is our code that we have to do go to tails non-empty get head and find
 remainder and then we do a recursive call now notice recursive call is
 on n minus one because now the task is the compute n element sub sequences
 of a given sequence now we compute n minus 1 element sub sequences and
 sometimes this n would be 0 sometimes the remain will be empty so we need
 to check both of these cases separately so that's how it works exactly
 the same test passes next example is the well-known 8 Queens problem 8
 Queens is a chess Queens on the chess board and you need to find all locations
 for the 8 Queens so that they don't threaten each other the Queens on the
 chess board threaten each other if they're in the same row in the same
 column or on the same diagonal so let's first write a function that finds
 out whether Queens threaten each other so on the chess board it is clear
 that each Queen must be in a different room if any of the two queens are
 in the same row they they threaten Charlie so we'll just take a shortcut
 and the Queen if every Queen will be in the next row always and the only
 question is in which column it is so the integer coordinates here is a
 column and these are columns and we assume that they're all in consecutive
 rows so this function will compute the condition that some Queen in this
 position in this column is not threatened by any of the previous Queens
 given in the previous rows with columns specified here so that is when
 X is not the same as other X so they're not in the same column and when
 they're not in the same diagonal so diagonals are computed by differences
 row minus column row - come on your plus column so these are the two diagonals
 alright so now how do we find all solutions of the hit Queens problem so
 here's a straightforward just to be quicker let's say the row is the set
 of indices 0 1 2 and so etcetera 7 now x1 is the column of the first or
 maybe row of that says I want to say so x1 is the column of the first clean
 x2 is a column of the second Queen now we need to check that the second
 queen is not threatened or does not threaten the first so then we iterate
 over the column for the third queen and then we check the threat that the
 third queen is not threatened by the first we already know that the first
 two don't threaten each other so we all need to check that the additional
 Queen does not threaten the previous columns and so on at each step we
 check that the additional Queen does not threaten the previous Queens and
 the previous Queens already find so this is the entire code and then we
 output the columns for the Queens that we found the result is going to
 be a sequence of sequence of integer because we yield sequence so each
 of our containers is a sequence so all the types here are sequence and
 the result is also a sequence but the type of element is different is sequence
 of integer no and we just check that there are 92 solutions we know that
 there are 92 solutions now let's generalize this example to solve any Queens
 problem that is n by n board with n Queens and we do the same thing you
 notice here we had hard-coded their eight Queens and all this code has
 to be now generalized which is done in the same way as before by introducing
 recursion so how do we do that so again let's rename this to column because
 I prefer to think about this this column actually so we define a function
 that is going to be the recursive function that adds another queen we have
 a previous Queens and it finds all the possible ways of adding another
 queen and so that's going to be our solution so n Queens is going to be
 [Music] : n Queens partial on the required number of Queens and initially
 we have none no Queens already selected so this function says I want to
 add this many Queens and here are the initial here are the previously selected
 kunas so we do the same as we did before so X is going to be the column
 of the next queen then we check that the next queen does not threaten previous
 Queens then we find the sequence of the new Queens and call so these are
 the newly selected Queens after the filter line so after this line we are
 sure that the X is an admissible column for the new queen so this is going
 to be the sequence of the Queen we found and we call the same function
 recursively so now we need to add n minus 1 new Queens and here are the
 queens we found so far so rest is going to be a sequence of integer and
 we append that sequence to the X the X is being the queen we found and
 then we're done and so to verify that this is correct I run the test for
 eight nine ten and eleven Queens and check the links and it is known how
 many solutions there must be look at this page here that I found nobody
 really knows how to compute these numbers without numerating all the Queen
 positions these numbers seem to be very hard to predict otherwise so this
 is how we solve problems like permutations and traversing a solution tree
 and filtering out solutions that are undesirable in some way and finding
 the list of all solutions notice just a comment here in all these examples
 functions that are in person are not actually tail recursive because the
 recursive call occurs in the for yield block and it's in other words inside
 some deeply nested flat map somewhere all these are translated into nested
 flat maps so if you look at this also this is a recursive call you see
 this little symbol here so that is the IntelliJ telling me that it's recursive
 method but the recursion is not tail recursion occurs on the right hand
 side here and so there is some more computation that is being done after
 this call and so it's not a tail recursive call it's not the last computation
 being done the tail recursive call would have been if the result returned
 by this function is the result that the entire call he returns but that
 is not so after this whole there is more computation to be done so this
 is just a short comment here that these non tail recursive functions are
 certainly not great in terms of safety because if for any reason you need
 a large number of recursive calls that will blow up the stack give you
 a stack overflow exception there are ways of making this stack safe but
 this is out of scope for this tutorial right now we will talk about it
 in a later tutorial how to make monadic recursion Starke safe it is slightly
 more involved than usual recursion because the recursive calls a curve
 in a freon block under magnetic flatmap context so that would be I will
 discuss in a different tutorial so the last example for the list like Munez
 is a slightly different problem that I found quite interesting I worked
 on it some time ago when I was implementing and another open source project
 I found that I have to transform boolean formulas from distributed normal
 form and token sorry from disjunctive normal form into conjunctive normal
 form so CNF is conjunctive normal form and I found that this transformation
 is very simple if you formulate it in terms of the West model so let me
 show you the code it's really I'll explain now what it means to transform
 between these normal forms in case you're not familiar with the boolean
 logic it's not difficult at all it's just terminology so what does it mean
 the conjunctive normal form so it's all about boolean formulas like this
 one so we have boolean operations or and sorry and so these are boolean
 operations and the boolean formula in general can have any combination
 of these boolean operations now we say that the conjunctive normal form
 is when the formula has the the shape has already it has some parentheses
 that are connected with and and inside the parenthesis there all only or
 so there is nothing no end is allowed inside the parenthesis no or is allowed
 outside the parentheses so that is how we define the conjunctive normal
 form and disjunctive normal form is the opposite inside the parentheses
 the and only is allowed outside the parentheses the or only is the left
 so these are these the normal forms and why are they important at all the
 reason is any boolean formula can be transformed into one of these forms
 into both actually whatever you want that the reason is there are boolean
 identities for example the or and the end operations are distributive so
 you can you can expand the brackets or the parentheses so for instance
 if you imagine let me let me just make a little comment here so that it
 is more illustrative so this imagine that you replace or with a plus and
 you replace and with x so that becomes an algebraic expression that you
 can transform by expanding the parentheses like an ordinary algebra and
 then you can again replace the start of the multiplication with end and
 the war with sorry the plus with an or and you put parentheses around this
 and then you have a valid transformation of william formulas so this is
 you see on the Left we have conjunctive normal form because on the left
 hand side we have only our operations inside parentheses which are disjunctions
 and conjunctions which are and operations are outside so the simple expanding
 of brackets or expanding of parentheses in the sense of ordinary algebra
 is what transforms one of these normal forms into another so in this example
 we will implement these transformations will implement the transformation
 left responds to expanding brackets as a symbolic computation in order
 to do this we need to represent the formulas in some way symbolically so
 we will do this by using sets so let's use a type parameter T as a type
 of represents individual prepositions in the boolean formula we won't do
 anything with that value it will be symbolic for this reason just manipulate
 sets of these values of type T and so our in our representation the normal
 form already forces us to have this structure that there there is a one
 or more actually zero or more parentheses and outside it's always the boolean
 and and inside is always boolean over so all we need to say is there is
 a there is this set that has a and B in it and there is this set that has
 CD in it the water of course is immaterial because any of these designs
 be Jorge so sets are sufficient to represent this and then we have a set
 of these two so the outer set will be impossible the boolean conjunction
 and between these and the inner set will be implicitly the boolean disjunction
 between lives so that is going to be our short representation of the boolean
 formula so now let's just briefly consider what would be the true and false
 values in this representation the value true is the empty conjunction which
 is a conjunction of no parentheses and that's empty set the value false
 is an empty disjunction which means we do have one set of parentheses but
 there is nothing inside it so that's a set of a single empty set now the
 disjunctive normal form has the same representation in terms of data type
 it still sets of set of sets of T but it just that the other said now is
 the disjunction and the inner set is conjunction so because of this the
 true and false are represented in the opposite way so the true for this
 DN F is the set of empty set its if you are wondering why is it that empty
 conjunction is true while conjunctions are abundant so if you have some
 non empty conjunction and you imagine that you have a conjunction of that
 with an empty conjunction that shouldn't change anything and so that's
 why the the empty conjunction must be true because the conjunction of true
 and X is X the same as with false false is the empty element for the disjunctio
n 108 so that's why false is the empty disjunction so now as I just showed
 you it is easy to convert one end to the other you just need to expand
 brackets so let's see how we can expand brackets so let's just define these
 types type constructors so that we can distinguish them more easily the
 equality we just define this for convenience to compare we want to run
 tests and want to convert one to the other and compare results so these
 are our presentations of true and false as discussed so let's think about
 how we can expand parentheses or brackets here for example so we have a
 set of sets and we need to prepare a set of these sets of them so in order
 to do this transformation using a functor block let's go like this so X
 goes over this set Y goes over that set and then we need a set of all sets
 that has one X out of here and one way out of here right okay see a deep
 B C B so that is easily accomplished we have X from the first set a quiet
 from the second set we just make a set that cascada means x and y so that's
 going to be the result so if we just had two sets of parenthesis then we
 would write code like this so now we need to generalize this code so that
 it is applicable to any number of parenthesis not just two and we do it
 the same way that that we generalized before we write this code once and
 we use a recursive call so let's do that so the the trick I'm using is
 that I need to check that the set is empty actually I I can check that
 I can do in the previous code examples check that it's empty and if not
 take the head a slightly more visual and clear way of writing the same
 code is to use head option so head option is defined on the set remember
 V is the name of our data element inside the case class so that's just
 our set of sets we take a head option the head option is going to be a
 set or other option of a set and we match that if there is nothing that
 means we have a false so we could have put this CNF false here actually
 just to be more visual then we have the case when it's not empty so then
 we have the first Clause we need to let X go over the first Clause and
 then we need to do a recursive call on the rest so in this example over
 just two we need to go over the second one but actually in a recursive
 call with will have more than one y in here so let's take all of these
 waters is going to be then set Y are all other terms that are connect converted
 to cmf by the recursive call and so now we have an X which was chosen from
 the first set of parentheses and all the Y's is the rest of the CNF that
 was computed by the recursive call so now we just need to concatenate these
 sets and that's the result and that's actually the entire code so that's
 very simple in order to run we need to actually simplify things because
 it turns out that simply expanding brackets will not produce results that
 are identical here's an example if you have this kind of thing this kind
 of boolean formula it's actually the same as this boolean formula because
 this entire formula is true only when this is true when this is true then
 here we have true we don't need to compute anything else here I already
 have true in this set of parentheses inside here so this can be just ignored
 this can be simplified away it is unnecessary to compute any of this so
 this simplification can be just made by by saying well is there any clause
 well these are called closes is there any clause that is a subset of another
 Clause so for example this Clause is a subset of this one if so then we
 can ignore this larger clause and this is what this code does it's sort
 the closes by size and then it finds what are the closes that our subsets
 of another and then if so we ignore the larger Clause which is to the previous
 and if not we don't ignore it so this is the code that simplifies using
 a fold and these are tests so for instance this is the example and actually
 another interesting property is that this function is its own inverse if
 we convert from DNF to CNF and then we want to convert it back we can use
 the same function to convert back this is so because expanding brackets
 is an operation doesn't really depend on what operations are in and out
 of the brackets as long as they are distributive and they are distributed
 in the boolean logic in both directions and so it's the same operation
 the enough to CNF it's the same as CNF to DNF it's its own inverse and
 the test verifies that go dnf2 CNF and then we first we convert this and
 then we can write back and it's the same thing I would like to add some
 more examples of linear algebra manipulations and to illustrate certain
 properties of the function block these are examples taken from the standard
 Scala library documentation I rewrote them to be slightly more functional
 clear so the first example is the computer transpose of a matrix so in
 the matrix is represented as a sequence of sequences and the result is
 again sequence of sequences so how do we transpose a matrix it's actually
 not so simple because for instance the first sequence in the result must
 be the sequence of all first elements of the sequences listed here the
 second sequence in this result is the sequence of all second elements of
 these sequences so how do we get all second elements of sequences we need
 to know the index 0 1 2 and take that by index so here's what we do we
 define this index as an iteration here going over all indices of the first
 sequence in this sequence of sequences so indices and a standard library
 function it returns a range such as zero to zero until something zero until
 lengths so then once we go over these indices what do we healed we yield
 another four expression it seems in other words we yield a sequence that
 is computed in a different way how is it computed we need for example here
 the first sequence we need to return is a sequence of elements at index
 0 so that's what we return return I think the name is back to high perhaps
 when I hear 0 that will return a sequence because the for yield returns
 a sequence of whatever you yield here a sequence of 0 of elements from
 X s where access goes over all of these so in this way we'll return a sequence
 of 0 of elements of these sequence of set first elements second elements
 and so on as I goes over an indices so you see in order to do this we had
 to put a 4 inside of a yield and the result is not easy to read this is
 a bit of a complication so nested fours either inside of a yield or inside
 here you could put a for else inside here it's harder to read and probably
 easier to refactor in some other way so for instance to make this function
 depends on I and XS when they put that function here and make it more clear
 what exactly is being computed but that is a core code that and that can
 be refactored when necessary for clarity that's how it works transposes
 this into this the second example is to compute a scalar product of two
 vectors so we use a zip function we have two vectors two or two sequences
 generally and notice I'm using the numeric typeclass in order to have the
 sum and I'll do this import so that I now have syntax I can do star multiplicat
ion on the numeric type you see X is a numeric type and but I have multiplicatio
n that I have addition on it because it's from the numeric typeclass so
 the zip will create me a sequence of tuples of pairs so now for each tuple
 I I can write syntax like this I can put a tuple right here I yield the
 product so that means the result this entire four expression inside the
 parentheses is a sequence of these products now I take the sum of all these
 products that's the scalar product of two vectors this is a test that it
 works directly and finally I write matrix product so again matrix product
 is kind of difficult because it's it it has to be a yield that has a nested
 four but this is how it works so first of all we transpose the second Matrix
 and then we take the scalar product of one vector the first matrix and
 the one better from the second Matrix and we put that into the resulting
 matrix so that is I'm not going to go into mathematical details here how
 to compute matrix product but this is the way that you can use the for
 yield block in order to iterate over these data structures not particularly
 visual maybe but at least there's a no way to make an error in terms of
 indices or anything else so that's an advantage the next type of monads
 we are going to consider is the pass/fail units examples are optional either
 trying future so as I already mentioned before pass/fail monads are containers
 that can hold 1 or 0 values of some type usually that is interpreted as
 success or failure so if you do hold a value of type a and you have success
 you have successfully completed it and if you don't then you have failed
 to compute it that's how it's usually interpreted and these containers
 usually have special methods in order to create pass and fail values and
 an example of this is a is a try a good example try has methods to catch
 exceptions if exception occurred then it will be a fail and if it didn't
 occur then you would have a value so that's a typical pass/fail monad here
 is a skeleton or schematic example of a functor block program that uses
 try we have some compute Asians that might throw exception so we put them
 in to try then we say well X is from this and what does it mean well this
 container can have at most one value inside so actually this is not an
 iteration at all unlike what we had in the list known as this is not an
 iteration this is we're binding X as a new name in case that this is a
 success if it's a failure then there's nothing to buy in so this entire
 filter block will collapsed to the failure remember that when the collection
 or the container on the right hand side has zero elements when the entire
 for yield or founder block computation collapses to zero length container
 this is exactly what happens if this computation here were to fail if it
 doesn't fail and we can continue compute something else in this line nothing
 can well nothing can fail provided that F does not throw an exception of
 course here we can filter if this returns false then again the entire function
 block will collapse to a zero length container so to speak if it does not
 collapse then we continue with new computation again here this function
 could throw an exception if so then the exception will be caught and the
 entire thing collapses when this entire thing collapses the result is still
 a try so the result will contain information about the failure it will
 just contain no value of type a so there won't be any value of type a in
 that case and so on so this is how we write code with the pass/fail moments
 we keep assigning new variables here and hoping for the best so the only
 way that we can yield the value here is when all of these computations
 are successful so there's no failure in any of them if so then we owe the
 value of type a and the result is their fourth of type try of it now the
 same rule holds that the right-hand side of the generator lines must be
 the same type constructor but the type of these values could be different
 in each line the type of values held by the container may be different
 but the type of the container itself the type constructor must be the same
 or at least it must be some superclass in Scala we have inheritance so
 this could be used to have a superclass and that is used for sequences
 you can have different subclasses of sequence but that must be somehow
 convertible to the same superclass so another important thing to notice
 about pass/fail munoz is that the computation is really sequential so until
 this is done until this computation is finished there's no way to continue
 we have to have this X to continue until this computation is done and if
 it is successful of course there's no going no way to find Z and so we
 cannot have an X here until this and unless this is successful so this
 is really a sequential computation we cannot continue usually with the
 next line of the computation until the previous line is done so this is
 true even if we have the future functor in the future factor scheduled
 computations on different threads and these computations could be proceeding
 in parallel but still the computations are sequential we'll see an example
 about this [Music] so once the any computation fails the entire functor
 block fails so remember the number of elements in the entire collection
 is going to be the product of the number of elements in the generator lines
 and sorry for in if any one of them is zero then the entire thing collapses
 to zero so there are going to be zero elements in the result in other words
 it's going to be a failure and if all the computations succeed if there's
 no failure Miniver so for option fader means none for either failure means
 a left for try there is a failure constructor for future there is a failure
 constructor only when all of them are successful then this entire fungal
 block will have a value as a result just one value also filtering can make
 it fail so the benefit of using the for yield syntax with a type constructor
 such as option either try and future is that you don't need to write code
 with nested if-else or match case expressions you could have written this
 code with just match case first you compute this drive then you match the
 result if it's successful then you get an X then you compute this and you
 if this is successful then you compute this and so on then you match on
 the result so it will be a bunch of nested if-else or a bunch of nested
 match case that kind of code is hard to read hard to modify this is kind
 of a flat flat looking our code that is easier to read so you see this
 has to be done this has to be done the code is logically flat that is the
 advantage it's easier to understand easier to read of course they have
 to be get used to the same that the type constructors I'm just writing
 out again that these must be familiar to you by now these are disjunctions
 so the pass/fail Monitor typically disjunctions now the tri is equivalent
 to an either where the type Z is throwable which captures exceptions and
 then there is this data type a so the typical reason we use these moments
 is we need to perform a sequence of computations each of these computations
 might fail and we cannot continue if one of them fails we have to report
 the error somehow so we just make this explicit with return an error value
 which is not to crash it is not sometimes exception or error situation
 it's a value that captures the information we want to give about what happened
 and why things failed and so that's the typical use of a sphere moniz let's
 look at some work examples the first example is to read Java properties
 so Java properties are strings which are held in the system dictionary
 of key value pairs so you have a key which is a string and a value which
 is a string so here's an example we have some properties and we want to
 compute something for example for the client we want to find out which
 corporation the client is working for for that corporation what are the
 orders as were posted and then for the order we want to have the amount
 or something like this now the Java API is such that you can say get property
 only when you do get property that returns a string but actually it could
 return null if this property does not exist and so in Java this is the
 usual reason for null pointer exceptions so some function returns null
 but you didn't expect it you start following methods on that you get a
 crash so in order to avoid this and make it safe let's put this inside
 an option so the option type has a function that you put an option of something
 and if that something is null then you will get an empty option otherwise
 you would get a non empty option so that's a very convenient function whenever
 you have some Java API that can return null in order to signal that something
 wasn't there or something was incorrect wrap it into an option like this
 it becomes safe and now the code we write looks like this first let's say
 somebody gives us the client name we want to return the amount of the order
 now it might be that this client is not found where the corporation is
 not found or ordered is not found in this case we cannot return the amount
 renamed this function for clarity I cannot return the amount in this case
 so I will return an empty option otherwise I will return a non empty option
 with the requested amount so this is the idea are always return a well
 defined value just that sometimes this value will be empty or it will not
 contain the data that I was supposed to return because I can't return love
 data and so I write a for yield with these values being strings but because
 this is a monadic block whenever one of these is now this entire block
 would collapse to an empty option so I can write the code as if everything
 is good so this is the so-called good path or happy path but I know that
 whenever something is null here either the corporation's property does
 not exist or orders property does not exist then this entire for your blog
 will collapse into an empty option so I'm safe to write code here last
 line I'm trying to convert the string value to integer now the string value
 is guaranteed to be not novel but it could be incorrectly formatted so
 it's conversion to end might fail with an exception no matter I'll grab
 that into a try so after that exception is going to be caught and then
 I convert that to option so there was this helpful method to convert to
 try values to option so if try had I would have an empty ocean here and
 then everything will collapse I'll return an empty option so you see this
 code has no if else it looks very linear and yet it's completely safe all
 the errors are handled invalid non integer values either our handle they're
 going to be ignored so the test is that if I want the order mount for client
 3 there is no client 3 and the second example is to obtain values from
 computations using future so this is an interesting example in order to
 work with futures I make this import just for simplicity so imagine I have
 a long computation now I'm going to compute something not particularly
 useful maybe some kind of long Sun with cosine functions and whatever it's
 not particularly important I just want to have a computation that takes
 time in order to save time this computation I want to make it in parallel
 so I put this computation into a future and I'm going to try to compute
 them in parallel now here's the code I write I have this auxiliary function
 time which will return me the result and also the time it took to compute
 the result so how do i compute the result well I have a 4 for yield which
 uses the future so that the right-hand side of these computes the future
 of double and therefore the left hand side is double so the type of the
 container in this for yield block is future it must be the same type throughout
 the container so that is future and the result type is going to be a future
 double as well and so this looks like I am performing first along computation
 which is going to be in the future when that computation is done I perform
 another long computation using that value as input which will call this
 function and create a new future and what future will depend on this X
 because the computation uses the X C and so I cannot really start this
 computation until this one is finished putting future's in a for yield
 block will sequence them in other words first it will wait until this future
 has done its computation to return its value and then will put this value
 in here call this function and start a second future wait until that is
 done put this here and wait another feature I should I should return I
 should return Z probably to be slightly less useless for this block in
 any case the result is that these futures are sequenced one of them waits
 until the other is done now imagine that these computations were not depending
 on each other well here they do this computation depends upon respects
 imagine that that weren't the case if that were in the case let's say we
 have three computations and these parameters are known in advance then
 we could have started started all of them up front so look at this code
 so we create three futures of all of these part of type future we create
 three futures and in Scala future is a funny type because once you create
 a future you already schedule is to run there's no separate operation to
 started or to run it once you make a future it means the system will attempt
 to run it already there will be probably already running process so this
 means these three computations are probably already running by the time
 we are here what do we do here we make a four-year block which is superficially
 similar to this one we just put the computations in variables and put them
 here so the result however is going to be faster because all these futures
 are started at the same time yes here you wait for them but they already
 started all in parallel so you would just wait less you would first wait
 until this is done and while you wait maybe this is already done so this
 second wait will take no time at all and so the result I expect to be faster
 so in this test I'm fringing how long it takes and the typical output I
 got in my tests was like this so the first sequential futures it took six
 seconds and a second took 2.7 seconds so this is not exactly three times
 faster but it is more than twice as fast in any case we were able to do
 this only because the three computations don't depend on each other if
 they do is there is no no way to speed it up it's just there's no advantage
 in putting that computation in the future if you cannot do it in parallel
 for this at least for this test let's look at the other example example
 3 which is we want to make a rithmetic safe and we use the either type
 to return error messages so that's a very common use for disjunction type
 so let's make this type that has either string or double in it and string
 will be an error message of some kind meaning that we cannot compute the
 double value strictly speaking this is not a factor because it doesn't
 have a type parameter so I'm just abusing well I'm the either is a function
 I'm using the inner function and I'm just specifying the type to double
 because this is going to be in my example but actually this is a functor
 with double as a type parameter so we could think about this as a function
 and that's what it is how we are going to use it so the idea is that if
 there is a operation that could fail then we return the left with some
 error message and if there isn't success in returning right with that value
 so if we already have a double and we do an implicit conversion of that
 to the safe double by just putting a right around it and in this example
 the only operation we're concerned is division so we can divide by zero
 we don't want to try to do it do that we want to return an error message
 and so that's what this function does is a safe divide it would tell tell
 me what I tried to divide by zero so hopefully it will help me in my debugging
 so then that's the point of this example so here's the code that I use
 so instead of writing well x equals one and I've put everything in a functor
 block and you see quite unlike the things we did with sequences these are
 not loops at all these are not iterations in any sense for yield is not
 a loop that is a important point that I would like to make there is no
 iteration going on necessarily it's a monadic sequencing operation rather
 so we are sequencing computations that might fail if they fail we want
 to fail the entire computation if any any of the steps fail so here is
 what we do X is assigned to be one that's not going to fail because there's
 no division here is a division let's say no it's not going to fail but
 we still use a safe divide and then we do this so the result is going to
 be always safe double so here the right hand side of the generator arrows
 is either of the type either already is a safe double or it's automatically
 converted to safe double so safe double is a type of the right hand side
 of this look and here's an example where it fails so we divide by zero
 we do exactly the same things but because this step divided by zero the
 entire thing collapses we never get here and the result is a left of that
 a last example for the pass fail is to sequence amputations that may throw
 an exception so here we sequenced computations that could divide by zero
 and here we just have arbitrary exception so here is what we do dividing
 by zero throws an exception for integers it doesn't for doubles it gives
 you a not a number but for integers it throws an exception so imagine we
 have some functions that might throw an exception we wrap all of this into
 a try and then we have code like this and so this is completely safe the
 result is of type try of int and we can in examine the result to see that
 it's a success or a failure so we do match expression and then in this
 test I know it's going to be a failure because I first what what did I
 do if one of one so I divide two by one the result is two then I subtract
 2 minus 2 the result is 0 then I divide one by zero so I know I know it's
 going to be a failure but in principle here you could have a case of success
 and that's how you use the pass/fail chain so you put everything in to
 try the result is also going to be a track so I can just add the type here
 for clarity you don't have to write this but for clarity I want to the
 next type of monads I'd like to talk about are tree like monads so what
 are the tree like moments here are some examples these are type constructors
 defined recursively and I use the short type notation so it's easier to
 understand what's happening so the binary tree is either a leaf or a pair
 of two binary trees so that's a familiar type perhaps and because it's
 recursive then this can be again either a leaf or a pair of two binary
 trees and this also can be maybe a pair and so this is a pair and this
 is another pair that just keeps splitting until it ends with a leaf another
 stability of generalizing this kind of construction is to say well actually
 this is a functor this is a pair of F and F let's say that the pair of
 F and F is a function y 2f let's call this one term s shape and so then
 it will be s of F of ready let's take arbitrary function s not necessarily
 just a pair so it could be triple then the tree would branch in three branches
 at each each point instead of two branch so we can just parameterize the
 shape of the tree by an arbitrary function S this factor could be actually
 arbitrary could be list when you would have a rosetree what's called where
 the branching can be arbitrarily large in ten you point could be any factor
 so that's what I call an s-shaped tree where s is a funder functor shape
 dream another interesting example of a tree is when both the leaves and
 the branches have the same shape so the leaf must have a pear and the branches
 must be too and analogous generalization is when you have functor shaped
 leaf and a functor shaped branching so these are perhaps more rarely used
 but I found them interesting to Q consider most examples for all of these
 you can implement flat map and we'll look at examples of how to do that
 so here's here's how you implement a flat map for a binary tree with binary
 leaves this is our first type constructor here I'm sorry this is a third
 type constructor here the binary tree with binary leaves so how do you
 implement flat map well let's first define the type so the type is this
 it's a disjunction the first element of the disjunction is a pair of a
 a so just follow the type here the first element of the disjunction has
 a pair of a a the second element the second part of the disjunction is
 a pair of two three factors themselves so I call this B X and B Y now we
 need to implement a functor instance for this and I have my own typeclass
 here called semi monad just for convenience where I can define flatmap
 [Music] so to define functor is pretty easy obviously if you have a pair
 of a a you just map both of them with a function f and if you have a branch
 then you recursively map each part of the branch in the same way so flat
 map works actually quite similarly except for the leaf if you have a leaf
 the leaf has two elements and so you have a function that takes the leaf
 and returns a tree so now you have two trees so you can't have a leaf if
 two trees in it but we can have a branch and so we put these two new trees
 into a branch here is how we can implement flat map for a functor shaped
 tree and here I make a more abstract formulation where I have actually
 a tree that's permit rised by an arbitrary function so that's a functor
 shaped tree so the leaf is just one element of type a one data item and
 branch is a functor s applied to the tree so it's a functor shaped branch
 how do we implement the functor instance and how to implement the semi
 Monod instance for this tree this is a little involved but the sin it's
 just a syntax that's a little complicated here because we need to parameterize
 by an arbitrary function and so the type constructor is this so the factor
 s is fixed the type parameter is free the map works by matching so if it's
 a leaf and we map the leaf value with the function f if it's a branch then
 we we use the map function only the factor s which we should have because
 we assume that s as a function and the function we use to map is the recursive
 instance of mapping the same tree here is what we do where it were in this
 case so if we want to map a to be we map a to be over here recursively
 and then we map over the function s because we know it's a function and
 flat map works similarly if we have a function from A to F B then this
 is just mapped to FB by itself and we haven't have been and this Maps afraid
 to have be recursively and then the out the outer layer of the Thunder
 s is mapped using its own map function so here's how it works so we have
 a function f from a to the tree if we have a leaf and we just put that
 entire tree instead of the leaf or as one can say we graft the subtree
 at this point and if we have a branch then we map over the branch which
 it because we have the outlaw outer layer on the family yes so we've mapped
 that and underneath we used the recursive call to the flat map here's an
 example of an entree like type constructor it is a disjunction of this
 kind so it can have one a can have two is it can have four A's and so on
 all the powers of two now this type constructor is actually not recursive
 so it is not a tree like type constructor it is not one of these cannot
 be represented as one of these and it is not a ma not in the usual sense
 or not a tree like ma not in any case so a little bit more intuition about
 how flat map map works for a binary tree so imagine that we have a tree
 that looks like this and we need to flat map it with a function that takes
 any so all these are leaves of type a and so a function f takes a and returns
 a tree of type B imagine that when we apply the function f to these three
 values of type a we get three different trees of type B so suppose that
 these are the trees we get so the tree that has these two leaves a tree
 that just has one leaf and a tree that has these two so then if what the
 flat map is supposed to do its supposed to replace a one with this subtree
 so instead of anyone will have this subtree a tree with b2 so that's this
 replacement a3 is going to be replaced with this subtree so a3 used to
 be here now it's this subtree so this is the result of applying flatmap
 to tree like walnuts its grafts sub trees in places of leaves that plays
 the role of flattening so actually nothing is being flattened here in some
 in a sense of trees remain trees trees are not flat in the organ Airy sense
 and they do not become flat in any sense however what becomes flat is that
 we had a tree in the shui for each leaf we replaced that with a tree but
 we don't get tree of trees tree of trees is just equivalent to a tree that
 is what it means to be flat note that the tree becomes somehow meant dreamlike
 but a tree of tree of B can be seen as simply a tree of D there is no need
 to say that we have a tree of trees the trees already branching enough
 so that's what flattening does for trees typical tasks that dream tree
 like monads perform are traversing a tree and replacing leaves by sub trees
 are grafting leaves grafting sub trees at leaves one example of doing this
 is a user is transferring a syntax tree representing some expression where
 you substitute sub expressions in it so if if this is some expression tree
 then you want to substitute sub expressions instead of leaves and that's
 it kind of typical tasks that tree-like Mona will do so let's look at worked
 examples the first example is to implement a tree of strength properties
 so let's take a look at that so probe tree is going to be our factor so
 just for simplicity I'm going to put a map and flatmap into the street
 right there we'll implement them in case classes that implement the trait
 this is not necessarily how you want to do it but if this is your own type
 it's easy to do that if it's not your own type so that your you cannot
 change the source code for some somebody else's type constructor then you
 need to do typeclasses and add map and flatmap using type 1 system I just
 want to make it short okay so what is this type so he has a leaf which
 has a value of a and also it has a fork which has a name and a sequence
 of other trees so it's a it's a slightly different shape so the forks are
 named so there's a name and it can have zero or more sub trees here is
 a sequence so it's kind of a rosetree with named branches so how do we
 implement map well if it's a leaf we just map the value if it's a fork
 then name stays the same but each of the trees is mapped with its its own
 function this is a recursive call Raney however the recursion is hidden
 it's not the same function this function on a different object what's the
 same it's still recursive flatmap so if we are in the leaf we need to replace
 value any with a different proper tree we just graphed that probe tree
 in place of the leaf that's a standard thing to do and flatmap for a fork
 is just mapping so basically this is our example of a functor shaped tree
 this was this example where the founder s has a specific type it is a product
 of a string and the sequence of a or a sequence of of trees so that is
 just a special case of the construction of a functor shape trip right so
 here is an example we have a fork with named a1 and it has a leaf one a
 leaf - and another fork named a - with leaf 3 now we can map on the stree
 with the function that adds 10 so then each leaf will get 10 added to it
 the structure of the tree remains the same after mint because map doesn't
 graft anything it just changes the values and leaves now let's look at
 this code we want to look at the leaves and somehow transform leaves that
 are small and small is less or equal to 1 so here's the code for this so
 we we said X goes over tree which means that actually the value of X goes
 over leaf values because that's the values in the tree that are being being
 used and then if the leaf is larger we keep it as a leaf otherwise we make
 a fork in it and call it small and put a leaf inside this work and so we
 yield that so this code transforms a tree the tree that we had here has
 fork a 1 and so on it transforms into this so the leaf one is a small and
 instead of leaf 1 we have now a different tree this one everything else
 stays this sparkly one but me maybe format this so that it's easier to
 see easier to compare the two different trees before it after the transformatio
n so the only difference is that instead of leaf 1 we now have this fork
 with extra information so that's the result of transforming the tree so
 you see this for yield is a kind of a loop but it's a loop over a tree
 and it can transform a tree into a new one so just to repeat for yield
 is not really iteration it's more like a general kind of operation that
 goes over your container and depending on what the container is like it
 will it can do many things so for the tree like monads it's usually tree
 traversal exactly the same computation written by flatmap syntax to study
 for yield is this the second example is to implement variable substitutions
 for an arithmetic language so what do I mean by an arithmetic language
 so imagine we have a symbolic manipulation program wants to manipulate
 expressions it can be a compiler or it can be some kind of calculator program
 or anything else like that so that kind of program needs to work with symbolic
 language that does some kind of reputation and let's say every filter so
 for us we're going to have a very simple language language is going to
 have variables and multiplication and it will have constants integer constants
 and that's it so to define this language we define a disjunction so basically
 this is the term let me write down maybe the short notation for this term
 is it was a so int is one part of the disjunction which is called Const
 the second part of the disjunction is the variable which is called the
 var and the third part of the disjunction is malt which is two terms so
 this is the definition of the type this is recursive and you see this tree
 like except that we have this extra thing here now that's fine that doesn't
 carry modify and structure so much against that belief now can have an
 extract information so let's define map and flatmap oh this is trivial
 and I'm going to go over it this is the same structure we found before
 and now let's implement variable substitution so what does it mean so suppose
 we're so expressions in this language will look like this as a constant
 times VAR times constant times more and so on there's nothing else in this
 language except constants variables on multiplication so we can do that
 in any order we want and that's all now there are two operations we can
 do use a map and flatmap using map I can modify variable names so we can
 for example append X to every variable name so here's what the result will
 be depending X 2 variable mass second thing we can do is substitute variables
 so for example instead of very well a we can substitute this expression
 so we can substitute new expressions of the same language instead of variables
 and that's usually what mathematical expressions do variables in mathematics
 are substituted with new expressions of the same kind so that's what we
 are going to do here so let's substitute there I will a with this expression
 and the variable B with that expression and we do it like this so X is
 going to range over there Able's wine is going to replace X so we'll do
 I instead of X if we just said for excellent expression yield X that's
 going to be the same unmodified expression as before so we modify we say
 Y is is that and well we just threw an exception here just so that I have
 some simple example but basically if the name of the variable is a then
 we substitute this otherwise we substitute that so the result is correct
 finally we come to the non-standard containers for single value monads
 they are not really single valued in the sense that they are not equivalent
 their container with the single value container with a single value is
 identity unit or identity functor it just a continuous has a value agent
 that's not what they actually do but they are similar to that they can
 be imagined or reasoned about to some extent thinking that the only and
 always hold one value actually the meaning of the single value units is
 that they hold the value and also they have some kind of context together
 with that value and when you do computations then contexts play a role
 they can be combined and they can also be used to do something and usually
 for these moments we have methods that insert a value one container hold
 one value so that's necessary to be able to insert that value in there
 somehow and also usually there are methods to work with this context and
 we will now look at five examples of single value moments and we'll appreciate
 the variety of what this idea can do holding a value in a context so the
 typical tasks that single value Mullins do are to manage extra information
 about computations as you do the computations along the way and also to
 perform a chain of can rotations that have some kind of non-standard evaluation
 strategy so in the first case where we are managing extra information the
 context is this extra information in the second case when we are changing
 computations with some non-standard evaluation strategy for example in
 synchronous computation or lazy computation then the context is that what
 makes the evaluation strategy non-standard so it's not a value this context
 cannot be just seen as a value in this case it is kind of the way that
 we do computations or extra effects or maybe side effects that occurred
 during the computation for something like this so we'll see examples of
 both of these kinds so let's look at the first example it's the writer
 monad the writer monad is defined as this type constructor very simple
 is just a pair of a data item of type a and a value of type W where W must
 be a mono it or a semigroup suffer for this to be a full mode add W must
 be a monoid and for this to be a semi mode add W can be a semigroup to
 remind you the difference between 100 and semigroup a mono it has a unit
 element or identity or empty element which is a selected element so that
 you can combine it with other elements without changing those other elements
 a semigroup does not have that element it's just a set with the binary
 operation that is associative so here in this tutorial we can consider
 a semi munna des writer as well because we're not necessarily so interested
 in the mona fully form on that right now and so we will assume that w is
 the same so this w will hold some kind of logging information about our
 computations and logging information should be able we should be able to
 attend one piece of logging information to another and that's the semigroup
 operation so let's look at the code so in this example we have so I defined
 the writer as semi moonlit where a is our data type and s is a semigroup
 and so that is just a pair of a and s why I wrote s instead of W let me
 just make W out of this just so that I'm consistent with my slides so we
 can easily find the instance of functor and instance of semilunar now instance
 of sending one is just flat map so semi-modern is typeclass that just requires
 flat map with a standard type signature so how does that work well obviously
 functor works by mapping mapping the value but not changing the log so
 log is this information that we logged about the computation now the flat
 map has this type signature so when we do the flat map we need to take
 the previous value which is already a pair of a and W then we map a to
 another pair of BMW now we have to double use so we have FA dot log and
 FB deplored FB was computed knowing this and so we combine the two log
 values by using the semi group operation so this is how we could use this
 in practice imagine that I want to record in my log some comments about
 the operation and the time let the computations began and the time at computati
on is finished for the entire chain of computations not just for each operation
 separately but for the entire chain of computations I want to find begin
 time and end here's how I can implement this I make a semigroup that has
 three values and the semigroup type is a triple of local date time local
 date time and string how do i define a semigroup instance I need to combine
 two logs of this type so the messages I combine by just appending them
 with some new line separator but the beginning end I combine in a specific
 way further from the begin I take the first begin but for the end I take
 the second and second why today because it I'm combining two operation
 so the first log in the second blog and I assume that the first log occurred
 first and so the beginning of this entire operation is the beginning of
 the first log while the end of this entire operation is going to be the
 end of the second log so that's why I'm putting it like this now this is
 actually a semigroup it is associative but it is not a monoid it cannot
 be read into mono it so my writer here will be a semi Munna but that's
 the use case so that's that's what I want it for so now I define a convenience
 type constructor which is the writer with this logs as a type and i also
 define a help of helper function that will do the logging so i have a value
 i have some message and then I insert the timestamp into the log and the
 message that's very easy mean I just insert begin and / convenience as
 the same timestamp and things will automatically be adjusted as necessary
 once I combine this with computations made later so this import is necessary
 in order to use this machinery with the same Amanat typeclass and here
 is the code so these compute things are fake computations that pretend
 to take time so they actually wait for this time but that's fine for this
 example so you see I'm logging so I log in everything with the message
 and the times will be automatically looked so I first start with the log
 int so the integer value so X so the integer then I add 1 to that X that
 becomes my life so that's going to be 4 and then I multiply by the 2.0 which
 is a double so the result will be log double and I'll yield Z in the log
 function block so the result is of type log the devil so as usual the right-han
d side of the generator lines is always of the same container type which
 is logged this is the container type for this entire function block this
 is the function so these are computations in the context of a factor this
 is what I call computations in the context of a functor we write as if
 these are values we compute but actually these are inside the function
 so everything is so as if we return a double but actually when we compute
 any factor parameterize by double so logged double that's the type of the
 result let me put it in here for clarity and the result is 8 so it's 3
 plus 1 4 times 2 now we checked what the log message is so the log message
 is actually beginner is 3 then there is a newline head wound there's a
 new line x 2.0 neither our global messages and also I can check what is
 the interval between beginning and end and test checks that this is about
 right so it's 20 milliseconds 50 milliseconds at 100 milliseconds together
 it's going to be slightly bigger but anyway not much bigger so this is
 the example of using a writer movement in our case it was a semi mu not
 actually not a moaner use a writer monad we can easily make automatically
 logging computations with keeping track of wall clock time the second example
 is the reader movement so the reader monad is also to be thought of as
 a container that holds exactly one value in the context and the context
 is some value representing the environment some type II which is given
 it is read-only you can read it and it's always available for you to read
 so this can be used for dependency injection or for passing some common
 parameters that you don't want to pass with explicitly with every function
 and dependency injection means that the computation within the reader functor
 or with the context of the reader frontier take this as a parameter automatical
ly they don't depend on what it is and then you you inject it later so that's
 how it works let's taken let's look at an example the example will be that
 we have logged computations and the logger is the injected dependency so
 let's say performs some kind of side effects a function of this type and
 we want to make computations that use this function but we don't we want
 to depend on this function as read-only context so somebody will give this
 this to us later but we want to write code now so we use the reader monad
 which is just a cat's reader now cats reader is equivalent to this type
 which is just a function from Italy so for convenience we define this type
 as a reader of log duration hey so we will understand this container hence
 a container that has a single value of a but that value depends somehow
 our computations can depend on this logger function in some way so let's
 make a constructor for convenience that will log a message so this constructor
 now has a lazy argument X so this syntax in Scala means that the function
 argument is lazy and unevaluated until the function evaluates it so that's
 kind of automatic lazy parameter passing and here's the code so the log
 returns a reader with the log duration in it so it's a function from log
 duration to a first we compute this X here and we time it so we compute
 the time to actually run this XC as I just said a result equals x actually
 because x is a lazy parameter it is not yet evaluated until I do this so
 this is when X will be evaluated and this might take time and so I compute
 that duration and then I log it using blogger function and I return the
 result so that's my convenience function so once I coded this I can write
 code like that like I did before very similar with now I had I can do add
 another set with reading which is usually called tell now tell is just
 a function that returns the injected dependency or the environment or the
 context and this is just a reader of identity which is a function from
 e to e that's an identity function so using that you can always extract
 that dependency explicitly and use it in if you want so here's how we do
 this we say log duration is tell and now we can use that that's our logger
 function we can just use a hand hook if we want to we don't have to do
 this because our computations are automatically logged what we might need
 to use it for some in some example so the tail is the usual function that
 people define for the video moona all right so how is it going to be tested
 I'm going to have logger will just print some message how much it took
 nearly seconds and then I'm going to do a run so important I already computed
 this result reader but nothing as jim has run yet this result reader is
 a function from log duration to double this function hasn't been called
 yet I have written the code as if the computation is already done but actually
 it isn't yet done it needs to be run still so units of this kind usually
 have a method called run and so this method takes a log duration and it
 gives me a double and so that's what I have to do at the end and so the
 there is always this printout as we expected it's about 20 seconds about
 50 milliseconds about hundred milliseconds and then there is this extra
 ad hoc computation now just one note here so the usefulness of this technique
 is that you can separate this code from this code you can combine these
 readers with each other you can put result reader here on the right hand
 side a generator line because it has the right type the whatever is on
 the right of the generator line must be of type reader of something as
 long as it's the right type a reader of log duration and something you
 can put it on the right hand side so in this way you can combine several
 values of the reader type income in computation to make a longer computation
 and at the very end once you have done all you need you actually run it
 at the very end when you actually know what logger you need or what context
 you need what dependencies you inject you run it so this is the this is
 the event that you can separate injecting your dependencies from writing
 code it uses the dependencies and this code looks like this dependency
 is invisible here we made it visible because we wanted to illustrate that
 you can but you don't have to if I remove this it's invisible if you have
 this dependency your code doesn't get cluttered with it so that's this
 message a third example is an evil unit which is something that cats library
 implements we will implement a very simple version of it ourselves for
 purposes of illustration the idea here is to perform lazy computations
 in other words computations that are not immediately executed and so in
 order to do that let's define this type so this type is a disjunction is
 either has a value that's already computed or it has a value that will
 be computed once we call this function now this function has a unit argument
 so there is no nothing we are waiting for but we just haven't haven't called
 it yet and so there's no data that we need to receive from someone in order
 to run this function well it's up to us when we want to run it and so that's
 the point of this monad it's either a value that's already been done and
 then so-called it's memoirist in other words if you try to compute it again
 it's already there or it hasn't yet been computed and then it's this is
 a explicit representation of lazy value Scala has built-in lazy values
 but sometimes it's useful to have a more explicit representation so here's
 how it works so let's define a trait which is evil like I said the cats
 library already defines this with slightly different API but I don't want
 to use their evil because I want to show how it works the main function
 that it has is get so yet means get give me the value so evil is a same
 single you monitored it holds inside it a single value of type it so get
 me that value and if that value hasn't been computed yet compute it and
 give it to me otherwise if it's already computed don't give it to me right
 away that's the point of this get and then we have a map and flatmap because
 it's a semi wounded it's actually a full modded of course because it's
 easy to put a into here so pure would be very easy to implement it has
 a disjunction as we have indicated a and 1/2 wave so let's see is this
 one it's called eval now so it's already evaluated now and the second one
 is a function from unit 2 episodes eval later it will be evaluated later
 so to get what's already valued it is trivial to get what will be very
 linear we'll just call that X let's call this actually call us if call
 this ok I don't want to be nameless we just call that function on a unit
 argument and we get what we want implementing the map and flatmap is trivial
 except well except for one thing so for flat map we evaluator but what
 we evolve here we get in other words we don't postpone that evaluation
 anymore we already postponed once so we don't want the postponed twice
 that's the point of flat map so a non flared structure would be that we
 postpone the postponed computation so that's kind of nested postponement
 we've want to flatten it so we want to postpone exactly once and so we
 postpone wait for the unit but once the unit is given that's evaluated
 it was not postponed anymore that's how it works now we can define convenience
 constructor so this is a pillar which just gives you an eval now and you
 can have a constructor for later which gives you an evaluator and it's
 just for convenience see I'm using lazy evaluated argument in the function
 just one little comment here in programming a software engineering community
 these arguments are called by named arguments can't be more wrong than
 calling this I'm not by name they're undervalued and or lazily evaluated
 it's not the name that you pass you pass an unavailing it'ld expression
 that needs to be evaluated you don't have to have a name for it and often
 you don't so they are not by name argument they're an evaluate it or lazy
 evaluated arguments anyway so what do we do let's again use our compute
 helper function that will introduce delays into computations and here however
 we do we can write a for yield block with all sorts of things in it and
 on the right hand side we can either put later of something or not off
 of something so that's how we will use this and this way we'll chain computatio
ns that are postponed and computations that are not postponed so we can
 combine them very easily with very clear organization of the code and the
 result is again eval in so this result is probably postponed and we can
 get it and when we get it it will print things so this is the output not
 you yet so when you create a value of this type it doesn't necessarily
 compute anything and you see this because this message is printed first
 so this message is printed first and only then these two messages are printed
 that we have here so this might be counterintuitive but actually when you
 do this none of this is run yet again this is a kind of Munna that has
 non-standard evaluation strategy it doesn't run immediately when you do
 a for yield it will make these computations postponed you have to run it
 so the run for this model is called get and so that's when these two lines
 will be printed so this could be a little counterintuitive when you work
 with these single single value mu nuts because many of them encapsulate
 non-trivial evaluation strategies reader monitor was at the same kind once
 you do this nothing is that done yet the function is constructed the function
 still has to be called so that's the REM call here it's a gate call and
 that actually runs the moment the first example is continuation unit this
 is not necessarily very clear what it means I prefer to call it a callback
 monad but continuation monad is a standard name for it so I will go into
 detail now but how it works the purpose of this moment is to chain asynchronous
 operations operations that register callbacks so it's managing callbacks
 that's the main use case for this moment there are other use cases one
 of the main use cases is this one so let's look at the code an example
 I will show is using the Java input/output operations on files and using
 asynchronous file operations so these are called asynchronous file channels
 and there are asynchronous in the sense that you start reading the file
 and you need to pass a callback that will be called when it's finished
 reading it so this is asynchronous code in this example is to read a file
 so I created a sample file which is this one which is very short I'm going
 to read it into a buffer I'm going to write the same thing that I just
 read into a different file into this one then I'm going to read that file
 again and compare the results so that I verify that whatever I have in
 this second file is the same as what I had in the first file so to read
 it into a second buffer and assert that the buffers have the same strings
 in them now you see how much code was necessary to get that done all I
 did is to read one file write the contents to another read that contents
 and compare with the first look at how much code I have to write using
 the Java look at look at this nested thing it's a deeply nested combination
 of functions this is a typical problem with asynchronous API is that you
 use callbacks callbacks get nested let's see how he how that works the
 API is like this you make a file channel then you call the read function
 on it which takes a buffer and some parameters just in my case are just
 0 and then it takes a callback now the callback is a new object of type
 or value rather of type completion handler and the completion henry has
 two functions inside one is called when there's a failure and the other
 is called when there is success the file has been read so for the purposes
 of this example I'm not going to handle errors I'm just going to print
 that errors occurred so I'm just going to concentrate on the happy path
 on the success so the callback for success is this not in my code what
 I have to do is I need to well I need to wait until this callback is called
 there's no way to wait for it so the only way I can write my program is
 to write the rest of the program inside this callback so that's how I get
 into a deep nesting so the rest of my program is inside the callback I'm
 closing the channel rewinding the buffer opening another channel and then
 I call the right function on this other channel the right function similarly
 takes the buffer and a completion Handler a new completion Handler with
 its own callbacks the failed callback had print a message a completed callback
 will be called when the second file is written successful there is no way
 for me to find out when that happens so right because I already called
 the right function the right function has finished very quickly and then
 the file has started to be written after the right function has already
 returned there is no way for me to figure out when is completed function
 will be called this callback therefore my entire rest of the program must
 be inside the callback I closed the alpha channel I make another input
 channel I read and with a third callback print message when failed completed
 and the entire rest of my program must be in here so for example I want
 to check that bytes were correctly read and correctly and incorrectly written
 I cannot really pass this information to somebody else outside of this
 callback unless I use local variables global Global mutable variables where
 I I write some information and a semaphore that somebody will have to wait
 for on the thread this is horrible very hard to write such programs or
 I need another callback that I will call here to pass this information
 I could do this if somebody gave me a call back such as report result I
 could put that result into the callback and call it so somebody else will
 then have to continue writing this kind of code that everything is inside
 the callback because of this problem people call this people usually say
 this is callback hell all these callbacks that forced you to write the
 rest of your program inside a deeply nested structure wangus a continuation
 monad manages all this in a much better way so let's rewrite this code
 by using the continuation or not now the type of the continuation monad
 is going to be this it is kind of not clear why this type is useful but
 let's look at this and consider what it is doing this type is a function
 that takes this as an argument now this function itself this is a callback
 this is a typical callback that we had in the completion handler it took
 it takes some result or some in input and returns unit so a function that
 takes data and returns unit that's a typical callback signature so the
 continuation monad is something that consumes a callback it's a consumer
 of a callback that's how we can interpret this type what can I do how what
 does it mean to consume a callback well you can use the combat the only
 way to use the callback is to to run it to give it a value of type a and
 run this function and then whatever it does you don't know but that's what
 you can do you can call it twice if you have several different values a
 you can call it many times or you can omit omit calling it at all if you
 don't get any values of type way so that's what you can do with a callback
 so when you create a value of this type it means you have created code
 that will do something possibly obtain one or more values of type a and
 run this callback on those values that's what the continuation what it
 is doing so creating a value of this type of this continuation type means
 you have created your callback consumer or your callback logic that's why
 it is so useful for situations where you need a lot of callbacks you should
 not use callbacks like I just showed you in this complicated looking code
 you should use the continuation monad here is calm so in our case let's
 come let's define this type constructor the read and write functions for
 the Java and IO need to be adapted to this type so let's create values
 of this type and for convenience we will allocate the buffer inside this
 function so the read will take the channel and return a value of the moolaade
 type so you see the mana type is this type constructor and I will moon
 out of a so we're going to use and I am honored of the pair of bytebuffer
 an integer we can use anything as a type parameter why because the idea
 is that the continuation monad manages callbacks or consumes callbacks
 that will be run on values of type a and so the callback that we had in
 the previous code returned an integer or rather it was called on an integer
 value and so the byte buffer actually is another useful value that we want
 to pass on and so we by using this type we make the API easier to use so
 the callbacks in the Java API only take the result or parameter which is
 a number of bytes read you are supposed to have your byte buffers somewhere
 as global variables it will be much better if they actually took data here
 has arguments and that's what we can easily accomplish so ni or it will
 be a function that returns the Monod type therefore we can use ni or read
 at the right hand side of the generator here's how we do we count as a
 constructor of the continuation which takes remember continuation is this
 type so we need to create a value of this type in other words we need to
 write a function that takes this and returns this so we write a function
 that takes this and it returns unit so this entire thing should return
 unit Handler is going to be this function because we defined it like this
 [Music] so what does it do well we allocate the buffer for the purposes
 of this example I'm cutting all kinds of corners I'm just allocating a
 fixed length buffer for its simplicity and I'm ignoring errors I'm just
 planting that errors happened all of this can be done much better with
 more work so in order to start understanding how to use it we start with
 a simple example so we allocate the buffer then we call the read with this
 buffer and we make a completion you know there is no going around this
 API but we only are going to do it once and it's going to be much easier
 to understand nothing will be invested callbacks so the failed way ignore
 the completed log print something then we do all this rewinding the buffer
 closing the channel and then we call the handler on the data that we obtained
 on the buffer and the number of bytes read so that's the call that will
 return unit remember so the handler is a callback that returns unit we
 can actually rename this for clarity make it call back and so we call this
 callback at the end giving it the results we obtained that is what a value
 of this type can do it can take this callback produce some values of type
 a and call the callback on this value so in our case is just one value
 we're not going to call it ever in case of error we do exactly the same
 thing for the right now the right method needs a buffer and the channel
 has two arguments and it returns them an IO monad of integer so that's
 very similar let's also rename this handler to callback consistency and
 it's exactly the same thing so check close the channel and call the results
 so now let's see how this is going to be used we open the channel to the
 file can then we start writing the for yield or the function block we do
 read the result is a pair of buffer and result then we'll make another
 channel we do a write with this buffer and this channel that's a result
 we make another channel we do a read of that channel into a buffer to err
 is not three when we compute this is identical if the number of bytes the
 same and the string in the buffer is the same after copying and we return
 or yield rather is identical in other words this is a boolean value our
 entire for yield gives us an enablement of boolean so this is a non-standard
 container so none of this actually has been run yet when we do this when
 we make this value none of those operations have been done yet we need
 to run the bonnet in order to run it but how do we run it well the run
 means that we take a value of this type and provided with an argument of
 this type and applied that function to that argument so we need to provide
 a callback of type a to unit where a is boolean because we returned it
 and I have one of the boolean so we need to provide a callback from boolean
 to unit let's provide it so the status is boolean so it's a function from
 Wooyoung to unit so whatever we want we can put in here and then we run
 that's what's going to print and it does print exactly what we want at
 this point now just one little remark here you see declaration is never
 used indeed we never used this value it is returned so to speak but it's
 not used that's just put an underscore here that is the usual way that
 we indicate that there is a value but we don't need it and we put underscore
 over there it's alright so that's how now our code has become flat in a
 sense there is no nested anything there is a bit of there wasn't a here
 because of all these options and so on well you can always refactor that
 to be some function somewhere else but basically you you can combine callbacks
 very easily like this now nothing is so so hard to understand except for
 the type of this thing continuation or not the type of the continuation
 well that is hard to understand have to go through the steps it's a callback
 consumer that will call the call back when the value is available and that's
 what the ROM does and you need to understand that flatmap does the same
 thing so yeah by the way the implementation of flatmap for my continuation
 that's automated that's done by the Curie Harvard library all right let
 me go back to my slides there's a last example which is a statement a statement
 is defined as this type and it's used for doing a sequence of steps that
 update some state along the way so each of these steps is a computation
 that returns some result but also it has a side effect of updating some
 state so recall this idea that single value monads are are containers that
 hold one value and have a context so the context for the state model is
 this state which is a value of type s as a fixed type the type a is a type
 parameter of the container but the state the state value S is a fixed type
 and the context consists of this state and of the fact that you can update
 it as you go so you can change it and this is the type constructor again
 just like continuation it's not easy to understand why it must be like
 this I will talk about this a little later at first let's see how it works
 so one good example of using the state monad is to implement a random number
 generator so a random number generator were more stood more precisely a
 pseudo-random number generator has an internal state that is updated every
 time you ask it for a new random number so it gives you a result which
 is a random number but at the same time it updates its internal state so
 state monad allows you to do that in a pure functional way without any
 mutability and also it has the same advantages as other moments that you
 can combine things much easier so without using the state moment how will
 we do this so imagine that all the functions are already implemented so
 here's how the PCG random is a very little package that I wrote it's has
 an initial state so the state is some values initial default state or you
 can seed it with some other value you want and then it has a function which
 I called in 32 that takes the initial state and returns a pair of some
 value and a new state then you would have to call this function again with
 this new state and get some random value Y and a state as two now you have
 to call it again with s2 and get Z and s 3 and so on so you would have
 to yourself keep track of these s0 here as near here as 1 here as 1 here
 as 3 as 2 here is 2 here and so and if you make a mistake it's very easy
 to make a mistake the types are not going to help you avoid this mistake
 if you here say as instead of this one the type is still the same compiler
 would not the compiler will not notice so that is error-prone and ugly
 the state monad hides this so it hides this as they say threading of the
 state for putting you know keeping track of this new state every time here's
 how so in 32 is a function that takes internal state and returns a tuple
 of internal state an empty out so actually I need to interchange the order
 of these things just for clarity in 32 returns a pair of [Music] internal
 state and a random integer so R&D is going to be the type that is a state
 monad so this is going to be the factor in the factor block orangie and
 here's how we can use it now look at this code the state is magically handled
 all we do is as if we just have a random number function that gets us a
 new integer and this is defined here so it's a constructor of the state
 monad which has this type which was asked to escape and this is exactly
 the type signature of this function s 2 s so this is the result the result
 will be an already of string well you see orangie of in doesn't mean that
 it's a random integer this is a constructor this is a functor the type
 of the value inside the furniture can be anything doesn't have to be random
 the randomness is only in this piece that returns random integers once
 you have those into you can make doubles out of them course and whatever
 you want restraining assaulted them so just to warn you what looked confused
 that somehow this type constructor itself makes everything random inside
 it no it doesn't this is just a statement it it just takes care of the
 state and that's how you use it now you actually have to run I'm using
 the cat's State Mona which has it's only POA has a run so you have to run
 it on initial state and then the result will be something of which you
 need to get a value and then that will be a tuple of state and result so
 you take a second part of the tuple and that's your result so that's the
 API of cats state monad and you do this only once anyway you usually accumulate
 a state value combine them together it's very easy to combine because monads
 are easy to combine you can put a state value on the right-hand side of
 a generative area you have combines them just like we did here so once
 you're ready to run them you perform the run and get all of this done so
 just like the other non-standard containers computing this value does not
 actually run any of these computations it creates a function that will
 run the computations this function still needs to be called and that call
 is usually called as usually run the run method so now we have seen how
 these different non-standard containers are used and in what sense they
 can be interpreted as containers that hold one value together with a context
 or how they perform computations in a context in this slide I will try
 to motivate why these types must be like that you see for the writer maybe
 you understand why it must be like this we need to log some information
 so let's just put this information into this type here but for these especially
 these this is kind of clear you either have a value that's already computed
 or it's postponed these types are far from clear why are they like this
 why do these types embody what they do so here is how I could kind of derive
 or motivate from first principles the choice of these type constructors
 the main principle here is that we want to use flatmap in order to chain
 computations together and so flatmap is the function that's going to be
 transforming some previous values to some next values in this chain of
 computations so let's apply this reasoning and see what is the signal type
 signature of flatmap and just by type reasoning we will derive the correct
 types start with the writer monad so the this computation and there's some
 information about it the code we would write would be that first we have
 some value of type a would say some X of type a and we transform it into
 some f of X of type B so that's our computation that goes from A to B at
 the same time we compute some login information of type W using the X so
 what we have here in other words is a pair of functions one from A to B
 and one from a to W that is the kind of single step computation that we
 want to chain together so these are the things that we want to change our
 flat map should take this as its argument because our principle is that
 we want to make it into a chain of flat Maps so in other words this type
 must be the type of the argument of flat map but we know that flat map
 has a type signature which looks like this from a to writer B right so
 in other word more precisely the argument of flat map has this type the
 flat map has an argument of this type and it returns a writing B it has
 an argument of type writer a an argument of this type and it returns Rho
 B so writer a yes we already have writer a always as the first argument
 so in other words this type must be the same as this if that is so we would
 be able to use flat map to chain computations what is the type writer be
 so that this type is equivalent to this one in order to decide type equivalence
 we need to use the arithmetic very hard correspondence as I called it in
 this correspondence the function types corresponds to miracle powers so
 A to B corresponds to B to the power a a to W corresponds to table to the
 power a and product is product now using school level algebra we can simplify
 this and we say it's like this it's the identity and by the arithmetic
 correspondence this is also the type equivalence and so this is a type
 from a to product of BW and so from a to product of BW hence writer B must
 be productive BW so in this way we derived what the type of writer must
 be let's apply the same reasoning to the other units the reader for example
 we want to read only context or environment of type B so what is an elementary
 step in the computation we have some X of type a and we compute some value
 of type B but we can use this R which is the read-only environment of type
 e in other words our type of the elementary step on the computation is
 this we repeat the same reason if we want to chain these computations using
 flatmap it means that the argument of flatmap must be of this type but
 the argument of flatmap is of this type in order to do that we must have
 that these types are equivalent this can be done when reader is the function
 it to be again we use the arithmetic very hard correspondence this type
 is B to the power of product AE so this is just algebraic notation in a
 usual arithmetic I shouldn't say algebraic arithmetic notation this is
 just B to the power of a times e which represents this type and what we
 want is that this is something to the power a and so this is B to the e
 to the power a therefore we have the type e B so again a function type
 e to B is represented as B to the power E with reversing the order of this
 that is how the arithmetic Harvard correspondence works for function types
 I discussed this in the third chapter of the functional programming tutorial
 look at the continuation what not now the continuation monad or a call
 back unit if you wish it's a computation that registers a call back that
 will be called asynchronously asynchronously means it will be cold later
 at some later time or maybe not at all or maybe once or more than once
 what is the computation of this kind we take an X of type a and we call
 some function on the call back so what does it mean to register a callback
 we need to prepare some callback and pass it to somebody now this is the
 somebody who will take our callback and they will return a unit usually
 I mean they're not going to call the callback right away anyway so that
 so this function of registering the callback normally returns a unit well
 it could return a different type let's say indicating some error in registering
 the callback but let's suppose for simplicity it returns unit so the callback
 is of this type because usually callbacks also return unit so what is the
 type of this elementary step the type is this it's from a to a function
 f that takes a callback and returns unit so if this function head type
 eight account B we would be able to use it in a flat map well this is clear
 can be must be this and we can generalize this to return a non unit result
 type in case that this should return some kind of result may be error messages
 or something else a callback could return more information than just unit
 so maybe there's some error maybe some other other information so usually
 the continuation mullet therefore is defined as this type where ere R where
 R is a fixed result type finally let's look at the state monad state monad
 is a computation that can update the state while producing a result so
 what does it mean such a computation looks like this first we take some
 X of type a we take the previous state of type s and we produce some new
 value of type B using those two at the same time we produce a new value
 of type s from the previous [Music] from the previous state so we at the
 same time change the state and we compute a new value and while we are
 computing a new value we can use the old state and while we're changing
 the state we can use the value X that was given to us therefore the type
 of the elementary computation step is actually this it's a pair of two
 functions from a and s to B and from a and s to s so the first function
 computes a new result and the second function computes a new state value
 we now we repeat the same argument this type must be the type of the argument
 of flatmap in other words so what is state B if this type must be equivalent
 to this let's make a computation we again use the Curie Howard correspondence
 this type corresponds to this expression we wanted to be something to the
 power a in order to reduce it to this form so we transform it like this
 something to the power a and we can also simplify it like this something
 to the power in translating back to types it means that this type is equivalent
 to this in other words a going to this or more simply this so state B is
 the type that must be this so we have derived the type constructors for
 the monads from first principles just the principle was we have some elementary
 step of computation that deals with some kind of context together with
 a new value and we want this elementary step of the computation to be usable
 under flatmap in other words the type of this elementary step of the computatio
n must be of the kind a to FB where F is the function that is the type of
 the argument of want map so systematically we demanded that the type was
 of that kind and that allowed us straightforwardly to derive the types
 of these moments you need to get used to these moments in order to be proficien
t with them but I hope that this derivation kind of lifts the veil of mystery
 from the question of why are the types of that's chosen like this and what
 is this context and they manipulate here are some exercises for you to
 get more familiar with using walnuts and to implement simple examples using
 set sequence future lists or try and state units as well as implementing
 semi modded instances which means simply implementing flatmap for certain
 type instructors that concludes part 1 of chapter 7 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Laws and structure
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
this is part two of chapter seven in part one we have looked at several
 examples of Mona's and we found that generalizing the monad type signature
 led to very different types there are different properties of containers
 some of them expressed iteration other expressed failures recovery from
 flavors evaluation strategies and soon in this part I will talk in more
 detail about the laws and structure of these containers of these types
 and we will see why is it that flatmap type signature which is kind of
 a little strange and bizarre maybe at first sight gives rise to such a
 generalization we'll see that the properties of Mona's are completely logically
 the derived from the properties that the computations must have so let
 us think back to our examples of Thunder block programs and let's for simplicit
y consider that we are talking about the container such as list where the
 functor block let's say of this kind expresses iteration over a list so
 we have been here for example in nested iteration of some sort what will
 be the properties of counter block programs that we expect to have the
 main intuition is that when we write a line like this with the left arrow
 which is in scala called a generator we expect that in the later lines
 the value of x will go over items that are held in the container see this
 is our main intuition so in particular we expect that if we first say that
 X goes over items in container 1 and then we make some transformation of
 that X let's say using a function f then we expect and then we continue
 with that in some other way with some other generator we expect that the
 result will be the same as if we first transformed container 1 and replaced
 all its items by the transformed items by the f of X and then continued
 so so in other words we expect that this code and whatever follows it should
 be equivalent to this code and whatever follows it now if you remember
 the main intuition behind how to interpret the generator lines each generator
 line together with all the code that follows it defines a new container
 which would be a result of some flat map call so let's write down what
 that flat map call is for the left it has count 1 flat map and then X goes
 to cone 2 of f of X because Y is just a replacement of f of X on the right
 hand side we first apply a map on the cont 1 and then we do a flat map
 with y going to constitute of Y so if the code on the left is to be equal
 to the code on the right in all situations it means that we have this code
 should produce the same result as this code so that is an equation that
 we expect flat map to satisfy so flat map together with map must satisfy
 this equation the same situation should happen if we first have some generator
 and then we perform the same thing so in this example we first manipulated
 items and then we did another generator here we first do some generator
 and then we manipulate items it should be the same result that gives a
 rise to this law which is that first container flat map of this should
 be the same as the first container flat map of all this so that's the second
 law that we expect to hold it is necessary to do these two laws because
 the way that the lines are translated into flat maps is linear so it's
 the first line and then the second line and the third line and so if you
 have this construction replaced by this after a generator and that's a
 different code then if it were before January this these things cannot
 be interchanged especially since this could depend on X and so X is only
 available after this line so we could not possibly put this line after
 these two and so most in most cases but you cannot interchange lines in
 a functor block without changing the results so that's why we needed to
 have these two situations when the replacement is preceded by a generator
 and when the replacement is followed by a generator finally we expect another
 thing which is that we expect to be able to refactor programs so a for
 yield blog or a functor block as I call it returns a container value and
 this container value could be put on the right-hand side of another for
 yield blocks generator line we expect that this should not change the meaning
 if we in line caught the contents of that four yield block so here's an
 example on the Left we have a free Oh block with three generator lines
 on the right we put these two first lines into a four yield of their own
 the result of that four yield is a another container and we put that container
 in the right hand side of a generator line and we continue like this so
 this is I just call this YY for simplicity yes it's exactly the same as
 this Y except the two lines here are in line here they're hearing a separate
 for um block so we expect this to always give the same result as that if
 that were not true would be very hard to reason about such programs if
 you in line things in programs and have gives you different results that's
 a bug usually it would be very hard to find languages where this happens
 are broken and shouldn't be used if they have better choices so now we
 therefore require that this law should hold so if you in line things then
 results should be the same and if you express this in code then you see
 here on the left you have called a flat map of P and then flat map of contour
 on the right you have firstly have a con flat map of P which gives you
 this and then you get flat map of come to so you see this second flat map
 is inside the first flat map as it should be in the filter block but the
 in this case it's not inside as you first do the flat map is a separate
 for you block and then we do another regenerating life so in this way we
 have these three laws now if we write these laws in this way that's in
 principle sufficient to check those laws for specific examples I just need
 to write code and transform code we would like to be able to reason about
 these laws in a more concise and elegant way we like to understand what
 these laws mean in a different way so that we can conceptualize them because
 right now it's just some complicated chunk of code should be able to give
 the same result as some another complicated chunk of code and it's not
 I'm just not clear what will it mean it's not easy to understand these
 laws like this so we're going to rewrite them in an equivalent way using
 a different notation so first of all we introduce notation which is flm
 which is kind of flat map with arguments reversed similar to what we did
 with f map where we put in a function argument first and then the monad
 type argument second whereas the flat map usually as this argument first
 in this argument second so for convenience we do that and that turns out
 to be much much similar to F map it's a kind of lifting so you lift this
 kind of function into this kind of function we will exploit very much this
 property and therefore FLM is a more convenient type signature for reasoning
 about the properties over semi monad I remind you that a semi monad is
 a monad without the pure method so semi monads just have flat map and you
 can define flattened in terms of flat map but that's it we do not have
 the pure method in semi monads and a full monads additionally must have
 the pure method so right now we start with semi monads so in other words
 we only talk about flat map and its properties which are summarized here
 later we will talk about pure and its properties so in what follows I will
 fix the factor s the semi Morland and I will not explicitly put that s
 as a type parameter anywhere so we F map will be with respect to the factor
 s and F Alam will be with respect to the founder s so let's write down
 these three laws in this notation and if you look at this I'm just going
 to translate this code into that notation you'll see it becomes more concise
 and then we look at types and we will be able to reason about it much easier
 so for example this is a composition of two functions we first apply f
 when we applied comes to so this is a flat map of a composition whereas
 here it's a map followed by flat map so it's a composition of map and flatmap
 sir here's this law flat map of a composition is equal to a composition
 of map and flatmap so this is now I wrote out the types of the functions
 F and G and here's a type diagram for this equation I remind you that the
 type diagrams are just a fancy way of writing equations more verbally with
 more detail and more visually so here the left-hand side is a function
 on the right-hand side of the function and these functions go from here
 to here so si is the initial type as C is the final type and the first
 function is a composition of F map and f LM and the second function is
 a nephilim over composition so if you go from here to here whether you
 go under upper route or the lower route you get the equal results that
 is the meaning of this diagram in mathematics this is called a commutative
 diagram meaning that this path and these paths can be commuted they can
 be in touch with no changes in results I will not call them commutative
 diagram because it's to me this is confusing what is what are we committing
 all the time it's just a type diagram for us that shows us very clearly
 what the types are and what the functions are between each pair of types
 and what are the intermediate types when we do a composition of functions
 and there's some intermediate result and I remind you also that my notation
 is such that this composition goes from left to right so we first apply
 this function to some value and then to forget the result this is this
 intermediate result of this type and when we applied that function to that
 guzol we get the final result so in this way it's easier to read the type
 diagrams so they follow the same order first F map Jennifer land from Steph
 map then f LM in many mathematics books this notation is used in other
 books it's used the opposite way where you first apply the function on
 the right and let me apply the function at the left of the composition
 now I write now I feel that this not convention is more visual there of
 course completely equivalent in terms of what you can compute with those
 notations and in terms of how easy it is to compute but this is a little
 more visual first you do this then we do that in Scala you have the operation
 called end then which is exactly the symbol that I'm using and also you
 have the operation called compose on functions which is in the opposite
 order so it's up to you what you want to use in star alright so now I have
 rewritten all these three laws in terms of this short notation now this
 here for example is flat map followed by map is equal to flat map of a
 map sorry of constitute followed by map so it is flat map followed by map
 is far or composition or something followed by a new app and the last one
 is flat map of something followed by flat map is flat map followed by flat
 map so that's flat my about something called by flat map is flat map followed
 by flat map and so these are the types so all these types go basically
 from si to SB 2 s C where a B and C are arbitrary types and then you get
 the equations by either going the upper route or going a lower route I
 also wrote the names of these laws which are just for illustration purposes
 and to kind of give you a way of remembering these laws the first two laws
 are naturality so what does it mean naturality well naturality means that
 there's a natural transformation going on somewhere between the two factors
 and in terms of equation a naturality law means that you have F map maybe
 on the left hand side or on the right hand side and you pull it out of
 that side and put it on the other side for example here F is f is under
 FL m and here F is before phones are pulled out the F out of fom but now
 I have to use EFT map on it after I pull it out so that's a typical thing
 for nationality you have a function that you pull out and then sometimes
 we use F map on it after you pull down sometimes before so here's another
 naturality so why is it naturally an a well it's because the function f
 so that pull out transforms the type a into B and here the function G that
 I pull out says forms a Type B into C and so flat map it goes always a
 to s of B it has to type Traverse a and B and the naturality should be
 in both of these type parameters so flatmap can be seen as a natural transforma
tion in two ways in both of these parameters and so that's why we have two
 naturality laws the third law is associative 'ti and it's not obvious why
 that is cold like that and we will see that much easier in later Oregon
 this tutorial but basically if you just look at this equation you see this
 is a kind of a law for composition of flat maps what happens when you compose
 two flat maps you can put one of the flat maps inside it's the same result
 so now this is much better than the previous formulation with code it is
 much shorter and you see the types goats always from a satyr as beta SC
 but still these laws are kind of complicated so there's this F map here
 you have to remember there's no F map here this is a bit a bit complicated
 so let's find out if there is a better and shorter formulation of these
 laws and remember what we did in the previous chapter when we talked about
 the filter rules we found a better formulation in that we factored out
 the flat that the F map out of some function we got an easier function
 which we called deflate back then so let's do the same thing here this
 functionally called flatten which I denote in the short notation as f TM
 and this function is standard in Scala understand the library is called
 flatten which is basically flat map on identity if you consider identity
 function of type as a to SMA then you can imagine that SAS is some other
 type C and so basically you have a function from C to sa you can do a flat
 map on it and you get a function from s ce2 s a and C is s to a so I put
 that brand on here and the result is a function from s of s of a to SMA
 and you can also define flat map out of flatten by prepending it with with
 a map with map so this is a diagram it shows their relationship so if you
 have an essay you can s map it with a function it was B you get an SS B
 then you flatten it to s B and that's the same as a flat map so that's
 a well-known equivalence but flat map is basically a map followed by flatten
 and that's a scholar convention for naming this function sir that flat
 map is basically flat a flatten that is applied to a result of a map and
 this is the type diagram that shows how that works so that the map from
 a to s be will replace this a by s beat the result will be s of s would
 be and then you flatten went back to SP so just like we found in the previous
 chapter on filterable it turns out that this function flatten has fewer
 laws than flat map it has only two laws its type signature is also simpler
 it has fewer type parameters and it's a shorter type signature so it turns
 out that this is a easiest way to reason about semi monent laws that is
 to consider flatten not to consider flat map to your flat instead so what
 are the two laws of flat the first law turns out to be this which is double
 F map of a function f and then flatten gives you a flattened followed by
 an F map of function f so that's naturally so naturality here is much easier
 it's just commuting flattened with a function so here you have that function
 on the left hand side the flattened here's on the right hand side of flatten
 and they need an extra F map on that it's important to have two F maps
 here on the one here you kind of just replace this with an arbitrary function
 G for example this you cannot replace this with an arbitrary G and have
 an F map of G in the red right on the left hand side here that law does
 not hold it's it's mean it's incorrect so the type diagram for this law
 is like this so you start with s of SMA you do a double flat map sorry
 you do a double map double F map of a function f which goes a to b so then
 you get a survey survey into SMS of B after the double map then you flatten
 that into s B or you directly flatten first a survey survey into a survey
 and then you just have a single AF map of A to B and you get a survey to
 assume D so those must be identically equal now just one more comment about
 notation I'm using here the short notation where I say for example F map
 F with a space F map space F I don't right parenthesis here I do that for
 functions of one argument and when when things are short here I don't I
 say F map of F map of F because this is not short this is a longer expression
 and be harder to read that's my notation so it's exactly equivalent to
 putting parentheses around this F around this F here it's shorter to read
 this so this is similar to the mathematical notation where you write cosine
 of X without parentheses you read cosine X cosine 2x sometimes without
 parentheses just shorter the same thing the second law now looks like this
 F map of flattened followed by flatten is flatten followed by flapping
 except that there is first flatten is a different type parameter as it's
 applied to a survey survey so let's look at the type diagram for this law
 both sides of this law applied to a value of this type which is kind of
 ridiculous but that's what it is it's a triple application of the factor
 s and you can flatten it into a single application and you can flatten
 it in two ways first the upper path in this diagram you f map of flatten
 which means that you flatten this into si and you f map the result so that
 you get flattened as a resume and then you flatten again the second way
 of flattening is to pretend that this type is some B so this is just a
 service of B you flatten that you get s of B now B is s of a but you just
 apply the same code for flatten to a different type parameter parameter
 s of a instead of parameter a and then you get again a service of a and
 then they flatten it again so the result must be the same of going up or
 going down now it's important that all so that we flatten twice these two
 are not going to be equal after the first step only after the second step
 they're going to because we'll see that on an example so why is this called
 associativity well this is a little easier to understand now why so look
 at this triple-s implication we can flatten it first by flattening the
 inner pair of s and then flattening the result or we can flatten it by
 first fighting the outer pair of s which is going this way and then flattening
 the result so this is like a subjectivity first we do we have three things
 we can first group two of them together and then group the result and the
 other thing together and that's two ways of doing that and so in mathematics
 and social division law is usually of that kind you have three things you
 can pair the first to combine them and you get the result and you can prepare
 that with a third one or you pair the last two combine them get the result
 and pair with the first one and that if if the two results are the same
 regardless of would you pair first that's a social tippity law that's the
 mathematical intuition so now it's a little easier to see why this is called
 associativity but the equation for this law does not look like a social
 ticket it doesn't look like there are three things that we're appearing
 together so that still maybe not great we'll see a different formulation
 of the law where it is completely obvious that that's associative 'ti and
 it looks like a socially routine but now we already see that it's getting
 there with this pairing of the functor layers now a little aside here we
 found that the functions F alone flat map and flatten are equivalent does
 it mean equivalent if you have one of them you can define the other if
 you have the other you have can define the first one but not only that
 but these definitions are equivalent if you take the first if you somebody
 gives you a definition of the first you define a second one and then you
 define again the first one through that second one you should get again
 the same function that you were given so that's full equivalence and we
 have seen this kind of equivalence like this in Chapter six when we looked
 at deflate and F map opt they were equivalent in a similar way deflate
 was F map of identity F map opt was F map followed by the flight it's exactly
 the same thing here with flatten and F and flat map so naturally I asked
 myself is there some general pattern where this kind of situation happens
 in two functions are equivalent yes there is it better it's a little difficult
 to see maybe right away but there is an obvious pattern in the end so here's
 the pattern suppose you have a natural transformation between two functors
 F of G of a and F of a that's how it must be sorry this is a complexity
 here F of G of a goes to F of a that's the entire complexity that needs
 to be understood before you go through this this example so you assume
 the two factors F and G and there's a natural transformation of this kind
 so [Music] TR is the transformation of this kind now we define F TR which
 is this type signature some sounds familiar right it's not quite so it's
 not quite it's a different filter here than here so it's not the flat now
 but it's quite similar that's the pattern so how do we define this f TR
 we first do an F map of F so f is this when we do an F map we get an F
 so we start with F of a we do have if map of F we get an F of G of B and
 then we apply the transformation TR which goes from F of G of B to F of
 B and then that's how we get F of B now it follows obviously that this
 TR is f TR of identity so if you put identity here instead of F then F
 map of identity is again identity so it's identity followed by TR that's
 TR so that kind of thing is immediate what is less obvious is that TR and
 f TR are equivalent not just TR can be defined from FDR but FDR is defined
 from TR and these two definitions are equivalent here's the type diagram
 we start from F a we do an F map with a function f from A to G B we get
 an F G B and we transform that with TR into FB we assume that this is given
 this this is a transformation that is available and the other way is to
 do F G R of F and that should be the same so that's a definition you can
 see that as a definition of F G are given TR or a definition of TR even
 f TR because you can put identity here and there are two interesting things
 that follow in this construction first interesting thing is that there
 is an automatic law for FDR that follows from the definition of FDR through
 TR so the naturality in a for FDR follows automatically and here's how
 it falls with an F map of G and FDR then you substitute the definition
 of FDR so then we get this then you have the F map composition law so you
 get this and then this is again a definition of fgr in terms of TR so you
 give this so that is a natural T law that pulls out G out of f TR and puts
 it in light left-hand side with an F map and this law automatically follows
 from the definition of FDR's root here and that's why TR has 100 fewer
 than FDR that's why we had flattened has two laws and flatmap has three
 laws same thing was with deflate and f map opted deflate has fewer laws
 one fewer laws then F my pooped for this reason because one law automatically
 follows from the definition and the second funny thing that follows is
 that they're always accruing these functions they don't this proof we can
 do a proof of their equivalents and the proof is for any F and G so this
 will be the same proof for deflate and I've mapped as for F a lemon of
 T M I believe in Chapter six I did not go through this proof I just told
 you that deflate can be defined from a flap opt and asthma pooped can be
 defined from the fly but I did not prove that these definitions are equivalent
 and it could be that they are not equivalent without proof we don't know
 that and the way that they couldn't be not equivalent is that somebody
 gives you a t flight you define a left may opt out of it then you define
 a deflate out of sorry sorry it's here somebody gives you a deflate you
 define define f map opt out of it and then you use that F map opt define
 another D flight here and that second deflate could be different from the
 first one and if that were so these definitions are not equivalent would
 be not equal so this is not so these definitions are always equal so how
 do you do that well the equivalents must be demonstrated into both directions
 so in one direction is obvious because it's just identity you substitute
 identity and that gives you the same function back in the other direction
 is less obvious you start with an arbitrary FTR that already satisfies
 this law the naturality in a look at the type signature and fti it has
 two type parameters a and B so it has naturally low in a and that relative
 low and B so what happens when you first transform a that's not reality
 in a what happens when you transform B that's not relevant B so you have
 to assume that you're given some FTR with this type signature that already
 satisfies the naturality in a if that so you can define TR of it by substitutin
g an identity and then you define again another of TR by using that TR you
 just defined so you want to verify that that FG r is equal to your previous
 one that was given to you here how do you fara Phi this well you take F
 map F followed by TR substitute the definition of TR then you have your
 natural it in low right here what you use you get f TR of G followed by
 evidence and that's FD R of F followed by identity identity disappears
 even FD R of F so that's why you're very that's how you verify the squiggles
 so we have shown at once with one proof we have shown equivalence of deflating
 as my popped and equivalence of flatten and flat map because they're just
 particular case of the same construction with different F and G if you
 look at the type signatures then it's clear clearly self now let's actually
 derive the laws for flat I have shown you the laws I have not derived them
 showing you these two laws per flat and I have not derived them yet so
 I will derive them now to make the derivation quicker I will have this
 notation instead of F map I'll put an up arrow now the up arrow reminds
 you that it's lifted into the functor so instead of Q a function of A to
 B you have a lifted Q which is a function from s a to s B so using this
 notation I'm just going to write shorter acquaintance other than that it's
 just F map and same properties flat map is defined like this let's substitute
 that into the three laws of flat map so the first law of flat map is like
 this second was like mysteries like this now I'm not going to write any
 types in these equations because we know that the types match and everything
 we substitute has matching types so we don't need to check that every time
 the types match so for example here I was writing these equations I wrote
 types in certain places so f is it to be for example I wrote types in full
 in these diagrams so once we have verified that the types match we don't
 need to keep writing these types we know they match so f is a to B let's
 just not right a to be here anymore f is a to B G cannot be just B to C
 because it's under flat map so G must be some b-2s C right so where is
 this law here G must be of type B 2 SC otherwise flat map doesn't have
 the right type of its argument so that is check to check this once we don't
 have to keep writing these types and it will be just shorter if we don't
 we believe now that types are correct initially and if they're correct
 initially whatever we substitute the types are continuing going to continue
 to be correct and so that's just going to save us time reading equations
 but in principle you should understand that these are specific types of
 example F here must be a to B and G here must be of type B going to SC
 otherwise it just doesn't work and similarly here so here this is lifted
 G so this is some s B 2 SC already and because of that F must be going
 to SB from something from a let's say a to SB so all these are implicitly
 the same as here and so I'm not going to repeat the types ok first law
 we take this we substitute a definition of F L M into both sides on the
 left it will be FG lifted followed by flatten on the right will be F lifted
 G lifted followed by flatten clearly this is always holding because of
 lifting is an F map and that preserves function composition second law
 substitute the definition of f LM and we have this so now if you think
 about the functional composition here then the lifting which is F map will
 preserve function compositions are all being F lifted followed by G double
 lifted and there was enough lifted on the left here as well so we can get
 rid of this F lifted because the SLO should hold for any F so we could
 for example substitute F equals identity into both sides and I will just
 F will just disappear I've lived in his disappearance the result will be
 this G double lifted followed by flatten is flat and followed by G lifted
 so that is the naturality law for flatten which we had here F method of
 G f SS 'td : back flatten is flat and followed by s waisted so that's naturalit
y so the first law was holding automatically that's the same thing that
 we found in general construction one fewer laws for fun the third law now
 the associativity law again we substitute the definition and we get this
 so flatten is this lifted followed by flat so this would be this F lifted
 G double lifted flatten lifted followed by slide on the right hand side
 will be F lifted flattened G lifted flattened so again we we find we can
 use the neutrality here so flatten followed by G lifted is here we replace
 it by this and so we get F lifted G double lift it flatten flatten and
 flip the G double if that is on the left it's a common factor we can just
 omit it or substitute both F and G identity for simplicity but it's clear
 why we can do this it's just a common factor on the two sides of the equation
 and the result will be flattened lifted followed by flattened equals flatten
 followed by flatten so that's the associativity law so that's how we can
 derive this law and because of this general construction are explained
 here once you start with flatten in the define flat map then the extra
 law will be holding automatically so in it's very similar way we're also
 going to we can also derive the laws backs if you assume that somebody
 gives you a flatten that satisfies these two laws then we can derive the
 laws for fom which is basically the same calculation except you see here
 the F and G are arbitrating so you can have to start from here and go back
 to this in the same way these are all equations and they are equal in both
 both directions we have been careful and we do not lose generality so in
 this way I have shown that flatten laws are equivalent to flat map laws
 but flatten has a simpler type signature and the fewest laws so when we
 check laws for monads and semicolons I will use flatten laws rather than
 flat map it's quicker even though flatten has this complicated Esteves
 of s of any type in its laws but even that complication is offset by the
 simplicity in in other places and there are fewer laws naturality is usually
 easy to check and the reason is that if the code of the function is pure
 it has no side effects and it is fully parametric so that it has no specific
 reference to a type other than the tag parameter so their only arguments
 that are type parameters and the only operations we use are those that
 are compatible with arbitrary types as type parameters if so it said what
 I call it fully metric code and then there is a periodicity theorem which
 says that if you have a function of this type with a tag parameter a and
 F and G being factors then this function code if this functions code is
 fully parametric and pure then this function implements of natural transformati
on what's the theorem I'm not going to prove that here but that's something
 we will use for basically not checking any naturality if it's obvious that
 the functions code is fully parametric has no side effects and does not
 refer to any specific type so for example doesn't match on type rather
 a being integer and then does something special none of that is permitted
 in fully parametric code checking associativity means a lot more work for
 monads it's a complicated law and that's not easy to check so I will show
 in detail how to do that on a number of examples as a as a remark so I've
 been talking about silly monads the catch library has a flat map typeclass
 which has a flatten method defined by a flat map but that type was in in
 the cache library also has another method called tail rec M which is the
 recursive modown method and that method is out of place at this point it's
 it's different more complicated method and not all walnuts have that and
 I'm not going to use the flat map typeclass from the cats library because
 of this but I can't define it without defining this extra method that's
 really out of place I believe that the scholars new library has also type
 glass like this with no such extra methods so good of you scholars the
 scholars in star classes but actually I will just define my own standing
 water plant class it's just not hard and not a lot of work so now let's
 go and check the code to see how we verify of that laws hold for the standard
 walnut so go through the list of standard units will implement the flatten
 for each of these the code implementing flat o is going to be fully parametric
 type parameters so there's only one type parameter in the flatten type
 signature its SOS so very going to isolate and so we're not going to check
 naturality it's it's going to be automatic but the social DVD has to be
 checked so after we check all this I will show you why certain examples
 are not fully correct they're incorrect implementations of flatten and
 that's that would be useful for you to understand that these laws actually
 are not arbitrate they express what it means for Lunada to do the computation
 we wanted to do to remind zero started all the way from what we want these
 programs to be like and these programs need to have certain properties
 if they don't have these properties which can happen if we don't implement
 the functions correctly mr.
 in cases then the programs written using those types will have very difficult
 to find bugs and that's a very bad situation that we can avoid so let's
 go into the code now we start with the option bow nod and the option monad
 has the flatten function so I'm just going to be writing out Scala code
 for all of this this is an obvious implementation of flat if the option
 is empty we have to return empty there's nothing else for us to return
 if it's not empty then there's an option inside we return that optional
 as there is not we also need a functor instance for this because we are
 going to use F map to check the law so the functor instance of course Scala
 library has flattened and map defined already on the option type but I
 want to write out this code explicitly so that we can check the law explicitly
 so there's this code if it's not then it's not if it's something we substitute
 the function instead of the value and curl F optional is an action of all
 witnesses of type a so I should not remain this into a perhaps clarity
 alright so now that we have this let's start the verifying the law how
 do we verify the law the law here's well morality we don't need to verify
 we verified this law associativity to verify this law we need to compute
 the left-hand side and the right-hand side and we need to compute them
 symbolically in other words we write code for the function that computes
 this we write code for the punch it appears that compare these two pieces
 of code and show that they are identical code so this is not right running
 a test with numbers sorry you know numerical check or arbitrary strings
 random strangers anything like this this is actual symbolic proof that
 these are identical functions symbolically and in order to go through that
 proof we need to compute for example this the F map of flatten as symbolic
 code then we will compute the as map of flattened followed by flatten again
 as symbolic codes what's go and see how that works so first let's compute
 F map of flatten so we have asked my up here we can flatten here let's
 combine them compose these functions so how do we do that well we say we
 first write the code of F map which is this let me write that in a car
 in a comment perhaps so that it's easy to see why that is like that so
 first I start with this code this is a code of ethnic now instead of a
 function f I needed to put FTM now what does f TM f TM is this code is
 so f TN of a is a match of this so that is the code that I'd see here so
 that's how it is that's how it was the same code except I write X here
 and sort of a so all right so now that's less less less code so now let's
 compute this thing which is the right-hand side of the associativity law
 how do we compute that we write the code of FGM applied to the type parameter
 F of 8 well that is not going to change the code of the code the vestian
 is generic it works for any age so we don't need to change the code before
 we need to change is to change the type parameter so this is going to be
 just instead of optional a this is going to be optional optional a and
 so there's going to be some different type the code remains the same we
 can put X instead of oh it's just the same code okay so this is this is
 flattened now we need to apply another flattened to the result of this
 now the result of this has two pieces there is this result and there is
 this result so let's apply this a flattened to each of the cases so this
 is going to be flattened of none this is going to be flattened of X so
 now we need to substitute the definition of flatten into here see what
 we're doing here is we pretend that we are the compiler and we symbolically
 write code that the program are specified by in lining functions we're
 just substituting definitions of functions where they are used so flatten
 is like this and so none goes to none and some of away he goes - away therefore
 none goes to none so this is none FTN of none is none an FTM of X is so
 let's call as X so this is going to be X match and then this code so that's
 why ft and of X is this so that's why we write that code so now we have
 FGM followed by left in the same way we compute ft/s map of FTM followed
 by f teen where none is still none and then I still have this we have this
 code so now we compare the code for this and the code for this and we see
 it's exactly the same code the types are the same but leave the types must
 be the same because that's one team but the code is actually same if we
 were named variables you know I renamed some variables X instead of Kawai
 whatever that doesn't change the code so after in naming variables we have
 exactly the same code therefore the law codes so that's how we check the
 law for the option not well so far we checked only semi mana so we check
 the associativity the next example is either gonna which is defined like
 this is some type Z which is fixed and the type A and the flatten has this
 type signature so in a Scala syntax flatten would have this type signature
 either of Z either of Z equal to either now we could do exactly the same
 thing we will will write down flatten write down F map then compute symbolicall
y a flap of flatten by substituting in computing symbolically this substituting
 in computing that and compare the code we got exactly the same code but
 now you're free to look at this computation and follow it in an example
 code but actually for either there is an easier way out you can check associati
vity with very little work and the reason is that the type signature of
 F map and F we have slather followed by flower and of this the type signatures
 actually misses one mistake it's miss Z plus Z plus Z was going to zero
 said right so Z plus a is just my short type notation for either of Z a
 now it turns out if you look at the curly Howard correspondence and try
 to give derive the implementation of a function of this type it turns out
 that this type signature only has one implementation it has only one implementa
tion which which is because either you have a Z in one of these positions
 in one of these parts of the disjunctions or you have a name have a Z there's
 only one thing you can return you can we must return the left part of the
 disjunction with a Z until heavenly you must return the right part of the
 disjunction with a knife there's nothing you can do other than that so
 there's only one implementation of a function of this type as long as you
 use peer functions that are fully parametric of course and that's where
 curry how it responds is valid only for those functions so therefore there
 must be exactly the same code for this function and for this function we
 don't have to prove that they are equivalent there's only one way to implement
 anything here so this one that can be implemented completely automatically
 from the type signature and no law needs to be checked in terms of associativit
y law doesn't need to be checked because there's only one implementation
 so that's a shortcut if you don't want to take this shortcut look at this
 code is done exactly the same way as we did for the option so I will not
 go into this huge detail the next example is the list monad now the list
 monad has a kind of a more difficult definition because it concatenates
 lists so we know in the Scala standard library the list flatten method
 is defined which just in cabinets nested lists into one nested list so
 it works like this you have you have a list of lists like this so all the
 nested lists are just concatenated together and one flat list is returned
 that's how flatten works so let's now show symbolically that the flatten
 defined in this way satisfies associative so we're just going to to do
 that so how did you probably show that I'm not going to write code it's
 possible certainly to prove this using code but it's much more cumbersome
 and it doesn't really give us a lot of new insight gives us it's obvious
 enough how it works so here it is so f map of flattened would take a list
 of lists of lists of it so here's a list of lists of wisdom I have X 1
 1 X 1 2 1 1 1 1 y 1 2 and so on so this is the first nested thing this
 is the second mr.thang another more maybe of those and what it does is that
 it flattens the inner ones because we're were lifting the flatten which
 means that the outer layer remains the same but we're operating on the
 inner layer so we're gluing together these and the result would be a list
 like this and then when we flatten that we get the same result as when
 we first flattened the outer layers and then flatten the inner layers so
 that is obvious because flattening basically says if you have a nested
 list of any depths you don't care about the depths you just erase all the
 brackets in between and just erase all of this and you get one big list
 with all the elements that you ever have in this order together and of
 course this doesn't depend on the order in which you erase brackets and
 that's why associativity holds so we can first flatten the inner two nested
 lists or we can flatten first the other two nested lists are going to be
 the same thing so flattened as applied to the type parameter list way means
 that the inner list of a remains untouched we just flatten the outer layers
 so we have as a result a list a flat list of all the inner lists the result
 is going to be the same so here I have some numerical tests to illustrate
 this so I made this list of lists of lists and if I flattened it first
 like this I get this and I flatten flatten I get this if I first a map
 flatten then I have this list which is first concatenated in earlier and
 then I can catenate it again so here I first and get immediately outer
 layers and the inner layers inner list remained unchanged so this illustrates
 how the list monad works the next example is the writer movement now the
 writer monad is this type or W must be something good so let me say that
 explicitly that W must be a semigroup and then flatten is defined like
 this so we have to pull a double on a tuple W and either these are the
 two WS and we just combine them using the semigroup operation so this is
 the second group operation and I'm using Katz syntax with seven OOP so
 let's check that the laws of a social Ava's associativity works here we
 will not be able to use the correspondence here because this does not follow
 from the types the second group operation can be arbitrary it doesn't follow
 from the types must be given so F map is obvious we just don't touch W
 we transform the first element of the tuple so we compute them flattened
 of flatten symbolically and that is we need to first flatten so that first
 flattening will give us combining W 2 and W 3 and the inner one untouched
 and then we can bind this and the result will be that so now it's the other
 way around first we do the F metal flatten which will combine the inner
 ones and flattening that will combine the outer ones after one with this
 result so we see the code is exactly the same except for the difference
 in the order in which we apply the semi group operation and so if the semi
 group operation is associative which it must be if it's a lawful semi group
 then the code is identical it will give you identical results so assuming
 that the law of serogroup holds which is a subjectivity of a single group
 operation we can see that the writer Malad is associative and the next
 example is the reader moment for the reader model we can use the curl our
 trick in fact did I check that there's only one implementation in the easier
 movement I did so I use the curly Howard library here which has this function
 so this is a great hard library and the function is any of type which gives
 you a list of all implementations of a given type and then I check the
 links of that list so if you look at the type of this function it's a sequence
 of functions of this type so this is a special API that allows you to check
 that actually how many implementations exist or given type and the test
 assert so there's only one implementation so that's what we can do with
 a curly Howard library automatically check how many implementations there
 exist and that's the same thing here so the flatten signature is like this
 for the reader wouldn't and the signature for the war for the associativity
 law is read a really reader of a which is this going to read their obeyed
 and again there's only one implementation and so therefore it's not necessary
 to check my hand any laws but I show nevertheless nevertheless how to check
 it's a little instructive so I'm an exercise in substituting functions
 until arguments or you have higher order functions as arguments so this
 is a bit complicated but let me just give you this if you want to go through
 it you can follow this derivation is there anything is commented let me
 just show you the beginning steps so the flattened function is defined
 in the obvious way basically you have a result and you need to return this
 function so then you're right this function which you return it takes an
 argument R and it must return a result of type a and the result of type
 a you can only get by substituting r twice into the function of this type
 which i called r ra to make it more visual what that type is and similarly
 the f map implementation is automatic there's only one way to implementing
 it you must take an R because that's the function you have to return and
 you must return a.b the only way to return a B is to apply F to some a the
 only way to get an ace to apply r8 or some art that's the only are you
 have and so you apply our a to that are and you apply F to that and then
 we compute for example this symbolically how do we compute that while we
 take FTL which is this function are going to this except you have this
 now as an argument as a different type of the code is the same it's generic
 code so the code doesn't change I just change the name of the variable
 here for more visual reference and then you apply FTM to that so when you
 apply FTM to that you take the code of FTM and substitute that function
 instead of this and instead of argument of ft n so when you do that you
 have are going to this function applied to R and again to R so this function
 applied the first one to R will give you this and then you again apply
 this to heart so let me get 3 R's and in the same way you compute so you
 substitute so the only the only problem here is that you need to understand
 what it means to substitute a function in as an argument and the function
 is given like this so you want to compute FTM of this function which is
 given by an expression so you need to substitute instead of RRA here intersubje
ctive this expression so you do that step by step the first application
 ar-ar-ar the first part is what will give this argument art here so then
 you substitute the body of this function which is our RA of our of our
 into our RA of our so ok let me show you that perhaps on an example so
 this is FTM now instead of rrn you need to use this this is the argument
 of FGM now so first we apply art to it so you apply it to R which will
 give you the first argument you need and so that means this goes away and
 this goes away and that's it so that's how it works not to get any result
 so in the same way you follow the other derivations and I'm going to skip
 them in the interest of time they're straightforward and you always get
 this AR AR AR AR AR AR AR as a result the next example is the statement
 the statement has some deep connections with category theory which are
 beyond the scope of this tutorial because for all those elegant mathematical
 connections I haven't seen much or at all that any code can be written
 because of knowledge of those theoretical connections so for this reason
 this lack of practical application I will not talk about this very much
 and also I haven't studied it extremely deeply but nevertheless it's important
 to understand the statement is quite special and so in particular it well
 this is the type of the statement it's not obvious that this type does
 what it should in the part one from this tutorial I have given some intuition
 behind choosing this type but nevertheless this type is not so easy to
 understand so unfortunately the curry Howard method does not work for this
 because there are several implementations of the type signature of flatten
 and so there's no way to argue that since there is only one implementation
 then the law must hold so let's check the law explicitly the associativity
 for the state model the flatten that we defined for the state model has
 this type signature and it's defined by returning this value which is a
 function and so your return function it takes the value of type s and then
 it should this function should return a tuple of a and s and what tuple
 does it return well the only way to return anything that contains a so
 to use this function somehow so we call this function on this value of
 s it doesn't seem to be much else we can do the result of colony's function
 is a tuple of two values one is this which I denoted here in SAS and the
 other is another value of S which I call this one so now we have SAS which
 is this and we have an S one which is of type s we're supposed to produce
 a tuple of a yes now we could call this function on an value of s to produce
 a tuple and that's what we do we call this function on s1 now this is quite
 important that we call it on s1 not an S as we could do all kinds of things
 we could call this function on s instead of this one or we could call this
 function and take just the a out of it it returns a tuple so we just take
 the first part of the tuple in the second part we could substitute again
 either by the S or by this one so there are different implementations possible
 I just outlined four different implementations of the function flatten
 or the same type signature and there are probably more implementations
 so for this reason the type signature alone is not enough to fix the implementa
tion and it's far from obvious that we need to do it like this that this
 s 1 must be here but this is the intuition that we have is that the state
 monad should update a state value and so each time you call this function
 it can give you a new value of the state s and you should use a new value
 henceforth so the intuition behind this implementation is that once you
 have used the old value you get a new state well you shouldn't use the
 old one anymore so whatever you do you should use a new one here after
 this step you get a value of type PS so that's again a new state you should
 use that you should return the new state shouldn't return the old states
 that you have have been used up so that's the intuition behind this implementat
ion but of course this intuition is not sufficient to show that this is
 the correct implementation of the state monad so that's what we'll have
 to do now so in order to demonstrate the associativity law we need to implement
 F map so I simplement it it takes an essayist and your turns in SBS so
 here is what we need to do again here we return the new state and not the
 old state we could presumably here return the old state but that would
 not be correct now let's compute the composition of flattened and flattened
 so here's what we do well we need to confront this triple layering of the
 state model I'm gonna type a which I denote it like this so first we apply
 flat into it so I'm just pasting the code for flatten which is this and
 substituting this thing in it and then you have to apply flatten to the
 result now how do you apply flatten to the result or you substitute the
 definition of wanton flatten of something is equal to this and then instead
 of this application we put the previous code the code that was here applied
 to the value s so that is now how we get the code of flatten of slapping
 it remains to simplify this code a little bit so we can pull this Val outside
 of the block because it doesn't depend on anything so you can pull it easily
 outside let's pull it outside now we don't need the blocks and then we
 have this more streamlined code so we have the first date we get it updated
 get the second state this one goes into here and gets us two and finally
 we use this tool and return the new state and the new value so that's kind
 of natural given that the statement is supposed to update previous state
 into a new state and return a new state so now let's see if we got the
 same code by looking up the other side of the associative a table so I
 remind you what that law is is that flatten flatten is equal to lifted
 flatten followed by flatten so we computed this part so for fighting fighting
 now we need to compute this so first we can put the lifting of flatten
 so how do we compute that we put the definition of flat inside of F map
 so f map of this function we substitute so it's the same way we substitute
 and we get this code so this is the code of flattened substituted into
 the code of F now now this is not easy to understand what I'm going to
 look at this right now and try to simplify it or just going to continue
 and simplify at the end so now we take this code and we apply flatten to
 that so the result is going to be less we we take the code of flatten which
 is this and instead of so let's look at called a flatten again just quickly
 it is this code so the argument of Latin is dysfunction that is applied
 so now the argument of flatten is this lifted flatten so first we applied
 the lifted flat and then we apply flatten so the argument of flatten is
 this so therefore it's like this so we need to apply it like this so now
 let's substitute the definition so we substitute this code into here we
 get this I encourage you to go through this yourself because it's hard
 to show exactly what happens but I'm basically just substituting a definition
 of this function which is here into here and applying it to the arguments
 so the first argument is this and the second argument is yes yes so the
 result is the scope now we need to simplify so how do we simplify I will
 pull out again we can pull out this and out of the block and then we notice
 that we have this function essayist that is being applied to this one and
 it's defined like this so I renamed it the first three but this is just
 the argument of this function I say yes so when we apply a sinister s1
 it means that here we get s 1 instead of s 3 so that's just replace as
 3 by s 1 in this block and in line it so the result will be this so now
 you see it's exactly the same code as we had when we did the first part
 is this good so after identical transformations identical transformations
 are just inlining definitions of functions into the code and substituting
 arguments into functions as if we are evaluating but we're evaluating some
 bulletin so the result is another piece of code that's what what I mean
 by evaluating symbolically so this shows that the subjectivity law holds
 for this implementation of the statement and in fact if we had any other
 implementation for example if we had here a second instead of s 1 then
 this law would fail there's only one implementation of the statement that
 satisfies the laws using connections to category theory that I was talking
 about you could show that laws are satisfied much easier but the price
 for that is a huge amount of extra effort in understanding the so called
 at junctions or adjoint factors and those are quite technical and not easy
 to imagine what they mean so I rather not go there right now and so we
 have actually valuable experience reasoning about code and that's good
 enough for now the next example is a continuation when I which is this
 type flatten would have this intimidating time signature well so actually
 again unfortunately we can't use the Curie Harvard correspondence because
 lots of implementations the correct hard very hard library returns ten
 implementations of fat map and 56 implementations of the type that is certainly
 flat not flattened and 56 implementations are flattened of flat type services
 can't count called triple layering of the Monad on top of the typing so
 we can't use that argument unfortunately so let's bite the bullet and unlike
 we did in the reader model where we could now if we actually have similar
 arguments with a bit of more complicated function types so how do we define
 flatten for the continuation monad well it's like this so a continuation
 is this type and if you have that type signature that was written over
 there then you need to return a function of this type but you're given
 a function of much more complicated type so let's actually write I'll just
 type maybe for reference so now CCA is continuation of continuation of
 a CCA is this and were given that CC is as you see is a function which
 has an argument of this type so we need to give that function so that CCA
 in order to get an R so once we do that basically that's what we need so
 we're given a tour which is this argument we need to return R so the only
 way to return or is to call CC on this function how do we get this function
 I'll just write it saying that it takes this which is a see a continuation
 of it and returns R so how do you return R if you are given this or you
 call this on it you are and you have a tour so we call that on a tour and
 that's the function that we pass an argument to see see that's how we implement
 the flatten for the continuation Mona anything bought clear actually once
 you look at this code it's very convoluted there all these functions that
 you create that are returning something it's unclear what this old us but
 that's kind of important just now F map for this mother is actually somewhat
 easier it's just a factor so we need to wrap this function under this it's
 a factor because the type parameter a is behind two layers of function
 arguments and so it is in a covariant position so this this entire parentheses
 is an in a contravariant position because it's behind the mirror and then
 a is behind another arrow within that so them a is covariant when wanting
 a factor for that is always possible and that's what we do here so we have
 a function f going from A to B we have a continuation from a winter eternal
 continuation from B so that's a function taking a be R which is a type
 B to R fucking right down from this to this so how do we do that so we
 get a br we need to return or we're given this which is ca we call CA on
 the function a to R so how do we get a function a to R we take an A so
 we write those functions to ourselves we take an am or returning our so
 how do we turn our we call BR on a B when B is obtained by calling ethylene
 so that's another exercise in juggling around functions and their arguments
 with higher-order functions so now we do the same kind of games we did
 with the readable not so for example we compute this symbolically first
 so we need to compute FTL of FTM now afternoon has this code so I just
 copied it here and renamed it to and CA to instead of the yarns yeah because
 we're going to have AR NCA all over the place you know and so I'll be confusing
 so I remained up now I have FTN of this so what is that last um is this
 function where instead of CCA I have to put in a set this function so that's
 what I do I copy this code and replace CCNE with this to notice that now
 I substitute so any r2 is the argument of this function which is now being
 applied to this so and so the pr2 I write this so let me do not I get this
 they are going to see CCA of c2 c2 and then instead of a until I wrote
 that so for I'm just mechanically substituting I'm not trying to simplify
 much as long as I don't have to I just substitute an argument into a function
 so that's the symbolic evaluation of this now let's compute a sniper vestian
 so that's Earth Map I'm just copying from this method over here and instead
 of F I put FTM so now I substitute FTM code and I get this now I apply
 F TN to that so f TN of Earth map of T an old CCC a so now at the end of
 this and just copy that over yet now I'll substitute f GN of x equals this
 and X now is this function and so since X is this entire thing I get to
 call X on this argument and X has one argument which is BR so instead of
 BR I need to write this total PR so let me do that I have that and I'm
 still here BR here because I don't want to make it too complicated but
 BR is basically this and now if I want to simplify this further then what
 I can do is I can say BR of this yes well I can just put it in there CBR
 has one argument instead of that argument I have this function the body
 of BR is applying this function to a hard one so basically instead of AR
 I must use AR one and then I like to write this as a result so that's the
 result with AR one instead of AR the final expression is this now if you
 compare that which is here and that which is here line three three five
 one three five five they are exactly the same functions except you need
 to rename a to see a two and AR one to VR so that's the proof that they
 are the same code you can go with rename and you get this income so now
 let's look at these two examples so this example is a useful semi do not
 what is not a full more that I talked about this example in part 1 of this
 tutorial so this is a reader one out with the type for the reader value
 sorry it's a right your motive not a reader mr.
 right your model the type of the writer value is a product of v MW and
 that needs to be a semi-group so what semigroup law do I use the same rope
 is that from the two V's it takes the left one but from the two w's it
 takes the right one so this is an interesting semigroup which is not trivial
 but it is another group it's not a monoid cannot make it into a monoid
 and so because of that you cannot make this thing into a formula but this
 is nevertheless a useful example now let me give you examples of incorrect
 implementations so here's an implementation where it is a writer monad
 and the writer type consists of a product of WNW but the flattened function
 uses this this computation so it takes it ignores V it takes W 1 and W
 2 inputs the millander in the opposite order so the type is correct but
 we'll see that the subjectivity law fails so alternatively we can say this
 fails because the pannier w w is not a semigroup when we define the binary
 operation like this when we ignore the first two and we take a second to
 and reverse the order so let's just verify that this is not a semigroup
 but the social tivity fails for for the same 804 this would be similar
 and that's the here's a numerical test we implement this combine like this
 so we take ignore P 1 we take P 2 and reverse the order of the parts on
 that tuple so then we have the tests so combine 1 2 3 4 gives you 4 strip
 that's the definition and so then let's take 1 2 3 4 5 6 if we first combine
 3 4 and 5 6 and then we combine the result with 1 2 and the first combine
 will reverse the order of 5 6 and the second will again reverse the order
 5 6 so then the order will be unchanged but if we first combine 1 2 & 3
 4 and then 5 6 then we'll get 6 5 so associative 18 is obviously failing
 and the second example where associativity is film is that we take a list
 and we define flatten in non-standard way it concatenates the nested lists
 in reverse order so in other words we just define it as reverse and then
 flatten so instead of I would say reverse one reverse one everywhere and
 then we do the computations that we did before in a triple nested list
 and we see what happens so the first flat it turns you this order but the
 second first you give a map and reversed pile and one reverse button and
 gives you a list of elements in a different order so they're not equal
 so once you start changing the order of things you break a subjectivity
 and this is because if you first flatten the two inner lists then you reverse
 the order a new flat and the outer list you can reverse the oilers the
 order a different way then if you first reverse the order within the outer
 part so this numerical example shows you how that works so we have done
 computations with semi moments so far we have been looking at flat map
 only or flat and looks like the lowest 420 and that's a semi moon now film
 will not have additionally a method called pure here's motivation as to
 why that seems to be useful as I was describing the front in the previous
 part with part 1 of this tutorial moon and represent values that have some
 kind of special computational context either they are evaluated non-standard
 way order many of these values extra value attached to them or some forest
 and monads would describe methods we would describe values that have different
 kinds of values of the context so you could have you could imagine for
 example for a list the context means you have several values so you could
 have a large list or smallest so specific monads will have methods that
 trade there is different contexts another example is the ether moment that
 has an error value and a successful value and you could have different
 error values for example so these are different contexts now when you compose
 monads then the contacts are combined in some way and as we just looked
 at the laws we find that the contacts need to be combined in an associative
 way so context in some sense make make up a semigroup for a similar that
 the contacts combine in a way that is associative now generally useful
 would be to have an empty contacts the contacts that you can combine with
 another context and that doesn't change that other contexts so some kind
 of a neutral element so if you think about contexts as values which is
 not always possible directly but it is possible for example for the writing
 movements so the writer more of this a good example where you have a value
 and another value which represents the context and this value is explicitly
 combined with other such values using a semigroup and so that's exactly
 what happens in general with monads except in general you cannot say that
 the moolaade is a product of a and some value it's not some so in general
 but contexts combined associative way and if you have an empty context
 and it will be like a neutral element or identity element of the context
 set its and so combining empty context and another context should be a
 no op and should not change another context so that's the motivation and
 in algebra we have a binary operation with a neutral element analysis that's
 a monoid associative binary operation with a neutral element and so in
 the writer monad the type W is required to be a mono in the writer semi
 Munna it's required to be only a semi group so what does it mean an empty
 context specifically for a muna it means that you have a function called
 peer which has this type so for any value a you can create a monadic value
 ma that contains in some sense this value a with an empty context or neutral
 context no effects if a monitor represents some kind of effect some kind
 of side effect then this value has no side effect so when you combine this
 value with another monadic value that has the side effect then that one
 out side effect is not have not changed so that's that's the idea let's
 useful to have such a such an element for mathematics and so we hope it
 will be useful also for programming in fact that is not so useful for programmi
ng you don't often use this method you use it sometimes but specific ones
 need to have many more different methods to create various non empty contexts
 as well as empty contexts if the only thing you could do is create empty
 contexts it will be impossible to use a moment for anything useful so certainly
 any specific one that needs more methods than just pure and flat nut but
 from the mathematical point of view as we will see this requirement that
 there should be a pyramid is a useful requirement it constrains the types
 in a useful way it kills off quite a few implementations that cannot admit
 this kind of function with correct laws and that's a good thing that you
 mean you know there's as we have seen well see later part of this tutorial
 many many more semigroups than mana with many many more semi models the
 Mona's so it's useful to constrain the types in some mathematically motivated
 way so what are the mathematical properties that we want now the two properties
 that I just again written up here in terms of code so if you make an empty
 context it means you are in certain the given value le into the monad with
 no extra computational effect or context or anything then this value should
 act as a no hope so as if you did not actually use them on that so for
 example this code or you iterate let's again think about lists as mu not
 so we iterate first over this container and then over this container but
 this container is only one value which is this X that you inserted and
 so this code should be equivalent to this and the code that you want is
 let's say you have a pure of X a flat map with that and that should be
 the same as count of 1 which is X context in the short notation it is a
 pure followed by flat map and it should be the same as the function if
 I'm your thunder and the second is that when first you have a generator
 and then you do a pure so just like we did in the associative also you
 need two situations when your construction is before a generator and your
 construction is a storage generator and in the second case that pure will
 be inside the flat map so that should be exactly the same as this should
 be should be able to simplify your code if you have this into this code
 and that is account flat map of X going to pure of X so that should be
 the same as just cont so this should give you exactly the same container
 as before and so that means flat map of pure is identity function so these
 are two was the called left identity and right identity at this point is
 not obvious why they're called like this and we will see children so there's
 an additional law in fact for pure it's required to be a natural transformation
 so pure is a map between a and M a sub a is the identity function and when
 is the MM functor so it's a map between two factors required to be a natural
 transformation and that chirality law looks like this difficult for materiality
 you interchange the order of some arbitrary function with your thumb in
 the natural transformation and that should work you need a knife map on
 the right hand side and here are the types so you start with a map to be
 and you insert that into the moolaade using pure ore you first insert and
 then here F map the moment and that should be the same result a left identity
 looks like this so let's substitute the definition of a flat map in terms
 of flatten which is f my path followed by flatten and then we have the
 law that F pure flatten it is F for any F which means that pure followed
 by flattened is identity but here F must be given your type inside the
 Munna so the both side of this identity must be applied to as a just with
 some weight so that's how it works some types of you start with some si
 the pure must be applied to the data so it gives you an SOS a so it's a
 pure that is applied to this type gives you a source a and when you flatten
 not give you back a say that should be identity so this should not introduce
 any extra effects or anything the right identity is similarly you substitute
 the definition of flat map in terms of flatten into the flat map of pure
 again F map of pure followed by flat that should be identity again both
 sides are applied to a type si so F map of pure is inserting a into the
 unit under s so that sa ghost SMA and it's different from this where we
 just applied pure to si as if that was some B so ever say this essay is
 just some B but here we don't be with her F map so I indicate this by putting
 a type parameter of pure explicitly just to be sure that it is clear what
 we're doing so this is a different function this is a pure and this is
 a hash map of pure although they work on the same types and then you flatten
 and that should again be identity so in this formulation it is shorter
 so you know then a formulation of Lois with like that but still it's not
 clear why these are left and right identity laws what is left and what
 is right here exactly well you can say for fom pure was on the right and
 here P Rose on the left but for flatten it is not for flatten both times
 flatten is on the right so we'll see why does it so but we know this either
 the laws in order to understand more deeply why what's happening here and
 why we're writing the laws and talking about them as right and left identity
 let's recall how we formulated the laws of filterable factories so we used
 the F map hoped which have the this type signature and then we found that
 we had to compose quite often functions of this type a t1 plus B so a t1
 plus B and then beta 1 plus C we define an operation which we defined already
 denoted like this to compose these functions so we have a very similar
 type signature here the flood map except that this was the option factor
 but this one is the same Thunder s as here so let's try to see if we can
 compose these functions so these are closely functions this is just how
 they're called a class-d function is a function of type it goes to s be
 where s is a certain factor so it's kind of a twisted type it's a function
 but it's life is a bit twisted and so because of the twisted type you cannot
 directly compose them a to s be beta SC kind of directly compose but using
 flatmap you can easily compose of course notes f8 o has been G beta SC
 and then you just take firstly apply F to some a you get an SD then you
 apply flatmap G to that s be so flat map G I goes from s B to C so you
 can easily compose that with us so you can post flat map G with F and that's
 the definition of what we call the closely composition which is denoted
 by diamond now further filterable factors I have the super had the subscript
 opt under the diamond just to remind us that the option is the optional
 factor that is being used to twist the function type in the classical function
 here it is the founder s that is being used for the class Li function type
 so if I were to be completely pedantic here I would have used diamond with
 subscript s but that would be a lot of extra symbols and actually we only
 have diamond s everywhere we don't have any other factors except s right
 now and so let me just her gravity always diamondden I mean diamond s so
 diamond defined like this where this flat map is for the same unit s or
 for one address we defined the class Li identity which is a function of
 this type and that's just a pure the pure has the right type so now let's
 see what the laws are so the composition law actually [Music] can be written
 like this because the composition law has flat map of F followed by flat
 map G so it's like this so basically the composition law for flat map which
 is similar to that of f map opt from chapter 6 this composition law shows
 that flat nervous some kind of lifting it takes functions of these types
 and it produces functions of these types and such that composition of these
 functions corresponds to composition of those functions after lifting so
 of course on the left are slightly composition on the right there is the
 ordinary composition but this is very similar to lifting and the laws are
 similar to function if ting laws as we will see so what are the properties
 of this closely operation so let's reformulate the laws of flat map in
 terms of the class the operation a class decomposition a diamond so the
 formulation becomes a very elegant set of laws so that left and right identity
 laws are like this so pure composed with F is if F composed with pure is
 f now here F must be one of these functions in now it's obvious why they're
 called left and right identity loss pure is identity and this is exactly
 like a binary operation in a mono ed which has left identity right identity
 associative eighty law is written like this which is very concise and it
 follows directly from flm law because they're phalam law all you need to
 do is you write the FLN law which is this the that equals that and you
 prepend it with some function f arbitrary function f and then you rewrite
 this by definition F followed by flatmap is the Dimond operation so that
 becomes directly the left-hand side from here and the right-hand side from
 here now in written in this way the laws are very suggestive of a monrad
 so these laws express amyloid of functions where the binary operation is
 the diamond composition or the classic composition the functions must be
 all Class C functions so they must all have the as twisted type a to s
 be for some a and B and pure must be a natural transformation that is of
 the type a to s a and so this is why you hear that Vinod is a mullet in
 a category of and the factors now I don't point explaining the details
 of this because actually after studying it I found it's not very useful
 as a description of what a monad is what is somewhat useful however is
 to look at the laws of the moon ad in this formulation it is actually not
 very convenient to program with this operation the diamond is also not
 very convenient to check laws for it because of the complexity lose all
 these type parameters and arbitrary functions that you have to keep but
 the formulation of the laws is certainly the most clear and suggestive
 so so this is a monoid in certain sense so on the set of functions of this
 type so if you consider just a set of functions of this type for any a
 and B then they form a monolid together with this as this empty element
 or neutral element or identity element whatever you want to call that and
 the operation which is the diamond so after this let me explain what is
 this category Theory stuff about and why we want to use it until until
 now we have seen several kinds of liftings that mapped functions from one
 kind of functions to another and so let's try to generalize all these different
 liftings that we saw so far we have seen liftings of plane functions until
 these kind of functions lifted into the Thunderer F this is an F map so
 f map was lifting from here to here we have seen F map opt which listed
 from a to option B into FA to FB so this was option and for some F the
 filter of the functor and this is now we have seen a lifting of this to
 this directly with the same factor nicely over half is how we call these
 functions nicely functions with 1/2 F or earth closely functions over factor
 f in each of these cases we saw an identity function also being present
 in some way except that in the closely functions the role of the identity
 function is played by the pure the composition was given by ordinary function
 composition of these first two cases and by the diamond operation in the
 third case however the laws are the same left identity right identity and
 subjectivity of composition so category theory generalizes the situation
 and says that the difference between these situations is just in the type
 of functions that are being used and the kind of composition that is being
 used other than that situations are very similar each of these are called
 a category and so to say I will present a very concrete view right now
 which is that category is basically a certain class of twisted functions
 which are denoted with this squiggly arrow and in different categories
 these types of these functions could be different so here are the three
 examples we have seen so far so twisted functions are called morphisms
 in category theory and you have to specify which category are working with
 so usually we work with playing functions and sometimes we work with of
 Indies now category must have certain properties these properties are that
 for any to morphisms there must be a composition morphism and the type
 you must be like this a to B B to C A to C now the squiggly arrow remains
 the same it could be each time this or each time this for each category
 the second axiom is that for each type any there must exist an identity
 morphism which has this type and the other two axioms are identity loss
 and associativity law so if you have found somehow the type of twisted
 functions or morphisms like this and you can define identity morphism and
 you can define the composition such that the laws hold then you have defined
 a category that is the idea so category is kind of an a twisting of the
 idea of functions and the value of this generalization is that you can
 now define factors in a general way as a map from one category to another
 so for example a map from this category to this is a functor when it preserves
 identity and compositions these are the functor laws identity in this category
 must be mapped into identity in that category so if you lift this twist
 and you must lift this to that and composition of function in this category
 or morphisms generally composition of morphisms must be lifted into the
 composition of lifted morphisms in this second category and this is the
 same for all these lifts so for example lifting from here to here same
 properties must be so it's flat magnet lifts but the properties are the
 same it preserves identity and compositions are the three laws that must
 hold now what we called functors so far in category theory is called endo
 factor so what we call functor is a lifting from here to here and this
 is called endo factor but category theory has a lot of terminology that
 is not particularly useful in programming just a terminology that is useful
 is what I'm talking about here so I just tell you about this in case you
 encounter this word basically this is just factor and it just goes from
 plane functions so I would say in my terminology the category of plane
 functions is just ordinary functions with ordinary identity in ordinary
 composition but the category of functions lifted to a founder F or type
 constructor F let's say is a category of functions of this type with identity
 like this and composition is still the ordinary composition class by category
 over from a third constructor F is this and then you can demand the properties
 of lifting and that would make it a functor or if you lift from here to
 here that would demand it to be a mu naught and so category theory in this
 way has a very concise language it allows you to define things like functor
 and monad just by saying this is a certain category that you you've got
 to lift from this category to that category and that already tells you
 what the rule must be what the laws must be everything the definitions
 it's a very concise way of talking things that a high level of abstraction
 but at this level of abstraction not much code can be written directly
 and so I I think this is kind of optional term to go this far and so as
 a last kind of abstract slide here I will show that if [Music] if these
 classic functions form a category for a specific type constructor s then
 it is a monad so first thing to notice is that if you are given just a
 class decomposition and the the pure operation and you can define map and
 flatmap for your type constructor so here's how so flat map of F is class
 decomposition of identity and F now this identity is an ordinary identity
 is not pure it's just ordinary identity of this type and it can be closely
 composed with F by pretending that this is some type Z and so this is z2
 as a and F is a toe has been so the result would be z2 as but Z is si so
 that's how it works so we can use identity ordinary identity and we can
 use the viewer and we can use the ordinary composition and we can use the
 class Li composition using those we can define map and flatmap so here's
 how well the help is defined through class Li like this it's just a flat
 map of a pure function which we'll see here so actually it turns out that
 we need to require two additional materiality Louis for peer which are
 [Music] written like this and they connect ordinary composition closely
 composition F map and peer so what I believe is that if somebody gives
 you just the Kleiss Lee composition operation and the pure we still have
 to verify that these laws hold it must be natural transformations so these
 laws kind of say that F followed by pure is kind of similar to closely
 functions if you have a non closely function have ordinary type you just
 take on a pure at the end of it and you get a closely function and then
 it behaves as a class Li function so ordinary composition can be replaced
 by closely composition and if you have an F map of an ordinary function
 then you can pretend this is a Class C function by putting it into pure
 and then you can do this so in this way you can also compute f map because
 you can put identity on the left here and then you get a live map with
 identity of G and pure and so then once you define in this way I can assume
 these laws the laws of pure and flatmap follow from the category noxious
 indeed so left and right identity laws or immediately discovered if you're
 right in this and for example this is just identity law because you can
 take any function nicely composed with pure and lets that function itself
 so if you write this and you write down the class like composition [Music]
 in terms of flatmap then you get left and right identity tools it's social
 do it if your flat map follows like this when you write this which is true
 and write it out and substitute flat map like this so identity diamond
 def is flat map F so this is flat map F and then this is another flat map
 of F G which is a flat mapping in this guy's where this F followed by flat
 man G so you just write it out and you get the Loess enough left naturality
 which we assumed here allows you to compute this which is kind of interesting
 fpou G H is f G H so there is a kind of a weird associated between going
 on here between ordinary composition and classic composition which is interesti
ng and very useful for computations so then you get naturally for pure for
 example by writing this this is our neutrality assumption and you get the
 natural D for pure out of it out of that flatten has defined them as identity
 diamond identity with these types and that rally for flatten can be found
 by saying well what is this it's flatten his identity diamond identity
 f map his F pure using this definition then you simplify you get identity
 where this thing can operate here is identity in diamond sometime so identity
 diamond something is F map of that something so then you can get rid of
 one of the identities you get this and the other side of the flatten that
 trowel tool is double F map which you have to write out so you write it
 out then you get this identity it can be simplified the way then you have
 again finally you know just this and these are the same so in these in
 this way I can derive from the moon applause I can derive the closely packed
 category lows and from plastic category rules together with these extra
 nationality assumptions I can give the Monad laws so let's go back to a
 more concrete world where we combine contexts associative way and in the
 semi monad that's sufficient the context are combined as an SME group but
 an effeminate the contexts are combined in as in the monoid they have an
 empty context which we can insert and so let's see what mono is are what
 are the types that have the property of being semi groups and one works
 there are quite a few examples of semi groups and monoids and there are
 some specific examples that have particular nature for example for integer
 type in many ways of defining a monoid you can have a product some maximum
 minimum different kinds of semi groups and monoids for string for example
 you can define different models different semigroups concatenating strings
 with separators for example in different ways for the set type you can
 define intersection of subsets or union of subsets as monoid operation
 another interesting example is the route type in the a collider in the
 HTTP which has an empty route that always rejects everything and the route
 concatenation operation that puts one round on top of another and combines
 them and that's a manorial operation but these are kind of special and
 here I listed some generic constructions of Mao's so that you could appreciate
 how to build new monoliths from old ones and what kind of properties are
 required for a monoid so let's now go through raising examples the first
 example is that you take any type and you make it into a semi group and
 that's very easy you just define a combined operation that ignore is one
 of the values so for example you just delete the right value ignore the
 right value you take the left value and that's your result that's how you
 come back this is a kind of a trivial operation that combines non-trivial
 perhaps not very interesting way but it satisfies associative it let's
 see why here's an example I define a 7 group for anyway and now any types
 are combined and ABCs of strings integers everything is combined in this
 way now after I define a simple associativity for example here's ABC and
 I combined them in two different ways and there's always always a so why
 is the social TVT correct that's because in any combination of these the
 operation will always between the leftmost value all the other values will
 be simply even ordered so obviously this is a so associative you are deleting
 all values except the leftmost value and it doesn't matter in which order
 you do need them and similarly the right trivial semigroup which ignores
 the left value and returns the right the next example is already seen in
 the previous chapter where you have a selling group and you add one to
 it so you have an option of a semigroup I'm not going to go through this
 but the laws are satisfied as long as that is a semigroup so identity laws
 are satisfied by construction and the semigroup laws are satisfied that
 that is a semigroup another example is the list list as a monoid for any
 type of sequence and so on because you can concatenate lists and that's
 a valid operation and the empty element is the empty list so you can catenate
 empty list with anything and that doesn't change that other list so obviously
 it's associative because you just concatenate the lists in the order in
 which you have written them and so that doesn't depend on the order in
 which you remove parentheses between the lists this construction for is
 also generic so it's for any type a it's a function from a to a that is
 a monoid the operation which I denote one this it could be a composition
 of functions in any specific order so there are two different one if you
 choose one order of competition or another so let's look at this left compositi
on or you say X and then Y for the combined operation and the empty element
 is identity function so obviously the composition respects identity and
 subjectivity is clear because you apply X then you apply Y then your plan
 Z so the order in which you apply x y&z is the same and it doesn't matter
 in which order you put parentheses here that's left composition as a right
 composition when you write composed instead of and then and compose is
 X compose Y of a is X of Y of a which is the same as Y and then X are we
 first you say y avait and then X of that identity laws are again obvious
 associative it is again easy because X compose why compose is basically
 this X Y Z there's no way and the order is the same and there's no way
 that this can change and so doesn't matter where you put parentheses here
 parentheses in here are unimportant the next example is total order type
 well this is also a generic kind of example of any total order types in
 the enumeration or integers so the only thing from on the way you need
 you need a maximum or minimum so if each have maximum as your binary operation
 you need a neutral element for a monoid and you might not have a neutral
 element for example for integers there is no maximum integer if you if
 you use arbitrary precision integers if you use finite integers then there
 is it max int so you could use that associative 'ti is clear because you
 take a maximum of several elements and doesn't matter which order you compute
 the maximum it's going to be the same maximum or minimum the next example
 is the product so if these two are seven groups or monoids then the product
 is also a semi group or a monoid let's see how that is done so I'm defining
 a one or a typeclass instance for the product given that these two were
 monoids the empty is a pair of two empty elements and the combine is a
 component wise combination so I have monoid operations separately in this
 one against two and because they are performed separately in each part
 of the tuple then each part of the tuple separately will satisfy all the
 laws because you can just delete the other part of the tuple temporarily
 and look only at what happens to one part and then obviously you just have
 the first one oh it you assumed its laws already hold or or Senegal and
 so obviously then the entire tuple will also satisfy the laws the next
 example is the disjunction of Tim seven groups are monuments which is kind
 of maybe less trivial than a product so here's what we do here it's a right
 biased either we have to choose if it's left biased or right box up to
 two different ways of doing this so there's not there's not a symmetric
 way of combining two semigroups or two more nodes into one but even either
 the left side or the left on the right side must be and chosen as the main
 side in particular the north and it's neutral overland and it must be either
 on the left or on the right there's no nowhere to do to do it symmetrical
 unlike in the product case so let's say we have a right biased either what
 does it mean well here's how it works we need to combine some values of
 type either a B where a and B are both mono it I'd say if all of them are
 left all of these others are left then we combine their values they're
 all values of type a so we can combine them into a left of some eight if
 they're not all of tied left already then at least some of them are right
 a right of B then we discard all the left and we combine all remaining
 right of the operands into one right that's that's the idea now this would
 be associative because we just formulated the rule that doesn't depend
 on the order in which we apply that rule so discard all operands of type
 left a dozen doesn't depend on the order in which we discard and then you
 combine all of them into one using the monoi operation which again my assumptio
n is associative and so identity element must be the empty element on the
 left and then clearly combining it with the left will produce correct results
 combining it with the right will produce there the right now you without
 change because you discard the left and you just get there right so that's
 why it will be respecting all the laws so here's an implementation so I'm
 writing down a monoid typed class instance for either a B given that a
 and B are monoids the empty is the left of empty a so we have chosen a
 right biased either so then the mono of the empties on the left now how
 do we define combined well we have two elements either could be a and B
 so we match there for combinations left and left we combine right and right
 we combine if we have a left on the right then we discard the left so in
 the first case we we must do this because if if X is empty then the result
 must be this and there's no other way to implement that so once we implemented
 in this way the laws will hold by construction here's an example how this
 works left one right two left three I'm just using the integer bond modulus
 addition then all the left are deleted in the right to remains right one
 right two left three the left are deleted so right one right two remains
 are combined into right three so for example u 2 and Q 3 deletes this keeps
 right - and another example so again left is deleted right and right are
 combined the next example is construction it if we have a monad can type
 constructor in and Illinois s then M of s is a manured kind of an interesting
 example because now you can construct a lot of types as more nodes if you
 have some standard monads and your planet to one law it's constructed previousl
y so here's how it works I'm defining a typeclass instance for semigroup
 so here I will only check the seven group not a full monoid and actually
 exercise one will be to show that it is a full moon would if if M is a
 moon odd then M is a monad s is a monoid an M of s is a Mulla Mulla well
 I'm only going to use a semi monad and the semi group so I only need to
 define the combined operation so how am I going to define that well like
 this very interesting elegant piece of code X is a monadic value with s
 y is another man Alec value so I just combine them using them monadic combinati
on and semigroup combination so associativity follows because if you do
 this then you would have called like that and if you first do the first
 two that's what would be if you first computed for yield with these two
 and then inserted it into another for yield here which is exactly the first
 the the associativity law for for the Monad which is that you can inline
 parts of your for yield block into a larger for yield block so that associativi
ty guarantees associative 'ti at this level and then the semigroup which
 is being used here must be assumed also to be associative and that guarantees
 associative et in the last line so it's kind of very easy to assume that
 this thing is associative without going through a lot of a lot of computation
 and coding as we did before and an example of when it becomes a full mode
 let's take a reader model reader monad and apply it to a Molloy yes so
 the empty element is a function that takes an argument and return the empty
 value of the mundo it and the combined two readers is to take the Z and
 we apply x and y 2z and you combine the results and so basically all the
 neural operations are performed with the values of s that you've obtained
 by applying functions to some Z so for each fixed value of Z once we apply
 this function you get a monoid valued and all the laws hold so they hold
 separately for each value of Z and so they always hold for all Z and therefore
 a function from Z to a moon or it is itself a monolid and Z doesn't have
 to be infinitely it's just fixed type doesn't have to be moderate adorned
 the final construction is more complicated and it's motivated by some mathemati
cs but actually it has applications in practice so the construction is a
 product but only one part of the product is a semigroup and the other is
 not necessary necessarily a semi-group so SS is similar but P is not P
 is just some type however the semigroup pacts on P so it has an action
 loopy and that is what makes makes it possible to define a semigroup on
 this product what does it mean that s was an action on the P and actually
 the function from s to a function from B to B so for each s there is a
 transformation of on P and these transformations must be such that their
 composition corresponds to the non-oil composition of s so this is in mathemati
cs a typical situation then let's say the group acts on a vector space there
 is a transformation and multiplication of transformations corresponds to
 group multiplication and here we just use a semi group and that's sufficient
 so the result is a product s and S&P which is called the twisted product
 so it's we wouldn't be able to define a semi group we define a semi group
 using this action without this action would be very very useful we could
 define a trivial selling group with one of these ignoring operations but
 I wouldn't be very interesting so here's an example of such situation if
 s is this which is something then it acts on a because for each function
 you can transform this P alpha is identity and obviously it satisfies this
 law because the composition of functions is the same as composition of
 transformations another example is a product of boolean and an option of
 a where you can act with boolean by filtering so filter operation satisfies
 this law because as we know from the properties of filter balls filter
 composition with another filter is a filter with boolean boolean conjunction
 of two boolean values so if we define this semi group as boolean conjunction
 then the filter would be good so this could be any filter it's not notice
 is really an option I just put here an option as an example but this could
 be any filterable so this is a generic example of a semi group with a non
 trivial structure so we're going to show you some code for this twisted
 product so here's how we define it so I'm defining a semigroup instance
 for don't actually doing this I have a single group s in a3 which is unknown
 type and I have an action has to be 2p and then I can define a semi group
 of SP with this combined operation so the first element of the tuple is
 combined using the semi group actions a semi group operation but the second
 one is an action that puts together the first X so the first semigroup
 and the second P so the first one here packets on this and that's the result
 so that's kind of a twist and here I can verify symbolically that associativity
 works I consider this definition so that is I just defined other things
 and then I consider three different values and their combination in two
 different orders and the result would be that the actions would be like
 that and they should be the same and there will be they're going to be
 the same as long as the action a satisfies the property that we assumed
 in other words a FS 1 over L of s 2 of P 3 is the same as a of s 1 plus
 s 2 of P 3 so and that is so let me just give an example where we define
 a semigroup using a boolean and an option int so boolean acts on any filter
 mode using the filter function so optional suitable we're just using a
 standard library for naught and we define this implicit value of semigroup
 for Q for the type Q by calling that function we just defined and I see
 that the values work and there is associative it now these are just very
 simple examples I'm not sure this is extremely useful to filter options
 with boolean but this could be useful in some application perhaps in any
 case these are the generic constructions that you can use to make new scenario
 humanoids out of old ones in the heart of other parts with this as inspiration
 let us now look at what are the constructions of possible semi models in
 Malad our intuition is that the best for analysis is to consider the flattened
 functions as the simplest type signatures simplest laws and the way if
 flattened works this text data in this nested container and somehow fits
 that data back into the original container and this should must be a natural
 transformation so you don't actually perform any computation with this
 data other than reshuffling it in some way now you have seen examples of
 monads and you have probably asked yourself a question of what are all
 the possible Muna's are so different how do I know that the given type
 is a unit or not in fact this is an open question I believe it is not obvious
 that we have an algorithm to decide whether any given type expression is
 a monitor or not and as you have seen it's a bit cumbersome to verify the
 laws of the moolaade but here are some constructions that I found that
 always give you lawful monads and so if you construct a monad using these
 then you don't need to check laws you can prove this in advance that all
 these constructions give you correct units and then you just use them you
 don't need to go through checking the laws every time in your application
 whatever you define new data type with a unit instance so all these constructio
ns use exponential play level types so they are either products or disjunctions
 or functions function types so the simplest construction is that of a constant
 factor and the constant factor is semi Malad for fixed type disease but
 it is not a fulminant because the identity laws cannot be satisfied unless
 the type G is unit so the only constant factor that is am honored fully
 model is a unit type constant factor so let's see why that is so let's
 define this type constructor with Z type parameter which is that constant
 and he is a functor type parameter that is not used in the actual type
 because it's a constant factor so the function is going to be written like
 this in the syntax for the Skull kind projector plug-in so here's the inst
 instance of a semi mullet we just do nothing flatmap returns the initial
 value with no changes ignoring this function that is given there's no changes
 because you map a to some something else but there's no way for you to
 there's no a there's no way for you to use this function if so you can't
 call it you have to return this Z so your Z is just stays the same flatten
 is identity flat map is identity F map is also identity because there's
 no a to total transform and so associativity is trivial there are other
 entity functions composition of identity functions is identity however
 this is not a fulminant the right identity law fails here's why the right
 identity law says that flatten of pure of some X must be equal to X for
 all X now what can pure do pure goes from A to Z it cannot do anything
 except give some fixed value of Z suppose I give you some fixed value of
 Z for all a there's no way that you can use the value of a 2 let's try
 that so pure actually cannot depend on its argument and therefore pure
 of X does not have any information about X it will be a fixed value of
 Z that's independent of X and flatten of that cannot possibly restore eggs
 the only exception is that if if type Z itself is unit then there is only
 one value of x you can always just put it in pure returns one flatten of
 that returns one and that's the same one that you had here everything is
 just always equal to unit and so in that case identity loss hold so that's
 the only way in which a constant factor can be am honored and fully lawful
 one world as well as a unit constant fuck factor otherwise it's a seven
 moment 
\end_layout

\begin_layout Plain Layout
the next example is the construction of a semi mullet or a monad which looks
 like this for any factor G we take the tuple of a and G of a and that is
 the new type constructor F and we will now show that in general you can
 define a semi mullet for F and if G is unit that is there's no G here just
 a that's the identity function and that's a full moon that there's no other
 way that you can get full mana out of this construction so how do we show
 this first of all we need to define the function instance for this and
 then we'll define a semi Menard instance define the Phantom instance we
 need to produce an implicit value of type factor of F but actually F is
 not defined as a type constructor because we have this arbitrary function
 G so we cannot define the type constructor F without first defining a G
 directly so instead of defining it directly we use the kind projector and
 so then this syntax will represent the type constructor that takes a type
 X and produces the type of tuple X and G of X and so we will have to keep
 writing this extra type expression instead of F which is okay if you don't
 have to do it for T many times later we will say we're looking a little
 calm down in this repetition so the factory instance for this type constructor
 is straight forward we need to implement the function map which takes an
 FA which is a engine way it takes also a function f which is arbitrary
 an arbitrary function of arbitrary type it to be and we need to produce
 a tuple of B and G of B so to do that is relatively straightforward and
 unambiguous we use the fact that G is already a functor so G already has
 a map function of its own we use the type constraint here typeclass constraint
 so say that G is a factor and we have imported the syntax for the for functors
 and so now we can just say g g a dot map so that's what we do here using
 the factor map from the front row G so how do we produce a tuple of being
 G of big well obviously we have a tuple of a and G of a so this is the
 stupidest structure it using a match expression obviously we need to use
 the function f to produce anything that has been it because there's no
 other way to get any any kind of be acceptable using F so we call F on
 a to be get a value of type B here and we do a G a dot map F and that gets
 us G B so that's easy enough now how do we define a cell or not this is
 a little more involved so again we assume that this is a factor and we
 are going to produce a value of type semi Malad of this type structor expressio
n and that's going to be the implicit value but this value is characterized
 by G so we need to make it a death so the function we need to define for
 the semicolon is flat map so how do we define flat map well we have an
 arbitrary function of type F sorry of type A to B and G B we have a tuple
 a G a and we need to obtain B G B so let's think about how that function
 can be defined and to get intuition about it let's remember that mu not
 represent some kind of computational context or effect that accompanies
 a value and so here obviously we have a value of type a and also a value
 of type G of a which we could consider to be the effect or the computational
 context of the value a so just intuitively now we have the initial value
 that has its own effect that's the first one and also we have when we apply
 F to anything we will get another G will be which is a second effect now
 clearly these G of a and G G of B near arbitrary functors we can't combine
 them so usually Mona would combine two effects into one so for instance
 if this were just the reader Mona that's that would be a tuple of a and
 W and here will be a tuple of B and some other W we will just combine this
 w and that W using the semigroup but here we don't have a second group
 G is an arbitrary factor there's no way for us to combine two values of
 type G of BC we could try to map F over this but then we'll have G of B
 and we can't combine that G of B together so we have to discard one of
 the effects basically that's the basic reason why this cannot be a full
 moon usually when they discard effects that's red flag in terms of having
 a full monad film Allah doesn't discard the two effects it combines them
 in a mono Idol fashion semigroup combination can discard but 108 combination
 cannot discard if you you cannot defy them annoyed when you define your
 binary operation that discards one of the arguments that will be not a
 lot from annoyed because it would not have an identity value because you
 could not combine identity and X to get X when X is discarded so you're
 not allowed to discard if you want to have a mono it's similarly here we
 shouldn't be discarding any effects or any information when we would like
 to have a full owner all right so that intuition gives us a guidance that
 probably we're going to have a semi monad here and not a homo not because
 we have to discourage something there's no way we can take into account
 all this information because we cannot combine G's so let's just arbitrarily
 decide to describe the second effect and that means we will basically ignore
 the second part of the tuple the function f produces so ignoring the first
 effect would mean that we ignore this you know in a second effect means
 that we ignore this so let's just arbitrarily decide that we will want
 to ignore the second effect so that means we define a function f1 so the
 first part of F which is this so this will apply F and then apply the extractio
n of the first element of the tuple which is then basically means we discard
 this and then we get the function a to b and now we just apply this map
 function that we have before so with a we get this result this is the same
 code as was above here so this is one way of defining a same unit which
 is really arbitrarily decided that we want to describe the second effect
 who would have decided them we could have decided to describe the first
 effect instead wouldn't be also similar than to show this as one of the
 exercises so let's continue now let's take care of the case when G equals
 unit and then we just have the identity function as our identity factor
 now this is also the identity monad because just define all the functions
 as identity flatmap f map flatten is identity pure is identity everything
 is identity and then obviously all Monad laws will trivially hold because
 all these laws mean composition of some identity with identity which should
 be equal to identity so it's always going to hold all those if you define
 all your functions as identity functions so for this function you can define
 all your methods as identity functions and that's what we do that's called
 the identity monad not a very interesting will not per se but it's interesting
 to note that it is a unit so for instance this is a functor also not a
 very interesting one but it's important to have that founder as an example
 because for instance in a construction you use an arbitrary factor or an
 arbitrary unit and you can substitute identity founder or identity monad
 into some constructions like one of these constructions that have arbitrary
 functional units in them and you get an example of a new unit by that so
 identity models and identity functions are not necessarily useless not
 necessarily useful directly but they are useful for constructing new moon
 and sometimes let's now go on to verify the associativity law for the semi
 moment that we found so for brevity will define type aliases so f is this
 you see this is not that this F is not the not a function by itself good
 it has two type construction I had to type parameters so it is a type construct
or that has two type parameters a functor should be a type constructor with
 1 type parameter so we need to write things with the kind projector as
 we did here in order to get the right syntax for a functor type constructor
 will not that constructor but just for gravity we're going to introduce
 this notation these are type aliases so this is fine this is f of GA which
 is there but what would you know that there is FA here it is explicitly
 taking G as a parameter now F F is just f of F this is just the same as
 if we stop writing G and that's what it won't be and and this is F of F
 of F of ad writing it now it would be quite cumbersome so I just want to
 introduce these type a leases now in order to check the laws the easiest
 ways to look at the flatten function what F not the flat map function so
 let's derive the flatten function probably the definition of the flat map
 that we were given above so we given this definition of flat map and flatten
 is flat map of identity which and the identity must be of this type so
 let's copy this code and substitute identity instead of F so that's what
 we get now F 1 is a simple function that just takes the first value of
 the tuple so we can substitute that into the code so let's see I'm going
 to rename this to FA and this to G FA because the types of these things
 are FA and GF this FFA is of type F F of GA which is this it's a tuple
 of F and G of F so therefore I'll choose my names here fa g fa these names
 were just copied from above so I want to rename for clarity to remind myself
 what types these variables are so now if when you say here for example
 f1 okay but with one is just taking the first element so instead of this
 I write this and here I write this so let's further simplify now obviously
 if a is FF a dot underscore one so then this is dot underscore one dot
 on your square one and this is FF a dot underscore two map underscore underscor
e alright so this is the code of the function f flatten now this is what
 I call a symbolic derivation of the code so this code was derived by substituti
ng function definitions and simplifying but simplifying is more or less
 like in algebra you have an expression you substitute a function into it
 and for example here FA is FF a dot underscore one and so you substitute
 here instead of F a so this is quite similar to mathematical derivations
 in algebra so you just substitute equal values for equal values anywhere
 and substitute definition of functions to apply them and then simplify
 and and so on and so this is a symbolic derivation of the code I could
 have just written this as a definition of flatten this would not be a symbol
 in derivation because I don't get the code of the function cannot reason
 about that code as easily here is the code of the function that I can later
 reason about I can again do the same substitute is simplified and that's
 what I will have to do in order to verify the laws so there's a there's
 a symbolic clarification that I'm going to do rather than so to speak a
 numerical verification if I just wrote this and then used Scala check to
 call this function on hundred examples with integer types or something
 like that now it will be you know certainly a bit helpful perhaps to do
 that unfortunately in this example we're trying to prove something for
 an arbitrary function G how are you going to do this with Scala check I
 don't think you can do this let's go check because there's no such thing
 as an arbitrary function in it I don't think so I will be interesting to
 add that functionality but it will be hard to do it just here in this tutorial
 and this functionality generating an arbitrary function is this is kind
 of vicious so you probably need a lot of code for that so anyway it would
 be hard to do and it would only give you specific type parameters and specific
 functions checked not arbitrary types and not an arbitrary function or
 as a symbolic computation that I'm doing here is more like a mathematical
 proof it is rigorous it is proving it correct for all type parameters and
 for all functors now if you remember the associativity law for the semilunar
 it involves f map of flatten so we need to implement ethnic let's do that
 F map is just the same as map what we did above except it's arguments are
 flipped first comes the function f and then comes F of a other than that
 the code is identical now the associativity law is that this expression
 is equal to this expression so this function and this function are identical
 that's the law so in order to check that we need to symbolically derive
 the code of these two functions and compare and somehow show by simplifying
 maybe renaming variables and such that they have the same code these two
 functions so let's start by computer for F map of flattened because that's
 the first function we need to check is that is f map of flatten followed
 by flatten so that's I just want to remind you is the law of associativity
 find that slide this is the law of flatten right here written in this short
 notation this is lifting in the functor so this is f man so basically f
 map of flatten followed by flatten must be equal to flatten followed by
 flatten with types accordingly matching what me back to this slide and
 go back to my code so first step therefore is to compute the code for this
 so let's do it how do we do it well with I I do it by writing out this
 function as if that were a separate function I'm defining and code for
 the body of this function will be symbolically derived so I call this function
 as my up flatten just it doesn't matter what I call it really I look at
 the COS function in the code so I name this function just to be sure about
 what I'm computing so this function f map of flatten takes an argument
 of type F F F of a and returns F F of a because flatten takes F of F of
 a and returns F of a and I'm lifting flatten once so I'm adding one more
 layer of F so in order to derive the code let's take the code of F map
 and substitute the function flatten instead of F into that code so I take
 this and instead of F I write flatten so that's what is going to be so
 it's going to be flattened of a which is here called f f/a because it's
 that type and then it's going to be this map F on this map flat so that's
 going to be the result of substituting the definition of F map in here
 so that's first step so now let's substitute the definition of flatten
 which was right here yeah that was flattened so let me keep it on the screen
 after we simplified it so that was the code for flatten so we need to apply
 this to F FA and we need to do the so f fa is instead of yeah if FA is
 right here so we just repeat this in here and the last part of the to boy
 is unchanged so I put this all in comments because this is my preparation
 now FFA is the first part of F F F a and G FFA is the second part so then
 I rewrite it like this so instead of FFA I write F F F a wand and so on
 so instead of G FFA I write F FFA too and so I get this expression which
 is kind of a longer expression but this is a this is the code of this function
 nested tuple I have a double nested tuple whatever and that's what I have
 to return and the Scala compiler compiles this and so that's how I check
 that I haven't made some trivial mistakes so having compiled this let us
 compile as certain having having derived this part let us now derive this
 entire thing symbolically so again I wrote a bunch of things in comments
 which is how I derived it so first step is to simply rewrite this notation
 in scope so rewriting this notation means you take F FFA first you apply
 this to F of F a and then you apply this to the result so in other words
 in scholar you would apply this to the result of applying this to F F F
 a which is written over here so I just copied it over here so this is now
 after inside of flatten and after that we substitute the definition of
 flatten from definition of flatten was up there let me look at it again
 it's right here so now I need to take that and apply that definition so
 this one one for example it would be just this because the first this is
 the first tuple and in the first tuple I take the first part so that is
 if F a 1 1 so this whole thing 1 1 it is this and so so I just apply these
 things so I extract two parts from here which is immediately possible notice
 here I didn't do anything with this F GM inside the map I just keep it
 why I can't do anything with it right now I can't simplify anything in
 this part of the expression it's under map so I've no idea what it is acting
 on and so I don't know what that is I cannot simplify any more but later
 I will be able to simplify maybe so I'll just keep it like that all right
 now we got this so this look yeah I still have this map a flattened with
 no simplification however now we can simplify because we have dot map of
 something don't map or something else we can combine the two maps and that
 will be like that so I just keep the first things unchanged and here I
 combine first I take flatten of some things I write out this function as
 FFA goes to something if a faith first goes to flight another for a and
 then I take the first element of that so however now we can simplify this
 flattened followed by taking the first element is just this remember the
 cone for flattening respects so the first element of flatten is this so
 then I can simplify and this is my result I could simplify this further
 I like that at the risk of getting less readable but we're not going to
 read this much more hopefully we'll get the second function now and have
 the same code and won't be done let's see how that goes all right so the
 second function we need to compute is this this is the right-hand side
 of that of the associativity law let's do the same thing again so we apply
 this to some arbitrary fffe and notice that the type of the return of this
 function is f so flatten flatten takes a triple F and flatten this twice
 and returns a single nothing here map flatten flatten did the same thing
 by first concatenate in the inner layers and this first thing getting into
 the outer layers so that's such a DVD law that's combining triple F into
 F doesn't depend on the order in which you combine the layers of it all
 right so let's continue the first step is to substitute the definition
 of flatten in here and so now we have flattened off this let's again substitute
 the definition of flattening now for the outer flat so we take this 1 1
 and so on so once we figure that out it's going to be this I'm copying
 1 1 and then again the same to map 1 remember them right there the code
 is take this FFA 1 1 and then take it to map one that's good I'm just being
 very careful to make no mistakes so I'm going slowly copying twice now
 let's simplify right this is a tuple we can compute what it means to have
 one one of it it's just this so then we take not we obtaining this so now
 we have again a situation with map map we can combine them into a single
 map which is less and voila we have the same exact code of the functions
 we just look at this code and we see they were the same expression so this
 shows the associativity law for the same unit why can it not be a full
 moment but mostly for the reason that you can't have a woman away if you
 discard information but if you discard one of the arguments in time but
 more formally I would say for a full minute we need to define purer and
 purer must have this type how do you define it how do you get a value of
 G of a for an arbitrary factor G you can't there's no way of doing that
 now if you now say well maybe G is not an arbitrary factor and maybe there
 is a function from A to G of a well that is already suspicious because
 then maybe G is already itself able nod or something like that so for arbitrary
 function G certainly I won't work we will have a construction three next
 which is similar work where we have two minutes a tuple of two morons so
 let us now go to example three and I will show that a tuple of two monads
 or semi womens is again Amanat or same unit so here I'm preparing the type
 aliases first now it's going to be quite both because I have two arbitrary
 Hunter's G and H and so how can I do anything with them well let me just
 do this for brevity and define this notation now notice we have G of a
 tuple of G of H of a so this is getting quite complicated each of a topology
 of a each way so we have G inside GG inside H and H inside G and H inside
 H which is kind of complicated so how can we define a munna instance products
 so I'm not going to define flatmap because it's much easier to define flat
 I did define flat map in the previous example but then I have to define
 flatten and so why don't I just start with flatten it's easier now how
 do you define flatten now we have to somehow convert this into this in
 imagine that we already know how to convert G of G of a into G of a because
 G is a unit in th a very into HIV because H is a moment or centric paalsamy
 mood let's say when we have more than this we have G of two po G of H of
 a so there's an H inside of G how could we flatten that into G H is an
 arbitrary type constructor well it is a 7 1 AD or a Mona but it there are
 so many different type constructors that fit that description as we have
 already seen it seems there's nothing else we could do here except to discard
 the H inside of G and to discard the G inside of H discarding it is easy
 because they're factors so we can f map or map this value with a function
 that takes the second part of the tuple or the first part of the tuple
 for this I can just map like this and that will discard those parts that
 we don't want so it seems this is the only way we can solve this problem
 and implement for it let's do it so that's going to be the first part map
 one flattened so this flatten is M G and the second part mapped to flatten
 that flattened image now we have interestingly here a map followed by flattened
 so here map fold by flatten this map is also in the factor H as this flatten
 this map is a new function G as this flatten therefore we can combine map
 and flatten into a flat map and we can write somewhat shorter code for
 this flatten function notice this flat map is in the first element of the
 tuple which is the function G so this is the flat map of the semi 1fg whereas
 this is the flat map of the 7-1 at H there are two different flat Maps
 really being used here to define this all right let's go 125 pure that's
 much easier we just take the pure of the Monon G and the pure of the Monad
 age and combine them in an inter tuple we're done with writing a code for
 the unit now let's prove the laws to prove the most women would need F
 map so what's the F map was just a tuple of two F knobs so here's a little
 bit of intuition about what the small knob will do so we have combined
 two more hands into one what does it give us so here's an example so actually
 if you look at the flattening you see only g and g are combined only H
 and H are combined so the cross terms so to speak H of G & G of age are
 just ignored so that suggests if we do if we write code like this then
 there will be no interaction between the two parts of the tuple so this
 will interact with this and this won't work with that so the result would
 be exactly the same as if we just split it into two and wrote two pieces
 of code separately like this and then combine the results in a tuple like
 that so it's just exactly the same so the result would be for instance
 here if G is a monad H is a monad then you would just perform the for yield
 block separately for G and H and combine the results in a tuple but you
 don't have to write it separately you can rank it when this is shorter
 than the writing news so let's go on to the laws the identity laws are
 easier to verify because the code is simpler so let's start with those
 two identity laws the left identity and the right identity now these are
 at least two laws so the first law means that a composition of these two
 functions is identity so let's define this composition as a function called
 pure flatten so again I have to write all this parameter stuff the type
 of this function is f - f so ya go back to the slides and look at the clause
 just to see that we have done it right so pure followed by flooding is
 identity services this so the type is si - si when our notation is FA -
 Fe and the right identity is also half a tuna Fame so that's what we do
 okay so flatten of pure of FA this is what it means first we apply pure
 to some arbitrary FA of this type and then we apply flatten to the result
 let's substitute the definition of pure which is this now we have plot
 flatten as the substitute the definition of flatten which is written here
 this is the definition so we just substitute it in there and we take the
 first one flat map one second one flat map cube now just not much we can
 do with this expression anymore unless we remember that this is and this
 are from one add H and this and this are from onaji and these monads must
 already satisfy the same law which is that pure followed by flat map of
 some F is the same as applying F to this X so let's use that law and that
 means we need to apply this function to this FA which means FA dot on your
 square one and similarly here so the result is this now if a is a tuple
 so if you have a tuple of which you take the first part and the second
 part and then put them back together you get the same tuples you started
 with so therefore this is just identity function and in this way we've
 showed that the first law holds so let's look at the second law similarly
 with good definition of what it means to have flat map viewer followed
 by flattened so you take some arbitrary FFA and you first apply F map of
 pure of it and then you apply flatten to the result so let's substitute
 what it means so basically F map works component by component on a tuple
 so you need to do FFA one in a pure if you fail to not pure then you substitute
 the definition of flatten which gives you a flat map one and flat map two
 on each release alright so now we have this situation we have map flatmap
 so this is in the factor G and this is in the function H so we can use
 a natural T laws for these two factors which we assumed already hold and
 if you look up what the naturality lawyers it basically can interchange
 the order of map and flatmap that's what we do so instead of this this
 is a naturality law map f flat map g gives you a flat map F and then G
 so if we do this then you get for example flat map of pure and then this
 so we have such expressions but if you look at the definition of pure it's
 one a deep your coma will not H pure and so the first part of this is 1
 a G pure so then we can simplify that the result is going to be this again
 we wouldn't be able to simplify here but any further except that we notice
 this flat map is from the moon LG and so we have a flat map acting on the
 pure from the same unit we can use the identity law for that one ad which
 means that this is identity function and this is for the moon and H the
 identity function and so the result is going to be F FA 1 and then identity
 function so we can just delete that get if FA 1 if you fatal and that's
 exactly identical to just F FA something I just something I just noticed
 is that the type here is FF and it should have been F so why did everything
 compile because this FF type actually is just more restrictive than F so
 we should have just changed this to F and things still compile now I can
 rename this for clarity so that it's going to be consistent so in this
 way we have symbolically verified the identity laws now let's verify dissociati
ve eg law and this is going to be a similar exercise and substituting functional
 definitions and simplifying now notice that we have used the moolaade laws
 for G and H to derive the identity laws for the construction F topology
 image but if G and H are only semi moments and not for women then we cannot
 use that but so we won't be able to derive pure either we won't be able
 to derive the laws for the construction so if these are just semi monads
 then all the proof of we have done so far does not apply and we can only
 prove the same unit for the resulting construction on the other hand in
 that proof we don't need have a full moon of the instances for G and H
 we only need a semi moon had laws and semi one-eyed functions where I'm
 going to use paper for G and H and so if G and H are semi bonnets then
 the result will be similar and we are going to prove that now so if we
 prove that associativity law that's what we will prove buts anymore let's
 give us a 1 have you film or not give you a full minute and and this is
 because in this proof now we're not going to use the pure functions from
 G and H we're not going to use anything but associativity laws for G H
 so let's see how that goes again we have to do two things we have to compare
 that these two functions and show that they have the same code so let's
 begin with this function so flat and followed by flatten I have written
 out the types for flattened type parameters just for clarity now let's
 apply this function to an arbitrary FFF a of this type so that means we
 first apply flatten to this function and then we again apply flattened
 to the result so flatten is this so we apply flatten to the result and
 there is an final expression is this so applying flatten to something means
 we have a tuple with underscore 1 5 I have a new square one go to five
 manners go to this twice so that's what you get and let's just leave it
 like this we could simplify this because there is a composition of two
 flat maps but it's not clear that this will help so let's keep it here
 the second function is the F map of flat and followed by flatten so that
 means we have F map of flatten applying it to F F F a and then applying
 flat into the result that's how it is we again do the same so applying
 to F F F a you get the first part of it if FA mapping flatten so that's
 I'm just substituting the definition of F map which is up here which is
 you take the first element of the tuple apply the map and you take the
 first second element of the tuple apply the map now these are two different
 maps this is the map from the function G and this is the map from the function
 H so that's that's what you have to do so that's what is here now first
 not pure I'm sorry I'm looking in their own thing yeah first my flat and
 second one now let's substitute a definition of the Eldar flattened here
 which will add a flat map one to each part of a tuple in flat magnitude
 to the second part of the tuple now let's look at this we can simplify
 actually because this is a map in the Hunter G this is a flat map in the
 function G and there's a naturality law for flat map so that war holds
 even for 7-1 ology because it's a largest involving flat map we're not
 using pure 4G anywhere so now we can exchange like this using a chirality
 we do that and we get those things that we've done before so flattened
 and then take first flatten and then take second so we do that simplify
 to first flat map one so now we have this expression flat map of first
 and flat map one flat map of second infinitum so now we have a flat map
 of something with flat map inside so that can be you know if you compare
 with what we have here we don't have your flat map inside flat but there's
 social DVT law for the moon ads if you look at the law for flat map that's
 exactly what it does it tells you that you can put flatten up inside flat
 map or you can put it outside and the result is the same so you can simplify
 it like this if you have flat man inside flat map and you can just simply
 find like this and if you do that again that so now this clearly one two
 oh eight nine two two three or identical so since they're the same expression
 then you social diva team or holes so the next construction is oh heavens
 haven't shown this so this is generally not saying well not even if G and
 H are semi magnets and the reason is remember how we discarded across terms
 the G of H and H of G well you cannot do that with a disjunction you can
 do that with a product but not with a son because if you want to implement
 flatten for this then you would have to combine g of g plus h plus h of
 g plus h into G Plus H G of G Plus H could just be G of H all the way so
 there could be no G of G because it's a disjunction so it could be either
 one or the other so G of G of H sorry G of G Plus H is possible to be just
 of type G of 0 plus h whatever the G of H and you cannot flatten that in
 general so that means this construction does not exist for disjunction
 of two monads to disjunction of two more lines are generally not known
 are not even a semi none of them easy the next construction is that you
 take a fixed type car and you take a function from a fixed type R into
 a semi one on G or a monarchy I will not give a proof for this I will leave
 this as an exercise I will give proofs for most other constructions and
 especially from the last construction you will see a similar kind of thing
 but as I leave for you to prove so let us now consider a construction five
 construction five is an interesting one not often seen basically it's making
 a new monad by disjunction with the type a itself I've seen we've seen
 that this is generally not a monolith you have here G and H but if one
 of them is just the identity movement then you can do it it turns out you
 need however a fro moment for a for G does not work with a semi mu naught
 so this construction is sometimes called a free pointed factor over G it's
 not important why it is called like this at this point but also later when
 we later in the tutorial when we talk about free constructions such as
 free factor or free will nod this will be one of those free constructions
 for you construct a new factor with another with a new property out of
 a factor that doesn't have this property now as I said for this construction
 G must actually be a full monad so it must be pointed when remind you would
 point it means for a functor pointed me in the natural transformation from
 identity in other words a natural transformation of type A to G of a which
 is the type of pure so if a founder has a function with the same signature
 as pure that what it means that the function is pointed so what's however
 these are theoretical considerations let's go to the code which shows how
 to implement the model instance for this and to prove that it is a lawful
 minute so here I'll again prepare my type our oasis for brevity the type
 F is just an either of a and G of a and F F is just F of F and so now how
 do we define in the monad or seven wounded instance all the easiest ways
 to define flatten in order to define flatten we need to take this kind
 of value and return this so this is an F of f of a written out info and
 this is an F of a so how can we transform this into this given a disjunction
 means where we could be given any part of it we could be given just this
 or just this or this and inside could be just this or just this or some
 combination because this G is an arbitrary monad so it could be a function
 a container having several values of this type so this could be one value
 up on the left one value on the right and so on so this could be complicated
 so how do you return a plus G of any out of this now if you are given this
 then you can just return the same with no change that is easy but what
 if you're given this part of the disjunction how do you extract a plus
 G away out of that now what seems to be a little difficult and the trick
 is that actually there is a function you can define which has this type
 which I call marriage I I don't attach a lot of importance to the name
 of this function marriage it's just for convenience let's call it marriage
 and this function can be defined to define right here I'll look at it in
 a second given that this function is defined we can map this function over
 to the factor G and lift it into G the result would be a function from
 G of this into G of G of a so we have this function and that function is
 what we need to transform this and if we were given this part of the disjunctio
n into G of G of a now we can flatten the G of G away into G of X and G
 is a mu naught and that's what is going to give us G of a and we can return
 the right part of the disjunction and we're done how do we define the verge
 function now that's a little interesting if we're given the F of G available
 means were given this we're either given a or not given G of a you need
 to return G of Allah forgiving a we use pure from the G when we return
 the uvula and if we're given G away we just return that so in defining
 this we use the fact that pure is already defined for the modern G this
 wouldn't be possible if G were a semi limit so the code for flatten follows
 more or less straightforwardly then flatten on the left of this this is
 FA so left of FA just returns that FA which is this type and the right
 of some GF it again I'm using variable names that conform to their type
 you see the type of G of F of V so if you have this then we would have
 mapped with the merge and then flattened which is flat map with lunch so
 we use that that's how it works so this flat map is giving you a G of B
 and you put that G of B in this case of GMA you put it in into the right
 part of the disjunction here so this disjunction is returned so we're done
 so this is the definition of flatten for the construction definition of
 pure is very easy because if you have an any just return the left of that
 a you don't actually use the pure of G to define this but as I have written
 here in a comment the Monad laws actually actually won't hold unless G
 is a full moon ad and we have used pure to define flatten here so we have
 used people of G already and that needs to satisfy the laws the F matrix
 standard just a slab for disjunction if you have a left apply F right apply
 F after now now just just a remark here we have been able to define pure
 without using the pure function from G and this is why this construction
 is called free pointed we were able to define a point for a pure function
 which is where old point in some libraries without so suffer the and constructe
d new frontier for this filter we're able to define the point or pure function
 without using the point or pure function on this and so that's that's why
 it's called free point it's a we wait we have information enough to construct
 the point function without already having given having been given this
 function before in the G now let's verify the laws i this is rather reasonably
 simple the first law and the second law for pure these let's begin with
 them so first we have a pure and then apply flatten so take some arbitrary
 FA applied pure to it and then apply flattened to the result now pure over
 failure is just left over fade that's the definition of pure now we flatten
 the left when you flatten the left it just gives you the value under the
 left therefore flatten of left of FA is just FA and that's the identity
 function as required now flat map of pure sorry F map of pure followed
 by flatten that also has to be identity now let's do a F map of pure and
 applying it to some arbitrary FFA I think I'm making again the same mistake
 as before let me check yes this type must be F to F naught F F F F and
 this I also should ever need so now this must be of type G yes good all
 right so let's go through this derivation first we substitute the definition
 of F map which is this where instead of the function f we use pure so we
 write this code but we put pure instead of F so that gives us this code
 now we can substitute the definition of outer flattened which is if you
 have a left than you so you see if flatten is applied to the result of
 this which is either this or that so we take these things and apply flatten
 to this which will be that and we apply flatten to this which will be that
 because the flatten of the right is a flat map merge all right so now we
 have this code now we need to simplify well what can we simplify here not
 obvious well so they have this map and flatmap and these are in the Mona
 G so Mona G must have its natural T law for flat map so once you use that
 this law and we use that law with F being equal to pure and the result
 is going to be flat map of F and then G so pure and energy so pure and
 then merge is the same as pure now this pure is our pure that we are defining
 for F is not the pure virgin I always write explicitly this for the pure
 for G because it is easy to get lost otherwise so pure is not for for G's
 for F now if we substitute what it does pure and then merge so pure gives
 you any left of something emerge of the left is a monad G pure of the content
 of the left so that means we have a monad G pure so pure and then merge
 is the same as moment jean-pierre so let's substitute it in there so now
 we have this code we have a flat map of cannot G pure and this flat map
 is in the mono G because I'm reminded by the name of this variable and
 I can check this also with IntelliJ was I'm sorry can you check it because
 it's because it's in the comment so I can check it here so the this is
 of type when this I should have said I should've called this da for less
 confusion but it's just names and variables doesn't even matter what they
 are but it's just helping to see what types they are so flat map is in
 the Mona G and therefore we have a low flat map of pure his identity so
 therefore we have this that is obviously identity so this verifies the
 identity laws for a woman if you know let's look at the associativity law
 oh yeah and I never mentioned any naturality laws for monad if we don't
 check them because the code already guarantee is not reality there is nothing
 in the code that uses specific types such as a being int or string or anything
 like this the code is a composition of functions it is substituting functions
 into arguments that is completely natural in the sense of natural transformatio
n so any code like that is fully parametric it uses functions such as swag
 map which are already natural transformations by assumption as they are
 in the moment G so compositions of natural transformations are any kind
 of use of natural transformations will be natural so we don't need to check
 much rather many of this code any of these constructions are automatically
 satisfying when chirality laws but associative eg1 needs to be checked
 so go on to check that law to check that law we need to compare this so
 flatten off flatten and this flat and F map of flatten begin with flatten
 of flatten so we apply flat on a flattened to cell FFF a so first we substitute
 the definition of flatten which is this and then we have the outer flatten
 on that substitute again the definition of outer flatten which means that
 on the left hand sides stay but the right hand sides get a flatten applied
 to them with me this is like that so left FFA goes to flatten of the FFA
 and write G FFA goes into this I can't simplify this anymore well I could
 like a sec before get another flat map the flat map that could be simplified
 into a flat map of large and flat map of merge I'm not sure that will help
 any right now so I'll keep this code as it is and look at the other one
 maybe we'll see what we need to simplify if we need to so the other code
 first so I define this function which is I don't do it now by steps this
 first do it right away so this function is going to compute that so it's
 just F map of flattened applied to an arbitrary FFA and then we apply flatten
 to that so first we substitute the F map of flatten of F F F F which is
 this this is a definition of F map where we put flatten instead of the
 function f so now we have this flatten and also this flatten inside go
 on substitute the outer flat so that means we apply flatten to these right
 hand side parts so this will apply flatten to this and we apply flatten
 to that so flatten of the left something is just that something so that
 inner flatten still remains here see I put type parameters explicitly so
 let's color compiles because I remove this it's read interesting right
 the types are correct and just that Scala cannot infer that your guess
 would be Piper it must be and this is often the case also here I had to
 put it in now notice this outer flap has been substituted already this
 is the inner flap in that still remains and this is also the inner flap
 them that still remains so now if we compare these to the left case is
 already identical so we don't have to worry about it anymore the right
 case is not yet identical it has this versus this so let's continue we
 need to show that these two are equal it's easier if we just stop writing
 all this code and start just reading one next smaller expression at a time
 so in the last expression we have a map and a flat map from the factor
 G so let's combine them using the natural to look for G and then we get
 this now let's substitute the definition of flatten and keep merge as it
 is we have merge applied to the result of flatten so see this is just the
 code of flatten if you get rid of merge here then it's just going to be
 the destination of one so now we can substitute the definition of merge
 on the left so merge over Roger Bobb this weekend up simplify but we can
 simplify it on on the on the right so merge of the right let's look at
 again a definition of marriage what it is mergers right is just the content
 of that right good so it's just going to give you this so that's the simplifica
tion we can do so now let's compare so we were supposed to compare these
 two functions we have simplified the second one and we got this expression
 so let's compare so now it seems to have a flat map on here of some larger
 function and here we have two flat maps of merge in order to compare them
 would be easy to merge these two flat maps together using associative et
 law or combine them together here and if we do that we will then have to
 compare GFF a flat map of blah with Jake if a flat map of something else
 and that would be a direct comparison we can drop jmf a flat map and compare
 those things inside so do that basically we need to compare the two functions
 inside flat map inside this construction and this is fine because G FFA
 is an arbitrary function sorry an arbitrary value and so if we show that
 these are the same and obviously we will have proved associativity long
 so then the result so far is that we need to prove that these two functions
 are the same these are the functions inside the flat map let's take this
 function substitute the definition of marriage and I put a flat map so
 if you delete this flat map that would be just a definition of merge and
 we have applied flat map on its result so far okay now we need to compare
 this and this the right cases are identical the left cases are not immediately
 identical but again we have here pure from model G and the flat map of
 money on G how do we know it's from one engine because as a result of pure
 is a G of something so that's going to be a flat map also in G therefore
 we can use the identity law for G and that's just that function so that's
 just going to be emerge of a fade which is exactly this so when once you
 simplify this you get this therefore both cases are identical so this finishes
 the proof of the associativity law for the thunder F notice that we have
 used both the identity law for G when we did this combination and we use
 the associative law for G when we combine the two flat maps on the G so
 G must be a full moon odd for associativity here to work he also must be
 a full moon odd for identity lost to work but this shows that unless G
 is a full moon that even associative et law would not call for F so it
 wouldn't be an even a semi movement unless G is a full moon that but if
 g is a film on that then f is also a full moon that so therefore we have
 shown that this F is a full monad for G also being a full moon and that's
 the only construction we can show the next construction is this one now
 it's a G which is an arbitrary monad applied to this type expression which
 is a kind of a linear function of a type A with coefficients Z and W where
 Z is a fixed type arbitrary type and W is M you know it so this is a kind
 of a straightforward construction if you understand and will not transformers
 but I just mentioned this for people who already know but if you don't
 know yet then this is just a construction that can be shown to work so
 let's see why that construction works now I'm getting tired of writing
 up all these type parameters all over the place like this so I'm going
 to cut down on the boilerplate in the later part of this tutorial and I'm
 going to just put these parameters up front so I'm going to define all
 the code inside a function that already has these type parameters and then
 inside I don't need to talk about these type parameters this is just to
 calm down unavoidably all right so now for this construction what we need
 is to apply some arbitrary Menagerie a type constructor which is this either
 of Z and tuple of W and a and this allows us to use a type alias now to
 define these things because g ZW and so on are already defined as type
 parameters up here all right now actually p is itself a monad and that
 will be an exercise line to show we have seen parts of P so to speak we
 have seen this this is the writer muna and we have seen that is either
 monad this is a combination of either and writer and this is also honored
 mathematically speaking this is Z plus W times a and so this is like a
 linear function of a which is kind of a simple example of a moment all
 right now f map is defined in the obvious way if you have a left of z you
 don't you don't change it remains left of z if you have a right of tuple
 w a then w doesn't change you transform a now we can write a cat's monad
 instance if we feel like it cats monad is my own typeclass that has flat
 map and pure and that can automatically export your model into cats how
 did you find Flattr Wallace is a little maybe come ok but it's it's very
 straightforward for P you don't do anything with the left and then you
 map on the right because on the right you have an a so you have some W
 1 a 1 you take f of that you get a P of B then you match that if it's a
 left I mean again you return the left if the right and you now you have
 to double use but you combine using the semi group and you have a a 2 which
 is actually a B so it should not be called a 2 but snow nameless you call
 this B to be more clear the pure function is defined clearly us is a right
 of every team annoyed value of W and they that you're given so that's clear
 but just like the right terminal and either Martin died so the flattened
 defined for P I'm writing this code here because we will need it for reasoning
 so let's look at how it works so we have this type expression and we want
 to convert it into this how do we do that well if we have a Z so see looking
 at this type expression means that we can have a Z or we can have a W times
 Z or we could have a W times W times a because this is just like school
 algebra so you just expand parentheses and plus and times symbols distribute
 so if you have a Z or if you have a W times Z you cannot possibly return
 on a T so you must return you see here the other case is that we have W
 times W times a so you can return an A and you combine these two w's so
 that's what this chrome does were consistent done so we have flattened
 and F map for P which I explicitly defined as flatten P and F map BMI also
 you find a flat map for people let's not let's see how we can define the
 flat map and flatten or something for F now for G we already have flat
 map and everything we just want names for them for convenience so I you
 find them here again with these names I'm using already defined called
 from a functor and the mall and typeclasses for G so that's just for convenienc
e because I we need to reason about these F map and flatmap G and so we
 want to have these functions but of course we can't reason about these
 much because we don't know what these actually do this is an arbitrary
 monad so we don't know what code is inside lease all we know is the properties
 so we know that this is a lawful monad or semi unit so it's the same story
 again we will see that to prove associativity we don't need the pure from
 G and we don't need the pure when we don't need the laws of identity for
 G we only need the social tivity of G and so if G is a semi wanna this
 will be Samuel F G is a film owner than F will be also a full moon on the
 F map for F is defined by doing a functor map on the function that takes
 a function P map because that's just a composition of two functions so
 f is defined as a composition of G and P so it's a composition of two maps
 map of that but let's write down the short notation which will be quite
 helpful so f map f is f map G of F of F of F or we can write it like this
 which is shorter and let's see if we use that in reasoning in a certain
 way so then we can define a function instance for g sr e 4f by composing
 my factor instances and we can define pure for f so this is a pure for
 F I should have probably called it a few F just so that we are not confused
 let me do this so pure for F is defined in the usual way we take the pure
 of G and we apply that to this which is a pure of P right when you find
 pure of P in here so pure of F is just your F equals purity followed by
 energy just like F map is like this curious like this let's see if this
 will help us reason about it so now the interesting part comes I need to
 define flat for this functor so the function f is G of P of a and so flatten
 needs to transform F of F of a into F of a so f of F of a is this and we
 need to flatten it into just one G and one P so we have two Gs and to peace
 and they are interleaved so somehow we need to transform that and we could
 transform this if we change the order here of p and g players if we could
 transform that into this type then it would be easy you just merge this
 flatten this into one G when you flatten that into one P and you're done
 so what you need is to define this so-called sequencing function which
 changes the order in the sequence of applying factors so it takes P of
 G of whatever and returns G of P of that and this function does not always
 exist for all kind of funk stars PMG you won't be able to define in general
 such a function but this function will exist for a specific factor T which
 is defined specifically by this type expression so for this function key
 and front a few other such factors this function will exist for the function
 changes the order and let's define it now how does it work so it's supposed
 to take a PGC and return this so well P is either the only thing we can
 lose to match so what is the result of matching if we have a left of Z
 then we should return a G of something well the only thing we can do obviously
 is use the pure of G to return the left of Z because there's no no way
 for us to return any Ace or double use in this case if we are in the right
 then we have a G actually and we have a W so let's see what we can do with
 this we can take this GC and map over it and we can add the W to that see
 what's inside it the result will be a tuple of WC we could put it into
 the right and that will be of type P of C and so now we have G of G of
 C exactly as we need so this is a little involved but that is a very important
 function without that kind of function was no hope to define this construction
 for a composition of two funders being imminent so seek this function seek
 is a transformation between functors P of G & G of K and since it's it's
 you only uses natural transformations and fully generic code fully parametric
 type C is anything we don't use any information about what C is then it's
 a natural transformation we don't need to verify the natural anymore and
 this is a naturality war the functor on the left is PF Geneva function
 on the right as G of since of maps must be in the first factor and F maps
 in the second factor that's a natural G law that exchanges the order of
 F map and your natural transformation so I'm not going to verify this because
 of the permit tricity theorem but it could be done there easily of course
 in the same way as we verify all these other laws just write down the code
 of F map PF map gene so one of you transform and substitute and simplify
 and you get that these two functions have exactly the same source code
 and so that's just a waste of time to do that because the chromaticity
 theorem guarantees naturality but you could do it so now let's define flatten
 for F we define it like this it was a monad G flat Maps it's a flat map
 from G which takes a function of complicated type so let's look carefully
 what it does we're supposed to do F of F of it now F of F of a is actually
 G of P of G of P of a and if we flatmap with something then something must
 be of type P of G of T of a going to something so therefore the inner function
 must take P of G of P of a and return something well what should it return
 well it should return G of something because that's what flat map does
 that map takes a function from some X into some G of Y and the result will
 be G of Y now the result must be this therefore this function this inner
 function that we are not yet ready to write this function must take this
 type and finally return that type so I'm showing how I got got this how
 I derived it you see I'm completely looking at types and I'm not guessing
 I'm just saying flat map must take that type and that's what it should
 be and it should return that type in order to return this now how do we
 get from here to here obviously we use the seek which will interchange
 p.m.
 G into G and P so that will be this and then we flatten P but flattening
 of P must be done under a layer of G so therefore it is F map G of flatten
 P and once we do that we're done so therefore the type of this inner function
 must be this and G of flat map of that type would be a function of this
 type exactly as we need take some time to check this so that the types
 are correct a flat map the right type parameters and if you once you have
 checked it it will see why it must be like this this is flatmap must have
 that signature G of X going to G of Y having a function X - G of Y as an
 argument and so X is this why is this and then if everything works so finally
 this is the code I'm just writing what I have seen what would I have done
 here secret random f9g faculty so this little piece of syntax is necessary
 for Scala [Music] for some reason I think it won't compile I had trouble
 compiling it um without this but this is basically saying that this is
 a function the seek is a function it's unnecessary parenthesis but let's
 put them in for clarity all right now the short notation for this function
 would be useful for reason is that I take flatmap in the G mu not of this
 composition and you can use natural T for flat map G to rewrite it like
 this so now actually we are in a very good shape we don't need to write
 code because the short notation works well enough now in the previous examples
 I didn't do this and I wrote the code but let me try to avoid writing code
 I could do the same as I did before just keep rewriting the code but let
 me see if the short notation works maybe it will work on up to a point
 alright so in order to verify the associativity of all we need to verify
 that this is equal to this so let's verify that F map F of flatten F followed
 by flattened F so we just substitute this definition of F where F which
 is this and then substitute the solution of flatten F which is yes flat
 map G of seek followed by F map G of Kelantan P so I just put it in here
 and put it in here and here I now look and try to simplify these things
 so how do we actually simplify anything like this just looks very complicated
 the way to do it is to try to understand what parts of these things belong
 together to be simplified so for example F map G and F a level G they can
 be manipulated because they're in the same factor and there's naturality
 law with interchanges flat map and F map or flattened and F map it has
 a much reality law but only in the same factors so flat map P does not
 have any natural ality law with F map G so we have to pull these things
 together somehow in order to in order to simplify anything so for example
 I want to use natural 'ti of seek how do how can I use it the only way
 I can use it is what I have F map P of F F of G of some F immediately before
 seek and here I have what I have seek here and seek here nothing is immediately
 before it so somehow I want to pull this thing together so that it's immediatel
y before seek and then I can achieve maybe some simplification using neutrality
 for seek so how do I pull that together well I have this I have this thing
 F map of this so let's see if we can first use this naturality which is
 f map G of something and FLL G of something else appears at higher level
 we have F map G of all this and F LMG of this so how do we pull this together
 we use this naturally G law and we apply it so we apply this law and we
 get FLNG of a big thing so that's the first step so inside is going to
 be all this stuff without the second F of energy because the second of
 all energy is going to be out so the result is that we have one big FLNG
 so by combining this and this [Music] using parentheses here somewhere
 just to be completely pedantic one two three two three two one zero that's
 right all right so now we have combined this F map G and F LMG into one
 big ecologic the result is this FLNG of this so now does this look like
 seek of and although to the left of seek I have [Music] F map PF mataji
 of something does it look like that to the left of seek I have F naught
 G of something but F map P is over there it needs to be immediately here
 below to the left of this so how do I get that well if map we can split
 so f map of composition is f map of this followed by f map of that so we
 can split that in the factor P the result is this F map p f mappy seek
 ethnology great now this is what we wanted we wanted to pull together C
 and F map P of F map G of whatever now we can pull this on the other side
 of seek by using that reality of see so much relative seek is this one
 and using this law we pull it and the other side of seek and also it exchanges
 the order of F map J and P but that's okay so the result is this now that's
 examine this we have F naught G F mataji let's pull them together maybe
 we get an F map G of this now this is a social dignity law for B it's equal
 to just flattened P followed by 20 people so this is a social activity
 law for tipping the result is their fullness now let's pull it apart and
 we get F map G under F L M G so then we can pull that out maybe it's not
 clear that this will help but let's just see if that helps because we still
 haven't seen the other expression so maybe the other expression will be
 similar to this all right so at this point there is nothing else we could
 usefully simplify let's look at the other expression the expression is
 lists so we substitute the definition of flatten F and we get this so now
 how can we compare this code and this code well both of them end in the
 same way that's good but this part is one big flat map and this part is
 so I have F map flatmap so we need to combine this into one big flat point
 to do that by using naturality and associativity of G we can do it so naturally
 allows me to pull this inside the flat map which gives me that associativity
 allows me to pull the second flat map inside the first part map which he
 gives me this so the result is one big flat map with this followed by this
 piece which is the same as that so don't want to compare you could say
 except for what's inside the big flat maps and both of these functions
 have the same type and look at the types yeah quite complicated but I just
 want to write down what we had here F may have seek holiness here after
 my PF a flat map G of seek followed by seek followed by this I just write
 down Scala code for this in order to make sure that everything is still
 like checked and correct so this is that now a short remark here about
 rotation all these computations I've done here I've never mentioned any
 types as if the types will always match whatever I do why is this why don't
 I need to check at every step that all these types are correct no the reason
 is that these functions are polymorphic they will adapt types to each other
 as long as types can match they will adapt as necessary each of our laws
 is a fully polymorphic fully parametric type function and so if the argument
 type ins to be changed it can be adapted automatically if will never leave
 their type mismatch whatever you substitute if a function is equal to another
 is substitute maybe the type needs to be adapted but it can be always adapted
 because there's always some more general type for which the laws hold which
 is the way we usually write them so for example for this law this goes
 from F of F of F of a to f of a but a is completely arbitrary so as long
 as you put that into any expression a might adapt to something and because
 it's an arbitrary type type but adapting won't ever break any types so
 the laws hold for the more general types compatible with these function
 signatures and that's why we don't actually need to check any types while
 we do this kind of manipulation so now let's see now these two functions
 is not obvious that they are the same there are quite different so first
 of all it starts with seek with a different type parameter and this is
 the seek under F met P FLNG it's completely unclear whether this is the
 same and it's probably not the same as this you follow it by flanton P
 under F map G and here the flatten PF my G is at the end and so it's not
 obviously these functions are the same so let's maybe write the code for
 these functions actually we're maybe trying to evaluate them on some on
 some values because it's impossible to simplify these expressions further
 in order to to show that they're equal simplify what I mean is that it's
 impossible to simplify by using laws of flat happens fmg symbolically like
 this and not actually getting inside the code of seek for example so these
 functions are equal but only for the specific code of seek that we defined
 so that's why we need to now go a little deeper into the code so the arguments
 of these functions are P of something because of that the argument can
 be either left of Z or a right of that so let's apply these two functions
 to a left of Z and then we apply to these functions to a right of this
 and see what happens so if say X is left of Z if we substitute the definition
 of seek then seek of left of Z where it is assumed to be of of that type
 of this type so Z left of Z is still of this type then the sick of it will
 be by definition of sick if you substitute into the code it will be this
 and flatten of it is just left of Z so you substitute the flatten P and
 again that and so if we try to evaluate F 1 which is sick followed by F
 map G or flatten P and followed by flat map G of Z so what happens first
 we do seek so we get a pure then we apply flat map so we apply a F map
 G of flatten so inside this pure applying F map means applying the function
 to this so we apply flatten to this we get left and then we do a flat map
 of seek on pure and F map of seek on pure is just sick applied to this
 left of Z which is this so sick of left of Z is ma not be pure of left
 of z f2 on the other hand gives me a trivial result because this F map
 doesn't change anything because I have a left of Z so f map P is identity
 on that so I have left of Z then I have seek which leaves me sick of left
 of Z which is this and then I have f map G again a flat of P which is the
 same as what we'll just complete it and so it's both f1 and f2 evaluated
 on left of Z will give me the same result so that is the first case now
 let's look at the second case that's going to be longer if X is the right
 of this then we need to compute think of it which is going to be that after
 seek we compute F map G and that means we are we're already inside map
 in the G function so we just add another map in the G factor so we do that
 the result is we can combine the two maps into one and first we apply this
 to some PG and then we put a flat mu P on top of that so that's the function
 we get therefore [Music] finally f1 so if one is seek than this and then
 flat map of seek so add that we can put in a map and flatmap by that's
 reality because they're both in the g-factor and when we get seek applied
 to that that's the result now this kind of thing is the result of F 1 of
 X now for F 2 of X we first compute a flat flat map G of seek under F map
 P which means that well for the functor key F map Maps the right and it
 leaves W unchanged that map's the value of x a so then we get this and
 then we do a flat map of seek on that finally we apply a seek so let's
 go back to definition yeah so we have done this so far we apply seek to
 that then we have to apply this so it's saying that we apply over here
 okay ply seek to that we and get this finally we apply F map of level B
 to this then we just tack on document flooding because this is a all these
 flat maps maps and maps they're all all analogy functor so let's pull out
 into one flat map using naturality begin this so now the result is we have
 F 2 and F 1 of X computer F 1 of X is this F 2 of X is is that both of
 them have the foreign GPG dot flat map of dois so we need to compare just
 those functions this functional body let's compare them one is this and
 the other is that now it's kind of hard to compare this because PGA is
 arbitrary W is arbitrary what can we do so what's pattern match on PGA
 and well I should have written code maybe but I always let's just substitute
 values and see if it's working better so PGA is either left Z or is the
 right of this with some W 2 and G if it's a left z then let's look at let's
 look at that so flatten of this would give you a left z but can't give
 you much else you couldn't possibly give you a right of anything because
 it doesn't for the right you need you know W so you have a lefty so sequins
 LLC is pure G of Z and so we have pure J of MZ as a result for f2 we have
 so we'll look at this function where PGA is left z c curve left is pair
 G and then pure G of left GU map whatever you want to map the Z is not
 going to go anywhere it's no it's not going to change so the result is
 this so therefore for the left these two expressions are the same so now
 it remains to compare these two expressions if PGA is right of something
 so we compute that and the result is that here we have the flattened p
 of the right of this and here we have to combine W and W tube using a semigroup
 operation the sick of that is going to be equal to this and for F 2 we
 perform similar computation and we basically again have the same expression
 because the flatten P works like that and that finishes our proof so I
 tried to make it shorter so part of the way I was just doing symbolic computati
on at the level of factors and units with no specific code so this would
 be general but after this point I could not continue the fully general
 computation I had to put in a specific code for seek and flatmap flatten
 P and so that's at this point maybe it will be sure to just start writing
 code and compare the code for these two functions but I found that if I
 first substituted left it was very quick and so onion it this way the next
 construction is this one it's a very important construction because it's
 recursive function f is defined recursively and it gives you a monad for
 any functor G a and G does not have to be a melody itself so this is the
 only construction here where get a moon ad out of a arbitrary factor rather
 than out of an arbitrary another one odd but because you get a moon ad
 out of an arbitrary factor so to speak for free remember it's called a
 free monad over G I mean mentioned that there are constructions called
 free constructions that give you properties for free well for free means
 you don't have these properties in the data that you are given and you're
 just creating them in some way out of the structure of new functor but
 in a later tutorial I will explain the free constructions in a more detailed
 presentation so for now it's just a name for this construction so let's
 see how it works now we have seen this construction in the examples and
 this was the G shaped tree functor so the G shaped tree in other words
 a tree with G shaped branches that's exactly this construction so the tree
 has either a leaf with a single value of type A or it has branches inside
 a functor G so the function G distribution describes the shape of the branches
 and under it each branch there's another tree again of the same recursive
 shape so let's see now how this how this works we assume an arbitrary function
 G not Superman I said yes so it's any function G wasn't this functor doesn't
 have to be itself Amana I define this function construction seven just
 so that I have fewer things to type now we can't define the type alias
 for this because it's recursive so I have to define a case class with a
 type parameter and that forces me to have a name for this inner part but
 that's not going to be used much so this is just a plus G of f of a how
 do we define flatten and F map which thing as before it's the tree the
 G shaped tree so f map on the leaf it's just a transformed leaf F map on
 a branch is the same F map recursively applied to each value in the branch
 container so G works as a container but may have one or more values and
 that's the branching if it has more than one value then you have several
 branches the flattened works by keeping leaves as they are so if you have
 a tree of trees and the leaf of the tree means you have just a single tree
 in return that tree if you have a branch then you need a map of flatten
 so this recursive case is going to be the same for all these of these construct
ions this code cannot be written otherwise they have to map over this functor
 with a recursive call to the same function pure is defined by just returning
 a tree having a single leaf that carries that given value let us verify
 the laws this is the identity second identity law we just substitute the
 definitions again so to verify this law we need to take some arbitrary
 FA apply pure to it and then apply flatten to that result so let's flatten
 of pure of F a substitute the definition of pure will get F of left of
 F a substitute definition of flatten what's FA it's against identity and
 let's compute F F map pure of flattened but actually it will be may be
 helpful to compute flatten the F map of something followed by flatten is
 flat map where definition so let's compute that function first flat map
 so how do you do that so it's flattened of F map of F of some arbitrary
 FC what's the definition of F map is this matching with recursive cursive
 match and when we substitute the definition of flatten which means that
 we apply flatten to these right hand sides of this match so this remains
 the same the right hand side is flattened flattening this gives you f of
 C flattening this gives you that and we can replace F map don't flatten
 because this is map of this dot map of this which is equal to dot map of
 this followed by this and we can just replace that again by a full line
 because that's the definition of you follow so that's going to be the code
 for a fella so again just your cursive keys is always the same we just
 use different functions of your map that's always the same alright so what
 is now a full MP rifle unpure is this f LM Puran must be in apply this
 to arbitrary F a substitute the definition of a for Lam which is this put
 P you are instead of F and so then again this now pure of C is f of left
 of C by definition so this first case is just identity by definition of
 pure the right case is this now if we have proved that it is identity on
 the leaf now we have a recursive case now we cannot directly prove that
 it is identity because we don't know what that is we haven't yet shown
 that the right case gives also identity so we need to prove this by induction
 induction is on the structure of the tree if we are in the leaf we have
 proved that it is identity if we are in the branches and for each branch
 we've already proved that this is an identity then we need to prove that
 it's identity here in other words we need to we can assume that the is
 identity when we recursively call that function once we assume that then
 it's obvious just map identity so this is f of right of GFC and so that's
 clearly identity so assuming inductive assumption which is that this function
 is equal to identity on any of the sub-trees we can prove that it's equal
 to identity on the whole tree that's how all these proofs are going to
 go for recursive functions that's the only thing you can do you assume
 that the recursive calls to your function already satisfy the property
 that you want and then you prove that's the inactive assumption then you
 prove the step of the induction alright so this proves the identity laws
 let's now prove the associativity law so she'll give it a law which is
 this you know let's write down the code for these functions apply this
 function to an arbitrary FFF a of this type substitute the definitions
 we get this so the left case is that the right case is kind of complicated
 so we can substitute this into into the first map so that will be flat
 and followed by flat which is the same as this function so now we can therefore
 write the code like this so you see all of these functions are always going
 to have the right case using exactly the same code so that's kind of a
 boilerplate isn't it there is a way of getting rid of us but it's more
 advanced these are called recursion skills and I will talk about this in
 a different tutorial but for now we will just keep writing this boilerplate
 each function will have a second case of this of this sort now flat map
 flatten is the second function we need to compare with this one we have
 substituted again flat map instead of this composition so flat map of flatten
 applied to an arbitrary FFF a what's substituted definition a flat map
 which is this and then we get if we rename FFA to instead of C then we
 get the code that's exactly the same as this except for the name of the
 function and the recursive call is of course to the function name differently
 so if we rename the function rather than we can't distinguish the two functions
 in the world so it means that their code is identical so this shows the
 associativity we have not used any properties of G other than map so all
 we have here is this map from G we have not used anything else we have
 concatenated the two maps into a single map that's a property of a functor
 and the composition law we have not used any other laws for G and so therefore
 indeed we have produced a monad out of an arbitrary function G the next
 two constructions are in general only semi winnette constructions so they
 do not yield full o'Nuts the first such construction is the G shaped leave
 and D shaped branch tree which we have seen before so leaves are of shape
 G and the branches are also a shape G that's a tree like this but we'll
 see it cannot be made a film or not only a Samana so what's looking this
 construction will show that it is not a Mona so how well let's define first
 so we define again a case class with type parameter it's a recursive type
 because it uses F inside itself so it's on either leaf and so we have G
 for functor G describing the leaf and the factor G describing the branches
 imagine that G is a pair of a a then this will be a leaf consisting of
 two values of n this will be two branches F of F of F consisting of two
 new trees so that's either two values or to introduce notice that the shape
 of this tree so the flattened can be defined certainly and by redistributing
 leaves in two branches so if you're on on the left and you have these leaves
 then you just these are leaves so you have G of F of a so this is of type
 G of F of a and that's what you need to return can return the right of
 that and you are in here you're in the right part of the either and so
 you can just immediately return that so essentially you're redistributing
 G leaves into G branches you have this option because the tree has this
 shape the the right case is just a recursive case doesn't do anything it
 just repeats the same operation on the branches F map again same thing
 you map over the leaves and you do the same operation on all the branches
 now I will leave it to exercise 15 to show that this is associative the
 proof is somewhat similar to associative 'ti of the ordinary train but
 I will show that you cannot make this into a full minute here if we wanted
 to do that and we defined pure well we need obviously a methodology in
 which which makes you some valium well suppose we had one maybe you can
 always have a pure from the free construction if you have any any factor
 say H that doesn't help here and you take an either of a H and that has
 a pure and just a pure rule on being left away so that's a free point to
 do for that construction you can always so that's it you can always do
 that so let's imagine that G has a pure method whatever it is then we can
 generate G leaves by using that method and we can define pure we could
 also generate G branches like this by doing recursive call of the pure
 but that's of course infinite recursion so that's not that's not great
 that's not it not great at all or we could terminate that recursion at
 some point for example we can do a pure of a which is this one-step pure
 generating leaves and we can put that into branches into another peer so
 it's pure of pure base because it's kind of a two-step regenerate any branches
 but each of these branches is a leaf itself so you could do this you could
 imagine defining pure in a number of ways and none of this works here is
 why we need to have this Lord some flatten of pure needs to be identity
 on an arbitrary FA of type F of a so flatten of pure if we substitute definitio
n of pure is like this I'm substituting this definition the first one the
 most straightforward one and the result is that flatten will redistribute
 the leaves into branches and so the result of this is always going to be
 a right of something there's no way this could be equal to FA for all FA
 what if I face your left that's it you can't do it it's not going to be
 under the identity function now no matter how you implement pure whatever
 pure returns it to be turned left it could return right after flatten you
 will get our F of right of something so there's no hope that that could
 be an identity function because it will never return an F of left of something
 and it must do that for some FA like let's say for this kind of a thing
 and so already we see that the left identity law cannot possibly hold for
 for this truth no matter how we implement peel one of these implementations
 we'll have a look all right so I keep you busy with the exercise that will
 show a social duty of this some walnut and only one construction is left
 this construction is unusual because it gives you a mu net out of an arbitrary
 contractor or a semi Monad out of an arbitrary contra funder and a functor
 similarly to this construction a full monad is only obtained when G is
 absent so this is a construction that gives a full moon of the results
 are different from those in the construction we have seen before those
 in construction - or here you could have a moon out where G is a moment
 not just an arbitrary factor here you cannot have a moment even if G is
 a moment we will see how that works to define this construction we start
 with semi Malad so assume when G is an arbitrary factor H is arbitrary
 contra factor and we define the type F as a function type going from H
 of a to the pair of a and G of a we will have to define a filter instance
 for F for this it is convenient to find to define a function instance for
 this type instructor which I'll denote F map a G which is what we've seen
 before in the previous construction in the construction - this is the same
 type constructor now F map F is defined like this so did you find it we
 need to take a function f going from A to B and arbitrary value F a of
 type F of a which is this function so f a is this function and we need
 to produce F of B which is again this kind of function will be instead
 of a so to produce that we write a function expression starting with HB
 and then we have to return here a tuple of B and G of B we do that by using
 F map in G that returns us a tuple B of G of B and we apply that F map
 F on some tuple of a G of a which we obtained by calling this function
 on em h way how do we get an HIV when we have H of B we use contra map
 on H of B using function f so contra map goes in the other direction takes
 a function of a to b and transforms h of b to HIV so in this way we obtain
 the correct type and there is no other way of doing it now how do we can
 compute flatten well we need to define a function that takes an arbitrary
 f of F of a and returns F of a how do we define that well to return F of
 a means to return a function of this type so we start the code by taking
 an argument of type H of a and we need to return now a tuple of AGOA we
 have a function of this type what we need is to return this tuple of a
 G of a so clearly we have to call this function on something there's nothing
 else we can do we cannot just create a tuple of type a G of a out of no
 data so we have to call this function but on what argument we need to get
 an argument of type H of F of a in other words of this type and suppose
 we can do that then we call F F of F FA on this we get a tuple of this
 kind well then we could discard the second part of the tuple and we get
 our F of a as this as as as required so it reminds just to get somehow
 a value of this type so how do we get the value of this type well we actually
 have a value of HIV so what we need is to produce H of F of a using HIV
 while using HIV because they have no other data at the moment so let's
 think about this so we can use contra map on H of a to get H of F of a
 and the control map would need a function of this type fly control map
 there's nothing else we can do with HIV H of a is a value of an arbitrary
 control function H we don't know anything about it and we the only thing
 we can do is to use control map on that control factor and notice we are
 trying to do nothing special with these types will not trying to match
 on types or use reflection to see what that H is we just use information
 that is available which is that each is a contra factor and G is a factor
 and since we keep doing just that the result will be a natural transformation
 so we're not doing everything special with specific types always fully
 generic in our type parameters okay so how do we get the function of this
 type of F of a going to a is a function that can be written like this it
 takes F of a and produces an e so how do we produce an a well we must apply
 F of a to something to produce an e F of a is this type so we need to apply
 F of a to some a tree and we have one this one so we apply F of a to HMA
 we get a to go NGO a we take the first part of the tool and that's an e
 so that's the function we need here on which we use contra map I write
 out the argument the type of argument of this function for contra map to
 compile because if I don't Scala will get confused we're done with this
 so we now have defined a value of type H of F of a we can apply FFA to
 it and get this and then we take the first part of the two ball and that's
 an F we apply that to H a and we get what we need so this is a bit convoluted
 but this is the correct way were the only actually way of doing this or
 implementing the type now let's think about this a little more and think
 about how we can simplify this flat map flatmap or flat pack flatten well
 this thing is a function that takes HIV and returns hm f of a and it turns
 out that this is a function we will use repeatedly so let's define this
 function separately with the name I call it insert f because it inserts
 a layer of F inside a layer of H which can be done with this specific type
 and it just usually cannot be done like this you cannot insert something
 into another type constructor arbitrarily but it is done as we have seen
 with these types so I just copy this inside the code here and then I can
 write the definition of flatten in a shorter way as this f f/a instead
 of H if a I use this so then it's clear this is a function of H a so the
 argument of AJ is used twice because of this it's hard to rewrite it in
 a point free style point free style means we don't write arguments of functions
 we just write function compositions so if we didn't have this application
 then I would be able to write it in a point free style as FTL equals 50
 n takes FFA and the result is a function that takes a chain applies insert
 F first to H a let me let me write it in a nice way I'm looking for the
 functional composition symbol this one copy it over there so first we apply
 insert if tha then we apply ff8 TJ and then we apply the first element
 in the tuple extraction but actually this still has to be is still a function
 that needs to be applied to each e and there's no nice way of writing that
 down so can't really write fully point freestyle and also a fully point
 freestyle would be the FT N equals something I'm not f TMF FFA or something
 and we can't do that is that the phase used like this inside it's very
 hard probably you could invent a notation for this will probably not be
 very useful for reasoning about it so that's I'm not sure if anyone has
 an invented notation for the point freestyle for such things and if so
 it's probably not very useful for reasoning but in Haskell ecosystem there
 is a tool called 0.3 that transforms functions into a point freestyle the
 result of that tool not always eliminating so we tried we don't see how
 much much useless let's not do it so we'll keep it in the code let's now
 verify the associative a table so to verify a social deity we need to compare
 this with this so let's define the first function which is a composition
 of flatten and flatten this function takes an arbitrary FFF a first it
 applies flatten to that so which is a flattened with the type parameter
 F of a I'm copying now the short definition of flatten and I rename h8
 of HF a because that's the type of that other than that it's the same code
 now I apply flatten to this code which means I write again this expression
 but instead of FFA I take this this function so this function is applied
 to insert F of H a so that means instead of this I have insert F of H a
 so instead of H F a I have insert F of H a so I just substitute I write
 this and instead of HFA I write insert F of H a so then the result is this
 I have now insert F of H a and insert F of insert F of H a because I substitute
d h fa into here the second function well there's nothing here we can simplify
 so at this point let's keep in this way we'll see what we need to transform
 when we look at the second function so the second function is flat map
 of ATM of F T n followed by F T n so we take F F F a we first applied flat
 map of F T onto it which is sorry not a flat map with F map so F map of
 f TM is obtained by substituting the definition of F map which is this
 so we copy this code in here and I just renamed it your face so that it's
 easier to be substitute later now we apply f TM to it we get f TM of that
 I just copied here substitute the definition of f TN which is the same
 as the substitute this into this expression so we have h a goes to this
 this H a comes from the definition of F T and I have TN and returns a function
 that starts with H a and returns this and instead of F FA you insert the
 function to which you apply flat map sorry flatten so result is this so
 this is instead of FFA in death code if you do that you get this so now
 it looks like can do very much except try to substitute the definition
 of F map a G now look we have F map a G of something dot underscore one
 so let's see what earth map AG does when we do underscore one after it
 so actually this can be simplified if you look at the definition of F map
 AG it returns a tuple so dot one of it is just this in other words applying
 F to the first part of Ag so that's what it is applying F to the first
 part of Ag now we can simplify F map a G of this function instead of F
 and this instead of a G so this is a G dot one to which we apply this function
 f teen mystery of F and then we still have to apply the result to AJ now
 see I'm very careful I'm just copying the code and inserting I'm not checking
 any type stuff actually I could I just uncomment this and save scholar
 complains well it probably complains what it complains about too many arguments
 oh yeah because I have this this thing let me comment this out right this
 is not valid scholar syntax right so this has a correct type and restore
 the comments as they were before so by just putting this into the Scala
 intelligent code I check the types that's how I did it so each of these
 would was type checked before I come in the default so now it remains to
 substitute the definition of FTM so we have FTM here as a shorter form
 with two arguments FFA and AJ so let's just list so we put this and substitute
 instead of F F F F F n this and AJ AJ so we just put that there and we
 get this now let's compare these two expressions HHA sorry fi cafe of something
 dot one of this the one of that so that dot one of blah is the common element
 here F F FA of something is common element so the only difference is these
 two pieces the in self of NSF and NSF come from AB flat so these two are
 different so let's see if they are transformed into each other if we put
 more effort both of these expressions have type H of F of F of a because
 we insert twice here and here we insert once and then we'll come to map
 so let's show that they're always equal and then if we can show that we're
 done we show that these two expressions are always equal this one in this
 one so it remains to compare these two so let me define just functions
 that take AJ and return this and the other function will take AJ and return
 that no no no I'll transform the code of these functions I'm defining them
 just so that I can easier easily check types without repeating all that
 so now the first function is this let's substitute the definition of insert
 F and we get F FA of this underscore one of this underscore one remind
 you the definition of constraint F is a shape control map of this we do
 a cheek contour map of this contra map of that which can be contracted
 to a single control map with composition of these two functions so that's
 what I did here combined to cause and the result is this we have this expressio
n let's try to see what happens in the other one we have this let's substitute
 the definition of insert F which is this one now let's compose the two
 contra maps so we need to compose in the opposite direction so we first
 apply this function and then we apply this function in this case the first
 function is flatly and the second function is is this one apply a chain
 not one so then we have this contra map first we flatten take some arbitrary
 F of F FA flatten it first and then apply this function to the result that
 results in this function then we substitute the definition of flatten and
 that is this short definition so now we can compare these two expressions
 and we see that they are identical you see I can probably remove this yes
 let's type a notation I can remove and I can just rewrite this for syntax
 so then they are syntactically identical so this shows that these two expressio
ns are identical so that concludes our proof of the associativity law that's
 to say it's a semi mu not the only thing we have used is a contra map property
 and the map property for G when we defined F map a G so f map a G is used
 to define F map for our constructor F and confirm map is used to define
 flat so that's the only thing we define we used to define flatten and F
 map for this type constructor so then it becomes a semi moment and we have
 checked the social activity so now let's see if this can be defined into
 a full moment we'll show that actually this cannot be done unless G of
 a his unit so in other words we can only done it in that way oh how to
 show that well first of all how can we create a pure for this F when you
 take an A and we need to return a function it takes H of a and returns
 a tuple of eight and G of a well how can we return a tuple of a and G of
 a we have an eight we need a G of a also the control factor H of a is of
 no help it cannot give us any values of type A or of type G of F so we
 must ignore that contra factor argument of type H a we have to ignore that
 argument and we return a tuple of le and then we have to have some function
 like pure G of a that returns a G of a given a name in other words we need
 that function in order to define pure flotsam and imagine we have that
 function in other words the factor G is pointed that's what it means to
 have that function a natural transformation with this type signature so
 imagine that the font of G is pointed can we define a full monad for the
 type constructor F let's see we can define pure with the right type signature
 that's for sure let's check the laws identity laws is that pure followed
 by flatten is identity so let's do that take an arbitrary FA apply pura
 to it and then apply flat into the result but substitute the definition
 of flattening acting on pure so that will be this now pure of a PHA is
 something that returns a function that ignores its argument so we can ignore
 this and the first part of pure of the fame of something is fa so therefore
 this is a che going to FA of AJ so all this goes away this returns a che
 so H sorry this returns FA so this becomes FA of AJ so now the code is
 like this and the function taking page a and returning FA of which is the
 same as the function FA so we don't we could rewrite this as simply effect
 so that is the left identity law so that holds let's take the right identity
 law its F map pure and followed by flatten so we take an arbitrary FA we
 apply F map Puran to it and then we apply flatten to the result and let's
 write a tray right here for simplicity and so we'll apply this to AJ what's
 now transform this expression this expression we substitute of the diff
 the definition of flattened FFA HJ where FFA is this so that gives you
 this piece followed by application to NSF of LJ dot 1 over J so that's
 not now let's substitute the definition of this in here where F is puree
 FA is FA and HB is this so the result I'm just going to take the code for
 F map which is up here and substitute F and H B as I just described so
 the result is this so now we again have the situation of F map a G of something
 dot under square one so that can be simplified we have a fear of whatever
 it was here the applied to this dot one so pure was the first argument
 of F map and G this was the second argument of F naught a G so then we
 have this first argument applied to the second argument dot underscore
 one now let's see what we can simply find here well we we can we need to
 substitute peer and we need to substitute this we already know that in
 insert F of H taken from map you really know we can simplify that so let's
 want to do that it's an H taken from a pure and then this function which
 is in SEF so we can combine them in into one function first applying pure
 and then applying that to the result so that gives us this function now
 this can be further simplified because that's definition of pure taking
 that one of this gives you just a so then basically this is just an identity
 function and applying culture map of identity function so this is just
 a dynasty function country map identity function is identity so H a culture
 map of this is just H a so therefore we can simplify our expression but
 using that this is just H a so then we have pure very fa fa j dot one h
 a we can simplify this further by inserting the definition of pure which
 is the tuple of this and pure g of that so now we have the simplify this
 we can simplify anymore because we don't know what pure gene does and we
 don't know what FA does and what if a old age is so now let's compare this
 has to be equal to F a of H a because this entire thing must be an identity
 function so identity function takes F a and returns again FA in other words
 it must return a function at X H a and the plies FA to a chip so that's
 we expect to see just this instead we see this tuple what is that - PO
 well this tuple has the first part from FHA now if a of H a is itself a
 tuple let's check that so FA of AJ is of type a G of a so it's a tuple
 and if this were equal to f AV J then this should have been a favorite
 a dot underscore one comma F aah a dot underscore two so instead of FA
 of H a dot underscore two we see this how could this two things these two
 things be equal for arbitrary a finucci it's the same as to say that we
 have an arbitrary tuple of this type and the second element of that tuple
 must be equal to pure G of the first element of the tuple so the function
 pure G must somehow be able to compute the second element of an arbitrary
 tuple from the first element that's impossible a tuple of two elements
 contains information in both elements so this could be some arbitrary value
 of type a this could be some arbitrary value of type G of a there's no
 possible way to compute a second value from the first in general as long
 as the second value contains any non-trivial information as long as it
 has more than one different value we couldn't possibly guess what that
 value is given some other value unrelated to it it's all related because
 we don't know what there's no constraint on the function f a if a is an
 arbitrary function that takes H a and gives a value of this type so the
 function f a gives an arbitrary value of type a and then an arbitrary another
 value of times G of a they're not relating these to the type of the type
 is like this so this is G of a and that's the same as here that's just
 the type the values are not related so it's as long as the value of type
 G of a can be more than one different now here we can posit we cannot possibly
 guess or compute what it is so it's impossible that this returns fa unless
 there's only one possible value in this type in other words G of a contains
 no information there's only one value of this type which means it's a unit
 type for away so G of a must be a trivial factor constant factor that returns
 a unit type for all types a so in that case pure G is just a function that
 returns unit and FA must have been a function that returns a unit in the
 second point of the tuple and we're done and it's the identity law wouldn't
 hold just the first part of the tuples is fine it's the second part of
 the tuple that's broken so if G of a is unit then the second part of the
 tuple is always unit and both identity laws hold so that conclude completes
 the proof that this construction returns a full monad when G is unit in
 other words when we don't have any gf and we can simply find a way product
 with unit until just a so this completes the proof of all our constructions
 let me give a brief overview of what we have found so first of all these
 are not all possible constructions that give you a monad out of something
 certain you can combine these constructions and you are assured that you
 will get a monad as a result but there are other there further constructions
 which I did not talk about which I know and probably there are also constructio
ns that I don't know there isn't it seems a theory in the literature that
 explains to you what are all possible constructions or what are all possible
 monads that theory seems to be lacking in the literature at least I couldn't
 find it I did a search online I made a question on Stack Overflow about
 this but nobody seems to know so for example the question of how to recognize
 a semi 1 ad or a monad from its type expression that seems to be an open
 question in other words nobody knows the answer if I give you some arbitrary
 type expression it's not clear that you can easily recognize that it's
 a monad or not you can certainly try to implement the methods pure and
 flatten there might be many implementations of these of these that fit
 the types and then you you would have to prove the flaws hold that's a
 lot of work for any given type expression it could be a huge amount of
 computation that is not easy and so it doesn't seem to be an easy criterion
 however if you can build a monad out of known constructions like these
 you're guaranteed that laws hold and so there's no need to check the laws
 so these constructions give you examples of Vinod's such as the constant
 function so again for full model you need a unit but for semi wallet it
 can be just any type a fixed type then you have a product of a and something
 which is a semi model only a full model only when the identity monad is
 considered so G is 1 so these are examples constant bonded identity model
 and we have a product of two models but not the disjunction or sometimes
 co-product as it is called you have a function from a fixed type to a moment
 or same Amanat note that here you don't have a function from a fixed type
 terminal if this is a moment that doesn't help to make that a moment so
 recall we just proved that the identities laws cannot hold unless G a is
 actually equal to one so if G a is a moon at itself that doesn't help it
 needs to be actually equal to one for this construction for this construction
 GA can be a moon odd and then it's a product of identity mullet and this
 moon up and the product works so this is how it works and here you can
 have a function from a fixed type to an arbitrary unit here not the fixed
 type is a control factor so this construction contains a fixed type as
 an option so if H a could be just some fixed type R but the right-hand
 side must be of this form it must be a if you want to fool monad so in
 this construction it's a constant on the left but this can be an arbitrary
 monad this construction is a free pointed so it gives you another moment
 for a given what does this construction do for you if you already have
 the moment why would you add a to it the reason is this monad can be easily
 recognized as a value being pure or not pure so in this mo not pure values
 are on the left and any non pure values are on the right so any value that
 has an effect is on the right and any value that doesn't have an effect
 is on the left so I'm saying that a monadic value or a value of a monadic
 type has an effect when it is not a result of applying pure to something
 so if it if it's equal to pure of something then that monadic value has
 no effect as as empty effect in it that's just an intuitive way of talking
 about it it's not really that we can recognize the presence of an effect
 in a value except for this mode so in this model it's very easy to recognize
 the presence of an effect if it's on the left and there is no effect it
 wasn't a result of pure but on the right then there is an effect so for
 example you start with pure you apply some flat maps to it you could get
 this but if you just apply maps to it then you would stay pure and in this
 mode it is easily recognizable if a value is pure or not you can pattern
 match on the disjunction and find out so maybe that is useful for certain
 applications to be able to recognize by pattern matching whether a monadic
 value is pure that this has an empty effect or it is not pure as some non-empty
 effect and also note remember in the derivation of this we had a function
 called merge which takes this and returns G of a so you can always merge
 this a back into the monad G and that could be useful if Mona Jie has some
 computational significance and this is just some extra structure that you
 need temporarily for computation and then you can get rid of it without
 losing any information or an emergent back so that could be useful structure
 now this is a model where you substitute the type parameter for another
 lunatic actually we have seen where you will see in an exercise that this
 itself is the moon odd the combination of writer monad and either moment
 so this is now a combination of an arbitrary monad and this now this combinatio
n is interesting because it's a come it's a functor composition of two minutes
 of G and of this and so this is an interesting example where a functor
 composition of two monads is again a monad this is by no means always the
 case but there are some units such as this one such that a functor composition
 of an arbitrary one at G and this mono is again a monad so that is important
 to know that that such one else exists in a thesis a certain class of Mona
 that have this property another class of Mona that have similar property
 is this this is also a function composition of the reader monad are two
 a and G of a but on in the opposite order so G of a is inside the reader
 unit and here G of a is outside of this moment so there this is a so reader
 belongs to a different class of monads such that their functor composition
 with any other monad inside is again a monad but this would not be the
 case if we use this moment if you put G instead of here that would not
 work so this so the reader madad and this linear type linear polynomial
 monad are of different classes with respect to founder composition and
 that has relevance for monad transformers which I will talk about in a
 later tutorial now this construction is very important it's a free madad
 over function G and it gives you a mu nod out of an arbitrary function
 G no restrictions on factor G so this is used a lot to obtain monads out
 of arbitrary factors now the last two constructions are somewhat peculiar
 haven't seen them in the literature much or at all I don't know if they
 have names but so this construction is unfortunately only a semi mu not
 it's a tree with G shaped leaves and G shaped branches and this construction
 is interesting because it gives you a monad out of an arbitrary control
 function now control factors can be seen as type constructors that have
 a function in them that consumes some values of type a let's say a general
 contractor can be a function from a functor to some constant type let's
 say my function from A to C or C is a constant type or function from a
 functor G A to Z where Z is a constant type so that's a general kind of
 control factor of polynomial exponential class of course I don't know if
 any other way of reasoning about types except by talking about exponential
 polynomial types that is type expressions that have function type disjunction
 and conjunction of product so within this class of types all control factors
 can be seen as functions from some G a let's say to a constant type Z so
 an example of this would be arbitrary factor G a going to Z all of that
 going to a and that's a moment for arbitrary control factor H a or if you
 represent a chase through another factor then it will be a moon ad for
 an arbitrary factor H now some G so this is another construction that gives
 you a moon out of an arbitrary factor or an arbitrary control factor I
 don't know yet what the use cases for those monads there might be but at
 this point these are just the constructions that I found and there are
 a few other constructions that come from one are transformers but then
 you're almost general and they all require Mona so there are no other construct
ions I know that take an arbitrary factor which is itself not a unit or
 an arbitrary control function and make a monad out of that these are these
 two constructions and finally I don't think there is any such thing as
 a contaminant or control function that is itself having a magnetic property
 I don't think that is possible because a contractor such as H a consumes
 values of a so the a inside the control factor are in the contravariant
 position now monad structure would mean that you transform H of H of a
 into H of a but if H is a control function then each of HIV is a functor
 so because because a to contravariant positions cancel each other it's
 impossible to have a natural transformation between a contra factor and
 D factor so there is no way that you could possibly have a function such
 as flatten that takes F of F of a and returns F of a where F is a contra
 factor just contravariance here and here is different there is no way to
 have a natural transformation between them between the founder and the
 control factor and so there's no way for you to implement flatten and so
 there is no analogue of contra factors that are monads in any way moani's
 must always be functors so this concludes the theoretical part now the
 exercises let me make some comments about the exercises so the first exercise
 is to complete the proof that we started in the working examples we showed
 that this is a semi group for a semi monad and semi group s but now if
 if in a film or not you should show that this is a film on right even if
 s is itself a mono it also for monoid the second exercise is a specific
 example of one noted non-trivial monoid this exercise is to show explicitly
 by symbolic code transformations this is a semi model you have to implement
 F nap and flatten and peer notice here boo is a specific type z is not
 but misses boo boo is a monoid so you can use any kind of OneNote structure
 on boo the next exercise is to show that this can be a semi woman but not
 a Mona no no yes this is actually equivalent to a disjunction of MA and
 ma because boolean is just two values and so you can expand the brackets
 and you get a disjunction so ma disjunction of ma and ma is not a monad
 we know it's a semi modem because we have the construction that product
 instruction but it's not a moaner so sure that the laws don't hold next
 is again an exercise to showing showing that one of them is emunah the
 other cannot be made into a semi moment at this point is see this is a
 reader for that and we compose readable not and the writer monad so we
 can pose it in one order first the reader and then apply the writer to
 that or we first take the writer and then apply the reader to them now
 this is construction for so this can be made in the same way but I did
 not prove construction for so you don't know that actually it will be exercise
 ten to verify construction for so for this exercise just look at the types
 and see which one can have the type of flatten that we require in other
 words the type of flatten for this needs to be implemented can it be implemente
d and can this be implemented and if so sure one of them expect this one
 to be not sad because the type cannot be implemented so similarly here
 show that you cannot implement the type necessary for a flat map or or
 flatten whatever you choose now here P and Q are arbitrary and different
 types you don't know anything about them so for specific types maybe you
 could implement the same Emunah but not for the arbitrary types in this
 exercise you have this type constructor which is just this and you can
 implement Clanton and pure for it the types could be implemented but the
 monado's the knothole so the exercise for you is to show that you can implement
 pure and you can implement flatten in many ways so the exercise tells you
 to do it in at least two different ways so these two different pure and
 at least two different flanking but the laws never hold whatever whatever
 combination of those implementations you take the Monad loads will not
 hold at least some of them will fail in this exercise I don't expect you
 to enumerate all possible implementations of pure and flatly and check
 that for all combinations of these the laws fail but this is so there is
 a stack overflow question about it which I initiated indeed not not I initiated
 somebody else actually had a comment on something I said in some other
 question and they asked this question so people have checked by explicit
 and full calculation and I have checked it as well myself that no implementatio
n of pure and flatten for this type constructor will satisfy laws so this
 is an example of a very simple type constructor which is a functor but
 not a monad cannot be made into a monad for some obscure reasons it's not
 obvious why but something is missing on this type and you cannot make a
 monad out of it next exercise is to check the laws now for functor not
 a monad this the functor laws are what we discussed in chapter 4 so this
 type constructor is actually not a function because it is not covariant
 it it contains an alien a covariant position and then a in a contravariant
 tradition so this is actually not a factor not a country function either
 but for some obscure reason you can implement a function f map that has
 the correct type signature this is the code for it you should check that
 this has the right types and so why is this possible well this is just
 some kind of accident but imagine that the programmer didn't think about
 covariance here and thought that this is this is my data type and I want
 F nap for it and I can implement it great does that make this function
 you know unless it satisfies the factor law so they the exercise is to
 show it doesn't the next exercise is to check the Monad laws for this which
 is similar to checking the Monad laws for for this except now instead of
 boom you here you only verify the social Liberty and here you need to verify
 everything and W must be a monoid then in this exercise this is actually
 one of the constructions but the exercise is to write down implementations
 for platinum pure explicitly and check the laws now in this exercise it's
 to show that pure so the construction 5 let me look at it within Islam
 so the construction 5 is this in this construction when you find fewer
 for F as left of a now the exercise here is to show that if we didn't and
 we defined it as right of Mona G pure of a which we could have done conceivably
 because G is a monad so we could put pure into the right part into here
 so show that if we did that the one of the identity laws would fail so
 there's no way this would work in the next exercise the question is to
 take this and find the constructions that you can use to construct this
 moment and once you find it you already know that list is a monad for example
 you don't need to check the laws so then you need to just implement the
 monad methods for it and to do that we look at the constructions and the
 constructions actually implement the Monad methods for each step of the
 construction so you don't have to guess how to implement a monad here because
 you have each step of the constructions showing you how to implement flatten
 given previous monads implementation but of course if you feel like guessing
 from scratch then you can implement the Monad and methods for this for
 you from scratch in the next exercise is to try the construction - which
 was this one in the worked examples I showed I implemented this construction
 by discarding the second effect in this exercise you should repeat that
 but they start the first defense it would be a different implementation
 of a semi Monnet and it's still a semi Monat so you show it and it should
 show that associativity is still satisfied for construction eight in the
 next exercise I I did not show that associativity holds I just showed that
 it cannot be a monad but I did not show that cannot be a full Mona so it's
 still a semi mode that only I did not show such activity so you should
 show it in this exercise and finally not in the last exercise you should
 revisit the standard known as the state and a continuation moments from
 the first parts of the tutorial we have verified the associativity laws
 for them but not the identity laws so this exercise is to verify the identity
 loss for them good luck with the exercises 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
