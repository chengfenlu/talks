
\chapter{The formal logic of types II. Higher-order functions\label{chap:Higher-order-functions} }

\section{Functions that return functions}

\subsection{Motivation and a first example}

\global\long\def\gunderline#1{\mathunderline{greenunder}{#1}}
Consider the task of preparing a logger function that prints messages
but adds a fixed prefix to each message. 

A simple logger function can be viewed as a value of type \lstinline!String => Unit!,
such as
\begin{lstlisting}
val logger: String => Unit = { message => println(s"INFO: $message") }

scala> logger("hello world")
INFO: hello world
\end{lstlisting}
This function prints any given message with the logging prefix \lstinline!"INFO"!. 

Note that the standard library function \lstinline!println(...)!
always returns a \lstinline!Unit! value after printing its arguments.
As we already know, there is only a single value of type \lstinline!Unit!,
and that value is denoted by \lstinline!()!. To verify, run this
code:
\begin{lstlisting}
scala> val x = println(123)
123
x: Unit = ()
\end{lstlisting}

The task is to make the logging prefix configurable. A simple solution
is to implement a function \lstinline!logWith! that takes a prefix
as an argument and returns a new logger with that prefix fixed. It
is important to note that the function \lstinline!logWith! will return
a new value of type \lstinline!String => Unit!, i.e.~a new \emph{function}:
\begin{lstlisting}
def logWith(prefix: String): (String => Unit) = {
    message => println(s"$prefix: $message")
}
\end{lstlisting}
The body of \lstinline!logWith! consists of a single expression,
\lstinline!{message => println(...)}!, which is a nameless function
of type \lstinline!String => Unit!. This expression is what \lstinline!logWith(...)!
will compute and return as its value.

We can now use \lstinline!logWith! to create a few logger functions:
\begin{lstlisting}
scala> val info = logWith("INFO")
info: String => Unit = <function1>

scala> val warn = logWith("WARN")
warn: String => Unit = <function1>
\end{lstlisting}
The logger functions are then used as normal functions:
\begin{lstlisting}
scala> info("hello")
INFO: hello

scala> warn("goodbye")
WARN: goodbye
\end{lstlisting}
The newly created logger functions can be now given as arguments to
other code that need a logging function.

It is important that the prefix is ``baked into'' the functions
created by \lstinline!logWith!. A logger such as \lstinline!warn!
will always print messages with the prefix \lstinline!"WARN"!, and
the prefix cannot be changed any more. The value \lstinline!prefix!
is treated as a local value in the scope of the function returned
by \lstinline!logWith!. For instance, the body of the function \lstinline!warn!
is equivalent to
\begin{lstlisting}
{ val prefix = "WARN"; (message => s"$prefix: $message") }
\end{lstlisting}
So, whenever a new function is created using \lstinline!logWith(prefix)!,
the (immutable) value of \lstinline!prefix! is stored within the
body of the newly created function. This is a general feature of nameless
functions created in a scope that contains other local values: the
function body keeps a copy of all the local values it uses. One sometimes
says that the function body ``closes over'' the local values; for
this reason, nameless functions are sometimes also called ``\textbf{\index{closure}closure}s''.
It would be perhaps clearer to say that nameless functions ``capture''
local values.

As another example of the capture of local values, consider this code:
\begin{lstlisting}
val f: Int => Int = {
  val p = 10
  val q = 20
  x => p + q * x
}
\end{lstlisting}
The body of the function \lstinline!f! is equivalent to \lstinline!{x => 10 + 20 * x}!
because the values \lstinline!p = 10! and \lstinline!q = 20! were
captured.

\subsection{Curried and uncurried functions}

If we reason mathematically about the code
\begin{lstlisting}
val info = logWith("INFO")
info("hello")
\end{lstlisting}
we should expect that \lstinline!info! is \emph{the same value} as
\lstinline!logWith("INFO")!, and so the code \lstinline!info("hello")!
should have the same effect as the code \lstinline!logWith("INFO")("hello")!.
This is indeed so:
\begin{lstlisting}
scala> logWith("INFO")("hello")
INFO: hello
\end{lstlisting}
The syntax \lstinline!logWith("INFO")("hello")! suggests that the
function \lstinline!logWith! is being applied to \emph{two} arguments.
And yet we have defined \lstinline!logWith! as a function with a
single argument of type \lstinline!String!. This works only because
\lstinline!logWith("INFO")! returns a function that accepts an additional
argument.

A function that can be applied to more than one argument in this way
is called a \textbf{\href{https://en.wikipedia.org/wiki/Currying}{curried}}\index{curried function}
function. A curried function can be applied to one argument at a time.

A function that must be applied to all arguments at once, such as
\begin{lstlisting}
def prefixLog(prefix: String, message: String): Unit =
  println(s"$prefix: $message")
\end{lstlisting}
is called an \textbf{uncurried\index{uncurried function}} function.

The type of the curried function \lstinline!logWith! is \lstinline!String => (String => Unit)!.
Scala adopts the syntax convention that the function arrow \lstinline!=>!
associates to the \emph{right}. So the parentheses in the type expression
\lstinline!String => (String => Unit)! are not necessary; the function's
type can be written as \lstinline!String => String => Unit!.

The type \lstinline!String => String => Unit! is \emph{different}
from \lstinline!(String => String) => Unit!, which is a type signature
of a function returning \lstinline!Unit! and taking a function of
type \lstinline!String => String! as its argument. When an argument's
type is a function type, it must be enclosed in parentheses.

In general, a curried function takes an argument and returns another
function that again takes an argument and returns another function,
and so on, until finally a non-function type is returned. So, the
type of a curried function looks like \lstinline!A => B => C => ... => R => S!,
where \lstinline!A!, \lstinline!B!, ..., \lstinline!R! can be viewed
as ``\textbf{curried arguments\index{curried arguments}}'' and
\lstinline!S! as the ``final'' result type. 

For most people, it takes time to get used to reading this kind of
syntax. In the type expression \lstinline!A => B => C => D!, the
first three types are curried arguments and the type \lstinline!D!
is the final result type.

In Scala, functions defined with multiple argument groups (enclosed
in multiple pairs of parentheses) are curried functions. We have seen
examples of curried functions before:
\begin{lstlisting}
def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
def fmap[A, B](f: A => B)(xs: Option[A]): Option[B]
def foldLeft[A, R](xs: Seq[A])(init: R)(update: (R, A) => R): R
\end{lstlisting}
The type signatures of these functions can be also written as
\begin{lstlisting}
def map[A, B]: Seq[A] => (A => B) => Seq[B]
def fmap[A, B]: (A => B) => Option[A] => Option[B]
def foldLeft[A, R]: Seq[A] => R => ((R, A) => R) => R
\end{lstlisting}
These examples show the need to use parentheses whenever a curried
argument is itself a function, such as \lstinline!(A => B)!.

The curried function \lstinline!logWith! can be defined in three
equivalent ways:
\begin{lstlisting}
def logWith1(prefix: String)(message: String): Unit =
  println(s"$prefix: $message")
def logWith2(prefix: String): String => Unit =
  message => println(s"$prefix: $message")
def logWith3: String => String => Unit =
  prefix => message => println(s"$prefix: $message")
\end{lstlisting}
Nameless functions in Scala may be enclosed in parentheses or curly
braces, but parentheses are unnecessary for very simple expressions.

The last line in the above code shows that the arrow \lstinline!=>!
within the code of nameless functions associates to the \emph{right}:
\lstinline!x => y => expr! means \lstinline!{ x => { y => expr } }!,
a nameless function taking an argument \lstinline!x! and returning
a nameless function that takes an argument \lstinline!y! and returns
an expression \lstinline!expr!. This syntax convention is useful
for two reasons. First, the code \lstinline!x => y => z! visually
corresponds to the curried function's type signature \lstinline!A => B => C!
where the same syntax convention is used. Second, the syntax \lstinline!(x => y) => z!
could not be valid for a nameless function because \lstinline!(x => y)!
is not a valid pattern expression for the function's argument; it
is impossible to define a pattern that matches arbitrary \emph{functions}
of type \lstinline!A => B!. 

Although the code syntax \lstinline!(x => y) => z! is invalid, a
type expression \lstinline!(A => B) => C! is valid. A nameless function
of type \lstinline!(A => B) => C! is written as \lstinline!f => expr(f)!
where \lstinline!f: A => B! is its argument and \lstinline!expr(f)!
its body. So \lstinline!x => (y => z)! is the only possible way of
inserting parenthesis into \lstinline!x => y => z!.

\subsection{Equivalence of curried and uncurried functions}

We defined the curried function \lstinline!logWith! in order to be
able to create logger functions such as \lstinline!info! and \lstinline!warn!.
However, some curried functions, such as \lstinline!foldLeft!, are
almost always applied to all possible arguments. A curried function
applied to all its possible arguments is equivalent to an uncurried
function that takes all those arguments at once. Let us look at this
equivalence in more detail.

A simple example of a curried function is one with type signature
\lstinline!Int => Int => Int!. This is a function that takes an integer
and returns a \emph{function} that again takes an integer and then
returns an integer. An example of defining such a function is
\begin{lstlisting}
def f0(x: Int): Int => Int = { y => x - y }
\end{lstlisting}

The function takes an integer argument \lstinline!x! and returns
the expression \lstinline!y => x - y!, which is a function of type
\lstinline!Int => Int!. The definition of \lstinline!f0! can be
also written equivalently as
\begin{lstlisting}
val f1: Int => Int => Int = { x => y => x - y }
\end{lstlisting}

Let us compare the function \lstinline!f1! with a function that takes
its two arguments at once. Such a function will have a different type
signature, for instance
\begin{lstlisting}
def f2(x: Int, y: Int): Int = x - y
\end{lstlisting}
has type signature \lstinline!(Int, Int) => Int!.

The syntax for calling the functions \lstinline!f1! and \lstinline!f2!
is different:
\begin{lstlisting}
scala> f1(20)(4)
res0: Int = 16

scala> f2(20, 4)
res1: Int = 16
\end{lstlisting}
The main difference between the usage of \lstinline!f1! and \lstinline!f2!
is that \lstinline!f2! must be applied \emph{at once} to both arguments,
while \lstinline!f1(20)! can be evaluated separately, \textendash{}
that is, applied only to its first argument, \lstinline!20!. The
result of \lstinline!f1(20)! is a function that can be later applied
to another argument:
\begin{lstlisting}
scala> val r1 = f1(20)
r1: Int => Int = <function1> 

scala> r1(4)
res2: Int = 16
\end{lstlisting}

Applying a curried function to some but not all of possible arguments
is called a \textbf{\index{partial application}partial application}.
Applying a curried function to all possible arguments is called a
\index{saturated application}\textbf{saturated} application.

If we need to apply an uncurried function to some of its arguments
but leave other arguments unspecified, we can use the Scala syntax
with the underscore ($\_$) symbol:
\begin{lstlisting}
scala> val r2: Int => Int = f2(20, _)
r2: Int => Int = <function1>

scala> r2(4)
res3: Int = 16
\end{lstlisting}
This code creates a function \lstinline!r2! by partially applying
\lstinline!f2! to the first argument but not to the second. The type
annotation \lstinline!Int => Int! is necessary in Scala. Other than
that, \lstinline!r2! is the same function as \lstinline!r1! defined
above (i.e.~\lstinline!r2! returns the same values for the same
arguments as \lstinline!r1!).

Another equivalent syntax for a partial application is
\begin{lstlisting}
scala> val r3: Int => Int = { x => f2(20, x) }
r3: Int => Int = <function1>

scala> r3(4)
res4: Int = 16
\end{lstlisting}

We can see that a curried function, such as \lstinline!f1!, is better
adapted for partial application than \lstinline!f2!, because the
syntax is shorter. However, the functions \lstinline!f1! and \lstinline!f2!
are \textbf{computationally equivalent}\index{computational equivalence}
in the sense that given \lstinline!f1! we can reconstruct \lstinline!f2!
and vice versa:
\begin{lstlisting}
def f2new(x: Int, y: Int): Int = f1(x)(y)
def f1new: Int => Int => Int = { x => y => f2(x, y) }
\end{lstlisting}
It is clear that the function \lstinline!f1new! computes the same
results as \lstinline!f1!, and that the function \lstinline!f2new!
computes the same results as \lstinline!f2!. The computational equivalence
of the functions \lstinline!f1! and \lstinline!f2! is not \emph{equality}
 \textendash{}  these functions are \emph{different}; but one of them
can be easily reconstructed from the other if necessary. 

More generally, a curried function may have a type signature of the
form \lstinline!A => B => C => ... => R => S!, where \lstinline!A!,
\lstinline!B!, \lstinline!C!, ..., \lstinline!S! are some types.
A function with this type signature is computationally equivalent
to an uncurried\index{uncurried function} function with type signature
\lstinline!(A,B,C,...,R) => S!. The uncurried function takes all
arguments at once, while the curried function takes one argument at
a time. Other than that, these two functions compute the same results
given the same arguments.

We have seen how a curried function can be converted to an equivalent
uncurried one, and vice versa. The Scala library defines the methods
\lstinline!curried! and \lstinline!uncurried! that convert between
these computationally equivalent forms of functions. Here convert
the function \lstinline!f2! to \lstinline!f1! and back:
\begin{lstlisting}
scala> val f1c = (f2 _).curried
f1c: Int => (Int => Int) = <function1>

scala> val f2u = Function.uncurried(f1c)
f2u: (Int, Int) => Int = <function2> 
\end{lstlisting}

The syntax \lstinline!(f2 _)! is used in Scala to convert methods
to function values. Recall that Scala has two ways of defining a function:
one as a method\index{Scala method} (defined using \lstinline!def!),
another as a function value\index{function value} (defined using
\lstinline!val!). 

The methods \lstinline!.curried! and \lstinline!.uncurried! are
easy to implement in Scala code, as we will see in the solved examples.

\section{Functions with fully parametric type signatures}

We have seen that some functions are declared with type parameters,
so that certain arguments can have an arbitrary type. Examples of
such functions are \lstinline!map! and \lstinline!filter! methods
with type signatures
\begin{lstlisting}
def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
def filter[A](xs: Seq[A])(p: A => Boolean): Seq[A]
\end{lstlisting}
It saves time for the programmer to implement a single function with
type parameters instead of a number of functions with the same function
bodies but applied to specific types. 

In the functions \lstinline!map! and \lstinline!filter! as just
shown, some types are parameters while others are specific types,
such as \lstinline!Seq! and \lstinline!Boolean!. It is sometimes
possible to replace \emph{all} types in the type signature of a function
by type parameters.

A function is \textbf{fully parametric\index{fully parametric function}}
if all its arguments have types described by type parameters, and
the code of the function always works with type parameters rather
than with fixed types such as \lstinline!Int! or \lstinline!String!.
In other words, fully parametric functions do not have any specific
types, such as \lstinline!Int! or \lstinline!String!, in their type
signature or in their body. When a fully parametric function is applied
to an argument of a specific type, the function does not use any information
about that type. 

What kind of functions are fully parametric? To build an intuition,
compare these two functions having the same type signature:
\begin{lstlisting}
def cos_sin(p: (Double, Double)): (Double, Double) = p match {
  case (a, b) =>
    val r = math.sqrt(a * a + b * b)
    (a / r, b / r) // Return cos and sin of the angle.
}

def swap(p: (Double, Double)): (Double, Double) = p match {
  case (a, b) => (b, a)
}
\end{lstlisting}
We can introduce type parameters into the type signature of \lstinline!swap!
to make it fully parametric, with no changes in the code of the function:
\begin{lstlisting}
def swap[A, B](p: (A, B)): (B, A) = p match {
  case (a, b) => (b, a)
}
\end{lstlisting}
We are able to generalize \lstinline!swap! to a fully parametric
function because swapping two parts of a tuple \lstinline!(A, B)!
is an operation that works in the same way for all types \lstinline!A!,
\lstinline!B!. 

In comparison, the function \lstinline!cos_sin! performs a computation
that is specific to the type \lstinline!Double!, and its arguments
cannot be generalized to arbitrary types such as \lstinline!Boolean!
or \lstinline!String! instead of \lstinline!Double!. The angle computation
in \lstinline!cos_sin! makes no sense for other types. So, \lstinline!cos_sin!
cannot be generalized to a fully parametric function.

The \lstinline!swap! operation for pairs is already defined in the
Scala library:
\begin{lstlisting}
scala> (1, "abc").swap
res0: (String, Int) = (abc,1)
\end{lstlisting}
For tuples with three and more elements, we may define various swapping
functions, e.g.
\begin{lstlisting}
def swap12[A,B,C]: ((A, B, C)) => (B, A, C) = {
  case (a, b, c) => (b, a, c)
}
\end{lstlisting}
The Scala syntax requires the double parentheses around tuple types
of arguments but not around the tuple type of a function's result.
So, the type signature of \lstinline!cos_sin! may be written as
\begin{lstlisting}
def cos_sin: ((Double, Double)) => (Double, Double)
\end{lstlisting}


\subsection{Examples of fully parametric functions\label{subsec:Examples-of-fully-parametric}}

Further examples of fully parametric functions are the identity function,
the constant function, the function composition methods, and the curry
/ uncurry transformations. The \index{identity function}identity
function (already defined in the Scala library as \lstinline!identity!)
is
\begin{lstlisting}
def id[T]: T => T = (t => t)
\end{lstlisting}
The constant function\index{constant function} (available in the
Scala library as \lstinline!Function.const!) takes an argument \lstinline!c!
and returns a new function that always returns \lstinline!c!:
\begin{lstlisting}
def const[C, X](c: C): X => C = { _ => c }
\end{lstlisting}
The syntax \lstinline!(_ => c)! is used to emphasize that the function
ignores its argument. 

The Scala library defines two different function composition methods,
called \lstinline!andThen! and \lstinline!compose!. The method \lstinline!andThen!
performs the \textbf{\index{forward composition}forward composition}
of two functions: the result is a new function, written in Scala as
\lstinline!f andThen g!. That function first applies \lstinline!f!
to the argument ``and then'' applies \lstinline!g! to the result.
Mathematically, this operation is denoted by $\bef$ (pronounced ``before'')
and can be defined as
\begin{equation}
f\bef g\triangleq\left(x\Rightarrow g(f(x))\right)\quad.\label{eq:def-of-forward-composition}
\end{equation}
The symbol $\triangleq$ means ``is defined as''.

In Scala, the forward composition may be written as a fully parametric
function,
\begin{lstlisting}
def andThen[X, Y, Z](f: X => Y)(g: Y => Z): X => Z = { x => g(f(x)) }
\end{lstlisting}
The type signature of this curried function is could be written as
\[
\text{andThen}:\left(X\Rightarrow Y\right)\Rightarrow\left(Y\Rightarrow Z\right)\Rightarrow X\Rightarrow Z\quad.
\]
This type signature shows how the types of the functions must match
for the composition to be defined.

The \textbf{backward composition\index{backward composition}} of
two functions $f$ and $g$ works in the opposite order: first $g$
is applied and then $f$ is applied to the result. Using the mathematical
symbol $\circ$ (pronounced ``after'') for this operation, we can
write
\begin{equation}
f\circ g\triangleq\left(x\Rightarrow f(g(x))\right)\quad.\label{eq:def-of-backward-composition}
\end{equation}
In Scala, the backward composition is called \lstinline!compose!
and used as \lstinline!f compose g!. This method may be redefined
as a fully parametric function
\begin{lstlisting}
def compose[X, Y, Z](f: Y => X)(g: Z => Y): Z => X = { z => f(g(z)) }
\end{lstlisting}
The type signature of this curried function is
\[
\text{compose}:\left(Y\Rightarrow X\right)\Rightarrow\left(Z\Rightarrow Y\right)\Rightarrow Z\Rightarrow X\quad.
\]

We have already seen the methods \lstinline!curried! and \lstinline!uncurried!
defined by the Scala library. As an illustration, let us write a transformation
from curried to uncurried functions in our own Scala code:
\begin{lstlisting}
def uncurry[A, B, R](f: A => B => R): ((A, B)) => R = {
  case (a, b) => f(a)(b) // Compute a value of type R.
}
\end{lstlisting}

We conclude from these examples that fully parametric functions perform
operations that are so general that they work in the same way for
all types of arguments. Some arguments of fully parametric functions
may have complicated types such as \lstinline!A => B => R!, which
are type expressions made up from type parameters alone. Fully parametric
functions do not perform any operations with specific types such as
\lstinline!Int! or \lstinline!String!.

The property of being fully parametric is also called \textbf{parametricity}\index{parametricity}
for short.

\subsection{Laws of function composition\label{subsec:Laws-of-function-composition}}

Function composition has three important properties or ``laws''
that follow naturally from the definitions. These laws are:
\begin{itemize}
\item the identity laws: the composition of any function $f$ with the identity
function will give again the function $f$;
\item the associativity law: the consecutive composition of three functions
$f$, $g$, $h$ does not depend on the order in which the pairs are
composed.
\end{itemize}
Let us write these laws rigorously as mathematical equations and prove
them. For brevity, we will denote the identity function by ``$\text{id}$''.

The composition of the identity function with an arbitrary function
$f$ can be $\text{id}\bef f$ with the identity function to the left
of $f$, or $f\bef\text{id}$ with the identity function to the right
of $f$. In both cases, the result must be equal to the function $f$.
So we actually have \emph{two} laws:
\begin{align*}
{\color{greenunder}\text{left identity law of composition}:}\quad & \text{id}\bef f=f\quad,\\
{\color{greenunder}\text{right identity law of composition}:}\quad & f\bef\text{id}=f\quad.
\end{align*}
To show that these laws always hold, we need to show that both sides
of the laws, which are functions, give the same result when applied
to an arbitrary value $x$. To see this, let us first clarify how
the type parameters must be set for the laws to have consistent types.

The laws must hold for an arbitrary function $f$. So we may assume
that $f$ has the type signature $A\Rightarrow B$, where $A$ and
$B$ are arbitrary type parameters. Consider the left identity law.
The function $\left(\text{id}\bef f\right)$ is, by definition~(\ref{eq:def-of-forward-composition}),
a function that takes an argument $x$, applies $\text{id}$ to that
$x$, and then applies $f$ to the result: 
\[
\text{id}\bef f=\left(x\Rightarrow f(\text{id}(x))\right)\quad.
\]
If $f$ has type $A\Rightarrow B$, its argument must be of type $A$,
or else the types do not match. Therefore, the identity function must
have type $A\Rightarrow A$, and the argument $x$ must have type
$A$. With these choices of the type parameters, the function $\left(x\Rightarrow f(\text{id}(x))\right)$
will have type $A\Rightarrow B$, as it must since the right-hand
side of the law is $f$. We add type annotations to the code as superscripts,
\[
\text{id}^{A}\bef f^{:A\Rightarrow B}=\left(x^{:A}\Rightarrow f(\text{id}(x))\right)^{:A\Rightarrow B}\quad.
\]
In the Scala syntax, this formula may be written as
\begin{lstlisting}
id[A] andThen (f: A => B) == { x: A => f(id(x)) }: A => B
\end{lstlisting}
It is quicker to write the short mathematical notation than code in
the Scala syntax. 

We write $\text{id}^{A}$ to denote the type parameter $A$ in the
identity function \lstinline!id[A]!; equivalently (but more verbosely)
we may write $\text{id}^{:A\Rightarrow A}$.

Since $\text{id}(x)=x$ by definition of the identity function, we
find that 
\[
\text{id}\bef f=\left(x\Rightarrow f\left(\text{id}\left(x\right)\right)\right)=\left(x\Rightarrow f\left(x\right)\right)=f\quad,
\]
since the expression $x\Rightarrow f\left(x\right)$ is a function
that takes an argument $x$ and applies $f$ to that argument; i.e.~$x\Rightarrow f\left(x\right)$
is the same function as $f$.

Now consider the right identity law:
\[
f\bef\text{id}=\left(x\Rightarrow\text{id}\left(f\left(x\right)\right)\right)\quad.
\]
To make the types match, assume that $f:A\Rightarrow B$. Then $x$
must have type $A$, and the identity function must have the type
$B\Rightarrow B$. The result of $\text{id}\left(f\left(x\right)\right)$
will be also of type $B$. With these choices of type parameters,
all types match:
\[
f^{:A\Rightarrow B}\bef\text{id}^{B}=\left(x^{:A}\Rightarrow\text{id}(f(x))\right)^{:A\Rightarrow B}\quad.
\]
Since $\text{id}(f(x))=f(x)$, we find that 
\[
f\bef\text{id}=\left(x\Rightarrow f\left(x\right)\right)=f\quad.
\]

In this way, we have demonstrated that both identity laws hold. 

The associativity law is written like this:
\begin{equation}
\left(f\bef g\right)\bef h=f\bef\left(g\bef h\right)\quad.\label{eq:associativity-of-function-composition}
\end{equation}
Let us first check whether the types match. The types of the functions
$f$, $g$, and $h$ must be such that all the function compositions
exist. If $f:A\Rightarrow B$ for some type parameters $A$ and $B$,
then the argument of $g$ must be of type $B$; so we can choose $g:B\Rightarrow C$,
where $C$ is another type parameter. The composition $f\bef g$ has
type $A\Rightarrow C$, so $h$ must be of type $C\Rightarrow D$
for some type $D$. Assuming the types as $f^{:A\Rightarrow B}$,
$g^{:B\Rightarrow C}$, and $h^{:C\Rightarrow D}$, we find that the
types in all the compositions $f\bef g$, $g\bef h$, $\left(f\bef g\right)\bef h$,
and $f\bef\left(g\bef h\right)$ match. We can write the associativity
law with type annotations as
\begin{equation}
(f^{:A\Rightarrow B}\bef g^{:B\Rightarrow C})\bef h^{:C\Rightarrow D}=f^{:A\Rightarrow B}\bef(g^{:B\Rightarrow C}\bef h^{:C\Rightarrow D})\quad.\label{eq:assoc-law-for-composition-with-types}
\end{equation}

Having checked the types, we are ready to prove the associativity
law. We note that both sides of the law~(\ref{eq:associativity-of-function-composition})
are functions of type $A\Rightarrow D$. To prove that two functions
are equal means to prove that they always return the same results
when applied to the same argument. So we need to apply both sides
of Eq.~(\ref{eq:associativity-of-function-composition}) to an arbitrary
value $x^{:A}$. Using the definition~(\ref{eq:def-of-forward-composition})
of the forward composition, 
\[
\left(f\bef g\right)(x)=g(f(x))\quad,
\]
we find
\begin{align*}
\left(\left(f\bef g\right)\bef h\right)(x) & =h\left(\left(f\bef g\right)(x)\right)=h(g(f(x)))\quad,\\
\left(f\bef\left(g\bef h\right)\right)(x) & =\left(g\bef h\right)(f(x))=h(g(f(x)))\quad.
\end{align*}
Both sides of the law are now equal when applied to an arbitrary value
$x$.

Because of the associativity law, we do not need parentheses in the
expression $f\bef g\bef h$, since the result is the same with $\left(f\bef g\right)\bef h$
and with $f\bef\left(g\bef h\right)$.

In the proof, we have not written out the types since we already checked
that the types match. This allows us to write shorter proofs.

\paragraph{Proofs in the backward notation}

This book uses the \textbf{forward notation}\index{forward notation}
$f\bef g$ for writing function compositions, rather than the backward
notation $g\circ f$. However, all equations can be automatically
converted from one notation to the other by reversing the order of
function compositions, since
\[
f\bef g=g\circ f
\]
for any functions $f^{:A\Rightarrow B}$ and $g^{:B\Rightarrow C}$.
Let us see how to prove the composition laws in the backward notation.
We will just need to reverse the order of function compositions in
the proofs above.

The left identity and right identity laws are
\[
f\circ\text{id}=f\quad\quad,\quad\text{id}\circ f=f\quad.
\]
To match the types, we need to choose the type parameters as
\[
f^{:A\Rightarrow B}\circ\text{id}^{:A\Rightarrow A}=f^{:A\Rightarrow B}\quad\quad,\quad\text{id}^{B\Rightarrow B}\circ f^{:A\Rightarrow B}=f^{:A\Rightarrow B}\quad.
\]
We can apply both sides of the laws to an arbitrary value $x^{:A}$.
For the left identity law, we find from definition~(\ref{eq:def-of-backward-composition})
that
\[
f\circ\text{id}=\left(x\Rightarrow f(\text{id}(x))\right)=\left(x\Rightarrow f(x)\right)=f\quad.
\]
Similarly for the right identity law,
\[
\text{id}\circ f=\left(x\Rightarrow\text{id}\left(f\left(x\right)\right)\right)=\left(x\Rightarrow f\left(x\right)\right)=f\quad.
\]
The associativity law,
\[
h\circ\left(g\circ f\right)=\left(h\circ g\right)\circ f\quad,
\]
is proved by applying both sides to an arbitrary value $x$ of a suitable
type:
\begin{align*}
\left(h\circ\left(g\circ f\right)\right)(x) & =h(\left(g\circ f\right)(x))=h\left(g\left(f\left(x\right)\right)\right)\quad,\\
\left(\left(h\circ g\right)\circ f\right)(x) & =\left(h\circ g\right)(f(x))=h(g(f(x)))\quad.
\end{align*}
The types are checked by assuming that $f$ has the type $f^{:A\Rightarrow B}$.
The types in $g\circ f$ match only when $g^{:B\Rightarrow C}$, and
then $g\circ f$ is of type $A\Rightarrow C$. The type of $h$ must
be $h^{:C\Rightarrow D}$ for the types in $h\circ\left(g\circ f\right)$
to match. We can write the associativity law with type annotations
as
\begin{equation}
h^{:C\Rightarrow D}\circ(g^{:B\Rightarrow C}\circ f^{A\Rightarrow B})=(h^{:C\Rightarrow D}\circ g^{:B\Rightarrow C})\circ f^{:A\Rightarrow B}\quad.\label{eq:assoc-law-for-composition-with-types-backward}
\end{equation}
Because of the associativity law, we do not need parentheses in the
expression $h\circ g\circ f$. 

The length of calculations is the same in the forward and the backward
notation. One difference is that types are less visually clear in
function compositions: it is easier to check types in Eq.~(\ref{eq:assoc-law-for-composition-with-types})
than in Eq.~(\ref{eq:assoc-law-for-composition-with-types-backward}).

\subsection{Example of a function that violates parametricity }

Fully parametric functions should not make any decisions based on
the actual types of its parameters. As an example of an \emph{incorrect}
implementation of a fully parametric function, consider the following
``fake identity'' function:
\begin{lstlisting}
def fakeId[A]: A => A = { // Special code for `A` = `Int`:
  case x: Int => (x - 1).asInstanceOf[A]
  case x => x // The usual code for all other types `A`.
}
\end{lstlisting}
This function's type signature is the same as that of \lstinline!identity[A]!,
and its behavior is the same for all types \lstinline!A! except for
\lstinline!A = Int!:
\begin{lstlisting}
scala> fakeId("abc")
res0: String = abc

scala> fakeId(true)
res1: Boolean = true

scala> fakeId(0)
res2: Int = -1
\end{lstlisting}
While Scala allows us to write this kind of code, the resulting function
does not appear to be useful; in any case, it is not a fully parametric
function.

The identity laws of composition will not hold if we use \lstinline!fakeId[A]!
instead of the correct function \lstinline!id[A]!. For example, consider
the composition of \lstinline!fakeId! with a simple function \lstinline!f_1!
defined by
\begin{lstlisting}
def f_1: Int => Int = { x => x + 1 }
\end{lstlisting}
The composition (\lstinline!f_1 andThen fakeId!) will have type \lstinline!Int => Int!.
Since \lstinline!f_1! has type \lstinline!Int => Int!, Scala will
automatically set the type parameter \lstinline!A = Int! in \lstinline!fakeId[A]!,
\begin{lstlisting}
scala> def f_2 = f_1 andThen fakeId
f_2: Int => Int
\end{lstlisting}
The identity law says that $f_{2}=f_{1}\bef\text{id}=f_{1}$. But
we can check that \lstinline!f_1! and \lstinline!f_2! are not the
same:
\begin{lstlisting}
scala> f_1(0)
res3: Int = 1

scala> f_2(0)
res3: Int = 0
\end{lstlisting}

It is important that we are able to detect a violation of parametricity
by checking whether some equation holds, without need to examine the
code of the function \lstinline!fakeId!. In this book, we will always
formulate any desired properties of functions through equations and
laws, and provide proofs.

\section{Symbolic calculations with nameless functions}

\subsection{Deriving a function's type from its code}

Checking that the types match is an important part of the functional
programming paradigm \textendash{} both in the practice of writing
code, and in theoretical derivations of general properties for various
functions. For instance, in the derivations of the composition laws
(Section~\ref{subsec:Laws-of-function-composition}), we were able
to deduce the possible type parameters for $f$, $g$, and $h$ in
the expression $f\bef g\bef h$. This worked because the composition
function \lstinline!andThen! (denoted $\bef$) is fully parametric.
Given a fully parametric function, it is often possible to derive
the most general type signature that matches the body of the function.
The same method will also work for generalizing a given function to
a fully parametric form.

Let us look at some examples of doing this.

\subsubsection{Example \label{subsec:Example-hof-derive-types-1}\ref{subsec:Example-hof-derive-types-1}}

The functions \lstinline!const! and \lstinline!id! were defined
in Section~\ref{subsec:Examples-of-fully-parametric}. What is the
value \lstinline!const(id)! and what is its possible type? Determine
the most general type parameters in the expression \lstinline!const(id)!.

\subparagraph{Solution}

We need to treat the functions \lstinline!const! and \lstinline!id!
as values, since our goal is to apply \lstinline!const! to \lstinline!id!.
Writing the code of these functions in a short notation, we get
\begin{align*}
\text{const}^{C,X} & =c^{:C}\Rightarrow\_^{:X}\Rightarrow c\quad,\\
\text{id}^{A} & =a^{:A}\Rightarrow a\quad.
\end{align*}
Begin by reasoning about the types. The types will match in the expression
\lstinline!const(id)! only if the argument of the function \lstinline!const!
has the same type as the type of \lstinline!id!. Since $\text{const}^{C,X}$
is a curried function, we need to look at its \emph{first} curried
argument, which is of type $C$. The type of $\text{id}$ is $A\Rightarrow A$,
where $A$ is an arbitrary type so far. So, the type parameter $C$
in $\text{const}^{C,X}$ must be equal to $A\Rightarrow A$. The type
parameter $X$ in $\text{const}^{C,X}$ is not constrained, so we
keep it as $X$. The result of applying $\text{const}$ to $\text{id}$
is of type $X\Rightarrow C=X\Rightarrow\left(A\Rightarrow A\right)$.
In this way, we find that the type of \lstinline!const(id)!,
\[
\text{const}^{A\Rightarrow A,X}(\text{id}^{A}):X\Rightarrow A\Rightarrow A\quad.
\]
The types $A$ and $X$ can be arbitrary. The type $X\Rightarrow A\Rightarrow A$
is the most general type for the expression \lstinline!const(id)!
because we have not made any assumptions on the types other than requiring
that all functions are always applied to arguments of the correct
types.

To compute the value of \lstinline!const(id)!, it remains to substitute
the code of \lstinline!const! and \lstinline!id!. Since we already
checked the types, we do not need to write type annotations any more:
\begin{align*}
 & \gunderline{\text{const}}\left(\text{id}\right)\\
{\color{greenunder}\text{definition of const}:}\quad & =(c\Rightarrow x\Rightarrow\gunderline c)\left(\text{id}\right)\\
{\color{greenunder}\text{substitute }c=\text{id}:}\quad & =(x\Rightarrow\gunderline{\text{id}})\\
{\color{greenunder}\text{definition of }\text{id}:}\quad & =\left(x\Rightarrow a\Rightarrow a\right)\quad.
\end{align*}
This is a function that takes an argument $x^{:X}$ and returns the
identity function $a^{:A}\Rightarrow a$. It is clear that the argument
$x$ is ignored by this function, so we can rewrite it equivalently
as
\[
\text{const}(\text{id})=(\_^{:X}\Rightarrow a^{:A}\Rightarrow a)\quad.
\]


\subsubsection{Example \label{subsec:Example-hof-derive-types-2}\ref{subsec:Example-hof-derive-types-2}}

Implement a function \lstinline!twice! that takes a function \lstinline!f: Int => Int!
as its argument and returns a function that applies \lstinline!f!
twice. For example, if the function \lstinline!f! is \lstinline!f = { x => x + 3 }!,
the result of \lstinline!twice(f)! should be equal to the function
\lstinline!x => x + 6!. After implementing the function \lstinline!twice!,
generalize it to a fully parametric function.

\subparagraph{Solution}

According to the requirements, the function \lstinline!twice! must
return a new function of type \lstinline!Int => Int!. So the type
signature of \lstinline!twice! is
\begin{lstlisting}
def twice(f: Int => Int): Int => Int = ???
\end{lstlisting}
Since \lstinline!twice(f)! must be a new function with an integer
argument, we begin to write the body of \lstinline!twice! as
\begin{lstlisting}
def twice(f: Int => Int): Int => Int = { (x: Int) => ??? }
\end{lstlisting}
The new function must apply \lstinline!f! twice to its argument,
that is, it must return \lstinline!f(f(x))!. We can finish the implementation
now:
\begin{lstlisting}
def twice(f: Int => Int): Int => Int = { x => f(f(x)) }
\end{lstlisting}
The type annotation \lstinline!(x: Int)! can be omitted. To test:
\begin{lstlisting}
scala> val g = twice(x => x + 3)
g: Int => Int = <function1>

scala> g(10)
res0: Int = 16
\end{lstlisting}

This example illustrates how a function can return a new function.
We just write a nameless function in the function body.

To generalize \lstinline!twice! to a fully parametric function means
to replace the type signature by a parameterized type while keeping
the function body unchanged,
\begin{lstlisting}
def twice[A, B, ...](f: ...): ... = { x => f(f(x)) }
\end{lstlisting}
 To determine the type signature and the possible type parameters
\lstinline!A!, \lstinline!B!, ..., we need to determine the most
general type that matches the function body. The function body is
the expression $x\Rightarrow f(f(x))$. Assume that $x$ has type
$A$; for types to match in the sub-expression $f(x)$, we need $f$
to have type $A\Rightarrow B$ for some type $B$. The sub-expression
$f(x)$ will then have type $B$. For types to match in $f(f(x))$,
the argument of $f$ must have type $B$; but we already assumed $f^{:A\Rightarrow B}$.
This is consistent only if $A=B$. In this way, $x^{:A}$ implies
$f^{:A\Rightarrow A}$, and the expression $x\Rightarrow f(f(x))$
has type $A\Rightarrow A$. We can now write the type signature of
\lstinline!twice! as
\begin{lstlisting}
def twice[A](f: A => A): A => A = { x => f(f(x)) }
\end{lstlisting}
This fully parametric function has only one independent type parameter,
\lstinline!A!. A mathematical notation for this function can be written
as
\[
\text{twice}^{A}=f^{:A\Rightarrow A}\Rightarrow x^{:A}\Rightarrow f(f(x))\quad.
\]

The procedure of deriving the most general type for a given expression
is called \textbf{type inference}\index{type inference}. The type
signature \lstinline!(A => A) => A => A! has been \textbf{infer}red
from the expression $f\Rightarrow x\Rightarrow f(f(x))$.

\subsubsection{Example \label{subsec:Example-hof-derive-types-3}\ref{subsec:Example-hof-derive-types-3}}

Consider the fully parametric function \lstinline!twice! defined
in Example~\ref{subsec:Example-hof-derive-types-2}. What is the
type of \lstinline!twice(twice)!, and what computation does it perform?
Test your answer on the expression \lstinline!twice(twice[Int])(x => x+3)(10)!.
What are the type parameters in that expression?

\subparagraph{Solution}

Begin by figuring out the required type of \lstinline!twice(twice)!.
We introduce unknown type parameters as \lstinline!twice[A](twice[B])!.
The types will match if the argument type of \lstinline!twice[A]!,
which is $A\Rightarrow A$, matches the type of \lstinline!twice[B]!,
which is $\left(B\Rightarrow B\right)\Rightarrow B\Rightarrow B$.
Since the symbol $\Rightarrow$ groups to the right, we have 
\[
\left(B\Rightarrow B\right)\Rightarrow B\Rightarrow B=\left(B\Rightarrow B\right)\Rightarrow\left(B\Rightarrow B\right)\quad.
\]
This can match with $A\Rightarrow A$ if we set $A=\left(B\Rightarrow B\right)$.
So the most general type of \lstinline!twice(twice)! is
\begin{equation}
\text{twice}^{A\Rightarrow A}(\text{twice}^{A}):\left(A\Rightarrow A\right)\Rightarrow A\Rightarrow A\quad.\label{eq:hof-twice-example-solved3}
\end{equation}

After determining the type parameters that match, we may omit types
from code derivations.

Since we are using \lstinline!twice! as an argument in the expression
\lstinline!twice(twice)!, we need to write the entire code of \lstinline!twice!
as a single value,
\[
\text{twice}=f\Rightarrow x\Rightarrow f(f(x))\quad.
\]
 Substituting this into the expression \lstinline!twice(twice)!,
we find
\begin{align*}
 & \text{twice}(\text{twice})\\
{\color{greenunder}\text{definition of twice}:}\quad & =(f\Rightarrow x\Rightarrow f(f(x)))(\text{twice})\quad.\\
{\color{greenunder}\text{substitute }f=\text{twice}:}\quad & =x\Rightarrow\text{twice}(\text{twice}(x))\\
 & =x\Rightarrow\left(f\Rightarrow x\Rightarrow f(f(x))\right)\left(\left(f\Rightarrow x\Rightarrow f(f(x))\right)(x)\right)\quad.
\end{align*}
The last expression is hard to work with: it is confusing that the
argument names $f$ and $x$ are repeated. The calculation will be
made clearer if we give the arguments new names and eliminate name
shadowing\index{name shadowing}. To avoid errors, we will rename
arguments in one scope at a time:
\begin{align*}
 & x\Rightarrow\text{twice}(\text{twice}(x))\\
{\color{greenunder}\text{rename }x\text{ to }z:}\quad & =z\Rightarrow\text{twice}(\text{twice}(z))\\
{\color{greenunder}\text{definition of twice}:}\quad & =z\Rightarrow\left(f\Rightarrow x\Rightarrow f(f(x))\right)\left(\text{twice}(z)\right)\\
{\color{greenunder}\text{rename }f,x\text{ to }g,y:}\quad & =z\Rightarrow(g\Rightarrow y\Rightarrow\gunderline g(\gunderline g(y)))\left(\text{twice}(z)\right)\\
{\color{greenunder}\text{apply, }g=\text{twice}(z):}\quad & =z\Rightarrow y\Rightarrow\gunderline{\left(\text{twice}(z)\right)}\left(\text{twice}(z)(y)\right)\\
{\color{greenunder}\text{have }\text{twice}(z)=\left(x\Rightarrow z(z(x))\right):}\quad & =z\Rightarrow y\Rightarrow\left(x\Rightarrow z(z(x))\right)(\gunderline{\text{twice}(z)(y)})\\
{\color{greenunder}\text{apply, }x=\text{twice}(z)(y)=z(z(y)):}\quad & =z\Rightarrow y\Rightarrow z(z(z(z(y))))\quad.
\end{align*}
We find that \lstinline!twice(twice)! is a function that applies
its (function-typed) argument \emph{four} times.

The type parameters can be written out as \lstinline!twice[Int => Int](twice[Int])!,
as we find from Eq.~(\ref{eq:hof-twice-example-solved3}) with $A=\text{Int}$.
To test, we need to write at least one type parameter in the code,
or else Scala cannot infer the types correctly:
\begin{lstlisting}
scala> twice(twice[Int])(x => x + 3)(100) // _ + 3 + 3 + 3 + 3
res0: Int = 112

scala> twice[Int => Int](twice)(x => x + 3)(100)
res1: Int = 112
\end{lstlisting}


\subsubsection{Example \label{subsec:Example-hof-derive-types-4}\ref{subsec:Example-hof-derive-types-4}}

Fill in the type signature for the fully parametric function
\begin{lstlisting}
def p[...]:... = { f => f(2) }
\end{lstlisting}
Can the types possibly match in the expression \lstinline!p(p)!?

\subparagraph{Solution}

In the nameless function $f\Rightarrow f(2)$, the argument $f$ has
to be itself a function, otherwise the expression $f(2)$ would make
no sense. The sub-expression $f(2)$ will have correct types only
if the argument of $f$ is of type \lstinline!Int!. Therefore, the
type signature of $f$ must be \lstinline!Int => A!, where \lstinline!A!
is the (so far unknown) type of the value \lstinline!f(2)!. The nameless
function $f\Rightarrow f(2)$ has the argument of type \lstinline!Int => A!
and the result of type \lstinline!A!, so the type of $p$ must be
\lstinline!(Int => A) => A!. With this type assignment, all types
match; so the type parameter \lstinline!A! remains undetermined,
and must appear as a type parameter of the function \lstinline!p!.
The code is
\begin{lstlisting}
def p[A]: (Int => A) => A = { f => f(2) }
\end{lstlisting}

To answer the question about the expression \lstinline!p(p)!, we
begin by writing that expression with explicit type parameters as
\lstinline!p[A](p[B])!, where the type parameters \lstinline!A!
and \lstinline!B! are initially unknown. Then we try to choose \lstinline!A!
and \lstinline!B! so that the types match in that expression. Does
the type of \lstinline!p[B]!, which is \lstinline!(Int => B) => B!,
match the type of the argument of \lstinline!p[A]!, which is \lstinline!Int => A!,
with some choice of \lstinline!A! and \lstinline!B!? A function
type \lstinline!P => Q! matches \lstinline!X => Y! only if \lstinline!P = X!
and \lstinline!Q = Y!. So \lstinline!(Int => B) => B! can match
\lstinline!Int => A! only if \lstinline!Int => B! matches \lstinline!Int!
and if \lstinline!B = A!. But it is impossible for \lstinline!Int => B!
to match \lstinline!Int!, no matter how we choose \lstinline!B!. 

We conclude that types cannot be chosen consistently in \lstinline!p[A](p[B])!.
One also says that the expression \lstinline!p(p)! is \textbf{not
well-typed}\index{well-typed expression}, or does not \textbf{typecheck}\index{type checking}.
Such expressions contain a type error and are rejected by the Scala
compiler.

For any given code expression containing variables and functions,
one can always find the most general type that makes all functions
match their arguments, unless the expression does not typecheck. Algorithms
such as the Damas-Hindley-Milner algorithm\footnote{\href{https://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner_type_system\#Algorithm_W}{https://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner\_type\_system\#Algorithm\_W}}
will perform type inference (or determine that there is a type error)
for a large class of expressions that may contain functions, tuples,
and disjunctive types. 

\subsection{Calculations with curried functions}

In mathematics, functions are evaluated by substituting their argument
values into their body. Nameless functions are evaluated in the same
way. For example, applying the nameless function $x\Rightarrow x+10$
to an integer $2$, we substitute $2$ instead of $x$ in \textquotedblleft $x+10$\textquotedblright{}
and get \textquotedblleft $2+10$\textquotedblright , which we then
evaluate to $12$. The computation is written like this, 
\[
(x\Rightarrow x+10)(2)=2+10=12\quad.
\]
To run this computation in Scala, we need to add a type annotation:
\begin{lstlisting}
scala> ((x: Int) => x + 10)(2)
res0: Int = 12 
\end{lstlisting}

Curried function applications such as $f(x)(y)$ are rarely used in
mathematics , so we need to gain some experience working with them.

Let us consider a curried nameless function being applied to arguments,
such as \lstinline!(x => y => x - y)(20)(4)!, and compute the result
of this function application. Begin with the argument \lstinline!20!;
applying a nameless function of the form \lstinline!(x => ...)! to
\lstinline!20! means to substitute \lstinline!x = 20! into the body
of the function. After that substitution, we obtain the expression
\lstinline!y => 20 - y!, which is again a nameless function. Applying
that function to the remaining argument \lstinline!(4)! means substituting
\lstinline!y = 4! into the body of that function. This yields the
expression \lstinline!20 - 4!. We can compute that and get the result,
\lstinline!16!. Check the result with Scala:
\begin{lstlisting}
scala> ((x: Int) => (y: Int) => x - y)(20)(4)
res1: Int = 16
\end{lstlisting}

Applying a curried function such as \lstinline!x => y => z => expr(x,y,z)!
to three curried arguments \lstinline!10!, \lstinline!20!, and \lstinline!30!
means to substitute \lstinline!x = 10!, \lstinline!y = 20!, and
\lstinline!z = 30! into the expression \lstinline!expr!. In this
way, we can easily apply a curried function to any number of curried
arguments.

This calculation is helped by the convention that \lstinline!f(g)(h)!
means first applying \lstinline!f! to \lstinline!g! and then applying
the result to \lstinline!h!. In other words, function application
associates to the \emph{left}: \lstinline!f(g)(h) = (f(g))(h)!. It
would be confusing if function application associated to the right
and \lstinline!f(g)(h)! meant first applying \lstinline!g! to \lstinline!h!
and then applying \lstinline!f! to the result. If \emph{that} were
the syntax convention, we would not be able to reason so easily about
applying a curried function to the arguments.

We see that the right associativity for the function arrow \lstinline!=>!
is well adapted to the left associativity for function applications.
All functional languages adopt these syntactic conventions.

To perform the calculations faster, we will write code in a short
mathematical notation rather than in the Scala syntax. We will write
type annotations with a colon in the \emph{superscript}, for example:
$x^{:\text{Int}}\Rightarrow x+10$ instead of the Scala code \lstinline!((x:Int) => x + 10)!.

The symbolic evaluation of the Scala code \lstinline!((x:Int) => (y:Int) => x - y)(20)(4)!
can be written as the following derivation,
\begin{eqnarray*}
 &  & (\gunderline{x^{:\text{Int}}\Rightarrow}\,y^{:\text{Int}}\Rightarrow\gunderline x-y)\left(20\right)\left(4\right)\\
{\color{greenunder}\text{substitute }x=20:}\quad & = & (\gunderline{y^{:\text{Int}}\Rightarrow}\,20-\gunderline y)\left(4\right)\\
{\color{greenunder}\text{substitute }y=4:}\quad & = & 20-4=16\quad.
\end{eqnarray*}
We use the green underline to show the part of the expression that
is being rewritten in the next step.

Here we have been performing calculations step by step, substituting
an argument into a function at each step. A Scala program is evaluated
in a similar way at run time.

Nameless functions are \emph{values} and so can be used as part of
larger expressions, just as any other values. For instance, nameless
functions can be arguments of other functions (nameless or not). Here
is an example of applying a nameless function $f\Rightarrow f(2)$
to a nameless function $x\Rightarrow x+4$:
\begin{align*}
 & (f\Rightarrow\gunderline f(2))\left(x\Rightarrow x+4\right)\\
{\color{greenunder}\text{substitute }f=\left(x\Rightarrow x+4\right):}\quad & =(x\Rightarrow\gunderline x+4)(2)\\
{\color{greenunder}\text{substitute }x=2:}\quad & =2+4=6\quad.
\end{align*}
In the nameless function $f\Rightarrow f(2)$, the argument $f$ has
to be itself a function, otherwise the expression $f(2)$ would make
no sense. The argument $x$ of $f(x)$ must be an integer, or else
we would not be able to compute $x+4$. The result of computing $f(2)$
is $4$, and integer. We conclude that in this example, $f$ must
have type \lstinline!Int => Int!, or else the types will not match.
To verify this result in Scala, we need to specify the type annotation
for $f$:
\begin{lstlisting}
scala> ((f: Int => Int) => f(2))(x => x + 4)
res2: Int = 6  
\end{lstlisting}
The type annotations are not necessary for $x\Rightarrow x+4$ since
the Scala compiler already knows the type of $f$ and can infer that
$x$ in $x\Rightarrow x+4$ must have type \lstinline!Int!.

To summarize the standard syntax conventions for curried nameless
functions:
\begin{itemize}
\item Function expressions group everything to the right:\\
so $x\Rightarrow y\Rightarrow z\Rightarrow e$ means $x\Rightarrow\left(y\Rightarrow\left(z\Rightarrow e\right)\right)$.
\item Function applications group everything to the left:\\
so $f(x)(y)(z)$ means $\big((f(x))(y)\big)(z)$. 
\item Function applications group stronger than infix operations:\\
so $x+f(y)$ means $x+(f(y))$, as in mathematics.
\end{itemize}
Here are some more examples of performing function applications symbolically.
Types are omitted for brevity, since every non-function value is of
type \texttt{}\lstinline!Int! in these examples.
\begin{align*}
\left(x\Rightarrow x*2\right)(10) & =10*2=20\quad.\\
\left(p\Rightarrow z\Rightarrow z*p\right)\left(t\right) & =(z\Rightarrow z*t)\quad.\\
\left(p\Rightarrow z\Rightarrow z*p\right)(t)(4) & =(z\Rightarrow z*t)(4)=4*t\quad.
\end{align*}
Some results of these computation are integer values such as $20$;
in other cases, results are nameless functions such as $z\Rightarrow z*t$.
Verify this in Scala:
\begin{lstlisting}
scala> ((x:Int) => x*2)(10)
res3: Int = 20

scala> ((p:Int) => (z:Int) => z*p)(10)
res4: Int => Int = <function1>

scala> ((p:Int) => (z:Int) => z*p)(10)(4)
res5: Int = 40 
\end{lstlisting}

In the following examples, some arguments are themselves functions:
\begin{align}
 & (\gunderline f\Rightarrow p\Rightarrow f(p))\left(g\Rightarrow g(2)\right)\nonumber \\
{\color{greenunder}\text{substitute }f=\left(g\Rightarrow g(2)\right):}\quad & =p\Rightarrow(g\Rightarrow\gunderline g(2))\,(p)\nonumber \\
{\color{greenunder}\text{substitute }g=p:}\quad & =p\Rightarrow p(2)\quad.\label{eq:higher-order-functions-derivation1}
\end{align}
The result of this expression is a function $p\Rightarrow p(2)$ that
will apply \emph{its} argument to the value $2$. In other words,
this function expects that its argument $p$ has the type of a function
\lstinline!Int => Int!. A suitable argument is a function $x\Rightarrow x+4$,
and we can apply the previous expression to that function:
\begin{align*}
 & \gunderline{\left(f\Rightarrow p\Rightarrow f(p)\right)\left(g\Rightarrow g(2)\right)}\left(x\Rightarrow x+4\right)\\
{\color{greenunder}\text{use Eq.~(\ref{eq:higher-order-functions-derivation1})}:}\quad & =(p\Rightarrow\gunderline p(2))\left(x\Rightarrow x+4\right)\\
{\color{greenunder}\text{substitute }p=\left(x\Rightarrow x+4\right):}\quad & =(x\Rightarrow\gunderline x+4)\left(2\right)\\
{\color{greenunder}\text{substitute }x=2:}\quad & =2+4=6\quad.
\end{align*}

To verify this calculation in Scala, we need to add appropriate type
annotations for $f$ and $p$. The reasoning bout types goes like
this: We know that the function $f\Rightarrow p\Rightarrow f(p)$
is being applied to the arguments $g\Rightarrow g(2)$ and $x\Rightarrow x+4$.
The variable $g$ in $g\Rightarrow g(2)$ must be a function with
argument of type \lstinline!Int!; let us assume that $g$ has type
\lstinline!Int => A! with a type parameter \lstinline!A! that we
do not yet know. It follows that the function $g\Rightarrow g(2)$
has type \lstinline!(Int => A) => A!. This must also be the type
of the argument $f$ in $f\Rightarrow p\Rightarrow f(p)$. 

The variable $x$ in $x\Rightarrow x+4$ must be of type \lstinline!Int!,
or else we cannot add $x$ to $4$. So, the type of the expression
$x\Rightarrow x+4$ is \lstinline!Int => Int!, and so must be the
type of the argument $p$ in $f\Rightarrow p\Rightarrow f(p)$. 

Finally, we need to make sure that the types match in the function
$f\Rightarrow p\Rightarrow f(p)$. The types match in $f(p)$ if the
type of $f$'s argument is the same as the type of $p$. Since $f$
has type \lstinline!(Int => A) => A!, its argument has type \lstinline!Int => A!.
This will be the same as the type of $p$, which is \lstinline!Int => Int!,
only if we set \lstinline!A = Int!. So, the actual type of $f$ is
\lstinline!(Int => Int) => Int!. We know enough to write the Scala
code now:
\begin{lstlisting}
scala> ((f: (Int => Int) => Int) => p => f(p))(g => g(2))(x => x + 4)
res6: Int = 6
\end{lstlisting}
Type annotations for $p$, $g$, and $x$ are not necessary because
Scala can derive their types unambiguously from the given type of
$f$.

\subsubsection{Example \label{subsec:Example-hof-derive-types-5}\ref{subsec:Example-hof-derive-types-5}}

Infer the most general type for the fully parametric function
\begin{lstlisting}
def q[...]: ... = { f => g => g(f) }
\end{lstlisting}
What types are inferred for the expressions \lstinline!q(q)! and
\lstinline!q(q(q))!?

\subparagraph{Solution}

In the sub-expression $f\Rightarrow g\Rightarrow g(f)$, the curried
argument $g$ must itself be a function, because it is being applied
to $f$ as $g(f)$. So we can assign types as $f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f)$,
where $A$ and $B$ are some type parameters. Since there are no other
constraints on the types, the parameters $A$ and $B$ remain arbitrary
and need to be added to the type signature:
\begin{lstlisting}
def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end{lstlisting}

To match types in the expression \lstinline!q(q)!, we first assume
arbitrary type parameters and write \lstinline!q[A,B](q[C,D])!. The
type of the first curried argument of \lstinline!q[A, B]!, which
is \lstinline!A!, must match the type of \lstinline!q[C, D]!, so
we must set
\[
A=\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\quad.
\]
The type of \lstinline!q(q)! becomes
\begin{align*}
q^{A,B}(q^{C,D}) & :\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad,\\
\text{where } & A\triangleq\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\quad.
\end{align*}

We use this result to infer the most general type for the expression
\lstinline!q(q(q))!. We may denote $r\triangleq q(q)$ for brevity;
then, as we already know, $r$ has type $\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B$.
To infer types in the expression \lstinline!q(r)!, we introduce new
type parameters \lstinline!E, F! and write \lstinline!q[E, F](r)!.
The type of the argument of \lstinline!q[E, F]! is \lstinline!E!,
and this must be the same as the type of \lstinline!r!. This gives
the constraint
\[
E=\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad.
\]
Other than that, the type parameters are arbitrary. The type of the
expression \lstinline!q(q(q))! is $\left(E\Rightarrow F\right)\Rightarrow F$.
We conclude that the most general type of \lstinline!q(q(q))! is
\begin{align*}
q^{E,F}(q^{A,B}(q^{C,D})) & :\left(\left(\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\right)\Rightarrow F\right)\Rightarrow F\quad,\\
\text{where } & A\triangleq\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\\
\text{and } & E=\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad.
\end{align*}
It is clear that we will be able to find matching types for expressions
such as \lstinline!q(q(q(q)))!, \lstinline!q(q(q(q(q))))!, and so
on.

To test our results in Scala, we write the type signatures (renaming
the type parameters for clarity to \lstinline!A!, \lstinline!B!,
\lstinline!C!, \lstinline!D!):
\begin{lstlisting}
scala> def qq[A, B, C]: ((A => (A => B) => B) => C) => C = q(q)
qq: [A, B, C]=> ((A => ((A => B) => B)) => C) => C

scala> def qqq[A, B, C, D]: ((((A => (A => B) => B) => C) => C) => D) => D =
     |  q(q(q))
qqq: [A, B, C, D]=> ((((A => ((A => B) => B)) => C) => C) => D) => D
\end{lstlisting}
We did not need to give any type parameters within the expressions
\lstinline!q(q)! and \lstinline!q(q(q))! because the full type signature
was declared at the beginning of each of these expressions. Since
the Scala compiler did not print any error messages, we are assured
that the types match correctly.

\subsubsection{Example \label{subsec:Example-hof-curried}\ref{subsec:Example-hof-curried}}

Infer types in the code expression
\[
\left(f\Rightarrow g\Rightarrow g(f)\right)\left(f\Rightarrow g\Rightarrow g(f)\right)\left(f\Rightarrow f(10)\right)\quad,
\]
and simplify the code as much as possible.

\subparagraph{Solution}

The given expression is a curried function $f\Rightarrow g\Rightarrow g(f)$
applied to two curried arguments. The plan is to consider each of
these sub-expressions in turn, assigning types for them using type
parameters, and then to figure out how to set the type parameters
so that all types match.

Begin by renaming the shadowed variables $f$ and $g$, so that no
names are repeated:
\begin{equation}
\left(f\Rightarrow g\Rightarrow g(f)\right)\left(x\Rightarrow y\Rightarrow y(x)\right)\left(h\Rightarrow h(10)\right)\quad.\label{eq:example-hof-curried-function-solved1}
\end{equation}
 As we have seen in Example~\ref{subsec:Example-hof-derive-types-5},
the sub-expression $f\Rightarrow g\Rightarrow g(f)$ is typed as $f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f)$,
where $A$ and $B$ are some type parameters. The sub-expression $x\Rightarrow y\Rightarrow y(x)$
is the same function as $f\Rightarrow g\Rightarrow g(f)$ after renaming
of the arguments ($x$ instead of $f$ and $y$ instead of $g$).
Renaming a function's arguments does not change that function. So
the types in $x\Rightarrow y\Rightarrow y(x)$ can be written as $x^{:C}\Rightarrow y^{:C\Rightarrow D}\Rightarrow y(x)$.
We need to introduce new type parameters $C$, $D$ because these
types may be different from $A$, $B$. The types $A$, $B$, $C$,
$D$ are so far unknown.

Finally, the variable $h$ in the sub-expression $h\Rightarrow h(10)$
must have type $\text{Int}\Rightarrow E$, where $E$ is another type
parameter. So, the sub-expression $h\Rightarrow h(10)$ is a function
of type $\left(\text{Int}\Rightarrow E\right)\Rightarrow E$.

The types must match in the entire expression~(\ref{eq:example-hof-curried-function-solved1}):
\begin{equation}
(f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f))(x^{:C}\Rightarrow y^{:C\Rightarrow D}\Rightarrow y(x))(h^{:\text{Int}\Rightarrow E}\Rightarrow h(10)\quad.\label{eq:example-hof-curried-function-solved2}
\end{equation}
It follows that $f$ must have the same type as $x\Rightarrow y\Rightarrow y(x)$,
and $g$ must have the same type as $h\Rightarrow h(10)$. The type
of $g$, which we know as $A\Rightarrow B$, will match the type of
$h\Rightarrow h(10)$, which we know as $\left(\text{Int}\Rightarrow E\right)\Rightarrow E$,
only if $A=\text{Int}\Rightarrow E$ and $B=E$. It follows that $f$
has type $\text{Int}\Rightarrow E$. At the same time, the type of
$f$ must match the type of $x\Rightarrow y\Rightarrow y(x)$, which
is $C\Rightarrow(C\Rightarrow D)\Rightarrow D$. This can work only
if $C=\text{Int}$ and $E=(C\Rightarrow D)\Rightarrow D$.

In this way, we have found all the relationships between the type
parameters $A$, $B$, $C$, $D$, $E$ in Eq.~(\ref{eq:example-hof-curried-function-solved2}).
The type $D$ remains undetermined (i.e.~arbitrary), while 
\begin{align}
A & =\text{Int}\Rightarrow\left(\text{Int}\Rightarrow D\right)\Rightarrow D\quad,\label{eq:example-hof-curried-solved3}\\
B & =E=\left(\text{Int}\Rightarrow D\right)\Rightarrow D\quad,\label{eq:example-hof-curried-solved4}\\
C & =\text{Int}\quad.\nonumber 
\end{align}
The entire expression in Eq.~(\ref{eq:example-hof-curried-function-solved2})
is a saturated application of a curried function, and thus has the
same type as the ``final'' result expression $g(f)$, which has
type $B$. So, the entire expression has type $\left(\text{Int}\Rightarrow D\right)\Rightarrow D$.

Having established that types match, we can now omit the type annotations
and rewrite the code expression as
\begin{align*}
 & (f\Rightarrow g\Rightarrow\gunderline g(\gunderline f))\left(x\Rightarrow y\Rightarrow y(x)\right)\left(h\Rightarrow h(10)\right)\\
{\color{greenunder}\text{substitute }f,g:}\quad & =(h\Rightarrow\gunderline h(10))\left(x\Rightarrow y\Rightarrow y(x)\right)\\
{\color{greenunder}\text{substitute }h:}\quad & =(x\Rightarrow y\Rightarrow y(\gunderline x))(10)\\
{\color{greenunder}\text{substitute }x:}\quad & =y\Rightarrow y(10)\quad.
\end{align*}
The type of this expression is $\left(\text{Int}\Rightarrow D\right)\Rightarrow D$
for an arbitrary type $D$. Since the argument $y$ is an arbitrary
function, we cannot simplify $y(10)$. We find that 
\[
y^{:\text{Int}\Rightarrow D}\Rightarrow y(10)
\]
is the final simplified form of Eq.~(\ref{eq:example-hof-curried-function-solved1}).

To test this in Scala, we first define the function $f\Rightarrow g\Rightarrow g(f)$
as in Example~\ref{subsec:Example-hof-derive-types-5},
\begin{lstlisting}
def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end{lstlisting}
We also define the function $h\Rightarrow h(10)$ with a general type
$\left(\text{Int}\Rightarrow E\right)\Rightarrow E$,
\begin{lstlisting}
def r[E]: (Int => E) => E = { h => h(10) }
\end{lstlisting}
To help Scala evaluate Eq.~(\ref{eq:example-hof-curried-function-solved2}),
we need to set the type parameters for the first \lstinline!q! function
as \lstinline!q[A, B]! where \lstinline!A! and \lstinline!B! are
given by Eqs.~(\ref{eq:example-hof-curried-solved3})\textendash (\ref{eq:example-hof-curried-solved4}):
\begin{lstlisting}
scala> def s[D] = q[Int => (Int => D) => D, (Int => D) => D](q)(r)
s: [D]=> (Int => D) => D
\end{lstlisting}
To verify that the function $s^{D}$ equals $y^{:\text{Int}\Rightarrow D}\Rightarrow y(10)$,
we apply $s^{D}$ to some functions of type $\text{Int}\Rightarrow D$,
say, for $D=\text{Boolean}$ and $D=\text{Int}$:
\begin{lstlisting}
scala> s(_ > 0) // Evaluate 10 > 0.
res6: Boolean = true

scala> s(_ + 20) // Evaluate 10 + 20.
res7: Int = 30
\end{lstlisting}


\subsubsection{Exercise \label{subsec:Exercise-hof-curried-1}\ref{subsec:Exercise-hof-curried-1}}

Apply the function $\left(x\Rightarrow\_\Rightarrow x\right)$ to
the value $\left(z\Rightarrow z(q)\right)$ where $q$ is a given
value of type $Q$. Infer types in the resulting expression.

\subsubsection{Exercise \label{subsec:Exercise-hof-curried-3}\ref{subsec:Exercise-hof-curried-3}}

Infer types in the following expressions:
\begin{align*}
\text{(a):}\quad & p\Rightarrow q\Rightarrow p(t\Rightarrow t(q))\quad,\\
\text{(b):}\quad & p\Rightarrow q\Rightarrow q(x\Rightarrow x(p(q)))\quad.
\end{align*}


\subsubsection{Exercise \label{subsec:Exercise-hof-curried-4}\ref{subsec:Exercise-hof-curried-4}}

Show that the following expressions are not well-typed:
\begin{align*}
\text{(a):}\quad & p\Rightarrow p(q\Rightarrow q(p))\quad,\\
\text{(b):}\quad & p\Rightarrow q\Rightarrow q(x\Rightarrow p(q(x)))\quad.
\end{align*}


\subsubsection{Exercise \label{subsec:Exercise-hof-curried-2}\ref{subsec:Exercise-hof-curried-2}}

Infer types and simplify the following code expressions:
\begin{align*}
\text{(a):}\quad & q\Rightarrow\left(x\Rightarrow y\Rightarrow z\Rightarrow x(z)(y(z))\right)\left(a\Rightarrow a\right)\left(b\Rightarrow b(q)\right)\quad,\\
\text{(b):}\quad & \left(f\Rightarrow g\Rightarrow h\Rightarrow f(g(h))\right)(x\Rightarrow x)\quad,\\
\text{(c):}\quad & \left(x\Rightarrow y\Rightarrow x(y)\right)\left(x\Rightarrow y\Rightarrow x\right)\quad,\\
\text{(d):}\quad & \left(x\Rightarrow y\Rightarrow x(y)\right)\left(x\Rightarrow y\Rightarrow y\right)\quad,\\
\text{(e):}\quad & x\Rightarrow\left(f\Rightarrow y\Rightarrow f(y)(x)\right)\left(z\Rightarrow\_\Rightarrow z\right)\quad,\\
\text{(f):}\quad & z\Rightarrow\left(x\Rightarrow y\Rightarrow x\right)\left(x\Rightarrow x(z)\right)(y\Rightarrow y(z))\quad.
\end{align*}


\section{Summary}

\begin{comment}
infer the type from the code that you write so you write some code
do specify some types like this and then clearly this is a string
since you're doing two strings so if you if you do control shift P
it knows is that to strain in the function it turns the string so
compose has type parameters the Scala compiler will find the values
of these type parameters that fit in this case so for example this
function obviously you're returning a boolean here because this expression
is a boolean expression so this first argument has type integer -
boolean this is inferred from the code that you wrote you don't have
to say explicitly that this is integer - boolean you just say this
is integer then it knows this must be boolean so it infers that this
expression is integer to boolean and the compose function has the
first argument text Y therefore X the type parameter the capital X
must be equal to the type integer as a type variable capital X and
the capital y must be equal to the type boolean similarly the second
argument of compose is this expression and it has type of a function
from boolean to string which follows from the code so the skeleton
Pilar then looks at your definition of the function compose and finds
that G has typed Y to Z so obviously the type variable y must be equal
to the type boolean and the type variable Z must be equal to the type
string in the previous argument Y was also equal to boolean so that
fits Y is the same one as this it has value blue in Z has value string
X has value int if any of these types did not match like for example
the first argument gave you from integer to integer and a second from
boolean to strengthen this y must be integer but this y must be boolean
that does not match this woman this must be the value of the type
variable the compiler will then give you an error in this way the
compiler in first the type that this is integer to string and so f
if you do control shift P it tells you it's integer to string another
function in IntelliJ is option enter which says add type annotation
it automatically inserts the type annotation that it inferred from
your code this is also a very useful function to check that the compiler
understands your code in the same way as you think your code is supposed
to be working in terms of types so this will give you a check that
the function f has the type you think it should help but you don't
once you check that maybe you don't need to write this type a Scala
compiler does not infer every type it in first most but not all types
in many cases you have to specify some types for example type of argument
in a function often needs to be specified alternatively you could
specify type arguments of the compose function let me show you how
that works let's call as f f1 now I'm going to delete the type annotation
here and now once I delete them things become red because it doesn't
know that X is integer you see compose has a fully parametric type
so the first function is X 2y it has no clue that X you think must
be integer but if I write here I can with this syntax I can say it's
integer so I I have to specify these three arguments integer boolean
string once I do that the Scala compiler will check that everything
I wrote here fits what I just said so what I said is that compose
in this line is called with type arguments int boolean string so F
must be in two boolean and then this fits X is in let me do ctrl shift
key so now Scala knows that this X is integer this Y is boolean so
it knows that once it knows that I can write it in the shorter format
which I showed you in a previous tutorial this format of the functions
typically if you have a function that looks like X going to X something
you just replace this by underscore this is a special syntax that
Scala provides to write functions in a shorter way and now since all
types are specified you don't need to specify in the don't need to
write type annotations in this long format so this is a shorter format
and then F 1 of 23 should equal false F 1 of 22 and equal true let's
run this test and see that it passes and let it compiles of course
even though we don't see in your head there might be errors but the
Scala compiler will catch everything is great good so let's look at
our first worked example I define the functions constant Eid as in
the previous slide what is coin stop it and what is the type of that
value cost of it so how do we find out well this looks like an idle
question but it's a useful exercise so let's reason about constant
it constant it are defined here so what would be cost of it const
has the first argument of type C so when we say Const of it it means
that C is the type of it now the type of it is T two T is a function
it means that C must be equal to the function T two T let's write
this as a comment constant get so C Const has two type parameters
and it has one type to another so let's try to put these parameters
in so it can have any parameter T constant must have the trend or
C of X so the first argument C must be equal to the type of Eid of
T which is C 2 T so C must be T 2 T 2 good then when we apply constitu
its first argument of type C it returns a function of type X to see
where X is anything so it means that the result of applying constant
to its argument is something of type X 2 C now C we know is T 2 T
so the result is this I don't write parentheses because by convention
these parentheses are unnecessary on the right side of the error so
this is the type of Const of it it has still two unknown type parameters
X and T and the type is X 2 T 2 T so that is our reasoning let me
go to the actual code that I prepared so Const of it so that let me
put the comment here and let's see what happens if we just start writing
I will delete this let's see what happens if we write code like this
Const of it what would be the type of this so let me press option
enter and add the type and notation it's a very curious type it inferred
any - nothing - nothing so it looks like X 2 T 2 T except it didn't
introduce type parameters so Scala does not infer the most general
type which we inferred well scholars compiler is limited in this way
its type inference is limited so this is certainly not going to work
nothing isn't very useless type in this case we actually don't need
one test type but that's what Scala in first because it has no information
now the second attempt we made I made was this I put a type parameter
here and then I say it has that parameter here so what the result
of this is any Tootsie Tootsie so it instead of it did not infer type
tramp your ex like I said Scala cannot really do this it will infer
nothing or any it cannot infer that there is a type parameter okay
so that is a little better any is really any type it's a type that
fits anything is also not very useful it doesn't check any any correct
types so that's not great let's try this so you see we had this idea
that this works when C is T - t let's put explicitly name this - T
so this is what we wrote okay so let's see if this makes intelligent
infer the type es so let me rename this to X and then we have exactly
what I have here in the comment so another way of achieving the same
result is that I write the type here and then I don't write any type
parameters on the right hand side that works too so here what happens
is that I specify the type and IntelliJ or Scala compiler rather will
fit the types so it knows this is T 2 T this is C 2 X 2 C and C will
be equal to T 2 T so until now I've only looked at types I don't actually
talk about didn't talk talk about what this value does this constant
it well it's a function it takes an argument of any type and returns
this which is the identity function let's check that it works actually
so let me say C equals example 0 1 B of let's say some number okay
so something is wrong here yes so I define this method twice let's
go see okay now the result of calling this function which is constant
of it on the number is a function which has no type nothing to nothing
so I need to specify type parameters here so let me say this is int
and this is moving then C will have type boolean tubulin so in this
way I get an identity function of type boolean to boolean now this
is more flexible I can define a function which is of type C you know
where I I say this is of type T and then I can have a function of
type t - t right so this is an identity so I can say for example C
of ABC that should be call ABC let me run this test so now C is identity
function now this identity function is fully parametric because I
put all the types in here so green to run the test I press control-shift
are by the way very useful thing you are in in a test code then you
just press control shift or it only runs one test all right so these
are the types and this is the value it's an identity function of some
arbitrary type second example define a function twice that takes the
function f as its argument returns a new function it applies F twice
for example twice of this must return a new function which is equivalent
to that is equivalent to adding six so adding three twice so let's
implement this function here is the implementation basically what
we remove the type now it's red so the function twice takes a function
f as an argument and function f has some type which type should it
have what's reason about this so this is a solution let's find out
how we reason about the problem to derive the solution so let me write
this as a comment I want to do a a function twice must take some F
as an argument so let's say this is a 2b and it must return some C
so what does it do what is this C well we return required to return
the function okay so that's this function should be applying F twice
to some argument so f of f of X now what is X well obviously X must
be the argument so we need to return this code so this code seems
to be clear we need to return a function that takes X and applies
F twice 2x so what remains is to determine the types here right now
I just said ABC because I don't know yet what they are the code is
already fixed this is what we want now what is the type of X well
it can be any type so let's say that the type of X is deep for example
well then we need to apply F to X and F has type A to B the only way
that can work is when X has type a then f of X will have type B okay
so D actually needs to be a now the result is that f of X has type
B now we apply F to that but F means type a has argument this can
only work when a is the same as B all right now F of a is a so the
result of this whole thing must be a so C is not actually a different
type it's also a alright so now we need an a as a parameter just one
parameter in this way we derived the code and actually oh actually
this is a to AML today sorry about that because we are returning a
function right now you see there are two ways of defining this they
are different only by syntax one is that we say define twice and then
we specify argument in parenthesis then we specify the return type
and when we write the code second way is just different syntax is
to say this is a kind of a value of this type so the first argument
this type which is the same as this it takes this argument and returns
this and here we could write parentheses again like that but this
is not necessary by the syntax convention the first pair of parentheses
is required it is necessary okay and what is the value of twice V
it is a function that takes this so it takes F of this type and return
the function that takes X of type T and returns this so these are
two I I not identical but equivalent ways of defining this function
which one is more convenient well the first one is less code to read
plus code to write and however the second one emphasizes the value
nature of functions so sometimes for clarity you would do this but
most of the time you undo this because it's shorter and also easier
to read as a function its argument its value and its code that takes
argument and so on and you could even declare this function with the
syntax with two pairs of parenthesis so let me show you how that works
so I declare the first argument I declare the second argument which
is of type T in the second pair of parenthesis so this is this X which
was here which must be of type T so I declare it here and then the
result is of type T and then I type this as the code now let's call
it twice zero so the tests don't stop working now all of these three
definitions declare exactly the same function which has effectively
two pairs of arguments at first sorry two sets of arguments the first
set is this the second set is that so in Scala you can have functions
that have any number of sets of arguments in this case each set has
just one argument so now notice this is not the same as twice f T
goes to T X T that's not the same that function is not returning a
function it just returns a value and it has two arguments you cannot
call this function with one argument at a time with this syntax with
two sets of arguments you can call as function with the first set
of argument and get a function back this is the curried syntax this
is not curried so this is not what we want if we wanted a function
that returns a function the only way to do that is to use this syntax
or this syntax or list syntax Scala gives you all these possibilities
most people would prefer this because this is the smallest code to
write but I just wanted to make it clear this is the same these all
three are the same thing and this is not the same all right so let
me delete that and now let's test so let's call twice on this function
right so we apply this function twice to ten we get 16 let's see how
we can specify types while Scala Allah requires you to specify types
somewhere so you can specify it here it will then infer that the type
arguments T on twice must be int or you can specify the type argument
T on twice it will then infer that this X must be int if you don't
do that things won't compile because it won't you know that T must
be int both are the same so another way of writing it is to write
both arguments at once so twice of this applied to 10 same answer
is 16 now I'm just testing twice V which I put over there let me just
doing this it's unnecessary to define it twice just to see that it
gives you the same results 16 another syntax for the same as this
remember in Scala when you have a function that looks like X goes
to X something then you can replace this entire thing next to X by
underscore so that is just making it shorter like this is a function
that adds 3 to its arguments so this underscore means argument this
is just fancy syntax a lot of people like it um so here the tests
basically show you all the different ways in which you can write the
same thing here's another interesting syntax that scholar gives you
again it's exactly the same thing it's twice V or applying which is
syntactic they are a variant of twice applied to the same argument
the function that takes X and goes to X plus 3 however now I put early
braces around this function which is possible acceptable and note
I don't need parentheses around the type anymore now this is a syntactic
convenience in Scala in most cases you want parentheses round round
parentheses for very simple functions and you want curly braces for
complicated functions functions in a curly brace can be multi-line
they can introduce new web new names like vowels you can do new depths
you can do whatever you want you cannot do this if you write that
in ordinary round parentheses that just won't work you are not allowed
to have multi-line expressions with vowels and deaths inside this
kind of parentheses Scala sandbox requires you in this case the right
curly brace once you write the curly brace we can't have multi-line
code with all kinds of stuff in it so we can here you can define new
things whatever you want it can be very complicated so for this reason
the Scala convention is that if your function is complicated use curly
braces if your function is extremely simple use round parentheses
let me undo all this and show you so this is a very simple function
that adds 3 to the argument for such things Scala provides a short
syntax and this syntax is equivalent but normally used for complicated
functions alright so much about cindex so Scala gives you all these
syntactic possibilities no matter how you define if and the syntax
works I just have all these tests that check that this all combinations
of syntax always worked in other programming languages there are fewer
versions of syntax in Scala der quite a lot don't think that I don't
think this is a drawback you can choose the one you like most the
most important thing however is the type that always needs to be given
when you have functions with fully parametric types Scala don't doesn't
usually know what X is in an anonymous function expression such as
this the next question is to derive what twice of twice is what does
it do well it's a function right twice returns a function so when
you call twice on something that returns a function so what does that
function do so if we reason about this twice applies its argument
two times to something so twice of twice will apply twice two times
to something so it will be like twice of twice of something now twice
of something is that something applied two times so twice of twice
of something means that itself applied to x so now I'm getting already
confused so let's write it down actually so these are the various
definitions of twice twice but before we start writing code let's
reason about what it should be so mathematically twice of twice is
a action that should be applied to some F so what is that first we
compute this so twice of something is going to be applying this two
times to that so this is the same as twice of twice all right now
twice of F is a function so this entire thing needs to be applied
to some X so this is equal to twice of X going to F of f of X now
this twice is going to apply this function two times to some argument
in other words this is some argument let's say X and it's going to
be applying this function two times to this argument so this is F
of F of F of f of X so that applies the function f for x to the argument
well maybe sense so these are the tests if you apply this twice twice
to a function like that it it applies this four times so it adds 12
and so the result of adding to a 12 to 10 is 22 now the interesting
thing is to apply it three times I leave that to you as an exercise
apply twice of twice of twice so I'm going to leave that and let's
concentrate now on types so we figured out what this function does
it just applies four times how to write it well if we just write twice
of twice things don't work the way we don't we see that as it doesn't
work if we do ctrl shift P that's the type it inferred and that's
no good it's nothing nothing nothing nothing so that's no good that's
no good now that's better so the type why is that type what is that
so let's reason about the type so twice has the type which we derived
over there the easiest way of thinking about the type of a function
is to write it like this as a kind of a value with parameter with
no explicit arguments and just as a value but of this type so this
is the type of twice now if I want to apply it twice to itself what
does it mean well this is that argument so the first argument is actually
t - t and in here it's again the same type so this cannot be the same
T in here and in here because the first argument of twice is T - t
and twice is this so the first realization is that these two instances
of twice cannot have the same type parameter let's call this type
parameter a let's call this type parameter B or or what's called as
T just to make it a little easier all right so twice T is is of this
type now what is a what can it be well the first argument of twice
a is of type so let me repeat this comment and say what is twice a
twice a has this type if it's a function whose first argument is this
the second argument is that so the first argument of twice a is this
so it has this type I remind you by convention this is how we interpret
this syntax with these parentheses so clearly this can be a to a only
when a is actually T to T and then a to a is this alright so now we
figured out that the type parameter a here must be actually t to t
okay so what is the result of : twice with argument twice well we
put this in here so this is twice of a right so we put this argument
here the result is this type so it's a to a a is this so it's again
that so a to a is equal to this now I'm this is not Scala code in
their comments that I wrote while I was thinking about the type of
this expression in Scala code you don't write this you cannot do that
so you can write that but you cannot write what I need so these are
just my notes for myself {[}Music{]} so now intelligent agrees there
are two ways to make or even three ways to make IntelliJ in further
types if I just write this IntelliJ doesn't infer the type if I write
this it doesn't improve the type which I verify here because this
example doesn't compile this example doesn't compile so three ways
that it works in terms of syntax first well obviously we have to specify
a type somewhere first we specify this parameter so we specify a remember
this was our a a second is we specified T the third is we specified
the entire thing on the left now maybe this is the best way because
it serves at the same time as documentation and as code if somebody
reads this code later it will be very helpful if they don't have to
go through this consideration again this is a calculation really what
we just did here is a calculation and I would say it's very nice that
we determine things by calculation in our programs we're not guessing
anything but once this calculation is done it is nice to document
its results so that other people don't have to repeat this calculation
again so however all these three things define exactly the same function
which I verify here in the tests calling this function again requires
you since this function is fully generic it doesn't have any non generic
parameters non parametric types generic and parametric is synonymous
it's I prefer to say parametric but in some programming languages
people use the word generic in terms of generic type nice parametric
type or type parameters so when you use this function you supply anonymous
function as the argument Scala needs to know the type of that function
either that type is inferred because you specify this where the type
is inferred because you specify this you can specify both that's not
an error it's just not necessary so that's how it works so now we
found out the type of twice twice let's go on the next example is
that we need to take a function with two arguments fix the value of
the first argument and return the function of the remaining one argument
we define this operation as a function with fully parametric types
and here is what we were supposed to do so we are supposed to have
a function first Arg with three type parameters the first argument
is a function from two arguments of types x and y to a z value x z
a second argument of the function is a value of type x and the result
must be a function from Y to Z so we fix the value of the first argument
of this F we call F on the x0 and the supplied Y so that results in
a new function that takes Y as an argument and returns Z so that is
the most general type that we could imagine for this kind of function
the code for this function is extremely simple just for readability
sometimes I like to put the code of the function on the next line
and also sometimes I like to put this into curly brackets in the curly
braces you saw that it's written or readable this is the code of the
function and this is the type of this return value but it's just syntax
it's exactly the same thing if the function is very simple like this
function for example it's okay to have it in all in one line all right
so this is it this is the reason this is the solution so how do we
reason about this problem how do we derive this solution so let me
see if I didn't know how to write this what would I do well I would
write the first part so we're supposed to have two arguments first
is a function of some type x and y sub two arguments function and
this is a general type of any function so that has two arguments then
the general type is XY going to Z I remind you this is not a to problem
XY Scala has a distinction if I wanted the tuple of XY I would have
done this and that means that the function f takes a single argument
that is a tuple of F of two parts having types x and y but in my problem
statement i was not supposed to do that i was supposed to define a
first arc whose argument is a function of two organs so that's a general
type and then the value x0 has type X and I'm then I'll return what
you can I return well there is not much I can return really all the
types are fully parametric so I cannot return Y for example because
I don't have any values of type Y I could return X but that's not
what I mean required to do and require to call F put in X 0 in it
so I don't know what that is but I need to call f of X 0 and y and
Y should be an argument of this new function so what is the type of
Y well obviously it must have type capital y there's no by the way
so this must be a capital y going to Z because F returns Z so in this
way I'm forced to have this as a return type and then I need to introduce
X Y Z as type variable since I'm using them here so in this way I
derive first well the code of the function is kind of clear from the
problem statement but then I derived the most general type signature
for this function a fully parameterised function type it does not
have any specific types like integers or emporia string or anything
all types are parameters alright so that is how I reason about this
solution and then I just check that this works so for example I have
a function try one that prints this and then I fix the argument of
the first argument the integer argument of try 1 to be 123 and then
the result is that so that works and also this syntax works so I can
call first Arg with two sets of arguments the first set of arguments
having two arguments the second set of arguments having a single argument
so now but by now I hope you can understand how this works and how
the syntax works alternative way of writing this function would be
to have a value like let's just call it first Arg 1 to make things
don't break a value like syntax where this doesn't have parameters
but it equals an expression which is a function so f okay so first
I say the type which is why point to Z and X so this is the first
set of arguments when I have a second set of arguments which is just
Y and then Z and then I say it's f going to Y going to I'm sorry F
comma X zero going to Y going to type of X near Y alright so this
is an alternative syntax for exactly the same function it has two
sets of arguments which means that here's the first set of arguments
arrow second set of arguments arrow result type this is a typical
thing for curried functions with multiple arrows and then the first
set of arguments actually has two arguments of these types the first
type is less the second type is this this is a bit harder to read
than that so I would not prefer to write things this way but this
is equivalent so it's important that you understand why this is equivalent
and how this works I can exactly the same syntax can be used for the
second function let's run this test to make sure this runs so this
is a solution of this example let me just wait until tests finish
component and then we'll go on moment the next example is we need
to implement a function that applies given function f repeatedly to
an initial value x0 until a given condition function returns true
so a hint is that this would be a signature so we'll have parameter
X type parameter X and then three arguments a function from X to X
initial value of type X and the condition from X to boolean now notice
we have this boolean so this is not a fully parametric function it
has a specific logic which is tied to this boolean type so that's
fine boolean is a very special type and that's probably okay so this
function is still widely usable for many different types X how would
we implement this function so there are two ways of implementing it
if you have gone through the previous tutorial we have seen how that
works the first way is using iterator which is a library function
second is to write explicit recursion let me go through the iterator
first I use the iterated function which is a standard library parameterize
by type X which is given to me here and iterate has two sets of arguments
it's a curried function the first argument is start which is of type
T which I called X here you see X is a type variable so this is like
an argument or a function as well so the type argument so these are
value arguments and this is a type argument and like in any function
argument I can rename this to anything I want I can rename this to
T I can reveal this to LA I can rename this to anything so by convention
these are single capital letters but it doesn't have to be this way
so iterate is the first argument which is start second argument is
a function from T to T so we have exactly the same arguments here
so I give X 0 and f as the arguments so what does iterate do it creates
an iterator that takes X 0 as the first value and then applies f repeatedly
getting the next value and again getting the next value and so on
that's exactly what we want however this will generate an infinite
iterators will never stop so what we need is to stop when this condition
is true so we filter which means we skip all the elements in the iterator
sequence for which the condition is not true after the filter I still
have an iterator of T but now all elements in this iterator sequence
are such that the condition returns true we actually only need the
first one so let's take one element the result of this is still an
iterator you see to see that I press command and I hover my mouse
over this symbol and then I see what type it would definition it has
an type in everything so after this I have a still an iterator of
T with just one element in it so now I can convert this to sequence
the result of that would be sequence of T having just one element
now I take a head of this sequence which is just one value it's safe
to take head because well either this condition is never true or it's
true sometimes if it's true sometimes we'll get that value this sequence
will be non-empty and head can be done on an on two secrets if this
condition is never true and this iterator will iterate forever the
filter will be never true so this entire thing will never return we
cannot do very much about this while we could in principle first specify
some max number of elements take that so we could do this to be safe
take 1 million elements and but that would is not what we were told
to do in the problem setting so in some real situation we should think
about limiting the number of iterations of course let's just forget
about this for now ok so this is a reasonably simple implementation
the second implementation uses tail recursion so that is a direct
translation of mathematical induction which is if the condition is
true already on the initial element that's the base case of the induction
and then we return that initial element otherwise we apply one function
f1 x and a function f to x0 and call the same function again so we
do the inductive step the the value is the same procedure applied
to the next value after the initial value now this is a little more
difficult to reason about perhaps than this and also what if I wanted
to limit the number of iterations then I have to complicate this code
significantly so tail recursion is not very nice to maintain its or
rather not Taylor just recursion at all recursive functions generally
take more work to write and more work to maintain that is to to make
the curve to make changes if you want to do other things or make things
different I'll do things differently it's more difficult to make changes
to recursive function then it is - this kind of code which is on the
surface it's not recursive was just calling library functions and
working directly on a sequence so iterator produces a sequence and
we just call functions on a sequence - nothing is recursive here recursion
is hidden somewhere in the library and it's safe so it's very easy
to change this code to do whatever we want so I would prefer this
implementation in production code it's easier to maintain how do I
test this well I test this using the procedure to compute approximate
square roots with the saturation so this is known from numerical methods
i iterate a square root sequence so given X and if given Y which is
an approximation to the square root then this formula gives a better
approximation to the square root of x and I iterate that with initial
value equal to 1/2 of X just randomly kind of chosen as Peralta strongly
not equal to x over 2 min most cases but anyway that's okay as an
initial guess and then the condition the condition is that Y times
y minus x is less than the given precision so I need to specify the
precision just write it like this with all s spaced out how do I test
this so I say precision is 10 to the minus 8 and then let's compute
square root of 25 that should be equal to 5 plus - precision so this
is test library that gives me their syntax and this test passes final
- worked examples are to infer types in a function so this is something
we have done when we were reasoning about twice and let's just do
this a little more to get practice to understand how types work in
functions alright so what is this let's reason about this I already
wrote of course the solution before but let's pretend we don't see
that so how do we reason about it so here's what we need right this
code is given what is the type of this value well obviously it's a
function what is the type of the argument of this function well this
is some kind of a so f has type a and then the code of the function
the expression is f of 2 well that can only work if F is itself a
function and this function has an argument that is an integer so a
must be actually int going to some B that's the only way that this
could make any sense all right now what is the result of applying
F to 2 the result is of type D so this will return B so what is the
type of this entire expression it's a function that takes F this and
returns this which is of type B so so it returns B and it takes this
does it type okay so it's let me write it a little more formatted
so this is the actual type now it has an unknown type B which is not
fixed by the code it could be any type so therefore we need this B
as a type parameter here this is how we derive the type now I wrote
this solution exactly the same code except I used T instead of B so
as we know this is a type variable so it can be renamed and we know
in mathematics our function arguments can be renamed type arguments
are the kind of function arguments as well although there are different
different sort so it's the same if we write B or T or any other letter
so in this way we infer the missing types so let's find out if this
works so how do we test well we need to supply a function of type
into T so I'd say T is boolean so let's supply this function which
is defined as this again this is a function I used before which checks
that X is even X going to this expression which is true only when
X is even so then P of F should equal true because 2 is even so the
function P applies def to a fixed argument which is 2 fixed value
which is 2 so then P of F is true because F in our example is checking
whether its argument is even another question here is whether P of
P works and I have a test here that says it does not compile so why
does P of P not compile let's reason about the type of P of P so P
of P let's write out the type arguments well it could be different
type arguments correct we don't know that so it could be different
type arguments since they're not written in this expression could
we find any type arguments a and B that would make this expression
well typed let's reason about this let's replace the expression P
of B with its type just for our own notes this is not going to be
Scala code it's going to be our reasoning which is some mathematical
like notation so we replace this with the type so the type of P of
B is this int going to be going to be and P of a is int going to a
going to a so this type is a function which is applied to this type
now the only way this can work is when the type of the argument of
this function is the same as the type of the expression that we are
applying it to so can it be that int int going to a is the same as
int going to be to be so the left hand side is something going to
something a function type mapping into a lab the right hand side is
again against something going to something so the only way this can
work is if a is the same as be yeah but now it doesn't worry because
int is not the same type as int going to 84 no possible type a we
could have int equal to this because this is a function type and this
is not a function type so there are no more type variables there is
nothing we can do to make this match so for this reason there are
no possibilities to find types or type parameters in this expression
so that the types match the compiler finds this and gives us an error
so if I write something like this I will have read type mismatch cannot
resolve reference be with such signature so it tries to find values
of type parameters that would match but it can't and so it gives me
read right away now this read is different from the read I would get
if I emitted type parameters somewhere because actually this can never
work whatever type parameters you put in it just will never match
because what we just saw well we just saw int cannot be equal to int
to me so that's why it will not compile the final worked example is
this inferred types in this code and ask questions about key of Q
and Q of Q of Q so this is kind of a puzzle a bit so let's go through
this just as an illustration of type directed reason so Q is given
as sowhat's again start reasoning q is given as f going to G going
to G of F f going to G going to G of F so this is the code that we
are given we should be able to put types on it so let me put this
into braces and let's put types so f is some type a maybe G is of
some type B I don't know what types so right now I just put some arbitrary
type various type of variables okay now G of F is in the code so it
means G must be a function such that its first argument is of type
a so this B must be of type a going to some C so let's call let's
put it more explicitly it's not helping to so okay so we assumed F
is of type a therefore G must be of type a to something so let's call
that something C without loss of generality the result is of type
C therefore so this whole thing is F type a going to a to C going
to C so the first argument is a the second is well it's a curried
function so it's the syntax with something arrow something arrow something
where the parentheses around the last pair are assumed so I'm not
going to write down but these parentheses are assumed and therefore
the type of Q must be this and that's the most general type I have
not assumed anything about any type so for example G is a function
it must be a function because it's applied to F but the result of
genius any types it could be any complicated type could be itself
a function I don't care so Q must have two type parameters a and C
therefore and that is the solution so this is exactly what I wrote
here except I used letters F and T instead of a and C and I have two
versions of syntax first is when I specify the types on the right
hand side the second if I specify the types on the left hand side
other than that it's exactly the same thing so Scala would not work
if I don't specify types it cannot infer type parameters so I have
to specify type parameters and I have to specify either this or this
if I specify this it will infer the right type if I specify that it
will infer types of F and type on G I prefer the second form because
it shows what type this value is so this computation doesn't have
to be repeated by people who will look at this code later and actually
I would even prefer q1 let's say which has two sets of our means one
is f-type F 1 and G of type F going to T and that's of type T so I
would actually prefer to write code like this because that is easier
to read I clearly show there two groups of arguments two sets of arguments
we are not actually mathematical sets leader sequences of arguments
as arguments are ordering here so first and second and I clearly separate
languages easier to read the types are given the result type in women
and the code is shortened so I don't have this longer expression which
is somewhat more difficult to read and I don't have this expression
however it's nice to understand that this is actually the function
value unworthiness all right so when I use this skill I need to specify
type parameters fmt otherwise it doesn't know what to do and that
means don't work well as we have seen before so let me just emphasize
two things first these three syntactic forms define exactly equivalent
code there's no difference between the code except the syntax second
thing I'd like to emphasize is that this function exists once in the
code and it can be used many times specifying different type parameters
so I could use it in this place in the code with these type parameters
at another place in the code with different type parameters I don't
have to repeat the definition of this function and it's not duplicate
it's called with different types so really type parameters are like
arguments where you call function call this function many times of
different audience you can call this function many tests also with
different type turnovers and different arguments here I show different
ways of using it so a has the type insta boolean - boolean and then
I use it on a function which is into the boolean I get boolean now
if I don't specify types then this doesn't work I have to specify
types here it works because I specified that this is returning boolean
so it could get both type parameters so you see sometimes you have
to specify types at other times if you give both arguments at once
then this is fine you don't have to specify type it's never an error
to specify type parameters just makes your code longer so it knows
this is an int because this is an int and then that is a boolean so
it knows this is a boy so in this case you didn't have to specify
this in here but you could and if you do the error message would probably
be easier to understand so I put here for example 10.0 type mismatch
expected int actual double but why does it expect int it's because
of this int that I wrote if I didn't write this this error wouldn't
be noticed so it's never a mistake to write types it's safer it guards
against mistakes in the code earlier but it's just more typing so
it's not always necessary alright now what is Q of Q well that's an
interesting same Q of Q and you see things are getting very long very
easy but I will not go through a key of P of Q perhaps because it's
very similar so let us go through Q of Q so that's reason about it
so what is Q of Q well first of all we need to put type parameters
Q has to type parameters a and B and this is C only right because
the two instances of Q could have completely different type parameters
the Scala compiler will try to find combinations of type parameters
that work together it may fail or it may succeed let's see if this
succeeds just as I did before I'm going to replace this expression
with its type just for the purposes of reasoning so what is the type
the easiest way to see the type is to look at this syntax so this
is the type F T is f f - t t so so this is going to be C going to
see me going through D and this is I'm just going to copy this in
here and replace CMD with mV so now I'm going to try to fit the types
together this function has the first argument which is of type a and
it's applied to this expression of this type so the only way this
can work if a equals this that's already something but once that is
so once a is equal to this then there is no more constraint so this
argument has been substituted it has the right type B is an is not
fixed so B can be anything so actually we have three arbitrate type
parameters now B CMD now I can rename them but I have three type parameter
so Q Q which is Q of Q has this type which is applying Q to this expression
and the result is this type now a is equal to that so I thought it
I'm dating just recently didn't it so let me copy this and instead
of a let me copy this now I need parentheses around it let me do it
slower put parentheses and then copy it in there now there are no
mistakes so this is actually the type of Q of Q it's a complicated
type it's a higher order function a function that takes as its first
argument this function that takes as its first argument this function
that takes as its first argument this of type C and the second argument
this so the complicated matching of types that we'll all be performed
automatically by the Scala compiler so the way that scholar can do
it for you is first you write this so we have just figured out it
a must be equal to this so let's put that in the type parameters and
then put all the type parameters explicitly and then say option enter
and add type annotations so the Scala compiler will infer this type
correctly in the same way reasoning about Q of Q of Q gives you this
set of type parameters and so I'm not going to go through this but
you're encouraged to travel now something that doesn't work is this
now you see there's a difference between this and this here I take
Q of Q and I apply Q to the result here I take Q of Q and apply that
again this does not compile because Scala cannot infer the correct
type arguments for these two cues so I can put arbitrary a and B but
it's complicated so how do it reason about this it is not clear actually
at the beginning whether this expression can be typed so in programming
languages such as Oh camel and Haskell I'm pretty sure this would
be done by the compiler because their type systems are different and
these examples can be typed automatically but in Scala this is not
automatic so let's reason about it and this is also a good exercise
so what is this expression is the same as QQ applied to Q here we
have a type of QQ with three type argument so let's put it here and
this Q has two type arguments so let's take this expression so basically
our {[}Music{]} question is can we find ABC F and T so that this is
a well typed expression now expression is well typed when all functions
receive arguments of the correct types that's basically the definition
here we have this function which is applied to this argument of this
type so the only condition is whether this function QQ o of types
ABC has the first argument which can be matched with this type let's
check what is the type of QQ of ABC it is this this is a function
whose first argument is yes parentheses so let's copy that so this
must equal this if that can be matched with some choice of ABC F T
then we're done there are no other problems how can this be matched
so again the only way that this can be matched is when the left is
a function of some X to some Y and the right also is a function from
some X to some one the same x and y now the left is a function from
this to see the right is a function from F to this remember there's
implicitly there are these parentheses here therefore f must equal
this and C must equal this okay can we do this of course we can F
can be equal to this and once that is true C must be equal to that
so let's put parentheses here and I'll paste it in alright so now
we can put this instead of F in here so that's right code actually
some parameters C T whatever actually C will be equal to that so a
B and T will remain and then we get QQ of a B C of Q of F C right
now let's paste so f is equal to this and C is equal to that and now
everything is green so now we can do option enter here and it will
infer the type so the type of this expression is actually this which
is the same as the type of QQ up to changing C 2 T so we can rename
this to C and it will be exactly the same type so this is very interesting
we we have Q of Q of this type and Q of Q of Q is again of this type
so clearly we can continue doing this Q of Q of Q of Q of Q and it
will still have the same type up to some complicated substitutions
in the types now this example I admit is quite artificial but this
serves to show you how type reasoning works here are some exercises
for you and you can apply the typed reasoning as I just showed you
in the same way and I encourage you to do these exercises 
\end{comment}


\subsection{Solved examples: higher-order functions}

Implement a function that applies a given function $f$ repeatedly
to an initial value $x_{0}$, until a given condition function cond
returns true:

def converge{[}X{]}(f: X $\Rightarrow$ X, x0: X, cond: X $\Rightarrow$
Boolean): X = ???
\begin{enumerate}
\item Using both \lstinline!def! and \lstinline!val!, define a function
that...
\begin{enumerate}
\item ...adds $20$ to its integer argument.
\begin{lyxcode}
def~fa(i:~Int):~Int~=~i~+~20

val~fa\_v:~(Int~$\Rightarrow$~Int)~=~k~$\Rightarrow$~k~+~20
\end{lyxcode}
It is not necessary to specify the type of the argument \texttt{k}
because we already fully specified the type \texttt{(Int => Int)}
of \texttt{fa\_v}. The parentheses around the type of \texttt{fa\_v}
are optional, I added them for clarity.
\item ...takes an integer $x$, and returns a \emph{function} that adds
$x$ to \emph{its} argument.
\begin{lyxcode}
def~fb(x:~Int):~(Int~$\Rightarrow$~Int)~=~k~$\Rightarrow$~k~+~x

val~fb\_v:~(Int~$\Rightarrow$~Int~$\Rightarrow$~Int)~=~x~$\Rightarrow$~k~$\Rightarrow$~k~+~x

def~fb\_v2(x:~Int)(k:~Int):~Int~=~k~+~x
\end{lyxcode}
Since functions are values, we can directly return new functions.
When defining the right-hand sides as function expressions in \texttt{fb}
and \texttt{fb\_v}, it is not necessary to specify the type of the
arguments \texttt{x} and \texttt{k} because we already fully specified
the type signatures of \texttt{fb} and \texttt{fb\_v}. The last version,
\texttt{fb\_v2}, may be easier to read and is equivalent to \texttt{fb\_v.}
\item ...takes an integer $x$ and returns \texttt{true} iff $x+1$ is a
prime. Use the function \texttt{is\_prime} defined previously.
\begin{lyxcode}
def~fc(x:~Int):~Boolean~=~is\_prime(x~+~1)

val~fc\_v:~(Int~$\Rightarrow$~Boolean)~=~x~$\Rightarrow$~is\_prime(x~+~1)
\end{lyxcode}
\end{enumerate}
\item Define a function \texttt{comp} that takes two functions $f:$\texttt{Int
$\Rightarrow$ Double} and $g:$\texttt{Double $\Rightarrow$ String}
as arguments, and returns a new function that computes $g(f(x))$.
What is the type of the function \texttt{comp}?
\begin{lyxcode}
{\footnotesize{}def~comp(f:~Int~$\Rightarrow$~Double,~g:~Double~$\Rightarrow$~String):~(Int~$\Rightarrow$~String)~=}{\footnotesize\par}

{\footnotesize{}~~x~$\Rightarrow$~g(f(x))}{\footnotesize\par}

{\footnotesize{}scala>~val~f:~Int~$\Rightarrow$~Double~=~x~$\Rightarrow$~5.67~+~x}{\footnotesize\par}

{\footnotesize{}scala>~val~g:~Double~$\Rightarrow$~String~=~x~$\Rightarrow$~f\textquotedbl x=\%3.2f\textquotedbl}{\footnotesize\par}

{\footnotesize{}scala>~val~h~=~comp(f,~g)}{\footnotesize\par}

{\footnotesize{}scala>~h(10)}{\footnotesize\par}
\end{lyxcode}
The function \texttt{comp} has two arguments, of types \texttt{Int
$\Rightarrow$ Double} and \texttt{Double $\Rightarrow$ String}.
The result value of \texttt{comp} is of type \texttt{Int $\Rightarrow$
String}, because \texttt{comp} returns a new function that takes an
argument $x$ of type \texttt{Int} and returns a \texttt{String}.
So the full type signature of the function \texttt{comp} is written
as
\begin{lyxcode}
///~(Int~$\Rightarrow$~Double,~Double~$\Rightarrow$~String)~$\Rightarrow$~(Int~$\Rightarrow$~String)
\end{lyxcode}
This is an example of a function that both takes other functions as
arguments \emph{and} returns a new function.
\end{enumerate}

\subsection{Exercises}

For the function id defined above, what is id(id) and what is its
type? Same question for id(const). Are id(id)(id) or id(id(id)) well-typed? 

For the function const above, what is const(const), and what is its
type?

For the function twice above, what does twice(twice(twice))) do? Write
out the type parameters. Test your answer on an example.

Define a function thrice that applies its argument function 3 times,
similarly to twice. What does thrice(thrice(thrice))) do?

Define a function ence that applies a given function $n$ times.

Define a function flip(f) with fully parametric types, which swaps
arguments for any given function f of two arguments. To test: 

def f(x: Int, y: Int) = x - y // check that f(10, 2) gives 8

val g = flip(f)  // now check that g(10, 2) gives (\textendash{} 8)
\begin{enumerate}
\item Implement a function of type \texttt{}\lstinline!Int => List[List[Int]] => List[List[Int]]!
similar to Exercise~\ref{subsec:ch1-transf-Exercise-4} except that
the hard-coded number $100$ must be a \emph{curried} first argument.
Implement Exercise~\ref{subsec:ch1-transf-Exercise-4} using this
function.
\item Implement a function thrice that takes a function $f^{:\text{Int}\Rightarrow\text{Int}}$
as its argument and returns a new function that computes $f(f(f(x)))$
for any given $x$. What is the required type of the function $q$?
\item Implement a function \lstinline!curry2! that takes an uncurried function
of type \texttt{}\lstinline!(Int, Int) => Int! and returns an equivalent
curried function of type \texttt{}\lstinline!Int => Int => Int!.
\end{enumerate}

\section{Discussion}

\subsection{Higher-order functions}

The \textbf{order\index{order of a function}} of a function is the
number of function arrows ``\lstinline!=>!'' contained in the type
signature of that function. If a function's type signature contains
more than one function arrow, the function is called a \textbf{\index{higher-order function}higher-order}
function. A higher-order function takes a function as argument and/or
returns a function as its result value.

The methods \lstinline!andThen!, \lstinline!compose!, \lstinline!curried!,
and \lstinline!uncurried! are examples of higher-order functions
that both take other functions as arguments \emph{and} return a new
function.

Examples:
\begin{lyxcode}
def~f1(x:~Int):~Int~=~x~+~10
\end{lyxcode}
The function \texttt{f1} has type signature \texttt{Int $\Rightarrow$
Int} and order 1, so it is \emph{not} a higher-order function.
\begin{lyxcode}
def~f2(x:~Int):~Int~$\Rightarrow$~Int~=~z~$\Rightarrow$~z~+~x
\end{lyxcode}
The function \texttt{f2} has type signature \texttt{Int $\Rightarrow$
Int $\Rightarrow$ Int} and is a higher-order function, of order 2. 
\begin{lyxcode}
def~f3(g:~Int~$\Rightarrow$~Int):~Int~=~g(123)
\end{lyxcode}
The function \texttt{f3} has type signature \texttt{(Int $\Rightarrow$
Int) $\Rightarrow$ Int} and is a higher-order function of order 2.

Although \texttt{f2} is a higher-order function, its higher-orderness
comes from the fact that the return value is of function type. An
equivalent computation can be performed by an uncurried function that
is not higher-order:
\begin{lyxcode}
scala>~def~f2u(x:~Int,~z:~Int):~Int~=~z~+~x
\end{lyxcode}
The Scala library defines methods to transform between curried and
uncurried functions:
\begin{lyxcode}
scala>~def~f2u(x:~Int,~z:~Int):~Int~=~z~+~x

scala>~val~f2c~=~(f2u~\_).curried

scala>~val~f2u1~=~Function.uncurried(f2c)
\end{lyxcode}
The syntax \lstinline!(f2u _)! is used in Scala to convert methods
to function values. Recall that Scala has two ways of defining a function:
one as a method\index{Scala method} (defined using \lstinline!def!),
another as a function value\index{function value} (defined using
\lstinline!val!). 

The methods \lstinline!.curried! and \lstinline!.uncurried! can
be easily implemented in Scala code, as we will see in the solved
examples.

Unlike \lstinline!f2!, the function \lstinline!f3! cannot be converted
to a non-higher-order function because \lstinline!f3! has an argument
of function type, rather than a return value of function type. Converting
to an uncurried form cannot eliminate an argument of function type.

\subsection{Scope of bound variables}

A bound variable is invisible outside the scope of the expression
(called \textbf{local scope\index{local scope}} whenever it is clear
which expression is being considered). This is why bound variables
may be renamed at will: no outside code could possibly use them and
depend on their values. However, outside code may define variables
that (by chance or by mistake) have the same name as a bound variable
inside the scope.

Consider this example from calculus: In the integral
\[
f(x)=\int_{0}^{x}\frac{dx}{1+x}\quad,
\]
a bound variable named $x$ is defined in \emph{two} local scopes:
in the scope of $f$ and in the scope of the nameless function $x\Rightarrow\frac{1}{1+x}$.
The convention in mathematics is to treat these two $x$'s as two
\emph{completely} \emph{different} variables that just happen to have
the same name. In sub-expressions where both of these bound variables
are visible, priority is given to the bound variable defined in the
closest inner scope. The outer definition of $x$ is \textbf{shadowed}\index{name shadowing},
i.e.\ hidden, by the definition of the inner $x$. For this reason,
mathematicians expect that evaluating $f(10)$ will give
\[
f(10)=\int_{0}^{10}\frac{dx}{1+x}\quad,
\]
rather than $\int_{0}^{10}\frac{dx}{1+10}$, because the outer definition
$x=10$ is shadowed, within the expression $\frac{1}{1+x}$, by the
closer definition of $x$ in the local scope of $x\Rightarrow\frac{1}{1+x}$.

Since this is the prevailing mathematical convention, the same convention
is adopted in FP. A variable defined in a local scope (i.e.\ a bound
variable) is invisible outside that scope but will shadow any outside
definitions of a variable with the same name. 

It is better to avoid name shadowing\index{name shadowing}, because
it usually decreases the clarity of code and so invites errors. Consider
the function
\[
x\Rightarrow x\Rightarrow x\quad.
\]
Let us decipher this confusing syntax. The symbol $\Rightarrow$ associates
to the right, so $x\Rightarrow x\Rightarrow x$ is the same as $x\Rightarrow\left(x\Rightarrow x\right)$.
So, it is a function that takes $x$ and returns $x\Rightarrow x$.
Since the returned nameless function, $\left(x\Rightarrow x\right)$,
may be renamed to $\left(y\Rightarrow y\right)$ without changing
its value, we can rewrite the code to
\[
x\Rightarrow\left(y\Rightarrow y\right)\quad.
\]
It is now easier to understand this code and reason about it. For
instance, it becomes clear that this function actually ignores its
argument $x$ and always returns the same value (the identity function
$y\Rightarrow y$).

\subsection{Operator syntax for function applications}

In mathematics, function applications are sometimes written without
parentheses, for instance $\cos x$ or $\text{arg}\,z$. There are
also cases where formulas such as $\sin2x=2\sin x\cos x$ imply parentheses
as $\sin\left(2x\right)=2\cdot\sin\left(x\right)\cdot\cos\left(x\right)$.
The functions such as $\cos$ or $\arg$ are treated as syntactic
``operators'' that can be applied to their arguments without parenthesis,
similar to the operators of summation, $\sum_{k}k$, and differentiation,
$\partial_{x}f$.

Many programming languages (such as ML, OCaml, F\#, Haskell, Elm,
PureScript) have adopted this ``operator syntax\index{operator syntax}'',
where parentheses are optional for function arguments. The result
is a concise notation where \lstinline!f x! means the same as \lstinline!f(x)!.
Parentheses are still used where necessary to avoid ambiguity or for
readability.\footnote{The operator syntax has a long history. It is used in Unix shell commands,
for example \lstinline!cp file1 file2!, as well as in the programming
language Tcl/Tk. In LISP and Scheme, each function application is
enclosed in parentheses but the arguments are separated by spaces,
for example \lstinline!(+ 1 2 3)!.}

The conventions for nameless functions in the operator syntax become:
\begin{itemize}
\item Function expressions group everything to the right:\\
 $x\Rightarrow y\Rightarrow z\Rightarrow e$ means $x\Rightarrow\left(y\Rightarrow\left(z\Rightarrow e\right)\right)$.
\item Function applications group everything to the left:\\
 $f\,x\,y\,z$ means $\big((f\,x)\:y\big)\:z$. 
\item Function applications group stronger than infix operations: $x+f\,y$
means $x+(f\,y)$, just like in mathematics $x+\cos y$ groups $\cos y$
stronger than the infix ``$+$'' operation.
\end{itemize}
So, $x\Rightarrow y\Rightarrow a\,b\,c+p\,q$ means $x\Rightarrow\left(y\Rightarrow\left(\left(a\,b\right)\,c\right)+(p\,q)\right)$.
When this notation becomes hard to read correctly, one needs to add
parentheses, e.g.\ to write $f(x\Rightarrow g\,h)$ instead of $f\,x\Rightarrow g\,h$.

In this book, I will sometimes use this ``operator syntax'' when
reasoning about code. Scala does not support the operator syntax;
in Scala, parentheses need to be put around every curried argument.
The Scala infix method syntax such as \texttt{}\lstinline!List(1,2,3) map func1!
does not work with curried functions.

\subsection{Curried functions in other programming languages}

From the point of view of programming language theory, curried functions
are ``simpler'' because they always have a \emph{single} argument
(and may return a function that will consume further arguments). From
the point of view of programming practice, curried functions are often
harder to read and to write.

In the syntax used e.g.\ in OCaml and Haskell, a curried function
such as \lstinline!f2! is applied to its arguments as \lstinline!f2 20 4!.
This departs further from the mathematical tradition and requires
some getting used to. If the two arguments are more complicated than
just $20$ and $4$, the resulting expression may become significantly
harder to read, compared with the syntax where commas are used to
separate the arguments. (Consider, for example, the Haskell expression
\lstinline!f2 (g 10) (h 20) + 30!.) To improve readability of code,
programmers may prefer to first define short names for complicated
expressions and then use these names as curried arguments.

In Scala, the choice of whether to use curried or uncurried function
signatures is largely a matter of syntactic convenience. Most Scala
code tends to be written with uncurried functions, while curried functions
are used when they produce more easily readable code.

One of the syntactic features for curried functions in Scala is the
ability to specify a curried argument using the curly brace syntax.
Compare the two definitions of the function \lstinline!summation!
described earlier:
\begin{lstlisting}
def summation1(a: Int, b: Int, g: Int => Int): Int =
  (a to b).map(g).sum

def summation2(a: Int, b: Int)(g: Int => Int): int =
  (a to b).map(g).sum
summation1(1, 10, { x => x*x*x + 2*x })
summation2(1, 10){ x => x*x*x + 2*x }
\end{lstlisting}

The code that calls \lstinline!summation2! may be easier to read
because the curried argument is syntactically separated from the rest
of the code by curly braces. This is especially useful when the curried
argument is itself a function with a complicated body, since Scala's
curly braces syntax allows function bodies to contain their own local
definitions (\lstinline!val! or \lstinline!def!).

Another feature of Scala is the ``dotless'' method syntax: for example,
\lstinline!xs map f! is equivalent to \lstinline!xs.map(f)!. The
``dotless'' syntax works only for infix methods, such as \lstinline!.map!,
defined on specific types such as \lstinline!Seq!. Do not confuse
Scala's ``dotless'' method syntax with the operator syntax such
as \lstinline!fmap f xs!, used in Haskell and some other languages.

\subsection{Deriving a function's code from its type signature}

We have seen how the procedure of type inference\index{type inference}
derives the type of a fully parametric function from the function's
code. It is remarkable that one can sometimes derive the function's
\emph{code} from the function's type signature. We will now look at
some examples of this.

Consider a fully parametric function that performs a partial application\index{partial application}.
A possible type signature is
\begin{lstlisting}
def pa[A, B, C](x: A)(f: (A, B) => C): B => C = ???
\end{lstlisting}
The function \lstinline!pa! will substitute a fixed argument value
\lstinline!x:A! into another given function \lstinline!f!. 

How can we implement \lstinline!pa!? Since \lstinline!pa(x)(f)!
must return a function of type \lstinline!B => C!, we have no choice
other than to begin writing the function body as
\begin{lstlisting}
def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { b: B =>
  ??? // Need to compute a value of type C here.
}
\end{lstlisting}
In the inner scope, we need to compute a value of type \lstinline!C!,
and we have values \lstinline!x: A!, \lstinline!b: B!, and \lstinline!f:(A, B)=>C!.
Since the type \lstinline!C! is arbitrary, we cannot produce any
values of type \lstinline!C! from scratch. The only way of producing
any values of type \lstinline!C! is by applying the function \lstinline!f!
to arguments of types \lstinline!A! and \lstinline!B!. Since the
types \lstinline!A! and \lstinline!B! are arbitrary, we cannot obtain
any values of these types other than \lstinline!x: A! and \lstinline!b: B!.
So, the only way of obtaining a value of type \lstinline!C! is to
compute \lstinline!f(x, b)!, and the body of \lstinline!pa! \emph{must}
be
\begin{lstlisting}
def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { b => f(x, b) }
\end{lstlisting}
In this way, we have unambiguously derived the body of this function
from its type signature.

Another example is the operation of forward composition $f\bef g$,
viewed as a fully parametric function with type signature
\begin{lstlisting}
def before[A, B, C](f: A => B, g: B => C): A => C = ???
\end{lstlisting}
The only way of implementing \lstinline!before! is by returning a
nameless function of type \lstinline!A => C!,
\begin{lstlisting}
def before[A, B, C](f: A => B, g: B => C): A => C = { a: A =>
  ??? // Need to compute a value of type C here.
}
\end{lstlisting}
In the inner scope, we need to compute a value of type \lstinline!C!,
and we have \lstinline!a: A!, \lstinline!f: A => B!, and \lstinline!g: B => C!.
Since the type \lstinline!C! is arbitrary, the only way of obtaining
a value of type \lstinline!C! is to apply \lstinline!g! to an argument
of type \lstinline!B!. The only way of obtaining a value of type
\lstinline!B! is to apply \lstinline!f! to an argument of type \lstinline!A!.
Finally, we have only one value of type \lstinline!A!, namely \lstinline!a:A!.
So, the only way of obtaining the required result is to compute \lstinline!g(f(a))!.
We have again unambiguously derived the body of the function before
from its type signature:
\begin{lstlisting}
def before[A, B, C](f: A => B, g: B => C): A => C = { a => g(f(a)) }
\end{lstlisting}

In Chapter~\ref{chap:3-3-The-formal-logic-curry-howard} and in Appendix~\ref{app:The-Curry-Howard-correspondence},
we will see how function bodies can be derived from type signatures
for a wide range of fully parametric functions.
