
\chapter{The logic of types. II. Higher-order functions\label{chap:Higher-order-functions} }

\section{Functions that return functions}

\subsection{Motivation and a first example}

\global\long\def\gunderline#1{\mathunderline{greenunder}{#1}}
\global\long\def\bef{\forwardcompose}
Consider the task of preparing a logger function that prints messages
but adds a fixed prefix to each message. 

A simple logger function can be a value of type \inputencoding{latin9}\lstinline!String => Unit!\inputencoding{utf8},
such as\inputencoding{latin9}
\begin{lstlisting}
val logger: String => Unit = { message => println(s"INFO: $message") }

scala> logger("hello world")
INFO: hello world
\end{lstlisting}
\inputencoding{utf8}This function prints any given message with the logging prefix \inputencoding{latin9}\lstinline!"INFO"!\inputencoding{utf8}. 

The standard library function \inputencoding{latin9}\lstinline!println(...)!\inputencoding{utf8}
always returns a \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}
value after printing its arguments. As we already know, there is only
a single value of type \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8},
and that value is denoted by \inputencoding{latin9}\lstinline!()!\inputencoding{utf8}.
To verify, run this code:\inputencoding{latin9}
\begin{lstlisting}
scala> val x = println(123)
123
x: Unit = ()
\end{lstlisting}
\inputencoding{utf8}
The task is to make the logging prefix configurable. A simple solution
is to implement a function \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}
that takes a prefix as an argument and returns a new logger with that
prefix fixed. It is important that the function \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}
will return a new value of type \inputencoding{latin9}\lstinline!String => Unit!\inputencoding{utf8},
i.e.~a new \emph{function}:\inputencoding{latin9}
\begin{lstlisting}
def logWith(prefix: String): (String => Unit) = {
    message => println(s"$prefix: $message")
}
\end{lstlisting}
\inputencoding{utf8}The body of \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}
consists of a nameless function \inputencoding{latin9}\lstinline!message => println(...)!\inputencoding{utf8},
which is a value of type \inputencoding{latin9}\lstinline!String => Unit!\inputencoding{utf8}.
This value will be computed by \inputencoding{latin9}\lstinline!logWith("...")!\inputencoding{utf8}.

We can now use \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}
to create a few logger functions:\inputencoding{latin9}
\begin{lstlisting}
scala> val info = logWith("INFO")
info: String => Unit = <function1>

scala> val warn = logWith("WARN")
warn: String => Unit = <function1>
\end{lstlisting}
\inputencoding{utf8}The created logger functions are then used as ordinary functions:\inputencoding{latin9}
\begin{lstlisting}
scala> info("hello")
INFO: hello

scala> warn("goodbye")
WARN: goodbye
\end{lstlisting}
\inputencoding{utf8}The values \inputencoding{latin9}\lstinline!info!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!warn!\inputencoding{utf8} can
be used by any code that needs a logging function.

It is important that the prefix is ``baked into'' functions created
by \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}.
A logger such as \inputencoding{latin9}\lstinline!warn!\inputencoding{utf8}
will always print messages with the prefix \inputencoding{latin9}\lstinline!"WARN"!\inputencoding{utf8},
and the prefix cannot be changed any more. This is so because the
value \inputencoding{latin9}\lstinline!prefix!\inputencoding{utf8}
is treated as a local value in the scope of the function returned
by \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}.
For instance, the body of the function \inputencoding{latin9}\lstinline!warn!\inputencoding{utf8}
is equivalent to\inputencoding{latin9}
\begin{lstlisting}
{ val prefix = "WARN"; (message => s"$prefix: $message") }
\end{lstlisting}
\inputencoding{utf8}So, whenever a new function is created using \inputencoding{latin9}\lstinline!logWith(prefix)!\inputencoding{utf8},
the (immutable) value of \inputencoding{latin9}\lstinline!prefix!\inputencoding{utf8}
is stored within the body of the newly created function. This is a
general feature of nameless functions created in a scope that contains
other local values: the function body keeps a copy of all the local
values it uses. One sometimes says that the function body ``closes
over'' the local values; for this reason, nameless functions are
sometimes also called ``\textbf{\index{closure}closure}s''. It
would be perhaps clearer to say that nameless functions ``capture''
local values.

As another example of the capture of local values, consider this code:\inputencoding{latin9}
\begin{lstlisting}
val f: Int => Int = {
  val p = 10
  val q = 20
  x => p + q * x
}
\end{lstlisting}
\inputencoding{utf8}The body of the function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
is equivalent to \inputencoding{latin9}\lstinline!{x => 10 + 20 * x}!\inputencoding{utf8}
because the values \inputencoding{latin9}\lstinline!p = 10!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!q = 20!\inputencoding{utf8}
were captured.

\subsection{Curried and uncurried functions}

Reasoning mathematically about the code\inputencoding{latin9}
\begin{lstlisting}
val info = logWith("INFO")
info("hello")
\end{lstlisting}
\inputencoding{utf8}we would expect that \inputencoding{latin9}\lstinline!info!\inputencoding{utf8}
is \emph{the same value} as \inputencoding{latin9}\lstinline!logWith("INFO")!\inputencoding{utf8},
and so the code \inputencoding{latin9}\lstinline!info("hello")!\inputencoding{utf8}
should have the same effect as the code \inputencoding{latin9}\lstinline!logWith("INFO")("hello")!\inputencoding{utf8}.
This is indeed so:\inputencoding{latin9}
\begin{lstlisting}
scala> logWith("INFO")("hello")
INFO: hello
\end{lstlisting}
\inputencoding{utf8}The syntax \inputencoding{latin9}\lstinline!logWith("INFO")("hello")!\inputencoding{utf8}
looks like the function \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}
applied to \emph{two} arguments. Yet, \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}
was defined as a function with a single argument of type \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}.
This is not a contradiction because \inputencoding{latin9}\lstinline!logWith("INFO")!\inputencoding{utf8}
returns a function that accepts an additional argument. So, both function
applications \inputencoding{latin9}\lstinline!logWith("INFO")!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!logWith("INFO")("hello")!\inputencoding{utf8}
are valid. In this sense, we are allowed to apply \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}
to one argument at a time.

A function that can be applied to more than one argument in this way
is called a \index{curried function}\textbf{curried} function. A
curried function can be applied to one argument at a time.

An \textbf{uncurried}\index{uncurried function} function must be
applied to all arguments at once, e.g.\inputencoding{latin9}
\begin{lstlisting}
def prefixLog(prefix: String, message: String): Unit =
  println(s"$prefix: $message")
\end{lstlisting}
\inputencoding{utf8}and returns a value of a non-function type.

The type of the curried function \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}
is \inputencoding{latin9}\lstinline!String => (String => Unit)!\inputencoding{utf8}.
Scala adopts the syntax convention that the function arrow (\inputencoding{latin9}\lstinline!=>!\inputencoding{utf8})
groups to the \emph{right}. So the parentheses in the type expression
\inputencoding{latin9}\lstinline!String => (String => Unit)!\inputencoding{utf8}
are not necessary; the function's type can be written as \inputencoding{latin9}\lstinline!String => String => Unit!\inputencoding{utf8}.

The type \inputencoding{latin9}\lstinline!String => String => Unit!\inputencoding{utf8}
is different from \inputencoding{latin9}\lstinline!(String => String) => Unit!\inputencoding{utf8},
– the type of a function returning \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}
and taking a function of type \inputencoding{latin9}\lstinline!String => String!\inputencoding{utf8}
as its argument. When an argument's type is a function type, e.g.
\inputencoding{latin9}\lstinline!String => String!\inputencoding{utf8},
it must be enclosed in parentheses.

In general, a curried function takes an argument and returns another
function that again takes an argument and returns another function,
and so on, until finally a non-function type is returned. So, the
type signature of a curried function generally looks like \inputencoding{latin9}\lstinline!A => B => C => ... => R => S!\inputencoding{utf8},
where \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!B!\inputencoding{utf8},
..., \inputencoding{latin9}\lstinline!R!\inputencoding{utf8} are
the \textbf{curried arguments}\index{curried arguments} and \inputencoding{latin9}\lstinline!S!\inputencoding{utf8}
is the ``final'' result type.

For most people, it takes time to get used to reading this kind of
syntax. In the type expression \inputencoding{latin9}\lstinline!A => B => C => D!\inputencoding{utf8},
the first three types are curried arguments and the type \inputencoding{latin9}\lstinline!D!\inputencoding{utf8}
is the final result type.

In Scala, functions defined with multiple argument groups (enclosed
in multiple pairs of parentheses) are curried functions. We have seen
examples of curried functions before:\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
def fmap[A, B](f: A => B)(xs: Option[A]): Option[B]
def foldLeft[A, R](xs: Seq[A])(init: R)(update: (R, A) => R): R
\end{lstlisting}
\inputencoding{utf8}The type signatures of these functions can be also written equivalently
as\inputencoding{latin9}
\begin{lstlisting}
def map[A, B]: Seq[A] => (A => B) => Seq[B]
def fmap[A, B]: (A => B) => Option[A] => Option[B]
def foldLeft[A, R]: Seq[A] => R => ((R, A) => R) => R
\end{lstlisting}
\inputencoding{utf8}Curried arguments of a function type, such as \inputencoding{latin9}\lstinline!(A => B)!\inputencoding{utf8},
need parentheses.

The curried function \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}
can be defined in three equivalent ways in Scala:\inputencoding{latin9}
\begin{lstlisting}
def logWith1(prefix: String)(message: String): Unit =
  println(s"$prefix: $message")
def logWith2(prefix: String): String => Unit =
  message => println(s"$prefix: $message")
def logWith3: String => String => Unit =
  prefix => message => println(s"$prefix: $message")
\end{lstlisting}
\inputencoding{utf8}Nameless functions in Scala may be enclosed in parentheses or curly
braces. We will omit parentheses for simple expressions.

The last line in the above code shows that the arrow \inputencoding{latin9}\lstinline!=>!\inputencoding{utf8}
groups to the right within the \emph{code} of nameless functions:
\inputencoding{latin9}\lstinline!x => y => expr!\inputencoding{utf8}
means \inputencoding{latin9}\lstinline!{x => {y => expr}}!\inputencoding{utf8},
a nameless function taking an argument \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
and returning a nameless function that takes an argument \inputencoding{latin9}\lstinline!y!\inputencoding{utf8}
and returns an expression \inputencoding{latin9}\lstinline!expr!\inputencoding{utf8}.
This syntax convention is useful for two reasons. First, the code
\inputencoding{latin9}\lstinline!x => y => z!\inputencoding{utf8}
visually corresponds to the curried function's type signature \inputencoding{latin9}\lstinline!A => B => C!\inputencoding{utf8},
which uses the same syntax convention. Second, the syntax \inputencoding{latin9}\lstinline!(x => y) => z!\inputencoding{utf8}
could not be valid for a nameless function because \inputencoding{latin9}\lstinline!(x => y)!\inputencoding{utf8}
is not a valid pattern expression for the function's argument; it
is impossible to define a pattern that matches arbitrary \emph{functions}
of type \inputencoding{latin9}\lstinline!A => B!\inputencoding{utf8}. 

Although the code syntax \inputencoding{latin9}\lstinline!(x => y) => z!\inputencoding{utf8}
is invalid, a type expression \inputencoding{latin9}\lstinline!(A => B) => C!\inputencoding{utf8}
is valid. A nameless function of type \inputencoding{latin9}\lstinline!(A => B) => C!\inputencoding{utf8}
is written as \inputencoding{latin9}\lstinline!f => expr(f)!\inputencoding{utf8}
where \inputencoding{latin9}\lstinline!f: A => B!\inputencoding{utf8}
is its argument and \inputencoding{latin9}\lstinline!expr(f)!\inputencoding{utf8}
its body. So \inputencoding{latin9}\lstinline!x => (y => z)!\inputencoding{utf8}
is the only possible way of inserting parentheses into \inputencoding{latin9}\lstinline!x => y => z!\inputencoding{utf8}.

\subsection{Equivalence of curried and uncurried functions}

We defined the curried function \inputencoding{latin9}\lstinline!logWith!\inputencoding{utf8}
in order to be able to create logger functions such as \inputencoding{latin9}\lstinline!info!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!warn!\inputencoding{utf8}. However,
some curried functions, such as \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8},
are almost always applied to all possible arguments. A curried function
applied to all its possible arguments is equivalent to an uncurried
function that takes all those arguments at once. Let us look at this
equivalence in more detail.

Consider a curried function with type signature \inputencoding{latin9}\lstinline!Int => Int => Int!\inputencoding{utf8}.
This function takes an integer and returns an (uncurried) function
taking an integer and returning an integer. An example of such a curried
function is\inputencoding{latin9}
\begin{lstlisting}
def f1(x: Int): Int => Int = { y => x - y }
\end{lstlisting}
\inputencoding{utf8}
The function takes an integer \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
and returns the expression \inputencoding{latin9}\lstinline!y => x - y!\inputencoding{utf8},
which is a function of type \inputencoding{latin9}\lstinline!Int => Int!\inputencoding{utf8}.
The code of \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8}
can be written equivalently as\inputencoding{latin9}
\begin{lstlisting}
val f1: Int => Int => Int = { x => y => x - y }
\end{lstlisting}
\inputencoding{utf8}
Let us compare the function \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8}
with a function that takes its two arguments at once. Such a function
will have a different type signature, e.g.\inputencoding{latin9}
\begin{lstlisting}
def f2(x: Int, y: Int): Int = x - y
\end{lstlisting}
\inputencoding{utf8}has type signature \inputencoding{latin9}\lstinline!(Int, Int) => Int!\inputencoding{utf8}
but computes the same value as \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8}.

The syntax for using the functions \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!f2!\inputencoding{utf8} is different:\inputencoding{latin9}
\begin{lstlisting}
scala> f1(20)(4)
res0: Int = 16

scala> f2(20, 4)
res1: Int = 16
\end{lstlisting}
\inputencoding{utf8}The main difference between the usage of \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!f2!\inputencoding{utf8} is that
\inputencoding{latin9}\lstinline!f2!\inputencoding{utf8} must be
applied \emph{at once} to both arguments, while \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8}
applied to just the first argument, \inputencoding{latin9}\lstinline!20!\inputencoding{utf8}.
The result of evaluating \inputencoding{latin9}\lstinline!f1(20)!\inputencoding{utf8}
is a function that can be later applied to another argument:\inputencoding{latin9}
\begin{lstlisting}
scala> val r1 = f1(20)
r1: Int => Int = <function1> 

scala> r1(4)
res2: Int = 16
\end{lstlisting}
\inputencoding{utf8}
Applying a curried function to some but not all of possible arguments
is called a \textbf{\index{partial application}partial application}.
Applying a curried function to all possible arguments is called a
\index{saturated application}\textbf{saturated} application.

If we need to apply an \emph{uncurried} function to some of its arguments
but leave other arguments unspecified, we can use the underscore ($\_$)
symbol:\inputencoding{latin9}
\begin{lstlisting}
scala> val r2: Int => Int = f2(20, _)
r2: Int => Int = <function1>

scala> r2(4)
res3: Int = 16
\end{lstlisting}
\inputencoding{utf8}(Here, the type annotation \inputencoding{latin9}\lstinline!Int => Int!\inputencoding{utf8}
is required.) This code creates a function \inputencoding{latin9}\lstinline!r2!\inputencoding{utf8}
by partially applying \inputencoding{latin9}\lstinline!f2!\inputencoding{utf8}
to the first argument but not to the second. Other than that, \inputencoding{latin9}\lstinline!r2!\inputencoding{utf8}
is the same function as \inputencoding{latin9}\lstinline!r1!\inputencoding{utf8}
defined above; i.e.~\inputencoding{latin9}\lstinline!r2!\inputencoding{utf8}
returns the same values for the same arguments as \inputencoding{latin9}\lstinline!r1!\inputencoding{utf8}.
A more general syntax for a partial application is\inputencoding{latin9}
\begin{lstlisting}
scala> val r3: Int => Int = { x => f2(20, x) }
r3: Int => Int = <function1>

scala> r3(4)
res4: Int = 16
\end{lstlisting}
\inputencoding{utf8}
We can see that a curried function, such as \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8},
is better adapted for partial application than \inputencoding{latin9}\lstinline!f2!\inputencoding{utf8},
because the syntax is shorter. However, the functions \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!f2!\inputencoding{utf8} are
\textbf{computationally equivalent}\index{computational equivalence}
in the sense that given \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8}
we can reconstruct \inputencoding{latin9}\lstinline!f2!\inputencoding{utf8}
and vice versa:\inputencoding{latin9}
\begin{lstlisting}
def f2new(x: Int, y: Int): Int = f1(x)(y)
def f1new: Int => Int => Int = { x => y => f2(x, y) }
\end{lstlisting}
\inputencoding{utf8}It is clear that the function \inputencoding{latin9}\lstinline!f1new!\inputencoding{utf8}
computes the same results as \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8},
and that the function \inputencoding{latin9}\lstinline!f2new!\inputencoding{utf8}
computes the same results as \inputencoding{latin9}\lstinline!f2!\inputencoding{utf8}.
The computational equivalence of the functions \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!f2!\inputencoding{utf8} is not
\emph{equality}  –  these functions are \emph{different}; but one
of them can be easily reconstructed from the other if necessary. 

More generally, a curried function has a type signature of the form
\inputencoding{latin9}\lstinline!A => B => C => ... => R => S!\inputencoding{utf8},
where \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!B!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!C!\inputencoding{utf8}, ..., \inputencoding{latin9}\lstinline!S!\inputencoding{utf8}
are some types. A function with this type signature is computationally
equivalent to an uncurried\index{uncurried function} function with
type signature \inputencoding{latin9}\lstinline!(A,B,C,...,R) => S!\inputencoding{utf8}.
The uncurried function takes all arguments at once, while the curried
function takes one argument at a time. Other than that, these two
functions compute the same results given the same arguments.

We have seen how a curried function can be converted to an equivalent
uncurried one, and vice versa. The Scala library defines the methods
\inputencoding{latin9}\lstinline!curried!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!uncurried!\inputencoding{utf8} that
convert between these computationally equivalent forms of functions.
Here we convert the function \inputencoding{latin9}\lstinline!f2!\inputencoding{utf8}
to \inputencoding{latin9}\lstinline!f1!\inputencoding{utf8} and back:\inputencoding{latin9}
\begin{lstlisting}
scala> val f1c = (f2 _).curried
f1c: Int => (Int => Int) = <function1>

scala> val f2u = Function.uncurried(f1c)
f2u: (Int, Int) => Int = <function2> 
\end{lstlisting}
\inputencoding{utf8}
The syntax \inputencoding{latin9}\lstinline!(f2 _)!\inputencoding{utf8}
is needed in Scala\footnote{The extra underscore will become unnecessary in Scala 3.}
to convert methods to function values. Recall that Scala has two ways
of defining a function: one as a method\index{Scala method} (defined
using \inputencoding{latin9}\lstinline!def!\inputencoding{utf8}),
another as a function value\index{function value} (defined using
\inputencoding{latin9}\lstinline!val!\inputencoding{utf8}). 

The methods \inputencoding{latin9}\lstinline!.curried!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.uncurried!\inputencoding{utf8}
are easy to implement in Scala code, as we will show in Section~\ref{subsec:Examples-of-fully-parametric}.

\section{Fully parametric functions\label{sec:Fully-parametric-functions}}

We have seen that some functions are declared with type parameters,
which are set only when the function is applied to specific arguments.
Examples of such functions are the \inputencoding{latin9}\lstinline!map!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!filter!\inputencoding{utf8}
methods with type signatures\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
def filter[A](xs: Seq[A])(p: A => Boolean): Seq[A]
\end{lstlisting}
\inputencoding{utf8}Such functions can be applied to arguments of different types without
changing the function's code. So, it is better to implement a single
function with type parameters instead of several functions with the
same code but applied to different types. When we apply the function
\inputencoding{latin9}\lstinline!map!\inputencoding{utf8} as \inputencoding{latin9}\lstinline!map(xs)(f)!\inputencoding{utf8}
to a specific value \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}
of type, e.g., \inputencoding{latin9}\lstinline!Seq[Int]!\inputencoding{utf8},
and a specific function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
of type, say, \inputencoding{latin9}\lstinline!Int => String!\inputencoding{utf8},
the Scala compiler will automatically set the type parameters \inputencoding{latin9}\lstinline!A = Int!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!B = String!\inputencoding{utf8}
in the definition of \inputencoding{latin9}\lstinline!map!\inputencoding{utf8}.
We may also set type parameters explicitly and write, for example,
\inputencoding{latin9}\lstinline!map[Int, String](xs)(f)!\inputencoding{utf8}.
This syntax shows a certain similarity between type parameters such
as \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}
and ``value parameters'' (arguments) \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}.

In the functions \inputencoding{latin9}\lstinline!map!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!filter!\inputencoding{utf8}
as just shown, some types are parameters while others are specific
types, such as \inputencoding{latin9}\lstinline!Seq!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Boolean!\inputencoding{utf8}.
It is sometimes possible to replace \emph{all} types in the type signature
of a function by type parameters.

A function is \textbf{fully parametric\index{fully parametric function}}
if all its arguments have types described by type parameters, and
the code of the function works with type parameters rather than with
fixed types such as \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}.
In other words, fully parametric functions do not use any specific
types, such as \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!String!\inputencoding{utf8},
in their type signature or in their body. When a fully parametric
function is applied to an argument of a specific type, the function
does not use any information about that type. 

What kind of functions are fully parametric? To build an intuition
for that, let us compare these two functions having the same type
signature:\inputencoding{latin9}
\begin{lstlisting}
def cos_sin(p: (Double, Double)): (Double, Double) = p match {
  case (x, y) =>
    val r = math.sqrt(x * x + y * y)
    (x / r, y / r) // Return cos and sin of the angle.
}

def swap(p: (Double, Double)): (Double, Double) = p match {
  case (x, y) => (y, x)
}
\end{lstlisting}
\inputencoding{utf8}We can introduce type parameters into the type signature of \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
to make it fully parametric, with no changes in the code of the function:\inputencoding{latin9}
\begin{lstlisting}
def swap[A, B](p: (A, B)): (B, A) = p match {
  case (x, y) => (y, x)
}
\end{lstlisting}
\inputencoding{utf8}Generalizing \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8}
to a fully parametric function is possible because the operation of
swapping two parts of a tuple \inputencoding{latin9}\lstinline!(A, B)!\inputencoding{utf8}
works in the same way for all types \inputencoding{latin9}\lstinline!A!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!B!\inputencoding{utf8}.

In contrast, the function \inputencoding{latin9}\lstinline!cos_sin!\inputencoding{utf8}
performs a computation that is specific to the type \inputencoding{latin9}\lstinline!Double!\inputencoding{utf8}
and cannot be generalized to an arbitrary type parameter \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!Double!\inputencoding{utf8}.
So, \inputencoding{latin9}\lstinline!cos_sin!\inputencoding{utf8}
cannot be generalized to a fully parametric function.

The \inputencoding{latin9}\lstinline!swap!\inputencoding{utf8} operation
for pairs is already defined in the Scala library:\inputencoding{latin9}
\begin{lstlisting}
scala> (1, "abc").swap
res0: (String, Int) = (abc,1)
\end{lstlisting}
\inputencoding{utf8}Other swapping functions can be defined for tuples with more elements,
e.g.\inputencoding{latin9}
\begin{lstlisting}
def swap12[A,B,C]: ((A, B, C)) => (B, A, C) = {
  case (x, y, z) => (y, x, z)
}
\end{lstlisting}
\inputencoding{utf8}The Scala syntax requires the double parentheses around tuple types
of arguments but not around the tuple type of a function's result.
So, the type signature of \inputencoding{latin9}\lstinline!cos_sin!\inputencoding{utf8}
may be written as\inputencoding{latin9}
\begin{lstlisting}
def cos_sin: ((Double, Double)) => (Double, Double)
\end{lstlisting}
\inputencoding{utf8}

\subsection{Examples. Function composition\label{subsec:Examples-of-fully-parametric}}

Further examples of fully parametric functions are the identity function,
the constant function, the function composition methods, and the curry
/ uncurry conversions. The \index{identity function}identity function
(available in the Scala library as \inputencoding{latin9}\lstinline!identity[T]!\inputencoding{utf8})
is\inputencoding{latin9}
\begin{lstlisting}
def id[T]: T => T = t => t
\end{lstlisting}
\inputencoding{utf8}The constant function\index{constant function} (available in the
Scala library as \inputencoding{latin9}\lstinline!Function.const!\inputencoding{utf8})
takes an argument \inputencoding{latin9}\lstinline!c!\inputencoding{utf8}
and returns a new function that always returns \inputencoding{latin9}\lstinline!c!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def const[C, X](c: C): X => C = (_ => c)
\end{lstlisting}
\inputencoding{utf8}The syntax \inputencoding{latin9}\lstinline!_ => c!\inputencoding{utf8}
is used to emphasize that the function ignores its argument.

\paragraph{Function composition}

\index{function composition}Consider two functions \inputencoding{latin9}\lstinline!f: Int => Double!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!g: Double => String!\inputencoding{utf8}.
We can apply \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
to an integer argument \inputencoding{latin9}\lstinline!x:Int!\inputencoding{utf8}
and get a result \inputencoding{latin9}\lstinline!f(x)!\inputencoding{utf8}
of type \inputencoding{latin9}\lstinline!Double!\inputencoding{utf8}.
We can then apply \inputencoding{latin9}\lstinline!g!\inputencoding{utf8}
to that result and obtain a \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}
value \inputencoding{latin9}\lstinline!g(f(x))!\inputencoding{utf8}.
The transformation from the original integer \inputencoding{latin9}\lstinline!x:Int!\inputencoding{utf8}
to the final \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}
value \inputencoding{latin9}\lstinline!g(f(x))!\inputencoding{utf8}
can be viewed as a new function of type \inputencoding{latin9}\lstinline!Int => String!\inputencoding{utf8}.
That new function is called the \textbf{forward composition}\index{forward composition}
of the two functions \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!g!\inputencoding{utf8}. In Scala,
this operation is written as \inputencoding{latin9}\lstinline!f andThen g!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
val f: Int => Double = x => 5.67 + x
val g: Double => String = x => f"Result x = $x%3.2f"

scala> val h = f andThen g
h: Int => String = <function1>

scala> h(40)
res36: String = Result x = 45.67
\end{lstlisting}
\inputencoding{utf8}The Scala compiler derives the type of \inputencoding{latin9}\lstinline!h!\inputencoding{utf8}
automatically as \inputencoding{latin9}\lstinline!Int => String!\inputencoding{utf8}.

The forward composition is denoted by $\bef$ (pronounced ``before'')
and can be defined as
\begin{equation}
f\bef g\triangleq\left(x\Rightarrow g(f(x))\right)\quad.\label{eq:def-of-forward-composition}
\end{equation}
The symbol $\triangleq$ means ``is defined as''.

We could write the forward composition as a fully parametric function,\inputencoding{latin9}
\begin{lstlisting}
def andThen[X, Y, Z](f: X => Y)(g: Y => Z): X => Z = { x => g(f(x)) }
\end{lstlisting}
\inputencoding{utf8}The type signature of this curried function is 
\[
\text{andThen}:\left(X\Rightarrow Y\right)\Rightarrow\left(Y\Rightarrow Z\right)\Rightarrow X\Rightarrow Z\quad.
\]
This type signature requires the types of the function arguments to
match in a certain way, or else the composition is undefined.

The method \inputencoding{latin9}\lstinline!andThen!\inputencoding{utf8}
is an example of a function that \emph{both} returns a new function
\emph{and} takes other functions as arguments.

The \textbf{backward composition\index{backward composition}} of
two functions $f$ and $g$ works in the opposite order: first $g$
is applied and then $f$ is applied to the result. Using the symbol
$\circ$ (pronounced ``after'') for this operation, we can write
\begin{equation}
f\circ g\triangleq\left(x\Rightarrow f(g(x))\right)\quad.\label{eq:def-of-backward-composition}
\end{equation}
In Scala, the backward composition is called \inputencoding{latin9}\lstinline!compose!\inputencoding{utf8}
and used as \inputencoding{latin9}\lstinline!f compose g!\inputencoding{utf8}.
This method may be implemented as a fully parametric function\inputencoding{latin9}
\begin{lstlisting}
def compose[X, Y, Z](f: Y => X)(g: Z => Y): Z => X = { z => f(g(z)) }
\end{lstlisting}
\inputencoding{utf8}The type signature of this curried function is
\[
\text{compose}:\left(Y\Rightarrow X\right)\Rightarrow\left(Z\Rightarrow Y\right)\Rightarrow Z\Rightarrow X\quad.
\]

We have already seen the methods \inputencoding{latin9}\lstinline!curried!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!uncurried!\inputencoding{utf8}
defined by the Scala library. As an illustration, let us write our
own code for converting curried functions to uncurried:\inputencoding{latin9}
\begin{lstlisting}
def uncurry[A, B, R](f: A => B => R): ((A, B)) => R = {
  case (a, b) => f(a)(b)
}
\end{lstlisting}
\inputencoding{utf8}
We conclude from these examples that fully parametric functions perform
operations that are so general that they work in the same way for
all types of arguments. Some arguments of fully parametric functions
may have complicated types such as \inputencoding{latin9}\lstinline!A => B => R!\inputencoding{utf8},
which are type expressions made up from type parameters alone. Fully
parametric functions do not perform any operations with specific types
such as \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}.

The property of being fully parametric is also called \textbf{parametricity}\index{parametricity}.
In some programming languages, functions with type parameters are
called ``generic\index{generic functions}''.

\subsection{Laws of function composition\label{subsec:Laws-of-function-composition}}

The operations of function composition, introduced in Section~\ref{subsec:Examples-of-fully-parametric},
have three important properties or ``laws'' that follow directly
from the definitions. These laws are:
\begin{itemize}
\item The two identity laws: the composition of any function $f$ with the
identity function will give again the function $f$.
\item The associativity law: the consecutive composition of three functions
$f$, $g$, $h$ does not depend on the order in which the pairs are
composed.
\end{itemize}
These laws hold for the forward and the backward composition, since
they are just syntactic variants of the same mathematical operation.
Let us write these laws rigorously as mathematical equations and prove
them.

\paragraph{Proofs in the forward notation}

The composition of the identity function with an arbitrary function
$f$ can be $\text{id}\bef f$ with the identity function to the left
of $f$, or $f\bef\text{id}$ with the identity function to the right
of $f$. In both cases, the result must be equal to the function $f$.
The resulting two laws are
\begin{align*}
{\color{greenunder}\text{left identity law of composition}:}\quad & \text{id}\bef f=f\quad,\\
{\color{greenunder}\text{right identity law of composition}:}\quad & f\bef\text{id}=f\quad.
\end{align*}
To show that these laws always hold, we need to show that both sides
of the laws, which are functions, give the same result when applied
to an arbitrary value $x$. Let us first clarify how the type parameters
must be set for the laws to have consistent types.

The laws must hold for an arbitrary function $f$. So we may assume
that $f$ has the type signature $A\Rightarrow B$, where $A$ and
$B$ are arbitrary type parameters. Consider the left identity law.
The function $\left(\text{id}\bef f\right)$ is, by definition~(\ref{eq:def-of-forward-composition}),
a function that takes an argument $x$, applies $\text{id}$ to that
$x$, and then applies $f$ to the result: 
\[
\text{id}\bef f=\left(x\Rightarrow f(\text{id}(x))\right)\quad.
\]
If $f$ has type $A\Rightarrow B$, its argument must be of type $A$,
or else the types will not match. Therefore, the identity function
must have type $A\Rightarrow A$, and the argument $x$ must have
type $A$. With these choices of the type parameters, the function
$\left(x\Rightarrow f(\text{id}(x))\right)$ will have type $A\Rightarrow B$,
as it must since the right-hand side of the law is $f$. We add type
annotations to the code as \emph{superscripts},
\[
\text{id}^{A}\bef f^{:A\Rightarrow B}=\big(x^{:A}\Rightarrow f(\text{id}(x))\big)^{:A\Rightarrow B}\quad.
\]
In the Scala syntax, this formula may be written as\inputencoding{latin9}
\begin{lstlisting}
id[A] andThen (f: A => B) == { x: A => f(id(x)) }: A => B
\end{lstlisting}
\inputencoding{utf8}It is quicker to write the mathematical notation than code in the
Scala syntax. We will follow the convention where type parameters
are single uppercase letters; however, this convention is not enforced
in Scala.

The colon symbol ($:$) in the superscript $x^{:A}$ means a type
annotation, as in Scala code \inputencoding{latin9}\lstinline!x:A!\inputencoding{utf8}.
A superscript without the colon, such as $\text{id}^{A}$, means a
type parameter, as in Scala code \inputencoding{latin9}\lstinline!id[A]!\inputencoding{utf8}.
Since the function \inputencoding{latin9}\lstinline!id[A]!\inputencoding{utf8}
has type \inputencoding{latin9}\lstinline!A => A!\inputencoding{utf8},
we can write $\text{id}^{A}$ or equivalently (but more verbosely)
$\text{id}^{:A\Rightarrow A}$ to denote that function.

Since $\text{id}(x)=x$ by definition of the identity function, we
find that 
\[
\text{id}\bef f=\left(x\Rightarrow f\left(\text{id}\left(x\right)\right)\right)=\left(x\Rightarrow f\left(x\right)\right)=f\quad.
\]
The last step works since $x\Rightarrow f\left(x\right)$ is a function
taking an argument $x$ and applying $f$ to that argument; i.e.~$x\Rightarrow f\left(x\right)$
is the same function as $f$.

Now consider the right identity law:
\[
f\bef\text{id}=\left(x\Rightarrow\text{id}\left(f\left(x\right)\right)\right)\quad.
\]
To make the types match, assume that $f^{:A\Rightarrow B}$. Then
$x$ must have type $A$, and the identity function must have type
$B\Rightarrow B$. The result of $\text{id}\left(f\left(x\right)\right)$
will be also of type $B$. With these choices of type parameters,
all types match:
\[
f^{:A\Rightarrow B}\bef\text{id}^{B}=\left(x^{:A}\Rightarrow\text{id}(f(x))\right)^{:A\Rightarrow B}\quad.
\]
Since $\text{id}(f(x))=f(x)$, we find that 
\[
f\bef\text{id}=\left(x\Rightarrow f\left(x\right)\right)=f\quad.
\]
In this way, we have demonstrated that both identity laws hold. 

The associativity law is written as an equation like this:
\begin{equation}
\left(f\bef g\right)\bef h=f\bef\left(g\bef h\right)\quad.\label{eq:associativity-of-function-composition}
\end{equation}
Let us first verify that the types match here. The types of the functions
$f$, $g$, and $h$ must be such that all the function compositions
exist. If $f$ has type $A\Rightarrow B$ for some type parameters
$A$ and $B$, then the argument of $g$ must be of type $B$; so
we can choose $g^{:B\Rightarrow C}$, where $C$ is another type parameter.
The composition $f\bef g$ has type $A\Rightarrow C$, so $h$ must
be of type $C\Rightarrow D$ for some type $D$. Assuming the types
as $f^{:A\Rightarrow B}$, $g^{:B\Rightarrow C}$, and $h^{:C\Rightarrow D}$,
we find that the types in all the compositions $f\bef g$, $g\bef h$,
$\left(f\bef g\right)\bef h$, and $f\bef\left(g\bef h\right)$ match.
We can rewrite Eq.~(\ref{eq:associativity-of-function-composition})
with type annotations, 
\begin{equation}
(f^{:A\Rightarrow B}\bef g^{:B\Rightarrow C})\bef h^{:C\Rightarrow D}=f^{:A\Rightarrow B}\bef(g^{:B\Rightarrow C}\bef h^{:C\Rightarrow D})\quad.\label{eq:assoc-law-for-composition-with-types}
\end{equation}

Having checked the types, we are ready to prove the associativity
law. We note that both sides of the law~(\ref{eq:assoc-law-for-composition-with-types})
are functions of type $A\Rightarrow D$. To prove that two functions
are equal means to prove that they always return the same results
when applied to the same argument. So we need to apply both sides
of Eq.~(\ref{eq:assoc-law-for-composition-with-types}) to an arbitrary
value $x^{:A}$. Using the definition~(\ref{eq:def-of-forward-composition})
of the forward composition, 
\[
\left(f\bef g\right)(x)=g(f(x))\quad,
\]
we find
\begin{align*}
\left(\left(f\bef g\right)\bef h\right)(x) & =h\left(\left(f\bef g\right)(x)\right)=h(g(f(x)))\quad,\\
\left(f\bef\left(g\bef h\right)\right)(x) & =\left(g\bef h\right)(f(x))=h(g(f(x)))\quad.
\end{align*}
Both sides of the law are now clearly equal when applied to an arbitrary
value $x$.

Because of the associativity law, we do not need parentheses in the
expression $f\bef g\bef h$. The function $\left(f\bef g\right)\bef h$
is the same as $f\bef\left(g\bef h\right)$.

In the proof, we have omitted the types since we already checked that
the types match. Checking the types beforehand allows us to write
shorter proofs.

\paragraph{Proofs in the backward notation}

This book uses the \textbf{forward notation}\index{forward notation}
$f\bef g$ for writing function compositions, rather than the backward
notation $g\circ f$. If necessary, all equations can be automatically
converted from one notation to the other by reversing the order of
function compositions, since
\[
f\bef g=g\circ f
\]
for any functions $f^{:A\Rightarrow B}$ and $g^{:B\Rightarrow C}$.
Let us see how to prove the composition laws in the backward notation.
We will just need to reverse the order of function compositions in
the proofs above.

The left identity and right identity laws are
\[
f\circ\text{id}=f\quad\quad,\quad\text{id}\circ f=f\quad.
\]
To match the types, we need to choose the type parameters as
\[
f^{:A\Rightarrow B}\circ\text{id}^{:A\Rightarrow A}=f^{:A\Rightarrow B}\quad\quad,\quad\text{id}^{B\Rightarrow B}\circ f^{:A\Rightarrow B}=f^{:A\Rightarrow B}\quad.
\]
We can apply both sides of the laws to an arbitrary value $x^{:A}$.
For the left identity law, we find from definition~(\ref{eq:def-of-backward-composition})
that
\[
f\circ\text{id}=\left(x\Rightarrow f(\text{id}(x))\right)=\left(x\Rightarrow f(x)\right)=f\quad.
\]
Similarly for the right identity law,
\[
\text{id}\circ f=\left(x\Rightarrow\text{id}\left(f\left(x\right)\right)\right)=\left(x\Rightarrow f\left(x\right)\right)=f\quad.
\]
The associativity law,
\[
h\circ\left(g\circ f\right)=\left(h\circ g\right)\circ f\quad,
\]
is proved by applying both sides to an arbitrary value $x$ of a suitable
type:
\begin{align*}
\left(h\circ\left(g\circ f\right)\right)(x) & =h\left(\left(g\circ f\right)(x)\right)=h\left(g\left(f\left(x\right)\right)\right)\quad,\\
\left(\left(h\circ g\right)\circ f\right)(x) & =\left(h\circ g\right)\left(f(x)\right)=h\left(g\left(f\left(x\right)\right)\right)\quad.
\end{align*}
The types are checked by assuming that $f$ has the type $f^{:A\Rightarrow B}$.
The types in $g\circ f$ match only when $g^{:B\Rightarrow C}$, and
then $g\circ f$ is of type $A\Rightarrow C$. The type of $h$ must
be $h^{:C\Rightarrow D}$ for the types in $h\circ\left(g\circ f\right)$
to match. We can write the associativity law with type annotations
as
\begin{equation}
h^{:C\Rightarrow D}\circ(g^{:B\Rightarrow C}\circ f^{A\Rightarrow B})=(h^{:C\Rightarrow D}\circ g^{:B\Rightarrow C})\circ f^{:A\Rightarrow B}\quad.\label{eq:assoc-law-for-composition-with-types-backward}
\end{equation}
The associativity law allows us to omit parentheses in the expression
$h\circ g\circ f$. 

The length of calculations is the same in the forward and the backward
notation. One difference is that types of function compositions are
more visually clear in the forward notation: it is easier to check
types in Eq.~(\ref{eq:assoc-law-for-composition-with-types}) than
in Eq.~(\ref{eq:assoc-law-for-composition-with-types-backward}).

\subsection{Example: A function that violates parametricity }

Fully parametric functions should not make any decisions based on
the actual types of its parameters. As an example of an \emph{incorrect}
implementation of a fully parametric function, consider the following
``fake identity'' function:\inputencoding{latin9}
\begin{lstlisting}
def fakeId[A]: A => A = { // Special code for `A` = `Int`:
  case x: Int => (x - 1).asInstanceOf[A]
  case x => x // Common code for all other types `A`.
}
\end{lstlisting}
\inputencoding{utf8}This function's type signature is the same as that of \inputencoding{latin9}\lstinline!id[A]!\inputencoding{utf8},
and its behavior is the same for all types \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
except for \inputencoding{latin9}\lstinline!A = Int!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> fakeId("abc")
res0: String = abc

scala> fakeId(true)
res1: Boolean = true

scala> fakeId(0)
res2: Int = -1
\end{lstlisting}
\inputencoding{utf8}While Scala allows us to write this kind of code, the resulting function
does not appear to be useful. In any case, \inputencoding{latin9}\lstinline!fakeId!\inputencoding{utf8}
is not a fully parametric function.

The identity laws of composition will not hold if we use \inputencoding{latin9}\lstinline!fakeId[A]!\inputencoding{utf8}
instead of the correct function \inputencoding{latin9}\lstinline!id[A]!\inputencoding{utf8}.
For example, consider the composition of \inputencoding{latin9}\lstinline!fakeId!\inputencoding{utf8}
with a simple function \inputencoding{latin9}\lstinline!f_1!\inputencoding{utf8}
defined by\inputencoding{latin9}
\begin{lstlisting}
def f_1: Int => Int = { x => x + 1 }
\end{lstlisting}
\inputencoding{utf8}The composition (\inputencoding{latin9}\lstinline!f_1 andThen fakeId!\inputencoding{utf8})
will have type \inputencoding{latin9}\lstinline!Int => Int!\inputencoding{utf8}.
Since \inputencoding{latin9}\lstinline!f_1!\inputencoding{utf8} has
type \inputencoding{latin9}\lstinline!Int => Int!\inputencoding{utf8},
Scala will automatically set the type parameter \inputencoding{latin9}\lstinline!A = Int!\inputencoding{utf8}
in \inputencoding{latin9}\lstinline!fakeId[A]!\inputencoding{utf8},\inputencoding{latin9}
\begin{lstlisting}
scala> def f_2 = f_1 andThen fakeId
f_2: Int => Int
\end{lstlisting}
\inputencoding{utf8}The identity law says that $f_{2}=f_{1}\bef\text{id}=f_{1}$. But
we can check that \inputencoding{latin9}\lstinline!f_1!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!f_2!\inputencoding{utf8} are
not the same:\inputencoding{latin9}
\begin{lstlisting}
scala> f_1(0)
res3: Int = 1

scala> f_2(0)
res3: Int = 0
\end{lstlisting}
\inputencoding{utf8}
It is important that we are able to detect a violation of parametricity
by checking whether some equation holds, without need to examine the
code of the function \inputencoding{latin9}\lstinline!fakeId!\inputencoding{utf8}.
In this book, we will always formulate any desired properties of functions
through equations or ``laws''. To prove the laws, we will need to
perform symbolic calculations\index{symbolic calculations} similar
to the proofs in Section~\ref{subsec:Laws-of-function-composition}.
These calculations are \textbf{symbolic} in the sense that we were
manipulating symbols such as $x$, $f$, $g$, and $h$ without substituting
any specific values for these symbols but using only the general properties
of functions. In the next section, we will get some more experience
with such calculations.

\section{Symbolic calculations with nameless functions}

\subsection{Solved examples: Deriving a function's type from its code\index{solved examples}}

Checking that the types match is an important part of the functional
programming paradigm – both in the practice of writing code and in
theoretical derivations of laws for various functions. For instance,
in the derivations of the composition laws (Section~\ref{subsec:Laws-of-function-composition}),
we were able to deduce the possible type parameters for $f$, $g$,
and $h$ in the expression $f\bef g\bef h$. This worked because the
composition operation \inputencoding{latin9}\lstinline!andThen!\inputencoding{utf8}
(denoted by the symbol $\bef$) is fully parametric. Given a fully
parametric function, it is often possible to derive the most general
type signature that matches the body of that function. The same type-matching
procedure may also help in converting a given function to a fully
parametric form.

Let us look at some examples of doing this.

\subsubsection{Example \label{subsec:Example-hof-derive-types-1}\ref{subsec:Example-hof-derive-types-1}}

The functions \inputencoding{latin9}\lstinline!const!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!id!\inputencoding{utf8} were
defined in Section~\ref{subsec:Examples-of-fully-parametric}. What
is the value \inputencoding{latin9}\lstinline!const(id)!\inputencoding{utf8}
and what is its type? Determine the most general type parameters in
the expression \inputencoding{latin9}\lstinline!const(id)!\inputencoding{utf8}.

\subparagraph{Solution}

We need to treat the functions \inputencoding{latin9}\lstinline!const!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!id!\inputencoding{utf8} as values,
since our goal is to apply \inputencoding{latin9}\lstinline!const!\inputencoding{utf8}
to \inputencoding{latin9}\lstinline!id!\inputencoding{utf8}. Write
the code of these functions in a short notation:
\begin{align*}
\text{const}^{C,X} & \triangleq c^{:C}\Rightarrow\_^{:X}\Rightarrow c\quad,\\
\text{id}^{A} & \triangleq a^{:A}\Rightarrow a\quad.
\end{align*}
The types will match in the expression \inputencoding{latin9}\lstinline!const(id)!\inputencoding{utf8}
only if the argument of the function \inputencoding{latin9}\lstinline!const!\inputencoding{utf8}
has the same type as the type of \inputencoding{latin9}\lstinline!id!\inputencoding{utf8}.
Since ``$\text{const}$'' is a curried function, we need to look
at its \emph{first} curried argument, which is of type $C$. The type
of $\text{id}$ is $A\Rightarrow A$, where $A$ is an arbitrary type
so far. So, the type parameter $C$ in $\text{const}^{C,X}$ must
be equal to $A\Rightarrow A$:
\[
C=A\Rightarrow A\quad.
\]
 The type parameter $X$ in $\text{const}^{C,X}$ is not constrained,
so we keep it as $X$. The result of applying $\text{const}$ to $\text{id}$
is of type $X\Rightarrow C$, which equals $X\Rightarrow A\Rightarrow A$.
In this way, we find that the type of \inputencoding{latin9}\lstinline!const(id)!\inputencoding{utf8},
\[
\text{const}^{A\Rightarrow A,X}(\text{id}^{A}):X\Rightarrow A\Rightarrow A\quad.
\]
The types $A$ and $X$ can be arbitrary. The type $X\Rightarrow A\Rightarrow A$
is the most general type for the expression \inputencoding{latin9}\lstinline!const(id)!\inputencoding{utf8}
because we have not made any assumptions about the types except requiring
that all functions must be always applied to arguments of the correct
types.

To compute the value of \inputencoding{latin9}\lstinline!const(id)!\inputencoding{utf8},
it remains to substitute the code of \inputencoding{latin9}\lstinline!const!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!id!\inputencoding{utf8}. Since
we already checked the types, we may omit all type annotations:
\begin{align*}
 & \gunderline{\text{const}}\left(\text{id}\right)\\
{\color{greenunder}\text{definition of const}:}\quad & =(c\Rightarrow x\Rightarrow\gunderline c)(\text{id})\\
{\color{greenunder}\text{substitute }c=\text{id}:}\quad & =(x\Rightarrow\gunderline{\text{id}})\\
{\color{greenunder}\text{definition of }\text{id}:}\quad & =\left(x\Rightarrow a\Rightarrow a\right)\quad.
\end{align*}
This is a function that takes an argument $x^{:X}$ and returns the
identity function $a^{:A}\Rightarrow a$. It is clear that the argument
$x$ is ignored by this function, so we can rewrite the result equivalently
as
\[
\text{const}(\text{id})=(\_^{:X}\Rightarrow a^{:A}\Rightarrow a)\quad.
\]


\subsubsection{Example \label{subsec:Example-hof-derive-types-2}\ref{subsec:Example-hof-derive-types-2}}

Implement a function \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
that takes a function \inputencoding{latin9}\lstinline!f: Int => Int!\inputencoding{utf8}
as its argument and returns a function that applies \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
twice. For example, if the function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
is \inputencoding{latin9}\lstinline!f = { x => x + 3 }!\inputencoding{utf8},
the result of \inputencoding{latin9}\lstinline!twice(f)!\inputencoding{utf8}
should be equal to the function \inputencoding{latin9}\lstinline!x => x + 6!\inputencoding{utf8}.
After implementing the function \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8},
generalize it to a fully parametric function.

\subparagraph{Solution}

According to the requirements, the function \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
must return a new function of type \inputencoding{latin9}\lstinline!Int => Int!\inputencoding{utf8}.
So the type signature of \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
is\inputencoding{latin9}
\begin{lstlisting}
def twice(f: Int => Int): Int => Int = ???
\end{lstlisting}
\inputencoding{utf8}Since \inputencoding{latin9}\lstinline!twice(f)!\inputencoding{utf8}
must be a new function with an integer argument, we begin to write
the body of \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
as\inputencoding{latin9}
\begin{lstlisting}
def twice(f: Int => Int): Int => Int = { (x: Int) => ??? }
\end{lstlisting}
\inputencoding{utf8}The new function must apply \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
twice to its argument, that is, it must return \inputencoding{latin9}\lstinline!f(f(x))!\inputencoding{utf8}.
We can finish the implementation now:\inputencoding{latin9}
\begin{lstlisting}
def twice(f: Int => Int): Int => Int = { x => f(f(x)) }
\end{lstlisting}
\inputencoding{utf8}The type annotation \inputencoding{latin9}\lstinline!(x: Int)!\inputencoding{utf8}
can be omitted. To test:\inputencoding{latin9}
\begin{lstlisting}
scala> val g = twice(x => x + 3)
g: Int => Int = <function1>

scala> g(10)
res0: Int = 16
\end{lstlisting}
\inputencoding{utf8}
This example illustrates how a function can return a new function.
We just write a nameless function in the function body.

To generalize \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
to a fully parametric function means to replace the type signature
by a parameterized type while keeping the function body unchanged,\inputencoding{latin9}
\begin{lstlisting}
def twice[A, B, ...](f: ...): ... = { x => f(f(x)) }
\end{lstlisting}
\inputencoding{utf8} To determine the type signature and the possible type parameters
$A$, $B$, ..., we need to determine the most general type that matches
the function body. The function body is the expression $x\Rightarrow f(f(x))$.
Assume that $x$ has type $A$; for types to match in the sub-expression
$f(x)$, we need $f$ to have type $A\Rightarrow B$ for some type
$B$. The sub-expression $f(x)$ will then have type $B$. For types
to match in $f(f(x))$, the argument of $f$ must have type $B$;
but we already assumed $f^{:A\Rightarrow B}$. This is consistent
only if $A=B$. In this way, $x^{:A}$ implies $f^{:A\Rightarrow A}$,
and the expression $x\Rightarrow f(f(x))$ has type $A\Rightarrow A$.
We can now write the type signature of \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8},\inputencoding{latin9}
\begin{lstlisting}
def twice[A](f: A => A): A => A = { x => f(f(x)) }
\end{lstlisting}
\inputencoding{utf8}This fully parametric function has only one independent type parameter,
$A$, and can be equivalently written in the mathematical notation
as the curried function
\begin{equation}
\text{twice}^{A}\triangleq f^{:A\Rightarrow A}\Rightarrow x^{:A}\Rightarrow f(f(x))\quad.\label{eq:hof-def-of-twice-in-math-notation}
\end{equation}

The procedure of deriving the most general type for a given code is
called \textbf{type inference}\index{type inference}. The presence
of the type parameter $A$ and the general type signature $\left(A\Rightarrow A\right)\Rightarrow A\Rightarrow A$
have been ``inferred'' from the code $f\Rightarrow x\Rightarrow f(f(x))$.

\subsubsection{Example \label{subsec:Example-hof-derive-types-3}\ref{subsec:Example-hof-derive-types-3}}

Consider the fully parametric function \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
defined in Example~\ref{subsec:Example-hof-derive-types-2}. What
is the type of \inputencoding{latin9}\lstinline!twice(twice)!\inputencoding{utf8},
and what computation does it perform? Test your answer on the expression
\inputencoding{latin9}\lstinline!twice(twice[Int])(x => x+3)(10)!\inputencoding{utf8}.
What are the type parameters in that expression?

\subparagraph{Solution}

Begin by figuring out the required type of \inputencoding{latin9}\lstinline!twice(twice)!\inputencoding{utf8}.
We introduce unknown type parameters as \inputencoding{latin9}\lstinline!twice[A](twice[B])!\inputencoding{utf8}.
The types will match if the argument type of \inputencoding{latin9}\lstinline!twice[A]!\inputencoding{utf8},
which is $A\Rightarrow A$, matches the type of \inputencoding{latin9}\lstinline!twice[B]!\inputencoding{utf8},
which is $\left(B\Rightarrow B\right)\Rightarrow B\Rightarrow B$.
Since the symbol $\Rightarrow$ groups to the right, we have 
\begin{align*}
 & \left(B\Rightarrow B\right)\Rightarrow B\Rightarrow B\\
 & =\left(B\Rightarrow B\right)\Rightarrow\left(B\Rightarrow B\right)\quad.
\end{align*}
This can match with $A\Rightarrow A$ only if we set $A=\left(B\Rightarrow B\right)$.
So the most general type of \inputencoding{latin9}\lstinline!twice(twice)!\inputencoding{utf8}
is
\begin{equation}
\text{twice}^{B\Rightarrow B}(\text{twice}^{B}):\left(B\Rightarrow B\right)\Rightarrow B\Rightarrow B\quad.\label{eq:hof-twice-example-solved3}
\end{equation}
After checking that types match, we may omit types from further calculations.

Example~\ref{subsec:Example-hof-derive-types-2} defined \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
with the \inputencoding{latin9}\lstinline!def!\inputencoding{utf8}
syntax. To use \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
as an argument in the expression \inputencoding{latin9}\lstinline!twice(twice)!\inputencoding{utf8},
it is convenient to define \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
as a value,\inputencoding{latin9}
\begin{lstlisting}
val twice = ...
\end{lstlisting}
\inputencoding{utf8}However, the function \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
has type parameters, and Scala 2 does not directly support \inputencoding{latin9}\lstinline!val!\inputencoding{utf8}
definitions with type parameters. Scala 3 will support type parameters
appearing together with value parameters in a nameless function:\inputencoding{latin9}
\begin{lstlisting}
val twice = [A] => (f: A => A) => (x: A) => f(f(x)) // Scala 3 only!
\end{lstlisting}
\inputencoding{utf8}Keeping this in mind, we will use the curried definition of \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
given by Eq.~(\ref{eq:hof-def-of-twice-in-math-notation}). Substituting
this into the expression \inputencoding{latin9}\lstinline!twice(twice)!\inputencoding{utf8},
we find
\begin{align*}
 & \text{twice}(\text{twice})\\
{\color{greenunder}\text{definition of twice}:}\quad & =(f\Rightarrow x\Rightarrow f(f(x)))(\text{twice})\quad.\\
{\color{greenunder}\text{substitute }f=\text{twice}:}\quad & =x\Rightarrow\text{twice}(\text{twice}(x))\\
{\color{greenunder}\text{definition of twice}:}\quad & =x\Rightarrow\left(f\Rightarrow x\Rightarrow f(f(x))\right)\left(\left(f\Rightarrow x\Rightarrow f(f(x))\right)(x)\right)\quad.
\end{align*}
The last expression is hard to use: it is confusing that the argument
names $f$ and $x$ are repeated. The calculation will be made clearer
if we rename the arguments to remove shadowing of names\index{shadowed name}.
To avoid errors, we will start with $x\Rightarrow\text{twice}(\text{twice}(x))$
and rename arguments one scope at a time:
\begin{align*}
 & x\Rightarrow\text{twice}(\text{twice}(\gunderline x))\\
{\color{greenunder}\text{rename }x\text{ to }z:}\quad & =z\Rightarrow\gunderline{\text{twice}}(\text{twice}(z))\\
{\color{greenunder}\text{definition of twice}:}\quad & =z\Rightarrow\gunderline{\left(f\Rightarrow x\Rightarrow f(f(x))\right)}\left(\text{twice}(z)\right)\\
{\color{greenunder}\text{rename }f,x\text{ to }g,y:}\quad & =z\Rightarrow(g\Rightarrow y\Rightarrow\gunderline g(\gunderline g(y)))\left(\text{twice}(z)\right)\\
{\color{greenunder}\text{apply, }g=\text{twice}(z):}\quad & =z\Rightarrow y\Rightarrow\gunderline{\left(\text{twice}(z)\right)}\left(\text{twice}(z)(y)\right)\\
{\color{greenunder}\text{use }\text{twice}(z)=\left(x\Rightarrow z(z(x))\right):}\quad & =z\Rightarrow y\Rightarrow\left(x\Rightarrow z(z(x))\right)(\gunderline{\text{twice}(z)(y)})\\
{\color{greenunder}\text{apply, }x=\text{twice}(z)(y)=z(z(y)):}\quad & =z\Rightarrow y\Rightarrow z(z(z(z(y))))\quad.
\end{align*}
So \inputencoding{latin9}\lstinline!twice(twice)!\inputencoding{utf8}
is a function that applies its (function-typed) argument \emph{four}
times.

The type parameters follow from Eq.~(\ref{eq:hof-twice-example-solved3})
with $A=\text{Int}$ and can be written as $\text{twice}^{\text{Int}\Rightarrow\text{Int}}(\text{twice}^{\text{Int}})$,
or in Scala syntax, \inputencoding{latin9}\lstinline!twice[Int => Int](twice[Int])!\inputencoding{utf8}.
To test, we need to write at least one type parameter in the code,
or else Scala cannot infer the types correctly:\inputencoding{latin9}
\begin{lstlisting}
scala> twice(twice[Int])(x => x + 3)(100) // _ + 3 + 3 + 3 + 3
res0: Int = 112

scala> twice[Int => Int](twice)(x => x + 3)(100)
res1: Int = 112
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-hof-derive-types-4}\ref{subsec:Example-hof-derive-types-4}}

Infer the type signature for the fully parametric function\inputencoding{latin9}
\begin{lstlisting}
def p[...]:... = { f => f(2) }
\end{lstlisting}
\inputencoding{utf8}Can the types possibly match in the expression \inputencoding{latin9}\lstinline!p(p)!\inputencoding{utf8}?

\subparagraph{Solution}

In the nameless function $f\Rightarrow f(2)$, the argument $f$ must
be itself a function with an argument of type \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8},
otherwise the sub-expression $f(2)$ makes no sense. So, types will
match if $f$ has type $\text{Int}\Rightarrow\text{Int}$ or $\text{Int}\Rightarrow\text{String}$
or similar. The most general case is when $f$ has type $\text{Int}\Rightarrow A$,
where $A$ is an arbitrary type (i.e.~a type parameter). The type
$A$ will then be the (so far unknown) type of the value $f(2)$.
Since nameless function $f\Rightarrow f(2)$ has an argument $f$
of type $\text{Int}\Rightarrow A$ and the result of type $A$, we
find that the type of $p$ must be $\left(\text{Int}\Rightarrow A\right)\Rightarrow A$.
With this type assignment, all types match. The type parameter $A$
remains undetermined and is added to the type signature of the function
\inputencoding{latin9}\lstinline!p!\inputencoding{utf8}. The code
is\inputencoding{latin9}
\begin{lstlisting}
def p[A]: (Int => A) => A = { f => f(2) }
\end{lstlisting}
\inputencoding{utf8}
To answer the question about the expression \inputencoding{latin9}\lstinline!p(p)!\inputencoding{utf8},
we begin by writing that expression with new type parameters as \inputencoding{latin9}\lstinline!p[A](p[B])!\inputencoding{utf8}.
Then we try to choose \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!B!\inputencoding{utf8} so that
the types match in that expression. Does the type of \inputencoding{latin9}\lstinline!p[B]!\inputencoding{utf8},
which is \inputencoding{latin9}\lstinline!(Int => B) => B!\inputencoding{utf8},
match the type of the argument of \inputencoding{latin9}\lstinline!p[A]!\inputencoding{utf8},
which is \inputencoding{latin9}\lstinline!Int => A!\inputencoding{utf8},
with some choice of \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!B!\inputencoding{utf8}? A function
type \inputencoding{latin9}\lstinline!P => Q!\inputencoding{utf8}
matches \inputencoding{latin9}\lstinline!X => Y!\inputencoding{utf8}
only if \inputencoding{latin9}\lstinline!P = X!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Q = Y!\inputencoding{utf8}.
So \inputencoding{latin9}\lstinline!(Int => B) => B!\inputencoding{utf8}
can match \inputencoding{latin9}\lstinline!Int => A!\inputencoding{utf8}
only if \inputencoding{latin9}\lstinline!Int => B!\inputencoding{utf8}
matches \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}
and if \inputencoding{latin9}\lstinline!B = A!\inputencoding{utf8}.
But it is impossible for \inputencoding{latin9}\lstinline!Int => B!\inputencoding{utf8}
to match \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8},
no matter how we choose \inputencoding{latin9}\lstinline!B!\inputencoding{utf8}. 

We conclude that types cannot be chosen consistently in \inputencoding{latin9}\lstinline!p[A](p[B])!\inputencoding{utf8}.
Such expressions contain a type error and are rejected by the Scala
compiler. One also says that the expression \inputencoding{latin9}\lstinline!p(p)!\inputencoding{utf8}
is \textbf{not well-typed}\index{well-typed expression}, or does
not \textbf{typecheck}\index{type checking}.

For any given code expression containing only function expressions,
one can always find the most general type that makes all functions
match their arguments, unless the expression does not typecheck. The
Damas-Hindley-Milner algorithm\footnote{\href{https://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner_type_system\#Algorithm_W}{https://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner\_type\_system\#Algorithm\_W}}
performs type inference (or determines that there is a type error)
for a large class of expressions containing functions, tuples, and
disjunctive types. 

\subsection{Calculations with curried functions}

In mathematics, functions are evaluated by substituting their argument
values into their body. Nameless functions are evaluated in the same
way. For example, applying the nameless function $x\Rightarrow x+10$
to an integer $2$, we substitute $2$ instead of $x$ in “$x+10$”
and get “$2+10$”, which we then evaluate to $12$. The computation
is written like this, 
\[
(x\Rightarrow x+10)(2)=2+10=12\quad.
\]
To run this computation in Scala, we need to add a type annotation:
\inputencoding{latin9}\begin{lstlisting}
scala> ((x: Int) => x + 10)(2)
res0: Int = 12 
\end{lstlisting}
\inputencoding{utf8}
Curried function applications such as $f(x)(y)$ are rarely used in
mathematics , so we need to gain some experience working with them.

Let us consider a curried nameless function being applied to arguments,
such as \inputencoding{latin9}\lstinline!(x => y => x - y)(20)(4)!\inputencoding{utf8},
and compute the result of this function application. Begin with the
argument \inputencoding{latin9}\lstinline!20!\inputencoding{utf8};
applying a nameless function of the form \inputencoding{latin9}\lstinline!(x => ...)!\inputencoding{utf8}
to \inputencoding{latin9}\lstinline!20!\inputencoding{utf8} means
to substitute \inputencoding{latin9}\lstinline!x = 20!\inputencoding{utf8}
into the body of the function. After that substitution, we obtain
the expression \inputencoding{latin9}\lstinline!y => 20 - y!\inputencoding{utf8},
which is again a nameless function. Applying that function to the
remaining argument \inputencoding{latin9}\lstinline!(4)!\inputencoding{utf8}
means substituting \inputencoding{latin9}\lstinline!y = 4!\inputencoding{utf8}
into the body of that function. This yields the expression \inputencoding{latin9}\lstinline!20 - 4!\inputencoding{utf8}.
We can compute that and get the result, \inputencoding{latin9}\lstinline!16!\inputencoding{utf8}.
Check the result with Scala:\inputencoding{latin9}
\begin{lstlisting}
scala> ((x: Int) => (y: Int) => x - y)(20)(4)
res1: Int = 16
\end{lstlisting}
\inputencoding{utf8}
Applying a curried function such as \inputencoding{latin9}\lstinline!x => y => z => expr(x,y,z)!\inputencoding{utf8}
to three curried arguments \inputencoding{latin9}\lstinline!10!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!20!\inputencoding{utf8}, and \inputencoding{latin9}\lstinline!30!\inputencoding{utf8}
means to substitute \inputencoding{latin9}\lstinline!x = 10!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!y = 20!\inputencoding{utf8}, and
\inputencoding{latin9}\lstinline!z = 30!\inputencoding{utf8} into
the expression \inputencoding{latin9}\lstinline!expr!\inputencoding{utf8}.
In this way, we can easily apply a curried function to any number
of curried arguments.

This calculation is helped by the convention that \inputencoding{latin9}\lstinline!f(g)(h)!\inputencoding{utf8}
means first applying \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
to \inputencoding{latin9}\lstinline!g!\inputencoding{utf8} and then
applying the result to \inputencoding{latin9}\lstinline!h!\inputencoding{utf8}.
In other words, function application groups to the \emph{left}: \inputencoding{latin9}\lstinline!f(g)(h) = (f(g))(h)!\inputencoding{utf8}.
It would be confusing if function application grouped to the right
and \inputencoding{latin9}\lstinline!f(g)(h)!\inputencoding{utf8}
meant first applying \inputencoding{latin9}\lstinline!g!\inputencoding{utf8}
to \inputencoding{latin9}\lstinline!h!\inputencoding{utf8} and then
applying \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
to the result. If \emph{that} were the syntax convention, it would
be harder to reason about applying a curried function to the arguments.

We see that the right grouping of the function arrow \inputencoding{latin9}\lstinline!=>!\inputencoding{utf8}
is well adapted to the left grouping of function applications. All
functional languages adopt these syntactic conventions.

To make calculations shorter, we will write code in a mathematical
notation rather than in the Scala syntax. Type annotations are written
with a colon in the superscript, for example: $x^{:\text{Int}}\Rightarrow x+10$
instead of the code \inputencoding{latin9}\lstinline!((x:Int) => x + 10)!\inputencoding{utf8}.

The symbolic evaluation of the Scala code \inputencoding{latin9}\lstinline!((x:Int) => (y:Int) => x - y)(20)(4)!\inputencoding{utf8}
can be performed as the following line-by-line derivation,
\begin{align*}
 & (\gunderline{x^{:\text{Int}}\Rightarrow}\,y^{:\text{Int}}\Rightarrow\gunderline x-y)\left(20\right)\left(4\right)\\
{\color{greenunder}\text{substitute }x=20:}\quad & =(\gunderline{y^{:\text{Int}}\Rightarrow}\,20-\gunderline y)\left(4\right)\\
{\color{greenunder}\text{substitute }y=4:}\quad & =20-4=16\quad.
\end{align*}
(The underlined part of the expression will be rewritten in the next
line.)

Here we performed calculations by substituting an argument into a
function at each step. A compiled Scala program is evaluated in a
similar way at run time.

Nameless functions are \emph{values} and so can be used as part of
larger expressions, just as any other values. For instance, nameless
functions can be arguments of other functions (nameless or not). Here
is an example of applying a nameless function $f\Rightarrow f(2)$
to a nameless function $x\Rightarrow x+4$:
\begin{align*}
 & (f\Rightarrow\gunderline f(2))\left(x\Rightarrow x+4\right)\\
{\color{greenunder}\text{substitute }f=\left(x\Rightarrow x+4\right):}\quad & =(x\Rightarrow\gunderline x+4)(2)\\
{\color{greenunder}\text{substitute }x=2:}\quad & =2+4=6\quad.
\end{align*}
In the nameless function $f\Rightarrow f(2)$, the argument $f$ has
to be itself a function, otherwise the expression $f(2)$ would make
no sense. The argument $x$ of $f(x)$ must be an integer, or else
we would not be able to compute $x+4$. The result of computing $f(2)$
is $4$, and integer. We conclude that in this example, $f$ must
have type $\text{Int}\Rightarrow\text{Int}$, or else the types will
not match. To verify this result in Scala, we need to specify the
type annotation for $f$:\inputencoding{latin9}
\begin{lstlisting}
scala> ((f: Int => Int) => f(2))(x => x + 4)
res2: Int = 6  
\end{lstlisting}
\inputencoding{utf8}No type annotation is needed for $x\Rightarrow x+4$ since the Scala
compiler already knows the type of $f$ and can infer that $x$ in
$x\Rightarrow x+4$ must have type \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}.

To summarize the standard syntax conventions for curried nameless
functions:
\begin{itemize}
\item Function expressions group everything to the right,\\
so $x\Rightarrow y\Rightarrow z\Rightarrow e$ means $x\Rightarrow\left(y\Rightarrow\left(z\Rightarrow e\right)\right)$.
\item Function applications group everything to the left,\\
so $f(x)(y)(z)$ means $\big((f(x))(y)\big)(z)$.
\item Function applications group stronger than infix operations,\\
so $x+f(y)$ means $x+(f(y))$, as in mathematics.
\end{itemize}
Here are some more examples of performing function applications symbolically.
Types are omitted for brevity; every non-function value is of type
\texttt{}\inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}.
\begin{align*}
\left(x\Rightarrow x*2\right)(10) & =10*2=20\quad.\\
\left(p\Rightarrow z\Rightarrow z*p\right)\left(t\right) & =(z\Rightarrow z*t)\quad.\\
\left(p\Rightarrow z\Rightarrow z*p\right)(t)(4) & =(z\Rightarrow z*t)(4)=4*t\quad.
\end{align*}
Some results of these computation are integer values such as $20$;
other results are nameless functions such as $z\Rightarrow z*t$.
Verify this in Scala:\inputencoding{latin9}
\begin{lstlisting}
scala> ((x:Int) => x*2)(10)
res3: Int = 20

scala> ((p:Int) => (z:Int) => z*p)(10)
res4: Int => Int = <function1>

scala> ((p:Int) => (z:Int) => z*p)(10)(4)
res5: Int = 40 
\end{lstlisting}
\inputencoding{utf8}
In the following examples, some arguments are themselves functions.
We saw in Example~\ref{subsec:Example-hof-derive-types-4} that the
most general type for $g\Rightarrow g(2)$ is $\left(\text{Int}\Rightarrow A\right)\Rightarrow A$.
Let us now compute an expression that uses $\left(g\Rightarrow g(2)\right)$
as an argument:
\begin{align}
 & (f\Rightarrow p\Rightarrow\gunderline f(p))\left(g\Rightarrow g(2)\right)\nonumber \\
{\color{greenunder}\text{substitute }f=\left(g\Rightarrow g(2)\right):}\quad & =p\Rightarrow(g\Rightarrow\gunderline g(2))\,(p)\nonumber \\
{\color{greenunder}\text{substitute }g=p:}\quad & =p\Rightarrow p(2)\quad.\label{eq:higher-order-functions-derivation1}
\end{align}
The result of this expression is a function $p\Rightarrow p(2)$ that
will apply \emph{its} argument to the value $2$. A possible argument
is the function $x\Rightarrow x+4$. So, let us apply the previous
expression to that function:
\begin{align*}
 & \gunderline{\left(f\Rightarrow p\Rightarrow f(p)\right)\left(g\Rightarrow g(2)\right)}\left(x\Rightarrow x+4\right)\\
{\color{greenunder}\text{use Eq.~(\ref{eq:higher-order-functions-derivation1})}:}\quad & =(p\Rightarrow\gunderline p(2))\left(x\Rightarrow x+4\right)\\
{\color{greenunder}\text{substitute }p=\left(x\Rightarrow x+4\right):}\quad & =(x\Rightarrow\gunderline x+4)\left(2\right)\\
{\color{greenunder}\text{substitute }x=2:}\quad & =2+4=6\quad.
\end{align*}

To verify this calculation in Scala, we need to add appropriate type
annotations for $f$ and $p$. To figure out the types, we reason
like this:

We know that the function $f\Rightarrow p\Rightarrow f(p)$ is being
applied to the arguments $f=g\Rightarrow g(2)$ and $p=x\Rightarrow x+4$.
The most general type of $g\Rightarrow g(2)$ is $\left(\text{Int}\Rightarrow A\right)\Rightarrow A$.
So, this must be the type of the argument $f$ in $f\Rightarrow p\Rightarrow f(p)$.

The variable $x$ in $x\Rightarrow x+4$ must be of type \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8},
or else we cannot add $x$ to $4$. Thus, the type of the expression
$x\Rightarrow x+4$ is $\text{Int}\Rightarrow\text{Int}$, and so
must be the type of the argument $p$ in $f\Rightarrow p\Rightarrow f(p)$. 

Finally, we need to make sure that the types match in the function
$f\Rightarrow p\Rightarrow f(p)$. The types match in $f(p)$ if the
type of $f$'s argument is the same as the type of $p$. Since $f$
has type $\left(\text{Int}\Rightarrow A\right)\Rightarrow A$, its
argument has type $\text{Int}\Rightarrow A$. To match that with the
type of $p^{:\text{Int}\Rightarrow\text{Int}}$ requires us to set
$A=\text{Int}$. So, the actual type of $f$ is $\left(\text{Int}\Rightarrow\text{Int}\right)\Rightarrow\text{Int}$.
We know enough to write the Scala code now:\inputencoding{latin9}
\begin{lstlisting}
scala> ((f: (Int => Int) => Int) => p => f(p))(g => g(2))(x => x + 4)
res6: Int = 6
\end{lstlisting}
\inputencoding{utf8}Type annotations for $p$, $g$, and $x$ may be omitted because the
Scala compiler will infer the missing types unambiguously from the
given type of $f$. However, it is never an error to specify more
types; it just makes the code longer.

\section{Summary}

What can we do with this chapter's techniques?
\begin{itemize}
\item Implement functions that return new functions and/or take functions
as arguments.
\item Simplify function applications symbolically.
\item Infer the most general type for a given code expression.
\item Convert functions to a fully parametric form.
\end{itemize}
The following solved examples and exercises illustrate these techniques.

\subsection{Solved examples\index{solved examples}}

\subsubsection{Example \label{subsec:Example-hof-simple-1}\ref{subsec:Example-hof-simple-1}}

Implement a function that applies a given function $f$ repeatedly
to an initial value $x_{0}$, until a given condition function \inputencoding{latin9}\lstinline!cond!\inputencoding{utf8}
returns \inputencoding{latin9}\lstinline!true!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def converge[X](f: X => X, x0: X, cond: X => Boolean): X = ???
\end{lstlisting}
\inputencoding{utf8}

\subparagraph{Solution}

We create an iterator that keeps applying the function $f$, and use
\inputencoding{latin9}\lstinline!.find!\inputencoding{utf8} to stop
the sequence when the condition first holds:\inputencoding{latin9}
\begin{lstlisting}
def converge[X](f: X => X, x0: X, cond: X => Boolean): X = 
  Stream.iterate(x0)(f) // Type is Stream[X].
  .find(cond) // Type is Option[X].
  .get // Type is X.
\end{lstlisting}
\inputencoding{utf8}Here it is safe to perform \inputencoding{latin9}\lstinline!.get!\inputencoding{utf8}
on an \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}:
If the condition never holds, the program will run out of memory (since
\inputencoding{latin9}\lstinline!Stream.iterate!\inputencoding{utf8}
keeps all computed values in memory) or the user runs out of time.

A tail-recursive implementation that works in constant memory is \inputencoding{latin9}
\begin{lstlisting}
@tailrec def converge[X](f: X => X, x0: X, cond: X => Boolean): X =
  if (cond(x0)) x0 else converge(f, f(x0), cond)
\end{lstlisting}
\inputencoding{utf8}
To test this code, let us compute an approximation to the square root
of a number $q$ by Newton's method. The iteration function $f$ is
\[
f(x)=\frac{1}{2}\left(x+\frac{q}{x}\right)\quad.
\]
We iterate $f(x)$ starting with $x_{0}=q/2$ until we obtain a given
precision:\inputencoding{latin9}
\begin{lstlisting}
def approx_sqrt(x: Double, precision: Double): Double = {
      def cond(y: Double): Boolean = math.abs(y * y - x) <= precision
      def iterate_sqrt(y: Double): Double = 0.5 * (y + x / y)
      converge(iterate_sqrt, x / 2, cond)
}
\end{lstlisting}
\inputencoding{utf8}Test it:\inputencoding{latin9}
\begin{lstlisting}
scala> approx_sqrt(25, 1.0e-8)
res0: Double = 5.000000000016778
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-hof-simple-2}\ref{subsec:Example-hof-simple-2}}

Using both \inputencoding{latin9}\lstinline!def!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!val!\inputencoding{utf8}, define
a Scala function that takes an integer \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
and returns a function that adds \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
to \emph{its} argument.

\subparagraph{Solution}

Let us first write down the required type signature: the function
must take an integer argument \inputencoding{latin9}\lstinline!x:Int!\inputencoding{utf8},
and the return value must be a function of type \inputencoding{latin9}\lstinline!Int => Int!\inputencoding{utf8}.\inputencoding{latin9}
\begin{lstlisting}
def add_x(x: Int): Int => Int = ???
\end{lstlisting}
\inputencoding{utf8}We are required to return a function that adds \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
to its argument. Let us call that argument \inputencoding{latin9}\lstinline!z!\inputencoding{utf8},
to avoid confusion with the \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}.
So, we are required to return a function that we can write as \inputencoding{latin9}\lstinline!{ z => z + x }!\inputencoding{utf8}.
Since functions are values, we can directly return a new function
by writing a nameless function expression:\inputencoding{latin9}
\begin{lstlisting}
def add_x(x: Int): Int => Int = { z => z + x }
\end{lstlisting}
\inputencoding{utf8}
To implement the same function via a \inputencoding{latin9}\lstinline!val!\inputencoding{utf8},
we first convert the type signature of \inputencoding{latin9}\lstinline!add_x!\inputencoding{utf8}
to the equivalent type expression $\text{Int}\Rightarrow\text{Int}\Rightarrow\text{Int}$.
Now we can write the Scala code of a function \inputencoding{latin9}\lstinline!add_x_v!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
val add_x_v: Int => Int => Int = { x => z => z + x }
\end{lstlisting}
\inputencoding{utf8}The function \inputencoding{latin9}\lstinline!add_x_v!\inputencoding{utf8}
is equal to \inputencoding{latin9}\lstinline!add_x!\inputencoding{utf8}
except for using the \inputencoding{latin9}\lstinline!val!\inputencoding{utf8}
syntax instead of \inputencoding{latin9}\lstinline!def!\inputencoding{utf8}.
It is not necessary to specify the type of the arguments \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!z!\inputencoding{utf8} because
we already specified the type $\text{Int}\Rightarrow\text{Int}\Rightarrow\text{Int}$
for the value \inputencoding{latin9}\lstinline!add_x_v!\inputencoding{utf8}. 

\subsubsection{Example \label{subsec:Example-hof-simple-3}\ref{subsec:Example-hof-simple-3}}

Using both \inputencoding{latin9}\lstinline!def!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!val!\inputencoding{utf8}, implement
a curried function \inputencoding{latin9}\lstinline!prime_f!\inputencoding{utf8}
that takes a function $f$ and an integer $x$, and returns \inputencoding{latin9}\lstinline!true!\inputencoding{utf8}
when $f(x)$ is a prime number. Use the function \inputencoding{latin9}\lstinline!is_prime!\inputencoding{utf8}
defined in Section~\ref{subsec:Nameless-functions}. 

\subparagraph{Solution}

First, we need to determine the required type signature of \inputencoding{latin9}\lstinline!prime_f!\inputencoding{utf8}.
The value $f(x)$ must type \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8},
or else we cannot check whether it is prime. So, $f$ must have type
$\text{Int}\Rightarrow\text{Int}$. Since \inputencoding{latin9}\lstinline!prime_f!\inputencoding{utf8}
should be a curried function, we need to put each argument into its
own set of parentheses:\inputencoding{latin9}
\begin{lstlisting}
def prime_f(f: Int => Int)(x: Int): Boolean = ???
\end{lstlisting}
\inputencoding{utf8}To implement \inputencoding{latin9}\lstinline!prime_f!\inputencoding{utf8},
we need to return the result of \inputencoding{latin9}\lstinline!is_prime!\inputencoding{utf8}
applied to \inputencoding{latin9}\lstinline!f(x)!\inputencoding{utf8}.
A simple solution is\inputencoding{latin9}
\begin{lstlisting}
def prime_f(f: Int => Int)(x: Int): Boolean = is_prime(f(x))
\end{lstlisting}
\inputencoding{utf8}
To implement the same function as a \inputencoding{latin9}\lstinline!val!\inputencoding{utf8},
rewrite its type signature as\inputencoding{latin9}
\begin{lstlisting}
val prime_f: (Int => Int) => Int => Boolean = ???
\end{lstlisting}
\inputencoding{utf8}(The parentheses around \inputencoding{latin9}\lstinline!Int => Int!\inputencoding{utf8}
are mandatory since \inputencoding{latin9}\lstinline!Int => Int => Int!\inputencoding{utf8}
would be a completely different type.) The implementation is\inputencoding{latin9}
\begin{lstlisting}
val prime_f: (Int => Int) => Int => Boolean = { f => x => is_prime(f(x)) }
\end{lstlisting}
\inputencoding{utf8}We also notice that the code is a forward composition of the functions
\inputencoding{latin9}\lstinline!f!\inputencoding{utf8} and \inputencoding{latin9}\lstinline!is_prime!\inputencoding{utf8},
so we can write it as\inputencoding{latin9}
\begin{lstlisting}
val prime_f: (Int => Int) => Int => Boolean = (f => f andThen is_prime)
\end{lstlisting}
\inputencoding{utf8}The function body is of the form \inputencoding{latin9}\lstinline!f => f.something!\inputencoding{utf8},
which is equivalent to a shorter Scala syntax \inputencoding{latin9}\lstinline!(_.something)!\inputencoding{utf8}.
So we can rewrite the code of \inputencoding{latin9}\lstinline!prime_f!\inputencoding{utf8}
as\inputencoding{latin9}
\begin{lstlisting}
val prime_f: (Int => Int) => Int => Boolean = (_ andThen is_prime)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-hof-simple-4}\ref{subsec:Example-hof-simple-4}}

Implement a function \inputencoding{latin9}\lstinline!choice(x,p,f,g)!\inputencoding{utf8}
that takes a value $x$, a predicate $p$, and two functions $f$
and $g$. The return value must be $f(x)$ if $p(x)$ returns true;
otherwise the return value must be $g(x)$. Infer the most general
type for this function.

\subparagraph{Solution}

The code of this function must be\inputencoding{latin9}
\begin{lstlisting}
def choice[...](x,p,f,g) = if (p(x)) f(x) else g(x)
\end{lstlisting}
\inputencoding{utf8}Now let us infer the most general type for this code. We begin by
assuming that $x$ has type $A$, where $A$ is a type parameter.
Then the predicate $p$ must have type \inputencoding{latin9}\lstinline!A => Boolean!\inputencoding{utf8}.
Since $p$ is an arbitrary predicate, the value $p(x)$ will be sometimes
\inputencoding{latin9}\lstinline!true!\inputencoding{utf8} and sometimes
\inputencoding{latin9}\lstinline!false!\inputencoding{utf8}. So,
\inputencoding{latin9}\lstinline!choice(x,p,f,g)!\inputencoding{utf8}
will sometimes return $f(x)$ and sometimes $g(x)$. It follows that
type $A$ must be the argument type of both $f$ and $g$, which means
that the most general types so far are $f^{:A\Rightarrow B}$ and
$g^{:A\Rightarrow C}$, yielding the type signature
\[
\text{choice}(x^{:A},p^{:A\Rightarrow\text{Boolean}},f^{:A\Rightarrow B},g^{:A\Rightarrow C})\quad.
\]

What could be the return type of \inputencoding{latin9}\lstinline!choice(x,p,f,g)!\inputencoding{utf8}?
If $p(x)$ returns \inputencoding{latin9}\lstinline!true!\inputencoding{utf8},
the function \inputencoding{latin9}\lstinline!choice!\inputencoding{utf8}
returns $f(x)$, which is of type $B$. Otherwise, \inputencoding{latin9}\lstinline!choice!\inputencoding{utf8}
returns $g(x)$, which is of type $C$. However, the type signature
of \inputencoding{latin9}\lstinline!choice!\inputencoding{utf8} must
be fixed in advance (at compile time) and cannot depend on the value
$p(x)$ computed at run time. So, the types of $f(x)$ and of $g(x)$
must be the same, $B=C$. The type signature of \inputencoding{latin9}\lstinline!choice!\inputencoding{utf8}
will thus have only two type parameters, $A$ and $B$:\inputencoding{latin9}
\begin{lstlisting}
def choice[A, B](x: A, p: A => Boolean, f: A => B, g: A => B): B =
  if (p(x)) f(x) else g(x)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-hof-derive-types-5}\ref{subsec:Example-hof-derive-types-5}}

Infer the most general type for the fully parametric function\inputencoding{latin9}
\begin{lstlisting}
def q[...]: ... = { f => g => g(f) }
\end{lstlisting}
\inputencoding{utf8}What types are inferred for the expressions \inputencoding{latin9}\lstinline!q(q)!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!q(q(q))!\inputencoding{utf8}?

\subparagraph{Solution}

Begin by assuming $f^{:A}$ for an arbitrary type $A$. In the sub-expression
$g\Rightarrow g(f)$, the curried argument $g$ must itself be a function,
because it is being applied to $f$ as $g(f)$. So we assign types
as $f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f)$, where
$A$ and $B$ are some type parameters. Since there are no other constraints
on the types, the parameters $A$ and $B$ remain arbitrary, so we
add them to the type signature:\inputencoding{latin9}
\begin{lstlisting}
def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end{lstlisting}
\inputencoding{utf8}
To match types in the expression \inputencoding{latin9}\lstinline!q(q)!\inputencoding{utf8},
we first assume arbitrary type parameters and write \inputencoding{latin9}\lstinline!q[A, B](q[C, D])!\inputencoding{utf8}.
We need to introduce new type parameters $C$, $D$ because these
type parameters will probably need to be set differently from $A$,
$B$ when we try to match the types in the expression \inputencoding{latin9}\lstinline!q(q)!\inputencoding{utf8}.

The type of the first curried argument of \inputencoding{latin9}\lstinline!q[A, B]!\inputencoding{utf8},
which is $A$, must match the entire type of \inputencoding{latin9}\lstinline!q[C, D]!\inputencoding{utf8},
which is $C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D$.
So we must set the type parameter $A$ as
\[
A=C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\quad.
\]
The type of \inputencoding{latin9}\lstinline!q(q)!\inputencoding{utf8}
becomes
\begin{align*}
q^{A,B}(q^{C,D}) & :\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad,\\
\text{where}\quad & A=C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\quad.
\end{align*}

We use this result to infer the most general type for \inputencoding{latin9}\lstinline!q(q(q))!\inputencoding{utf8}.
We may denote $r\triangleq q(q)$ for brevity; then, as we just found,
$r$ has type $\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B$.
To infer types in the expression \inputencoding{latin9}\lstinline!q(r)!\inputencoding{utf8},
we introduce new type parameters $E$, $F$ and write \inputencoding{latin9}\lstinline!q[E, F](r)!\inputencoding{utf8}.
The type of the argument of \inputencoding{latin9}\lstinline!q[E, F]!\inputencoding{utf8}
is $E$, and this must be the same as the type of $r$. This gives
the constraint
\[
E=\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad.
\]
Other than that, the type parameters are arbitrary. The type of the
expression \inputencoding{latin9}\lstinline!q(q(q))!\inputencoding{utf8}
is $\left(E\Rightarrow F\right)\Rightarrow F$. We conclude that the
most general type of \inputencoding{latin9}\lstinline!q(q(q))!\inputencoding{utf8}
is
\begin{align*}
q^{E,F}(q^{A,B}(q^{C,D})) & :\left(\left(\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\right)\Rightarrow F\right)\Rightarrow F\quad,\\
\text{where}\quad & A=C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\\
\text{and}\quad & E=\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad.
\end{align*}
It is clear from this derivation that all expressions such as \inputencoding{latin9}\lstinline!q(q(q(q)))!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!q(q(q(q(q))))!\inputencoding{utf8},
etc., are well-typed.

Let us test these results in Scala, renaming the type parameters for
clarity to \inputencoding{latin9}\lstinline!A!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!B!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!C!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!D!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> def qq[A, B, C]: ((A => (A => B) => B) => C) => C = q(q)
qq: [A, B, C]=> ((A => ((A => B) => B)) => C) => C

scala> def qqq[A, B, C, D]: ((((A => (A => B) => B) => C) => C) => D) => D = q(q(q))
qqq: [A, B, C, D]=> ((((A => ((A => B) => B)) => C) => C) => D) => D
\end{lstlisting}
\inputencoding{utf8}We did not need to write any type parameters within the expressions
\inputencoding{latin9}\lstinline!q(q)!\inputencoding{utf8} and \inputencoding{latin9}\lstinline!q(q(q))!\inputencoding{utf8}
because the full type signature was declared at the beginning of each
of these expressions. Since the Scala compiler did not print any error
messages, we are assured that the types match correctly.

\subsubsection{Example \label{subsec:Example-hof-curried}\ref{subsec:Example-hof-curried}}

Infer types in the code expression
\[
\left(f\Rightarrow g\Rightarrow g(f)\right)\left(f\Rightarrow g\Rightarrow g(f)\right)\left(f\Rightarrow f(10)\right)\quad,
\]
and simplify the code.

\subparagraph{Solution}

The given expression is a curried function $f\Rightarrow g\Rightarrow g(f)$
applied to two curried arguments. The plan is to consider each of
these sub-expressions in turn, assigning types for them using type
parameters, and then to figure out how to set the type parameters
so that all types match.

Begin by renaming the shadowed variables $f$ and $g$, to remove
shadowing:
\begin{equation}
\left(f\Rightarrow g\Rightarrow g(f)\right)\left(x\Rightarrow y\Rightarrow y(x)\right)\left(h\Rightarrow h(10)\right)\quad.\label{eq:example-hof-curried-function-solved1}
\end{equation}
 As we have seen in Example~\ref{subsec:Example-hof-derive-types-5},
the sub-expression $f\Rightarrow g\Rightarrow g(f)$ is typed as $f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f)$,
where $A$ and $B$ are some type parameters. The sub-expression $x\Rightarrow y\Rightarrow y(x)$
is the same function as $f\Rightarrow g\Rightarrow g(f)$ but with
possibly different type parameters, say, $x^{:C}\Rightarrow y^{:C\Rightarrow D}\Rightarrow y(x)$.
The types $A$, $B$, $C$, $D$ are so far unknown.

Finally, the variable $h$ in the sub-expression $h\Rightarrow h(10)$
must have type $\text{Int}\Rightarrow E$, where $E$ is another type
parameter. So, the sub-expression $h\Rightarrow h(10)$ is a function
of type $\left(\text{Int}\Rightarrow E\right)\Rightarrow E$.

The types must match in the entire expression~(\ref{eq:example-hof-curried-function-solved1}):
\begin{equation}
(f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f))(x^{:C}\Rightarrow y^{:C\Rightarrow D}\Rightarrow y(x))(h^{:\text{Int}\Rightarrow E}\Rightarrow h(10)\quad.\label{eq:example-hof-curried-function-solved2}
\end{equation}
It follows that $f$ must have the same type as $x\Rightarrow y\Rightarrow y(x)$,
and $g$ must have the same type as $h\Rightarrow h(10)$. The type
of $g$, which we know as $A\Rightarrow B$, will match the type of
$h\Rightarrow h(10)$, which we know as $\left(\text{Int}\Rightarrow E\right)\Rightarrow E$,
only if $A=\text{Int}\Rightarrow E$ and $B=E$. It follows that $f$
has type $\text{Int}\Rightarrow E$. At the same time, the type of
$f$ must match the type of $x\Rightarrow y\Rightarrow y(x)$, which
is $C\Rightarrow(C\Rightarrow D)\Rightarrow D$. This can work only
if $C=\text{Int}$ and $E=(C\Rightarrow D)\Rightarrow D$.

In this way, we have found all the relationships between the type
parameters $A$, $B$, $C$, $D$, $E$ in Eq.~(\ref{eq:example-hof-curried-function-solved2}).
The type $D$ remains undetermined (i.e.~arbitrary), while the type
parameters $A$, $B$, $C$, $E$ are expressed as
\begin{align}
A & =\text{Int}\Rightarrow\left(\text{Int}\Rightarrow D\right)\Rightarrow D\quad,\label{eq:example-hof-curried-solved3}\\
B & =E=\left(\text{Int}\Rightarrow D\right)\Rightarrow D\quad,\label{eq:example-hof-curried-solved4}\\
C & =\text{Int}\quad.\nonumber 
\end{align}
The entire expression in Eq.~(\ref{eq:example-hof-curried-function-solved2})
is a saturated application of a curried function, and thus has the
same type as the ``final'' result expression $g(f)$, which has
type $B$. So, the entire expression in Eq.~(\ref{eq:example-hof-curried-function-solved2})
has type $B=\left(\text{Int}\Rightarrow D\right)\Rightarrow D$.

Having established that types match, we can now omit the type annotations
and rewrite the code expression as
\begin{align*}
 & (f\Rightarrow g\Rightarrow\gunderline g(\gunderline f))\left(x\Rightarrow y\Rightarrow y(x)\right)\left(h\Rightarrow h(10)\right)\\
{\color{greenunder}\text{substitute }f,g:}\quad & =(h\Rightarrow\gunderline h(10))\left(x\Rightarrow y\Rightarrow y(x)\right)\\
{\color{greenunder}\text{substitute }h:}\quad & =(x\Rightarrow y\Rightarrow y(\gunderline x))(10)\\
{\color{greenunder}\text{substitute }x:}\quad & =y\Rightarrow y(10)\quad.
\end{align*}
The type of this expression is $\left(\text{Int}\Rightarrow D\right)\Rightarrow D$
with a type parameter $D$. Since the argument $y$ is an arbitrary
function, we cannot simplify $y(10)$ or $y\Rightarrow y(10)$ any
further. We conclude that $y^{:\text{Int}\Rightarrow D}\Rightarrow y(10)$
is the final simplified form of Eq.~(\ref{eq:example-hof-curried-function-solved1}).

To test this, we first define the function $f\Rightarrow g\Rightarrow g(f)$
as in Example~\ref{subsec:Example-hof-derive-types-5},\inputencoding{latin9}
\begin{lstlisting}
def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end{lstlisting}
\inputencoding{utf8}We also define the function $h\Rightarrow h(10)$ with a general type
$\left(\text{Int}\Rightarrow E\right)\Rightarrow E$,\inputencoding{latin9}
\begin{lstlisting}
def r[E]: (Int => E) => E = { h => h(10) }
\end{lstlisting}
\inputencoding{utf8}To help Scala evaluate Eq.~(\ref{eq:example-hof-curried-function-solved2}),
we need to set the type parameters for the first \inputencoding{latin9}\lstinline!q!\inputencoding{utf8}
function as \inputencoding{latin9}\lstinline!q[A, B]!\inputencoding{utf8}
where $A$ and $B$ are given by Eqs.~(\ref{eq:example-hof-curried-solved3})–(\ref{eq:example-hof-curried-solved4}):\inputencoding{latin9}
\begin{lstlisting}
scala> def s[D] = q[Int => (Int => D) => D, (Int => D) => D](q)(r)
s: [D]=> (Int => D) => D
\end{lstlisting}
\inputencoding{utf8}To verify that the function $s^{D}$ indeed equals $y^{:\text{Int}\Rightarrow D}\Rightarrow y(10)$,
we apply $s^{D}$ to some functions of type $\text{Int}\Rightarrow D$,
say, for $D=\text{Boolean}$ or $D=\text{Int}$:\inputencoding{latin9}
\begin{lstlisting}
scala> s(_ > 0) // Evaluate 10 > 0.
res6: Boolean = true

scala> s(_ + 20) // Evaluate 10 + 20.
res7: Int = 30
\end{lstlisting}
\inputencoding{utf8}

\subsection{Exercises\index{exercises}}

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-1}\ref{subsec:Exercise-hof-simple-1}}

For \inputencoding{latin9}\lstinline!id!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!const!\inputencoding{utf8} as defined
above, what are the types of \inputencoding{latin9}\lstinline!id(id)!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!id(id)(id)!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!id(id(id))!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!id(const)!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!const(const)!\inputencoding{utf8}?
Simplify these expressions.

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-3}\ref{subsec:Exercise-hof-simple-3}}

For the function \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
from Example~\ref{subsec:Example-hof-derive-types-2}, infer the
most general type for \inputencoding{latin9}\lstinline!twice(twice(twice)))!\inputencoding{utf8}.
What does that function do? Test your answer.

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-4}\ref{subsec:Exercise-hof-simple-4}}

Define a function \inputencoding{latin9}\lstinline!thrice!\inputencoding{utf8}
similarly to \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
except it should apply a given function $3$ times. What does the
function \inputencoding{latin9}\lstinline!thrice(thrice(thrice)))!\inputencoding{utf8}
do?

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-5}\ref{subsec:Exercise-hof-simple-5}}

Define a function \inputencoding{latin9}\lstinline!ence!\inputencoding{utf8}
similarly to \inputencoding{latin9}\lstinline!twice!\inputencoding{utf8}
except it should apply a given function $n$ times, where $n$ is
an additional curried argument.

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-6}\ref{subsec:Exercise-hof-simple-6}}

Define a fully parametric function \inputencoding{latin9}\lstinline!flip(f)!\inputencoding{utf8}
that swaps arguments for any given function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
of two arguments. To test: 

\inputencoding{latin9}\begin{lstlisting}
def f(x: Int, y: Int) = x - y // Check that f(10, 2) == 8.
val g = flip(f)  // Now check that g(2, 10) == 8.
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-7}\ref{subsec:Exercise-hof-simple-7}}

Revise the function from Exercise~\ref{subsec:ch1-transf-Exercise-4},
implementing it a curried function and replacing the hard-coded number
$100$ by a \emph{curried} first argument. The type signature should
become \texttt{}\inputencoding{latin9}\lstinline!Int => List[List[Int]] => List[List[Int]]!\inputencoding{utf8}\texttt{.}

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-8}\ref{subsec:Exercise-hof-simple-8}}

Implement the function \inputencoding{latin9}\lstinline!converge!\inputencoding{utf8}
from Example~\ref{subsec:Example-hof-simple-1} as a curried function,
with an additional argument to set the maximum number of iterations,
and returning \inputencoding{latin9}\lstinline!Option[Double]!\inputencoding{utf8}
as the final result type. The new version of \inputencoding{latin9}\lstinline!converge!\inputencoding{utf8}
should return \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}
if the convergence condition is not satisfied after the given maximum
number of iterations. The type signature and an example test:\inputencoding{latin9}
\begin{lstlisting}
@tailrec def convergeN[X](p:X => Boolean)(x:X)(m:Int)(f:X => X): Option[X] = ???

scala> convergeN[Int](_ < 0)(0)(10)(_ + 1)
res0: Option[Int] = None

scala> convergeN[Double]{ x => math.abs(x * x - 25) < 1e-8 }(1.0)(10) { x => 0.5 * (x + 25 / x ) }
res1: Option[Double] = Some(5.000000000053722)
\end{lstlisting}
\inputencoding{utf8}\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
def convergeN[X](p: X => Boolean)(x:X)(m:Int)(f: X => X): Option[X] =  {
              if (m <= 0) None
              else if (p(x)) Some(x) else converge(p)(f(x))(m-1)(f)             } // Defining as def convergeN[X]: (X => Boolean) => X => Int => (X => X) => Option[X] = ??? will break tail recursion!
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{subsec:Exercise-hof-simple-8-1}\ref{subsec:Exercise-hof-simple-8-1}}

Write a function \inputencoding{latin9}\lstinline!curry2!\inputencoding{utf8}
converting an uncurried function of type \texttt{}\inputencoding{latin9}\lstinline!(Int, Int) => Int!\inputencoding{utf8}
into an equivalent curried function of type \texttt{}\inputencoding{latin9}\lstinline!Int => Int => Int!\inputencoding{utf8}.

\subsubsection{Exercise \label{subsec:Exercise-hof-curried-1}\ref{subsec:Exercise-hof-curried-1}}

Apply the function $\left(x\Rightarrow\_\Rightarrow x\right)$ to
the value $\left(z\Rightarrow z(q)\right)$ where $q$ is a given
value of type $Q$. Infer types in these expressions.

\subsubsection{Exercise \label{subsec:Exercise-hof-curried-3}\ref{subsec:Exercise-hof-curried-3}}

Infer types in the following expressions:
\begin{align*}
\text{(a):}\quad & p\Rightarrow q\Rightarrow p(t\Rightarrow t(q))\quad,\\
\text{(b):}\quad & p\Rightarrow q\Rightarrow q(x\Rightarrow x(p(q)))\quad.
\end{align*}


\subsubsection{Exercise \label{subsec:Exercise-hof-curried-4}\ref{subsec:Exercise-hof-curried-4}}

Show that the following expressions cannot be well-typed:
\begin{align*}
\text{(a):}\quad & p\Rightarrow p(q\Rightarrow q(p))\quad,\\
\text{(b):}\quad & p\Rightarrow q\Rightarrow q(x\Rightarrow p(q(x)))\quad.
\end{align*}


\subsubsection{Exercise \label{subsec:Exercise-hof-curried-2}\ref{subsec:Exercise-hof-curried-2}}

Infer types and simplify the following code expressions:
\begin{align*}
\text{(a):}\quad & q\Rightarrow\left(x\Rightarrow y\Rightarrow z\Rightarrow x(z)(y(z))\right)\left(a\Rightarrow a\right)\left(b\Rightarrow b(q)\right)\quad,\\
\text{(b):}\quad & \left(f\Rightarrow g\Rightarrow h\Rightarrow f(g(h))\right)(x\Rightarrow x)\quad,\\
\text{(c):}\quad & \left(x\Rightarrow y\Rightarrow x(y)\right)\left(x\Rightarrow y\Rightarrow x\right)\quad,\\
\text{(d):}\quad & \left(x\Rightarrow y\Rightarrow x(y)\right)\left(x\Rightarrow y\Rightarrow y\right)\quad,\\
\text{(e):}\quad & x\Rightarrow\left(f\Rightarrow y\Rightarrow f(y)(x)\right)\left(z\Rightarrow\_\Rightarrow z\right)\quad,\\
\text{(f):}\quad & z\Rightarrow\left(x\Rightarrow y\Rightarrow x\right)\left(x\Rightarrow x(z)\right)(y\Rightarrow y(z))\quad.
\end{align*}


\section{Discussion}

\subsection{Higher-order functions}

The \textbf{order\index{order of a function}} of a function is the
number of function arrows (\inputencoding{latin9}\lstinline!=>!\inputencoding{utf8})
contained in the type signature of that function. If a function's
type signature contains more than one arrow, the function is called
a \textbf{\index{higher-order function}higher-order} function. A
higher-order function takes a function as argument and/or returns
a function as its result value.

The methods \inputencoding{latin9}\lstinline!andThen!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!compose!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!curried!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!uncurried!\inputencoding{utf8}
are examples of higher-order functions that take other functions as
arguments \emph{and} return a new function.

The following example illustrates the concept of a function's order.
Consider \inputencoding{latin9}
\begin{lstlisting}
def f1(x: Int): Int = x + 10
\end{lstlisting}
\inputencoding{utf8}The function \texttt{}\inputencoding{latin9}\lstinline!f1!\inputencoding{utf8}
has type signature \texttt{}\inputencoding{latin9}\lstinline!Int => Int!\inputencoding{utf8}
and order $1$, so it is \emph{not} a higher-order function.\inputencoding{latin9}
\begin{lstlisting}
def f2(x: Int): Int => Int = z => z + x
\end{lstlisting}
\inputencoding{utf8}The function \texttt{}\inputencoding{latin9}\lstinline!f2!\inputencoding{utf8}
has type signature \texttt{}\inputencoding{latin9}\lstinline!Int => Int => Int!\inputencoding{utf8}
and is a higher-order function of order $2$. \inputencoding{latin9}
\begin{lstlisting}
def f3(g: Int => Int): Int = g(123)
\end{lstlisting}
\inputencoding{utf8}The function \texttt{}\inputencoding{latin9}\lstinline!f3!\inputencoding{utf8}
has type signature \texttt{}\inputencoding{latin9}\lstinline!(Int => Int) => Int!\inputencoding{utf8}
and is a higher-order function of order $2$.

Although \texttt{}\inputencoding{latin9}\lstinline!f2!\inputencoding{utf8}
is a higher-order function, its ``higher-orderness'' comes from
the fact that the return value is of a function type. An equivalent
computation can be performed by an uncurried function that is not
higher-order:\inputencoding{latin9}
\begin{lstlisting}
scala> def f2u(x: Int, z: Int): Int = z + x
\end{lstlisting}
\inputencoding{utf8}
Unlike \inputencoding{latin9}\lstinline!f2!\inputencoding{utf8},
the function \inputencoding{latin9}\lstinline!f3!\inputencoding{utf8}
\emph{cannot} be converted to a non-higher-order function because
\inputencoding{latin9}\lstinline!f3!\inputencoding{utf8} has an argument
of a function type. Converting to an uncurried form cannot eliminate
an argument of a function type.

\subsection{Name shadowing and the scope of bound variables}

Bound variables are introduced in nameless functions whenever an argument
is defined. For example, in the curried nameless function $x\Rightarrow y\Rightarrow f(x,y)$,
the bound variables are the curried arguments $x$ and $y$. The variable
$y$ is only defined within the scope $\left(y\Rightarrow f(x,y)\right)$
of the inner function; the variable $x$ is defined within the entire
scope of $x\Rightarrow y\Rightarrow f(x,y)$.

Another way of introducing bound variables in Scala is to write a
\inputencoding{latin9}\lstinline!val!\inputencoding{utf8} or a \inputencoding{latin9}\lstinline!def!\inputencoding{utf8}
within curly braces:\inputencoding{latin9}
\begin{lstlisting}
val x = {
  val y = 10 // Bound variable.
  y + y * y
} // Same as `val x = 10 + 10 * 10`.
\end{lstlisting}
\inputencoding{utf8}
A bound variable is invisible outside the scope that defines it. This
is why bound variables may be renamed at will: no outside code could
possibly use them and depend on their values. However, outside code
may define a variable that (by chance) has the same name as a bound
variable inside the scope.

Consider this example from calculus: In the integral
\[
f(x)=\int_{0}^{x}\frac{dx}{1+x}\quad,
\]
a bound variable named $x$ is defined in \emph{two} local scopes:
in the scope of $f$ and in the scope of the nameless function $x\Rightarrow\frac{1}{1+x}$.
The convention in mathematics is to treat these two $x$'s as two
\emph{completely} \emph{different} variables that just happen to have
the same name. In sub-expressions where both of these bound variables
are visible, priority is given to the bound variable defined in the
closest inner scope. The outer definition of $x$ is \textbf{shadowed}\index{name shadowing},
i.e.\ hidden, by the definition of the inner $x$. For this reason,
mathematicians expect that evaluating $f(10)$ will give
\[
f(10)=\int_{0}^{10}\frac{dx}{1+x}\quad,
\]
rather than $\int_{0}^{10}\frac{dx}{1+10}$, because the outer definition
$x=10$ is shadowed within the expression $\frac{1}{1+x}$ by the
closer definition of $x$ in the local scope of $x\Rightarrow\frac{1}{1+x}$.

Since this is the standard mathematical convention, the same convention
is adopted in functional programming. A variable defined in a function
scope (i.e.\ a bound variable) is invisible outside that scope but
will shadow any outside definitions of a variable with the same name.

Name shadowing\index{name shadowing} is not advisable, because it
usually decreases the clarity of code and so invites errors. Consider
the function
\[
x\Rightarrow x\Rightarrow x\quad.
\]
Let us decipher this confusing syntax. The symbol $\Rightarrow$ groups
to the right, so $x\Rightarrow x\Rightarrow x$ is the same as $x\Rightarrow\left(x\Rightarrow x\right)$.
It is a function that takes $x$ and returns $x\Rightarrow x$. Since
the nameless function $\left(x\Rightarrow x\right)$ may be renamed
to $\left(y\Rightarrow y\right)$ without changing its value, we can
rewrite the code to
\[
x\Rightarrow\left(y\Rightarrow y\right)\quad.
\]
Having removed name shadowing, we can more easily understand this
code and reason about it. For instance, it becomes clear that this
function ignores its argument $x$ and always returns the same value
(the identity function $y\Rightarrow y$).

\subsection{Operator syntax for function applications}

In mathematics, function applications are sometimes written without
parentheses, for instance $\cos x$ or $\sin z$. There are also cases
where formulas such as $2\sin x\cos x$ imply parentheses as $2\cdot\sin\left(x\right)\cdot\cos\left(x\right)$.
Functions such as $\cos x$ are viewed as ``operators'' that are
applied to their arguments without parentheses, similar to the operators
of summation, $\sum_{k}k$, and differentiation, $\partial_{x}f$.

Many programming languages (such as ML, OCaml, F\#, Haskell, Elm,
PureScript) have adopted this ``operator syntax\index{operator syntax}'',
making parentheses optional for function arguments. The result is
a syntax where \inputencoding{latin9}\lstinline!f x!\inputencoding{utf8}
means the same as \inputencoding{latin9}\lstinline!f(x)!\inputencoding{utf8}.
Parentheses are still used where necessary to avoid ambiguity or for
readability.\footnote{The operator syntax has a long history in programming. It is used
in Unix shell commands, for example \inputencoding{latin9}\lstinline!cp file1 file2!\inputencoding{utf8}.
In LISP and Scheme, function applications are enclosed in parentheses
but the arguments are separated by spaces, for example \inputencoding{latin9}\lstinline!(f 10)!\inputencoding{utf8}.}

The conventions for nameless functions in the operator syntax become:
\begin{itemize}
\item Function expressions group everything to the right,\\
so $x\Rightarrow y\Rightarrow z\Rightarrow e$ means $x\Rightarrow\left(y\Rightarrow\left(z\Rightarrow e\right)\right)$.
\item Function applications group everything to the left,\\
so $f\,x\,y\,z$ means $\big((f\,x)\:y\big)\:z$.
\item Function applications group stronger than infix operations,\\
so $x+f\,y$ means $x+(f\,y)$, just as in mathematics $x+\cos y$
groups $\cos y$ stronger than the infix ``$+$'' operation.
\end{itemize}
Thus, $x\Rightarrow y\Rightarrow a\,b\,c+p\,q$ means $x\Rightarrow\left(y\Rightarrow\left(\left(a\,b\right)\,c\right)+(p\,q)\right)$.
When this notation becomes hard to read correctly, one needs to add
parentheses, e.g.\ to write $f(x\Rightarrow g\,h)$ instead of $f\,x\Rightarrow g\,h$.

This book will avoid using the ``operator syntax'' when reasoning
about code. Scala does not support the parentheses-free operator syntax;
parentheses need to be put around every curried argument.

From the point of view of programming language theory, curried functions
are ``simpler'' because they always have a \emph{single} argument
(and may return a function that will consume further arguments). From
the point of view of programming practice, curried functions are often
harder to read and to write.

In the operator syntax used e.g.\ in OCaml and Haskell, a curried
function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
is applied to curried arguments as, e.g., \inputencoding{latin9}\lstinline!f 20 4!\inputencoding{utf8}.
This departs further from the mathematical tradition and requires
some getting used to. If the two arguments are more complicated than
just $20$ and $4$, the resulting expression may become harder to
read, compared with the syntax where commas are used to separate the
arguments. (Consider e.g.~the expression \inputencoding{latin9}\lstinline!f (g 10) (h 20) + 30!\inputencoding{utf8}.)
To improve readability of code, programmers may prefer to first define
short names for complicated expressions and then use these names as
curried arguments.

In Scala, the choice of whether to use curried or uncurried function
signatures is largely a matter of syntactic convenience. Most Scala
code tends to be written with uncurried functions, while curried functions
are used when they produce more easily readable code.

One of the syntactic features for curried functions in Scala is the
ability to specify a curried argument using the curly brace syntax.
Compare the two definitions of the function \inputencoding{latin9}\lstinline!summation!\inputencoding{utf8}
described in Section~\ref{subsec:Nameless-functions-in-mathematical-notation}:\inputencoding{latin9}
\begin{lstlisting}
def summation1(a: Int, b: Int, g: Int => Int): Int =
  (a to b).map(g).sum

def summation2(a: Int, b: Int)(g: Int => Int): Int =
  (a to b).map(g).sum
\end{lstlisting}
\inputencoding{utf8}These functions are used in the code with a slightly different syntax:\inputencoding{latin9}
\begin{lstlisting}
scala> summation1(1, 10, { x => x*x*x + 2*x })
res0: Int = 3135

scala> summation2(1, 10){ x => x*x*x + 2*x }
res1: Int = 3135
\end{lstlisting}
\inputencoding{utf8}
The code that calls \inputencoding{latin9}\lstinline!summation2!\inputencoding{utf8}
is easier to read because the curried argument is syntactically separated
from the rest of the code by curly braces. This is especially useful
when the curried argument is itself a function with a complicated
body, since Scala's curly braces syntax allows function bodies to
contain their own local definitions (\inputencoding{latin9}\lstinline!val!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!def!\inputencoding{utf8}).

Another feature of Scala is the ``dotless'' method syntax: for example,
\inputencoding{latin9}\lstinline!xs map f!\inputencoding{utf8} is
equivalent to \inputencoding{latin9}\lstinline!xs.map(f)!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!f andThen g!\inputencoding{utf8}
is equivalent to \inputencoding{latin9}\lstinline!f.andThen(g)!\inputencoding{utf8}.
The ``dotless'' syntax is available only for infix methods, such
as \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}, defined
on specific types such as \inputencoding{latin9}\lstinline!Seq!\inputencoding{utf8}.
In Scala 3, the ``dotless'' syntax will only work for methods having
a special \inputencoding{latin9}\lstinline!@infix!\inputencoding{utf8}
annotation. Do not confuse Scala's ``dotless'' method syntax with
the operator syntax used in Haskell and some other languages.

\subsection{Deriving a function's code from its type signature\label{subsec:Deriving-a-function's}}

We have seen how the procedure of type inference\index{type inference}
derives the type of a fully parametric function from the function's
code. It is remarkable that one can sometimes derive the function's
\emph{code} from the function's type signature. We will now look at
some examples of this.

Consider a fully parametric function that performs a partial application\index{partial application}
for arbitrary other functions. A possible type signature is\inputencoding{latin9}
\begin{lstlisting}
def pa[A, B, C](x: A)(f: (A, B) => C): B => C = ???
\end{lstlisting}
\inputencoding{utf8}The function \inputencoding{latin9}\lstinline!pa!\inputencoding{utf8}
will substitute a fixed argument value \inputencoding{latin9}\lstinline!x:A!\inputencoding{utf8}
into another given function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}. 

How can we implement \inputencoding{latin9}\lstinline!pa!\inputencoding{utf8}?
Since \inputencoding{latin9}\lstinline!pa(x)(f)!\inputencoding{utf8}
must return a function of type \inputencoding{latin9}\lstinline!B => C!\inputencoding{utf8},
we have no choice other than to begin writing the function body as\inputencoding{latin9}
\begin{lstlisting}
def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { y: B =>
  ??? // Need to compute a value of type C in this scope.
}
\end{lstlisting}
\inputencoding{utf8}In the inner scope, we need to compute a value of type \inputencoding{latin9}\lstinline!C!\inputencoding{utf8},
and we have values \inputencoding{latin9}\lstinline!x:A!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!y:B!\inputencoding{utf8}, and \inputencoding{latin9}\lstinline!f:(A, B)=>C!\inputencoding{utf8}.
How can we compute a value of type \inputencoding{latin9}\lstinline!C!\inputencoding{utf8}?
If we knew that \inputencoding{latin9}\lstinline!C = Int!\inputencoding{utf8}
when \inputencoding{latin9}\lstinline!pa(x)(f)!\inputencoding{utf8}
is applied, we could have simply selected a fixed integer value, say,
\inputencoding{latin9}\lstinline!1!\inputencoding{utf8}, as the value
of type \inputencoding{latin9}\lstinline!C!\inputencoding{utf8}.
If we knew that \inputencoding{latin9}\lstinline!C = String!\inputencoding{utf8},
we could have selected a fixed string, say, \inputencoding{latin9}\lstinline!"hello"!\inputencoding{utf8},
as the value of type \inputencoding{latin9}\lstinline!C!\inputencoding{utf8}.
But a fully parametric function cannot use any knowledge of the actual
types used in the code when that function is being applied to arguments.

So, a fully parametric function cannot produce a value of an arbitrary
type \inputencoding{latin9}\lstinline!C!\inputencoding{utf8} from
scratch. The only way of producing a value of type \inputencoding{latin9}\lstinline!C!\inputencoding{utf8}
is by applying the function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
to arguments of types \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!B!\inputencoding{utf8}. Since
the types \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!B!\inputencoding{utf8} are arbitrary,
we cannot obtain any values of these types other than \inputencoding{latin9}\lstinline!x:A!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!y:B!\inputencoding{utf8}. So,
the only way of obtaining a value of type \inputencoding{latin9}\lstinline!C!\inputencoding{utf8}
is to compute \inputencoding{latin9}\lstinline!f(x, y)!\inputencoding{utf8}.
Thus, the body of \inputencoding{latin9}\lstinline!pa!\inputencoding{utf8}
must be\inputencoding{latin9}
\begin{lstlisting}
def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { y => f(x, y) }
\end{lstlisting}
\inputencoding{utf8}In this way, we have \emph{unambiguously} derived the body of this
function from its type signature, by assuming that the function must
be fully parametric.

Another example is the operation of forward composition $f\bef g$,
viewed as a fully parametric function with type signature\inputencoding{latin9}
\begin{lstlisting}
def before[A, B, C](f: A => B, g: B => C): A => C = ???
\end{lstlisting}
\inputencoding{utf8}To implement \inputencoding{latin9}\lstinline!before!\inputencoding{utf8},
we need to create a nameless function of type \inputencoding{latin9}\lstinline!A => C!\inputencoding{utf8},\inputencoding{latin9}
\begin{lstlisting}
def before[A, B, C](f: A => B, g: B => C): A => C = { x: A =>
  ??? // Need to compute a value of type C in this scope.
}
\end{lstlisting}
\inputencoding{utf8}In the inner scope, we need to compute a value of type $C$, and we
have the values $x^{:A}$, $f^{:A\Rightarrow B}$, and $g^{:B\Rightarrow C}$.
Since the type $C$ is arbitrary, the only way of obtaining a value
of type $C$ is to apply $g$ to an argument of type $B$. The only
way of obtaining a value of type $B$ is to apply $f$ to an argument
of type $A$. Finally, we have only one value of type $A$, namely
$x^{:A}$. So, the only way of obtaining the required result is to
compute $g(f(x))$. We have again unambiguously derived the body of
the function before from its type signature:\inputencoding{latin9}
\begin{lstlisting}
def before[A, B, C](f: A => B, g: B => C): A => C = { x => g(f(x)) }
\end{lstlisting}
\inputencoding{utf8}
In Chapter~\ref{chap:3-3-The-formal-logic-curry-howard} and in Appendix~\ref{app:The-Curry-Howard-correspondence},
we will see how a function's code can be derived from type signatures
for a wide range of fully parametric functions.
