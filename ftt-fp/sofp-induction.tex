
\chapter{Mathematical formulas as code. II. Mathematical induction\label{chap:2-Mathematical-induction}}

We will now study more flexible ways of working with data collections
in the functional programming paradigm. The Scala standard library
has methods for performing general iterative computations, that is,
computations defined by induction. Translating mathematical induction
into code is the focus of this chapter.

But first we need to become fluent in using tuple types with Scala
collections.

\section{Tuple types}

\subsection{Examples of using tuples}

Many standard library methods in Scala require working with \textbf{\index{tuples}tuple}
types. A simple example of a tuple is a \emph{pair} of values, – such
as, a pair of an integer and a string. The Scala syntax for this type
of pair is\inputencoding{latin9}
\begin{lstlisting}
val a: (Int, String) = (123, "xyz")
\end{lstlisting}
\inputencoding{utf8}The type expression \inputencoding{latin9}\lstinline!(Int, String)!\inputencoding{utf8}
denotes this tuple type.

A \textbf{triple} is defined in Scala like this:\inputencoding{latin9}
\begin{lstlisting}
val b: (Boolean, Int, Int) = (true, 3, 4)
\end{lstlisting}
\inputencoding{utf8}Pairs and triples are examples of tuples. A \textbf{tuple} can contain
any number of values, which I call \textbf{parts\index{tuples!parts}}
of a tuple. The parts of a tuple can have different types, but the
type of each part is fixed once and for all. Also, the number of parts
in a tuple is fixed. It is a \textbf{type error}\index{type error}
to use incorrect types in a tuple, or an incorrect number of parts
of a tuple:\inputencoding{latin9}
\begin{lstlisting}
scala> val bad: (Int, String) = (1,2)
<console>:11: error: type mismatch;
 found   : Int(2)
 required: String
       val bad: (Int, String) = (1,2)
                                   ^
scala> val bad: (Int, String) = (1,"a",3)
<console>:11: error: type mismatch;
 found   : (Int, String, Int)
 required: (Int, String)
       val bad: (Int, String) = (1,"a",3)
                                ^
\end{lstlisting}
\inputencoding{utf8}Parts of a tuple can be accessed by number, starting from $1$. The
Scala syntax for \textbf{tuple accessor\index{tuple accessor}} methods
looks like \inputencoding{latin9}\lstinline!._1!\inputencoding{utf8},
for example:\inputencoding{latin9}
\begin{lstlisting}
scala> val a = (123, "xyz")
a: (Int, String) = (123,xyz)

scala> a._1
res0: Int = 123

scala> a._2
res1: String = xyz 
\end{lstlisting}
\inputencoding{utf8}It is a type error to access a tuple part that does not exist:\inputencoding{latin9}
\begin{lstlisting}
scala> a._0
<console>:13: error: value _0 is not a member of (Int, String)
       a._0
         ^

scala> a._5
<console>:13: error: value _5 is not a member of (Int, String)
       a._5
         ^
\end{lstlisting}
\inputencoding{utf8}Type errors\index{type error} are detected at compile time, before
any computations begin.

Tuples can be \textbf{nested}\index{tuples!nested}: any part of a
tuple can be itself of a tuple type.\inputencoding{latin9}
\begin{lstlisting}
scala> val c: (Boolean, (String, Int), Boolean) = (true, ("abc", 3), false)
c: (Boolean, (String, Int), Boolean) = (true,(abc,3),false)

scala> c._1
res0: Boolean = true

scala> c._2
res1: (String, Int) = (abc,3)
\end{lstlisting}
\inputencoding{utf8}
To define functions whose arguments are tuples, we could use the tuple
accessors. An example of such a function is\inputencoding{latin9}
\begin{lstlisting}
def f(p: (Boolean, Int), q: Int): Boolean = p._1 && (p._2 > q) 
\end{lstlisting}
\inputencoding{utf8}The first argument, \inputencoding{latin9}\lstinline!p!\inputencoding{utf8},
of this function, has a tuple type. The function body uses accessor
methods (\inputencoding{latin9}\lstinline!._1!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!._2!\inputencoding{utf8}) to
compute the result value. Note that the second part of the tuple \inputencoding{latin9}\lstinline!p!\inputencoding{utf8}
is of type \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8},
so it is valid to compare it with an integer \inputencoding{latin9}\lstinline!q!\inputencoding{utf8}.
It would be a \index{type error}type error to compare the \emph{tuple}
\inputencoding{latin9}\lstinline!p!\inputencoding{utf8} with an \emph{integer}
using the expression \inputencoding{latin9}\lstinline!p > q!\inputencoding{utf8}.
It would be also a type error to apply the function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
to an argument \inputencoding{latin9}\lstinline!p!\inputencoding{utf8}
that has a wrong type, e.g.~the type \inputencoding{latin9}\lstinline!(Int, Int)!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!(Boolean, Int)!\inputencoding{utf8}.

\subsection{Pattern matching for tuples}

Instead of using accessor methods when working with tuples, it is
often convenient to use \textbf{pattern matching\index{pattern matching}}.
Pattern matching occurs in two situations in Scala:
\begin{itemize}
\item destructuring definition: \inputencoding{latin9}\lstinline[mathescape=true]!val $pattern$ = ...!\inputencoding{utf8}
\item \inputencoding{latin9}\lstinline!case!\inputencoding{utf8} expression:
\inputencoding{latin9}\lstinline[mathescape=true]!case $pattern$ => ...!\inputencoding{utf8}
\end{itemize}
An example of a \textbf{destructuring\index{destructuring} definition}
is\inputencoding{latin9}
\begin{lstlisting}
scala> val g = (1, 2, 3)
g: (Int, Int, Int) = (1,2,3)

scala> val (x, y, z) = g
x: Int = 1
y: Int = 2
z: Int = 3
\end{lstlisting}
\inputencoding{utf8}The value \inputencoding{latin9}\lstinline!g!\inputencoding{utf8}
is a tuple of three integers. After defining \inputencoding{latin9}\lstinline!g!\inputencoding{utf8},
we define the three variables \inputencoding{latin9}\lstinline!x!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!y!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!z!\inputencoding{utf8}
\emph{at once} in a single \inputencoding{latin9}\lstinline!val!\inputencoding{utf8}
definition. We imagine that this definition ``destructures'' the
data structure contained in \inputencoding{latin9}\lstinline!g!\inputencoding{utf8}
and decomposes it into three parts, then assigns the names \inputencoding{latin9}\lstinline!x!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!y!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!z!\inputencoding{utf8}
to these parts. The types of the new values are also assigned automatically.

The left-hand side of the destructuring definition contains the tuple
pattern \inputencoding{latin9}\lstinline!(x, y, z)!\inputencoding{utf8}
that looks like a tuple, except that its parts are names \inputencoding{latin9}\lstinline!x!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!y!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!z!\inputencoding{utf8}
that are so far \emph{undefined}. These names are called \textbf{\index{pattern variables}pattern
variables}. The destructuring definition checks whether the structure
of the value of \inputencoding{latin9}\lstinline!g!\inputencoding{utf8}
``matches'' the three \index{pattern variables}pattern variables.
(If \inputencoding{latin9}\lstinline!g!\inputencoding{utf8} does
not contain a tuple with exactly three parts, the definition will
fail.) This computation is called \textbf{pattern matching}\index{pattern matching}.

Pattern matching is often used when working with tuples:\inputencoding{latin9}
\begin{lstlisting}
scala> (1, 2, 3) match { case (a, b, c) => a + b + c }
res0: Int = 6
\end{lstlisting}
\inputencoding{utf8}The \textbf{case expression\index{case expression}} (\inputencoding{latin9}\lstinline!case (a, b, c) => ...!\inputencoding{utf8})
performs pattern matching on the tuple argument \inputencoding{latin9}\lstinline!p!\inputencoding{utf8}.
The pattern matching will ``destructure'' (i.e.~decompose) the
tuple and try to match it to the given pattern \inputencoding{latin9}\lstinline!(a, b, c)!\inputencoding{utf8}.
In this pattern, \inputencoding{latin9}\lstinline!a!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!b!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!c!\inputencoding{utf8}
are as yet undefined new variables, – that is, they are \index{pattern variables}pattern
variables. If the pattern matching succeeds, the pattern variables
\inputencoding{latin9}\lstinline!a!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!b!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!c!\inputencoding{utf8} are assigned
their values, and the function body can proceed to perform its computation.
In this example, the pattern variables \inputencoding{latin9}\lstinline!a!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!b!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!c!\inputencoding{utf8}
will be assigned values $1$, $2$, and $3$, so the function returns
$6$ as its result value.

Pattern matching is especially convenient when working with nested
tuples. Here is an example of such code:\inputencoding{latin9}
\begin{lstlisting}
def t1(p: (Int, (String, Int))): String = p match {
  case (x, (str, y)) => str + (x + y).toString
}

scala> t((10, ("result is ", 2)))
res0: String = result is 12
\end{lstlisting}
\inputencoding{utf8}The type structure of the argument is visually repeated in the pattern.
It is easy to see that \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!y!\inputencoding{utf8} become
integers and \inputencoding{latin9}\lstinline!str!\inputencoding{utf8}
becomes a string after pattern matching. If we rewrite the same code
using the tuple accessor methods instead of pattern matching, the
code will look like this:\inputencoding{latin9}
\begin{lstlisting}
def t2(p: (Int, (String, Int))): String = p._2._1 + (p._1 + p._2._2).toString
\end{lstlisting}
\inputencoding{utf8}This code is shorter but harder to read: For example, it is not immediately
clear what \inputencoding{latin9}\lstinline!p._2._1!\inputencoding{utf8}
refers to. It is also harder to change this code: Suppose we want
to change the type of the tuple \inputencoding{latin9}\lstinline!p!\inputencoding{utf8}
to \inputencoding{latin9}\lstinline!((Int, String), Int)!\inputencoding{utf8}.
Then the new code is\inputencoding{latin9}
\begin{lstlisting}
def t3(p: ((Int, String), Int)): String = p._1._2 + (p._1._1 + p._2).toString
\end{lstlisting}
\inputencoding{utf8}It takes time to verify, by going through every accessor method, that
the function \inputencoding{latin9}\lstinline!t3!\inputencoding{utf8}
computes the same expression as \inputencoding{latin9}\lstinline!t2!\inputencoding{utf8}.
In contrast, the code is changed easily when using the pattern matching
expression instead of the accessor methods:\inputencoding{latin9}
\begin{lstlisting}
def t4(p: ((Int, String), Int)): String = p match {
  case ((x, str), y) => str + (x + y).toString
}
\end{lstlisting}
\inputencoding{utf8}The only change in the function body, compared to \inputencoding{latin9}\lstinline!t1!\inputencoding{utf8},
is in the pattern matcher, so it is visually clear that \inputencoding{latin9}\lstinline!t4!\inputencoding{utf8}
computes the same expression as \inputencoding{latin9}\lstinline!t1!\inputencoding{utf8}.

Sometimes we do not need some of the tuple parts in a pattern match.
The following syntax is used to make this intention clear:\inputencoding{latin9}
\begin{lstlisting}
scala> val (x, _, _, z) = ("abc", 123, false, true)
x: String = abc
z: Boolean = true
\end{lstlisting}
\inputencoding{utf8}The underscore symbol \inputencoding{latin9}\lstinline!_!\inputencoding{utf8}
denotes the parts of the pattern that we want to ignore. The underscore
will always match any value regardless of type.

A feature of Scala is a short syntax for functions such as \inputencoding{latin9}\lstinline!{case (x, y) => y}!\inputencoding{utf8}
that extract elements from tuples. The shorter syntax is \inputencoding{latin9}\lstinline!(t => t._2)!\inputencoding{utf8}
or even shorter, \inputencoding{latin9}\lstinline!(_._2)!\inputencoding{utf8},
as illustrated here:\inputencoding{latin9}
\begin{lstlisting}
scala> val p: ((Int, Int )) => Int = { case (x, y) => y }
p: ((Int, Int)) => Int = <function1>

scala> p((1, 2))
res0: Int = 2

scala> val q: ((Int, Int )) => Int = (_._2)
q: ((Int, Int)) => Int = <function1>

scala> q((1, 2))
res1: Int = 2

scala> Seq( (1,10), (2,20), (3,30) ).map(_._2)
res2: Seq[Int] = List(10, 20, 30)
\end{lstlisting}
\inputencoding{utf8}

\subsection{Using tuples with collections}

Tuples can be combined with any other types without restrictions.
For instance, we can define a tuple of functions,\inputencoding{latin9}
\begin{lstlisting}
val q: (Int => Int, Int => Int) = (x => x + 1, x => x - 1)
\end{lstlisting}
\inputencoding{utf8}We can create a list of tuples,\inputencoding{latin9}
\begin{lstlisting}
val r: List[(String, Int)] = List(("apples", 3), ("oranges", 2), ("pears", 0))
\end{lstlisting}
\inputencoding{utf8}We could define a tuple of lists of tuples of functions, or any other
combination.

Here is an example of using the standard method \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
to transform a list of tuples. The argument of \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
must be a function taking a tuple as its argument. It is convenient
to use pattern matching for writing such functions:\inputencoding{latin9}
\begin{lstlisting}
scala> val basket: List[(String, Int)] = List(("apples", 3), ("pears", 2), ("lemons", 0))
basket: List[(String, Int)] = List((apples,3), (pears,2), (lemons,0))

scala> basket.map { case (fruit, count) => count * 2 }
res0: List[Int] = List(6, 4, 0)

scala> basket.map { case (fruit, count) => count * 2 }.sum
res1: Int = 10
\end{lstlisting}
\inputencoding{utf8}In this way, we can use the standard methods such as \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.max!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8} to manipulate
sequences of tuples. The names ``\inputencoding{latin9}\lstinline!fruit!\inputencoding{utf8}'',
``\inputencoding{latin9}\lstinline!count!\inputencoding{utf8}''
are chosen to help us remember the meaning of the parts of tuples.

We can easily transform a list of tuples into a list of values of
a different type:\inputencoding{latin9}
\begin{lstlisting}
scala> basket.map { case (fruit, count) =>
  val isAcidic = fruit == "lemons"
  (fruit, isAcidic)
}
res2: List[(String, Boolean)] = List((apples,false), (pears,false), (lemons,true)) 
\end{lstlisting}
\inputencoding{utf8}In the Scala syntax, a nameless function written with braces \inputencoding{latin9}\lstinline!{ ... }!\inputencoding{utf8}
can define local values in its body. The return value of the function
is the last expression written in the function body. In this example,
the return value of the nameless function is the tuple \inputencoding{latin9}\lstinline!(fruit, isAcidic)!\inputencoding{utf8}.

\subsection{Treating dictionaries (Scala's \texttt{Map}s) as collections}

In the Scala standard library, tuples are frequently used as types
of intermediate values. For instance, tuples are used when iterating
over dictionaries. The Scala type \inputencoding{latin9}\lstinline!Map[K,V]!\inputencoding{utf8}
represents a dictionary with keys of type \inputencoding{latin9}\lstinline!K!\inputencoding{utf8}
and values of type \inputencoding{latin9}\lstinline!V!\inputencoding{utf8}.
Here \inputencoding{latin9}\lstinline!K!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!V!\inputencoding{utf8} are \textbf{type
parameters\index{type parameter}}. Type parameters represent unknown
types that will be chosen later, when working with values having specific
types.

In order to create a dictionary with given keys and values, we can
write\inputencoding{latin9}
\begin{lstlisting}
Map(("apples", 3), ("oranges", 2), ("pears", 0))
\end{lstlisting}
\inputencoding{utf8}This is equivalent to first creating a sequence of key/value \emph{pairs}
and then converting that sequence into a dictionary.

Pairs are used often, so the Scala library defines a special infix
syntax for pairs via the arrow symbol \inputencoding{latin9}\lstinline!->!\inputencoding{utf8}.
The expression \inputencoding{latin9}\lstinline!x -> y!\inputencoding{utf8}
is equivalent to the pair \inputencoding{latin9}\lstinline!(x, y)!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> "apples" -> 3
res0: (String, Int) = (apples,3)
\end{lstlisting}
\inputencoding{utf8}With this syntax, it is easier to read the code for creating a dictionary:\inputencoding{latin9}
\begin{lstlisting}
Map("apples" -> 3, "oranges" -> 2, "pears" -> 0)
\end{lstlisting}
\inputencoding{utf8}A list of pairs can be converted to a dictionary using the method
\inputencoding{latin9}\lstinline!.toMap!\inputencoding{utf8}. The
same method works for other collection types such as \inputencoding{latin9}\lstinline!Seq!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!Vector!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!Stream!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!Array!\inputencoding{utf8}. 

The method \inputencoding{latin9}\lstinline!.toSeq!\inputencoding{utf8}
converts a dictionary into a sequence of pairs:\inputencoding{latin9}
\begin{lstlisting}
scala> Map("apples" -> 3, "oranges" -> 2, "pears" -> 0).toSeq
res20: Seq[(String, Int)] = ArrayBuffer((apples,3), (oranges,2), (pears,0))
\end{lstlisting}
\inputencoding{utf8}The \inputencoding{latin9}\lstinline!ArrayBuffer!\inputencoding{utf8}
is one of the many list-like data structures in the Scala library.
All these data structures are gathered under the common ``sequence''
type called \inputencoding{latin9}\lstinline!Seq!\inputencoding{utf8}.
The methods defined in the Scala standard library sometimes return
different implementations of the \inputencoding{latin9}\lstinline!Seq!\inputencoding{utf8}
type for reasons of performance.

The standard library has several useful methods that use tuple types,
such as \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}
(with dictionaries), \inputencoding{latin9}\lstinline!.toMap!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8}, and \inputencoding{latin9}\lstinline!.zipWithIndex!\inputencoding{utf8}.
The methods \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.groupBy!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!.sliding!\inputencoding{utf8}
also work with most collection types, including dictionaries and sets.
It is important to become familiar with these methods, because it
will help writing code that uses sequences, sets, and dictionaries.
Let us now look at these methods one by one.

\paragraph*{The \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!.toMap!\inputencoding{utf8} methods}

Chapter~\ref{chap:1-Values,-types,-expressions,} showed how the
\inputencoding{latin9}\lstinline!.map!\inputencoding{utf8} method
works on sequences: the expression \inputencoding{latin9}\lstinline!xs.map(f)!\inputencoding{utf8}
applies a given function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
to each element of the sequence \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8},
gathering the results in a new sequence. In this sense, we can say
that the \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
method ``iterates over'' sequences. The \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
method works similarly on dictionaries, except that iterating over
a dictionary of type \inputencoding{latin9}\lstinline!Map[K, V]!\inputencoding{utf8}
when applying \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
looks like iterating over a sequence of \emph{pairs}, \inputencoding{latin9}\lstinline!Seq[(K,V)]!\inputencoding{utf8}.
If \inputencoding{latin9}\lstinline!d:Map[K,V]!\inputencoding{utf8}
is a dictionary, the argument \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
of \inputencoding{latin9}\lstinline!d.map(f)!\inputencoding{utf8}
must be a function operating on tuples of type \inputencoding{latin9}\lstinline!(K,V)!\inputencoding{utf8}.
Typically, such functions are written using \inputencoding{latin9}\lstinline!case!\inputencoding{utf8}
expressions:\inputencoding{latin9}
\begin{lstlisting}
val m1 = Map("apples" -> 3, "pears" -> 2, "lemons" -> 0)

scala> m1.map { case (fruit, count) => count * 2 }
res0: Seq[Int] = ArrayBuffer(6, 4, 0)
\end{lstlisting}
\inputencoding{utf8}If we want to transform a dictionary into another dictionary, we can
first create a sequence of pairs and then convert it to a dictionary
with the \inputencoding{latin9}\lstinline!.toMap!\inputencoding{utf8}
method:\inputencoding{latin9}
\begin{lstlisting}
scala> m1.map { case (fruit, count) => (fruit, count * 2) }.toMap
res1: Map[String,Int] = Map(apples -> 6, pears -> 4, lemons -> 0)
\end{lstlisting}
\inputencoding{utf8}

\paragraph*{The \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}
method }

works on dictionaries by iterating on key/value pairs. The filtering
predicate must be a function of type \inputencoding{latin9}\lstinline!((K, V)) => Boolean!\inputencoding{utf8}.
For example:\inputencoding{latin9}
\begin{lstlisting}
scala> m1.filter { case (fruit, count) => count > 0 }.toMap
res2: Map[String,Int] = Map(apples -> 6, pears -> 4)
\end{lstlisting}
\inputencoding{utf8}

\paragraph*{The \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!.zipWithIndex!\inputencoding{utf8}
methods}

The \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8} method
takes \emph{two} sequences and produces a sequence of pairs, taking
one element from each sequence:\inputencoding{latin9}
\begin{lstlisting}
scala> val s = List(1, 2, 3)
s: List[Int] = List(1, 2, 3)

scala> val t = List(true, false, true)
t: List[Boolean] = List(true, false, true)

scala> s.zip(t)
res3: List[(Int, Boolean)] = List((1,true), (2,false), (3,true))

scala> s zip t
res4: List[(Int, Boolean)] = List((1,true), (2,false), (3,true)) 
\end{lstlisting}
\inputencoding{utf8}In the last line, the equivalent ``dotless'' infix syntax (\inputencoding{latin9}\lstinline!s zip t!\inputencoding{utf8})
is shown just to illustrate the flexibility of syntax conventions
in Scala.

The \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8} method
works equally well on dictionaries: in that case, dictionaries are
automatically converted to sequences of tuples before applying \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8}.

The \inputencoding{latin9}\lstinline!.zipWithIndex!\inputencoding{utf8}
method transforms a sequence into a sequence of pairs, where the second
part of the pair is the zero-based index:\inputencoding{latin9}
\begin{lstlisting}
scala> List("a", "b", "c").zipWithIndex
res5: List[(String, Int)] = List((a,0), (b,1), (c,2)) 
\end{lstlisting}
\inputencoding{utf8}

\paragraph*{The \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
method}

converts nested sequences to ``flattened'' ones:\inputencoding{latin9}
\begin{lstlisting}
scala> List(List(1, 2), List(2, 3), List(3, 4)).flatten
res6: List[Int] = List(1, 2, 2, 3, 3, 4)
\end{lstlisting}
\inputencoding{utf8}The ``flattening'' operation computes the concatenation of all inner
sequences. In Scala, sequences are concatenated using the operation
\inputencoding{latin9}\lstinline!++!\inputencoding{utf8}, e.g.:\inputencoding{latin9}
\begin{lstlisting}
scala> List(1, 2, 3) ++ List(4, 5, 6) ++ List(0)
res7: List[Int] = List(1, 2, 3, 4, 5, 6, 0)
\end{lstlisting}
\inputencoding{utf8}So the \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
method inserts the operation \inputencoding{latin9}\lstinline!++!\inputencoding{utf8}
between all the inner sequences.

Keep in mind that \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
removes \emph{only one} level of nesting, which is at the ``outside''
of the data structure. If applied to a \inputencoding{latin9}\lstinline!List[List[List[Int]]]!\inputencoding{utf8},
the \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
method returns a \inputencoding{latin9}\lstinline!List[List[Int]]!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> List(List(List(1), List(2)), List(List(2), List(3))).flatten
res8: List[List[Int]] = List(List(1), List(2), List(2), List(3))
\end{lstlisting}
\inputencoding{utf8}

\paragraph*{The \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
method}

is closely related to \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
and can be seen as a shortcut, equivalent to first applying \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
and then \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> List(1,2,3,4).map(n => (1 to n).toList)
res9: List[List[Int]] = List(List(1), List(1, 2), List(1, 2, 3), List(1, 2, 3, 4))

scala> List(1,2,3,4).map(n => (1 to n).toList).flatten
res10: List[Int] = List(1, 1, 2, 1, 2, 3, 1, 2, 3, 4)

scala> List(1,2,3,4).flatMap(n => (1 to n).toList)
res11: List[Int] = List(1, 1, 2, 1, 2, 3, 1, 2, 3, 4)
\end{lstlisting}
\inputencoding{utf8}The \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
operation transforms a sequence by mapping each element to a potentially
different number of new elements.

At first sight, it may be unclear why \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
is useful. (Should we perhaps combine \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
into a \inputencoding{latin9}\lstinline!.flatFilter!\inputencoding{utf8},
or combine \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
into a \inputencoding{latin9}\lstinline!.flatZip!\inputencoding{utf8}?)
However, we will see later in this book that the use of \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8},
which is related to ``monads''\index{monads}, is one of the most
versatile and powerful design patterns in functional programming.
In this chapter, several examples and exercises will illustrate the
use of \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
for working on sequences.

\paragraph*{The \inputencoding{latin9}\lstinline!.groupBy!\inputencoding{utf8}
method}

rearranges a sequence into a dictionary where some elements of the
original sequence are grouped together into subsequences. For example,
given a sequence of words, we can group all words that start with
the letter \inputencoding{latin9}\lstinline!"y"!\inputencoding{utf8}
into one subsequence, and all other words into another subsequence.
This is accomplished by the following code,\inputencoding{latin9}
\begin{lstlisting}
scala> Seq("wombat", "xanthan", "yoghurt", "zebra").
  groupBy(s => if (s startsWith "y") 1 else 2)
res12: Map[Int,Seq[String]] = Map(1 -> List(yoghurt), 2 -> List(wombat, xanthan, zebra))
\end{lstlisting}
\inputencoding{utf8}The argument of the \inputencoding{latin9}\lstinline!.groupBy!\inputencoding{utf8}
method is a \emph{function} that computes a ``key'' out of each
sequence element. The key can have an arbitrarily chosen type. (In
the current example, that type is \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}.)
The result of \inputencoding{latin9}\lstinline!.groupBy!\inputencoding{utf8}
is a dictionary that maps each key to the sub-sequence of values that
have that key. (In the current example, the type of the dictionary
is therefore \inputencoding{latin9}\lstinline!Map[Int, Seq[String]]!\inputencoding{utf8}.)
The order of elements in the sub-sequences remains the same as in
the original sequence.

As another example of using \inputencoding{latin9}\lstinline!.groupBy!\inputencoding{utf8},
the following code will group together all numbers that have the same
remainder after division by $3$:\inputencoding{latin9}
\begin{lstlisting}
scala> List(1,2,3,4,5).groupBy(k => k % 3)
res13: Map[Int,List[Int]] = Map(2 -> List(2, 5), 1 -> List(1, 4), 0 -> List(3))
\end{lstlisting}
\inputencoding{utf8}

\paragraph*{The \inputencoding{latin9}\lstinline!.sliding!\inputencoding{utf8}
method}

creates a sliding window of a given width and returns a sequence of
nested sequences:\inputencoding{latin9}
\begin{lstlisting}
scala> (1 to 10).sliding(4).toList
res14: List[IndexedSeq[Int]] = List(Vector(1, 2, 3, 4), Vector(2, 3, 4, 5), Vector(3, 4, 5, 6), Vector(4, 5, 6, 7), Vector(5, 6, 7, 8), Vector(6, 7, 8, 9), Vector(7, 8, 9, 10))
\end{lstlisting}
\inputencoding{utf8}Usually, this method is used together with an aggregation operation
on the inner sequences. For example, the following code computes a
sliding-window average with window width $50$ over an array of $100$
numbers:\inputencoding{latin9}
\begin{lstlisting}
scala> (1 to 100).map(x => math.cos(x)).sliding(50).
  map(_.sum / 50).take(5).toList
res15: List[Double] = List(-0.005153079196990285, -0.0011160413780774369, 0.003947079736951305, 0.005381273944717851, 0.0018679497047270743)
\end{lstlisting}
\inputencoding{utf8}

\paragraph*{The \inputencoding{latin9}\lstinline!.sortBy!\inputencoding{utf8}
method}

sorts a sequence according to a sorting key. The argument of \inputencoding{latin9}\lstinline!.sortBy!\inputencoding{utf8}
is a \emph{function} that computes the sorting key from a sequence
element. In this way, we can sort elements in an arbitrary way:\inputencoding{latin9}
\begin{lstlisting}
scala> Seq(1, 2, 3).sortBy(x => -x)
res0: Seq[Int] = List(3, 2, 1)

scala> Seq("z", "xxx", "yy").sortBy(word => word)
res1: Seq[String] = List("xxx", "yy", "z")

scala> Seq("z", "xxx", "yy").sortBy(word => word.length)
res2: Seq[String] = List("z", "yy", "xxx")
\end{lstlisting}
\inputencoding{utf8}Sorting by the elements themselves, as we have done here with \inputencoding{latin9}\lstinline!.sortBy(word => word)!\inputencoding{utf8},
is only possible if the element's type has a well-defined ordering.
For strings, this is the alphabetic ordering, and for integers, the
standard arithmetic ordering. For such types, a convenience method
\inputencoding{latin9}\lstinline!.sorted!\inputencoding{utf8} is
defined, and works equivalently to \inputencoding{latin9}\lstinline!.sortBy(x => x)!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> Seq("z", "xxx", "yy").sorted
res3: Seq[String] = List("xxx", "yy", "z")
\end{lstlisting}
\inputencoding{utf8}

\subsection{Solved examples: Tuples and collections\index{solved examples}}

\subsubsection{Example \label{enu:tuples-Example1-for}\ref{enu:tuples-Example1-for}}

For a given sequence $x_{i}$, compute the sequence of pairs $b_{i}=\left(\cos x_{i},\sin x_{i}\right)$.

Hint: use \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
assume \inputencoding{latin9}\lstinline!xs:Seq[Double]!\inputencoding{utf8}.

\subparagraph{Solution: }

We need to produce a sequence that has a pair of values corresponding
to each element of the original sequence. This transformation is exactly
what the \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
method does. So the code is\inputencoding{latin9}
\begin{lstlisting}
xs.map { x => (math.cos(x), math.sin(x)) }
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{enu:tuples-Example2}\ref{enu:tuples-Example2}}

Count how many times $\cos x_{i}>\sin x_{i}$ occurs in a sequence
$x_{i}$.

Hint: use \inputencoding{latin9}\lstinline!.count!\inputencoding{utf8},
assume \inputencoding{latin9}\lstinline!xs:Seq[Double]!\inputencoding{utf8}.

\subparagraph{Solution: }

The method \inputencoding{latin9}\lstinline!.count!\inputencoding{utf8}
takes a predicate and returns the number of times the predicate was
\inputencoding{latin9}\lstinline!true!\inputencoding{utf8} while
evaluated on the elements of the sequence:\inputencoding{latin9}
\begin{lstlisting}
xs.count { x => math.cos(x) > math.sin(x) }
\end{lstlisting}
\inputencoding{utf8}We could also reuse the solution of Exercise~\ref{enu:tuples-Example1-for}
that computed the cosine and the sine values. The code would then
become\inputencoding{latin9}
\begin{lstlisting}
xs.map { x => (math.cos(x), math.sin(x)) }
  .count { case (cosine, sine) => cosine > sine }
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{enu:tuples-Example3}\ref{enu:tuples-Example3}}

For given sequences $a_{i}$ and $b_{i}$, compute the sequence of
differences $c_{i}=a_{i}-b_{i}$.

Hint: use \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}, and assume
\inputencoding{latin9}\lstinline!as!\inputencoding{utf8} and \inputencoding{latin9}\lstinline!bs!\inputencoding{utf8}
are of type \inputencoding{latin9}\lstinline!Seq[Double]!\inputencoding{utf8}.

\subparagraph{Solution: }

We can use \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8}
on \inputencoding{latin9}\lstinline!as!\inputencoding{utf8} and \inputencoding{latin9}\lstinline!bs!\inputencoding{utf8},
which gives a sequence of pairs,\inputencoding{latin9}
\begin{lstlisting}
as.zip(bs) : Seq[(Double, Double)]
\end{lstlisting}
\inputencoding{utf8}We then compute the differences $a_{i}-b_{i}$ by applying \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
to this sequence:\inputencoding{latin9}
\begin{lstlisting}
as.zip(bs).map { case (a, b) => a - b }
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{enu:tuples-Example4-in}\ref{enu:tuples-Example4-in}}

In a given sequence $p_{i}$, count how many times $p_{i}>p_{i+1}$
occurs.

Hint: use \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.tail!\inputencoding{utf8}.

\subparagraph{Solution:}

Given \inputencoding{latin9}\lstinline!ps:Seq[Double]!\inputencoding{utf8},
we can compute \inputencoding{latin9}\lstinline!ps.tail!\inputencoding{utf8}.
The result is a sequence that is $1$ element shorter than \inputencoding{latin9}\lstinline!ps!\inputencoding{utf8},
for example:\inputencoding{latin9}
\begin{lstlisting}
scala> val ps = Seq(1,2,3,4)
ps: Seq[Int] = List(1, 2, 3, 4)

scala> ps.tail
res0: Seq[Int] = List(2, 3, 4)
\end{lstlisting}
\inputencoding{utf8}Taking a \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8}
of the two sequences \inputencoding{latin9}\lstinline!ps!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!ps.tail!\inputencoding{utf8},
we get a sequence of pairs:\inputencoding{latin9}
\begin{lstlisting}
scala> ps.zip(ps.tail)
res1: Seq[(Int, Int)] = List((1,2), (2,3), (3,4))
\end{lstlisting}
\inputencoding{utf8}Note that \inputencoding{latin9}\lstinline!ps.tail!\inputencoding{utf8}
is $1$ element shorter than \inputencoding{latin9}\lstinline!ps!\inputencoding{utf8},
and the resulting sequence of pairs is also $1$ element shorter than
\inputencoding{latin9}\lstinline!ps!\inputencoding{utf8}. In other
words, it is not necessary to truncate \inputencoding{latin9}\lstinline!ps!\inputencoding{utf8}
before computing \inputencoding{latin9}\lstinline!ps.zip(ps.tail)!\inputencoding{utf8}.
Now apply the \inputencoding{latin9}\lstinline!.count!\inputencoding{utf8}
method:

\inputencoding{latin9}\begin{lstlisting}
ps.zip(ps.tail).count { case (a, b) => a > b }
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:tuples-Example5}\ref{subsec:tuples-Example5}}

For a given $k>0$, compute the sequence $c_{i}=\max(b_{i-k},...,b_{i+k})$.

Hint:  use \inputencoding{latin9}\lstinline!.sliding!\inputencoding{utf8}.

\subparagraph{Solution:}

Applying the \inputencoding{latin9}\lstinline!.sliding!\inputencoding{utf8}
method to a list gives a list of nested lists:\inputencoding{latin9}
\begin{lstlisting}
scala> val bs = List(1, 2, 3, 4, 5)
bs: List[Int] = List(1, 2, 3, 4, 5)

scala> bs.sliding(3).toList
res0: List[List[Int]] = List(List(1, 2, 3), List(2, 3, 4), List(3, 4, 5)) 
\end{lstlisting}
\inputencoding{utf8}For each $b_{i}$, we need to obtain a list of $2k+1$ nearby elements
$\left(b_{i-k},...,b_{i+k}\right)$. So we need to use \inputencoding{latin9}\lstinline!.sliding(2*k+1)!\inputencoding{utf8}
to obtain a window of the required size. Now we can compute the maximum
of each of the nested lists by using the \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
method on the outer list, with the \inputencoding{latin9}\lstinline!.max!\inputencoding{utf8}
method applied to the nested lists. So the argument of the \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
method must be the function \inputencoding{latin9}\lstinline!nested => nested.max!\inputencoding{utf8}.
The final code is

\inputencoding{latin9}\begin{lstlisting}
bs.sliding(2 * k + 1).map(nested => nested.max)
\end{lstlisting}
\inputencoding{utf8}In Scala, this code can be written more concisely using the syntax\inputencoding{latin9}
\begin{lstlisting}
bs.sliding(2 * k + 1).map(_.max)
\end{lstlisting}
\inputencoding{utf8}because \inputencoding{latin9}\lstinline!_.max!\inputencoding{utf8}
means the nameless function \inputencoding{latin9}\lstinline!x => x.max!\inputencoding{utf8}.

\subsubsection{Example \label{subsec:tuples-Example6}\ref{subsec:tuples-Example6}}

Create a $10\times10$ multiplication table as a dictionary of type
\inputencoding{latin9}\lstinline!Map[(Int, Int), Int]!\inputencoding{utf8}.
For example, a $3\times3$ multiplication table would be given by
this dictionary,\inputencoding{latin9}
\begin{lstlisting}
Map( (1, 1) -> 1, (1, 2) -> 2, (1, 3) -> 3, (2, 1) -> 2,
  (2, 2) -> 4, (2, 3) -> 6, (3, 1) -> 3, (3, 2) -> 6, (3, 3) -> 9 )
\end{lstlisting}
\inputencoding{utf8}
Hint: use \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.toMap!\inputencoding{utf8}.

\subparagraph{Solution: }

We are required to make a dictionary that maps pairs of integers \inputencoding{latin9}\lstinline!(x, y)!\inputencoding{utf8}
to \inputencoding{latin9}\lstinline!x * y!\inputencoding{utf8}. Begin
by creating the list of \emph{keys} for that dictionary, which must
be a list of pairs \inputencoding{latin9}\lstinline!(x, y)!\inputencoding{utf8}
of the form \inputencoding{latin9}\lstinline!List((1,1), (1,2), ..., (2,1), (2,2), ...)!\inputencoding{utf8}.
We need to start with a sequence of values of \inputencoding{latin9}\lstinline!x!\inputencoding{utf8},
and for each \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
from that sequence, iterate over another sequence to provide values
for \inputencoding{latin9}\lstinline!y!\inputencoding{utf8}. Try
this computation:\inputencoding{latin9}
\begin{lstlisting}
scala> val s = List(1, 2, 3).map(x => List(1, 2, 3))
s: List[List[Int]] = List(List(1, 2, 3), List(1, 2, 3), List(1, 2, 3))
\end{lstlisting}
\inputencoding{utf8}We would like to get \inputencoding{latin9}\lstinline!List((1,1), (1,2), 1,3))!\inputencoding{utf8}
etc., and so we use \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
on the inner list with a nameless function \inputencoding{latin9}\lstinline!y => (x, y)!\inputencoding{utf8}
that converts a number into a tuple,\inputencoding{latin9}
\begin{lstlisting}
scala> List(1, 2, 3).map{ y => (x, y) }
res0: List[(Int, Int)] = List((1,1), (1,2), (1,3))
\end{lstlisting}
\inputencoding{utf8}Here the curly braces \inputencoding{latin9}\lstinline!{ y => (x, y) }!\inputencoding{utf8}
are used only for clarity; we could equivalently use parentheses and
write \inputencoding{latin9}\lstinline!(y => (x, y))!\inputencoding{utf8}. 

Using this \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
operation, we obtain the code for a nested list of tuples:\inputencoding{latin9}
\begin{lstlisting}
scala> val s = List(1, 2, 3).map(x => List(1, 2, 3).map{ y => (x, y) })
s: List[List[(Int, Int)]] = List(List((1,1), (1,2), (1,3)), List((2,1), (2,2), (2,3)), List((3,1), (3,2), (3,3)))
\end{lstlisting}
\inputencoding{utf8}This is almost what we need, except that the nested lists need to
be concatenated into a single list. This is exactly what \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
does:\inputencoding{latin9}
\begin{lstlisting}
scala> val s = List(1, 2, 3).map(x => List(1, 2, 3).map{ y => (x, y) }).flatten
s: List[(Int, Int)] = List((1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1), (3,2), (3,3))
\end{lstlisting}
\inputencoding{utf8}It is shorter to write \inputencoding{latin9}\lstinline!.flatMap(...)!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!.map(...).flatten!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> val s = List(1, 2, 3).flatMap(x => List(1, 2, 3).map{ y => (x, y) })
s: List[(Int, Int)] = List((1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1), (3,2), (3,3)) 
\end{lstlisting}
\inputencoding{utf8}This is the list of keys for the required dictionary, which should
map each \emph{pair} of integers \inputencoding{latin9}\lstinline!(x,y)!\inputencoding{utf8}
to \inputencoding{latin9}\lstinline!x*y!\inputencoding{utf8}. In
Scala, a dictionary is usually created by applying \inputencoding{latin9}\lstinline!.toMap!\inputencoding{utf8}
to a sequence of pairs \inputencoding{latin9}\lstinline!(key,value)!\inputencoding{utf8}.
So we need to create a sequence of nested tuples of the form \inputencoding{latin9}\lstinline!((x,y), product)!\inputencoding{utf8}.
To achieve this, we use \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
with a function that computes the product and creates a nested tuple:\inputencoding{latin9}
\begin{lstlisting}
scala> val s = List(1, 2, 3).flatMap(x => List(1, 2, 3).
  map{ y => (x, y) }).map{ case (x, y) => ((x, y), x * y) }
s: List[((Int, Int), Int)] = List(((1,1),1), ((1,2),2), ((1,3),3), ((2,1),2), ((2,2),4), ((2,3),6), ((3,1),3), ((3,2),6), ((3,3),9))
\end{lstlisting}
\inputencoding{utf8}We can simplify this code if we notice that we are first mapping each
\inputencoding{latin9}\lstinline!y!\inputencoding{utf8} to a tuple
\inputencoding{latin9}\lstinline!(x, y)!\inputencoding{utf8}, and
later map each tuple \inputencoding{latin9}\lstinline!(x,y)!\inputencoding{utf8}
to a nested tuple \inputencoding{latin9}\lstinline!((x,y), x*y)!\inputencoding{utf8}.
Instead, the entire computation can be done in the inner \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
operation:\inputencoding{latin9}
\begin{lstlisting}
scala> val s = List(1, 2, 3).flatMap(x => List(1, 2, 3).
  map{ y => ((x,y), x*y) })
s: List[((Int, Int), Int)] = List(((1,1),1), ((1,2),2), ((1,3),3), ((2,1),2), ((2,2),4), ((2,3),6), ((3,1),3), ((3,2),6), ((3,3),9))
\end{lstlisting}
\inputencoding{utf8}It remains to convert this list of tuples to a dictionary with \inputencoding{latin9}\lstinline!.toMap!\inputencoding{utf8}.
Also, for better readability, we can use Scala's pair syntax \inputencoding{latin9}\lstinline!key -> value!\inputencoding{utf8},
which is completely equivalent to writing the tuple \inputencoding{latin9}\lstinline!(key,value)!\inputencoding{utf8}.
The final code is

\inputencoding{latin9}\begin{lstlisting}
(1 to 10).flatMap(x => (1 to 10).map{ y => (x,y) -> x*y }).toMap
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:tuples-Example7}\ref{subsec:tuples-Example7}}

For a given sequence $x_{i}$, compute the maximum of all of the numbers
$x_{i}$, $\cos x_{i}$, $\sin x_{i}$. Hint: use \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.max!\inputencoding{utf8}.

\subparagraph{Solution:}

We will compute the required value if we take \inputencoding{latin9}\lstinline!.max!\inputencoding{utf8}
of a list containing all of the numbers. To do that, first map each
element of the list \inputencoding{latin9}\lstinline!xs:Seq[Double]!\inputencoding{utf8}
into a sequence of three numbers:\inputencoding{latin9}
\begin{lstlisting}
scala> List(0.1, 0.5, 0.9)
res0: List[Double] = List(0.1, 0.5, 0.9)

scala> res0.map{ x => Seq(x, math.cos(x), math.sin(x)) }
res1: List[Seq[Double]] = List(List(0.1, 0.9950041652780258, 0.09983341664682815), List(0.5, 0.8775825618903728, 0.479425538604203), List(0.9, 0.6216099682706644, 0.7833269096274834))
\end{lstlisting}
\inputencoding{utf8}This list is almost what we need, except we need to \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
it:\inputencoding{latin9}
\begin{lstlisting}
scala> res1.flatten
res2: List[Double] = List(0.1, 0.9950041652780258, 0.09983341664682815, 0.5, 0.8775825618903728, 0.479425538604203, 0.9, 0.6216099682706644, 0.7833269096274834)
\end{lstlisting}
\inputencoding{utf8}Now we just need to take the maximum of the resulting numbers:\inputencoding{latin9}
\begin{lstlisting}
scala> res2.max
res3: Double = 0.9950041652780258
\end{lstlisting}
\inputencoding{utf8}The final code (starting from a given sequence \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8})
is

\inputencoding{latin9}\begin{lstlisting}
xs.flatMap{ x => Seq(x, math.cos(x), math.sin(x)) }.max
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:tuples-Example8}\ref{subsec:tuples-Example8}}

From a dictionary of type \inputencoding{latin9}\lstinline!Map[String, String]!\inputencoding{utf8}
mapping names to addresses, and assuming that the addresses do not
repeat, compute a dictionary of type \inputencoding{latin9}\lstinline!Map[String, String]!\inputencoding{utf8}
mapping the addresses back to names.

Hint: use \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.toMap!\inputencoding{utf8}.

\subparagraph{Solution:}

Keep in mind that iterating over a dictionary looks like iterating
over a list of \inputencoding{latin9}\lstinline!(key, value)!\inputencoding{utf8}
pairs, and use \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
to reverse each pair:

\inputencoding{latin9}\begin{lstlisting}
dict.map{ case (name, addr) => (addr, name) }.toMap
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:tuples-Example-9}\ref{subsec:tuples-Example-9}}

Write the solution of Example~\ref{subsec:tuples-Example8} as a
function with type parameters \inputencoding{latin9}\lstinline!Name!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Addr!\inputencoding{utf8} instead
of the fixed type \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}.

\subparagraph{Solution:}

In Scala, the syntax for type parameters in a function definition
is\inputencoding{latin9}
\begin{lstlisting}
def rev[Name, Addr](...) = ...
\end{lstlisting}
\inputencoding{utf8}The type of the argument is \inputencoding{latin9}\lstinline!Map[Name, Addr]!\inputencoding{utf8},
while the type of the result is \inputencoding{latin9}\lstinline!Map[Addr, Name]!\inputencoding{utf8}.
So we use the type parameters \inputencoding{latin9}\lstinline!Name!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Addr!\inputencoding{utf8} in
the type signature of the function. The final code is\inputencoding{latin9}
\begin{lstlisting}
def rev[Name, Addr](dict: Map[Name, Addr]): Map[Addr, Name] =
  dict.map { case (name, addr) => (addr, name) }.toMap
\end{lstlisting}
\inputencoding{utf8}The body of the function \inputencoding{latin9}\lstinline!rev!\inputencoding{utf8}
remains the same as in Example~\ref{subsec:tuples-Example8}; only
the type signature changed. This is because the procedure for reversing
a dictionary works in the same way for dictionaries of any type. So
the body of the function \inputencoding{latin9}\lstinline!rev!\inputencoding{utf8}
does not actually need to know the types of the keys and values in
the dictionary. For this reason, it was easy for us to change the
specific types (\inputencoding{latin9}\lstinline!String!\inputencoding{utf8})
into type parameters in this function.

When the function \inputencoding{latin9}\lstinline!rev!\inputencoding{utf8}
is applied to a dictionary of a specific type, the Scala compiler
will automatically set the type parameters \inputencoding{latin9}\lstinline!Name!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Addr!\inputencoding{utf8} that
fit the required types of the dictionary's keys and values. For example,
if we apply \inputencoding{latin9}\lstinline!rev!\inputencoding{utf8}
to a dictionary of type \inputencoding{latin9}\lstinline!Map[Boolean, Seq[String]]!\inputencoding{utf8},
the type parameters will be set automatically as \inputencoding{latin9}\lstinline!Name = Boolean!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Addr = Seq[String]!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> val d = Map(true -> Seq("x", "y"), false -> Seq("z", "t"))
d: Map[Boolean, Seq[String]] = Map(true -> List(x, y), false -> List(z, t))

scala> rev(d)
res0: Map[Seq[String], Boolean] = Map(List(x, y) -> true, List(z, t) -> false)
\end{lstlisting}
\inputencoding{utf8}Type parameters can be also set explicitly when using the function
\inputencoding{latin9}\lstinline!rev!\inputencoding{utf8}. If the
type parameters are chosen incorrectly, the program will not compile:\inputencoding{latin9}
\begin{lstlisting}
scala> rev[Boolean, Seq[String]](d)
res1: Map[Seq[String],Boolean] = Map(List(x, y) -> true, List(z, t) -> false)

scala> rev[Int, Double](d)
<console>:14: error: type mismatch;
 found   : Map[Boolean,Seq[String]]
 required: Map[Int,Double]
       rev[Int, Double](d)
                        ^
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:tuples-Example10}\ref{subsec:tuples-Example10}{*}}

Given a sequence \inputencoding{latin9}\lstinline!words:Seq[String]!\inputencoding{utf8}
of words, compute a sequence of type \inputencoding{latin9}\lstinline!Seq[ (Seq[String], Int) ]!\inputencoding{utf8},
where each inner sequence contains all the words having the same length,
paired with the integer value showing that length. So, the input \inputencoding{latin9}\lstinline!Seq("the", "food", "is", "good")!\inputencoding{utf8}
should produce the output \inputencoding{latin9}
\begin{lstlisting}
Seq( (Seq("is"), 2), (Seq("the"), 3), (Seq("food", "good"), 4) )
\end{lstlisting}
\inputencoding{utf8}The resulting sequence must be ordered by increasing length of words.

\subparagraph{Solution:}

It is clear that we need to begin by grouping the words by length.
The library method \inputencoding{latin9}\lstinline!.groupBy!\inputencoding{utf8}
takes a function that computes a grouping key from each element of
a sequence. In our case, we need to group by word length, which is
computed with the method \inputencoding{latin9}\lstinline!.length!\inputencoding{utf8}
if applied to a string. So the first step is\inputencoding{latin9}
\begin{lstlisting}
words.groupBy{ word => word.length }
\end{lstlisting}
\inputencoding{utf8}or, more concisely, \inputencoding{latin9}\lstinline!words.groupBy(_.length)!\inputencoding{utf8}.
The result of this expression is a dictionary that maps each length
to the list of words having that length:\inputencoding{latin9}
\begin{lstlisting}
scala> words.groupBy(_.length)
res0: scala.collection.immutable.Map[Int,Seq[String]] = Map(2 -> List(is), 4 -> List(food, good), 3 -> List(the))
\end{lstlisting}
\inputencoding{utf8}This is already close to what we need. If we convert this dictionary
to a sequence, we will get a list of pairs\inputencoding{latin9}
\begin{lstlisting}
scala> words.groupBy(_.length).toSeq
res1: Seq[(Int, Seq[String])] = ArrayBuffer((2,List(is)), (4,List(food, good)), (3,List(the))) 
\end{lstlisting}
\inputencoding{utf8}It remains to swap the length and the list of words and to sort the
result by increasing length. We can do this in any order: first sort,
then swap; or first swap, then sort. The final code is\inputencoding{latin9}
\begin{lstlisting}
words
  .groupBy(_.length)
  .toSeq
  .sortBy { case (len, words) => len }
  .map { case (len, words) => (words, len) }
\end{lstlisting}
\inputencoding{utf8}This code can be written somewhat shorter if we use the syntax \_.\_1
for selecting the first part of the tuple, and .swap for swapping
the two elements of the pair:\inputencoding{latin9}
\begin{lstlisting}
words.groupBy(_.length).toSeq.sortBy(_._1).map(_.swap)
\end{lstlisting}
\inputencoding{utf8}However, the program may now be harder to read and to modify.

\subsection{Reasoning about types of sequences}

In Example~\ref{subsec:tuples-Example10} we have applied a chain
of operations to a sequence. Let us add comments showing the type
of the intermediate result after each operation:\inputencoding{latin9}
\begin{lstlisting}
words // Seq[String]
  .groupBy(_.length) // Map[Int, Seq[String]]
  .toSeq // Seq[ (Int, Seq[String]) ]
  .sortBy { case (len, words) => len } // Seq[ (Int, Seq[String]) ]
  .map { case (len, words) => (words, len) } // Seq[ (Seq[String], Int) ]
\end{lstlisting}
\inputencoding{utf8}In computations like this, the Scala compiler verifies at each step
that the operations are applied to values of the correct type.

For instance, \inputencoding{latin9}\lstinline!.sortBy!\inputencoding{utf8}
is defined for sequences but not for dictionaries, so it would be
a \index{type error}type error to apply \inputencoding{latin9}\lstinline!.sortBy!\inputencoding{utf8}
to a dictionary without first converting it to a sequence using \inputencoding{latin9}\lstinline!.toSeq!\inputencoding{utf8}.
The type of the intermediate result after \inputencoding{latin9}\lstinline!.toSeq!\inputencoding{utf8}
is \inputencoding{latin9}\lstinline!Seq[ (Int, Seq[String]) ]!\inputencoding{utf8},
and the \inputencoding{latin9}\lstinline!.sortBy!\inputencoding{utf8}
operation is applied to that sequence. So the sequence element matched
by \inputencoding{latin9}\lstinline!{ case (len, words) => len }!\inputencoding{utf8}
is a tuple \inputencoding{latin9}\lstinline!(Int, Seq[String])!\inputencoding{utf8},
which means that the pattern variables \inputencoding{latin9}\lstinline!len!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!words!\inputencoding{utf8} must
have types \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Seq[String]!\inputencoding{utf8}
respectively. It would be a type error to use the sorting key function
\inputencoding{latin9}\lstinline!{ case (len, words) => words }!\inputencoding{utf8}:
the sorting key can be an integer \inputencoding{latin9}\lstinline!len!\inputencoding{utf8},
but not a string sequence \inputencoding{latin9}\lstinline!words!\inputencoding{utf8}
(because sorting by string sequences is not defined).

If we visualize how the type of the sequence should change at every
step, we can more quickly understand how to implement the required
task. Begin by writing down the intermediate types that would be needed
during the computation:\inputencoding{latin9}
\begin{lstlisting}
words: Seq[String] // Need to group by word length.
Map[Int, Seq[String]]  // Need to sort by word length; can't sort a dictionary!
// Need to convert this dictionary to a sequence:
Seq[ (Int, Seq[String]) ] // Now sort this! Sorting does not change the type.
// It remains to swap the parts of all tuples in the sequence:
Seq[ (Seq[String], Int) ] // We are done.
\end{lstlisting}
\inputencoding{utf8}Having written down these types, we are better assured that the computation
can be done correctly. Writing the code becomes straightforward, since
we are guided by the already known types of the intermediate results:\inputencoding{latin9}
\begin{lstlisting}
words.groupBy(_.length).toSeq.sortBy(_._1).map(_.swap)
\end{lstlisting}
\inputencoding{utf8}
This example illustrates the main benefits of reasoning about types:
it gives direct guidance about how to organize the computation, together
with a greater assurance in the correctness of the code.

\subsection{Exercises: Tuples and collections\index{exercises}}

\subsubsection{Exercise \label{tuples-Exercise-1}\ref{tuples-Exercise-1}}

Find all pairs $i,j$ within $\left(0,1,...,9\right)$ such that $i+4*j>i*j$.

Hint: use \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}.

\subsubsection{Exercise \label{tuples-Exercise-2}\ref{tuples-Exercise-2}}

Same task as in Exercise~\ref{tuples-Exercise-1}, but for $i,j,k$
and the condition $i+4*j+9*k>i*j*k$.

\subsubsection{Exercise \label{tuples-Exercise-3}\ref{tuples-Exercise-3}}

Given two sequences \inputencoding{latin9}\lstinline!p: Seq[String]!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!q: Seq[Boolean]!\inputencoding{utf8}
of equal length, compute a \inputencoding{latin9}\lstinline!Seq[String]!\inputencoding{utf8}
with those elements of \inputencoding{latin9}\lstinline!p!\inputencoding{utf8}
for which the corresponding element of \inputencoding{latin9}\lstinline!q!\inputencoding{utf8}
is \inputencoding{latin9}\lstinline!true!\inputencoding{utf8}.

Hint: use \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}.

\subsubsection{Exercise \label{tuples-Exercise-4}\ref{tuples-Exercise-4}}

Convert a \inputencoding{latin9}\lstinline!Seq[Int]!\inputencoding{utf8}
into a \inputencoding{latin9}\lstinline!Seq[(Int, Boolean)]!\inputencoding{utf8}
where the \inputencoding{latin9}\lstinline!Boolean!\inputencoding{utf8}
value is \inputencoding{latin9}\lstinline!true!\inputencoding{utf8}
when the element is followed by a larger value. For example, \inputencoding{latin9}\lstinline!Seq(1,3,2,4)!\inputencoding{utf8}
is to be converted into \inputencoding{latin9}\lstinline!Seq((1,true),(3,false),(2,true),(4,false))!\inputencoding{utf8}.
(The last element, 4, has no following element.)

\subsubsection{Exercise \label{tuples-Exercise-5}\ref{tuples-Exercise-5}}

Given \inputencoding{latin9}\lstinline!p: Seq[String]!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!q: Seq[Int]!\inputencoding{utf8}
of equal length, and assuming that elements of \inputencoding{latin9}\lstinline!q!\inputencoding{utf8}
do not repeat, compute a \inputencoding{latin9}\lstinline!Map[Int, String]!\inputencoding{utf8}
that maps numbers from \inputencoding{latin9}\lstinline!q!\inputencoding{utf8}
to their corresponding strings from \inputencoding{latin9}\lstinline!p!\inputencoding{utf8}.

\subsubsection{Exercise \label{tuples-Exercise-6}\ref{tuples-Exercise-6}}

Write the solution of Exercise~\ref{tuples-Exercise-5} as a function
with type parameters \inputencoding{latin9}\lstinline!P!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Q!\inputencoding{utf8} instead
of the fixed types \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}. Test
it with \inputencoding{latin9}\lstinline!P = Boolean!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Q = Set[Int]!\inputencoding{utf8}.

\subsubsection{Exercise \label{tuples-Exercise-7}\ref{tuples-Exercise-7}}

Given \inputencoding{latin9}\lstinline!p: Seq[String]!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!q: Seq[Int]!\inputencoding{utf8}
of equal length, compute a \inputencoding{latin9}\lstinline!Seq[String]!\inputencoding{utf8}
that contains the strings from \inputencoding{latin9}\lstinline!p!\inputencoding{utf8}
ordered according to the corresponding numbers from \inputencoding{latin9}\lstinline!q!\inputencoding{utf8}.
For example, if \inputencoding{latin9}\lstinline!p = Seq("a", "b", "c")!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!q = Seq(10, -1, 5)!\inputencoding{utf8}
then the result must be \inputencoding{latin9}\lstinline!Seq("b", "c", "a")!\inputencoding{utf8}.

\subsubsection{Exercise \label{tuples-Exercise-8}\ref{tuples-Exercise-8}}

Write the solution of Exercise~\ref{tuples-Exercise-7} as a function
with type parameter \inputencoding{latin9}\lstinline!S!\inputencoding{utf8}
instead of the fixed type \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}.
The required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def reorder[S](p: Seq[S], q: Seq[Int]): Seq[S] = ???

scala> reorder(Seq(6.0,2.0,8.0,4.0), Seq(20,10,40,30))
res0: Seq[Double] = List(2.0, 6.0, 4.0, 8.0)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{tuples-Exercise-9}\ref{tuples-Exercise-9}}

Given a \inputencoding{latin9}\lstinline!Seq[(String, Int)]!\inputencoding{utf8}
showing a list of purchased items (where item names may repeat), compute
a \inputencoding{latin9}\lstinline!Map[String, Int]!\inputencoding{utf8}
showing the total counts: e.g.~for the input \inputencoding{latin9}
\begin{lstlisting}
Seq(("apple", 2), ("pear", 3), ("apple", 5))
\end{lstlisting}
\inputencoding{utf8}the output must be \inputencoding{latin9}
\begin{lstlisting}
Map("apple" -> 7, "pear" -> 3)
\end{lstlisting}
\inputencoding{utf8}Implement this computation as a function with type parameter \inputencoding{latin9}\lstinline!S!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}. 

Hint: use \inputencoding{latin9}\lstinline!.groupBy!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8}.

\subsubsection{Exercise \label{tuples-Exercise-10}\ref{tuples-Exercise-10}}

Given a \inputencoding{latin9}\lstinline!Seq[List[Int]]!\inputencoding{utf8},
compute a new \inputencoding{latin9}\lstinline!Seq[List[Int]]!\inputencoding{utf8}
where each inner list contains \emph{three} largest elements from
the initial inner list (or fewer than three if the initial inner list
is shorter).

Hint: use \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.sortBy!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.take!\inputencoding{utf8}.%
\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
numsLists.map(_.sortBy(-_).take(3))
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{tuples-Exercise-11}\ref{tuples-Exercise-11}}

\textbf{(a)} Given two sets \inputencoding{latin9}\lstinline!p:Set[Int]!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!q:Set[Int]!\inputencoding{utf8},
compute a set of type \inputencoding{latin9}\lstinline!Set[(Int, Int)]!\inputencoding{utf8}
as the Cartesian product of the sets \inputencoding{latin9}\lstinline!p!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!q!\inputencoding{utf8}; that
is, the set of all pairs \inputencoding{latin9}\lstinline!(x, y)!\inputencoding{utf8}
where \inputencoding{latin9}\lstinline!x!\inputencoding{utf8} is
from \inputencoding{latin9}\lstinline!p!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!y!\inputencoding{utf8} is from \inputencoding{latin9}\lstinline!q!\inputencoding{utf8}. 

\textbf{(b)} Implement this computation as a function with type parameters
\inputencoding{latin9}\lstinline!I!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!J!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}.
The required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def cartesian[I,J](p: Set[I], q: Set[J]): Set[(I, J)] = ???

scala> cartesian(Set("a", "b"), Set(10, 20))
res0: Set[(String, Int)] = Set((a,10), (a,20), (b,10), (b,20))
\end{lstlisting}
\inputencoding{utf8}
Hint: use \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8} on
sets.%
\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
a.flatMap(x => b.map(y => (x, y)))
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{tuples-Exercise-12}\ref{tuples-Exercise-12}{*}}

Given a \inputencoding{latin9}\lstinline!Seq[Map[Person, Amount]]!\inputencoding{utf8},
showing the amounts various people paid on each day, compute a \inputencoding{latin9}\lstinline!Map[Person, Seq[Amount]]!\inputencoding{utf8},
showing the sequence of payments for each person. Assume that \inputencoding{latin9}\lstinline!Person!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Amount!\inputencoding{utf8}
are type parameters. The required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def payments[Person, Amount](data: Seq[Map[Person, Amount]]): Map[Person, Seq[Amount]] = ???

scala> payments(Seq(Map("Tarski" -> 10, "Church" -> 20), Map("Church" -> 100, "Gentzen" -> 40), Map("Tarski" -> 50)))
res0: Map[String, Seq[Int]] = Map(Genzten -> List(40), Church -> List(20, 100), Tarski -> List(10, 50))
\end{lstlisting}
\inputencoding{utf8}
Hint: use \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.groupBy!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.mapValues!\inputencoding{utf8}
on dictionaries.%
\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
def payments[Person, Amount](data: Seq[Map[Person, Amount]]): Map[Person, Seq[Amount]] = data.flatMap(_.toSeq).groupBy(_._1).mapValues(_.map(_._2))
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\section{Converting a sequence into a single value}

Until this point, we have been working with sequences using methods
such as \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8}. These
techniques are powerful but still insufficient for solving certain
problems.

A simple computation that is impossible to do using \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
is to compute the sum of a sequence of numbers. The standard library
method \inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8}
already does this; but we cannot implement \inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8}
ourselves by using \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8}, or \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}.
These operations always compute \emph{new} \emph{sequences}, while
we need to compute a single value (the sum of all elements) from a
sequence. 

We have seen a few library methods such as \inputencoding{latin9}\lstinline!.count!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.length!\inputencoding{utf8}, and
\inputencoding{latin9}\lstinline!.max!\inputencoding{utf8} that compute
a single value from a sequence; but we still cannot implement \inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8}
using these methods. What we need is a more general way of converting
a sequence to a single value, such that we could ourselves implement
\inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.count!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.max!\inputencoding{utf8}, and other
similar computations.

Another task not solvable with \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8}, etc.,
is to compute a floating-point number from a given sequence of decimal
digits (including a ``dot'' character):\inputencoding{latin9}
\begin{lstlisting}
def digitsToDouble(ds: Seq[Char]): Double = ???

scala> digitsToDouble(Seq('2', '0', '4', '.', '5'))
res0: Double = 204.5
\end{lstlisting}
\inputencoding{utf8}Why is it impossible to implement this function using \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8}
and other methods we have seen so far? In fact, the same task for
\emph{integer} numbers (not for floating-point numbers) is solvable
using \inputencoding{latin9}\lstinline!.length!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def digitsToInt(ds: Seq[Int]): Int = {
  val n = ds.length
  // Compute a sequence of powers of 10, e.g. [1000, 100, 100, 1]
  val powers: Seq[Int] = (0 to n-1).map(k => math.pow(10, n-1-k).toInt)
  // Sum the powers of 10 with coefficients from `ds`.
  (ds zip powers).map { case (d, p) => d * p }.sum                                  
}

scala> digitsToInt(Seq(2,4,0,5))
res0: Int = 2405
\end{lstlisting}
\inputencoding{utf8}The computation can be written as the formula
\[
r=\sum_{k=0}^{n-1}d_{k}*10^{n-1-k}\quad.
\]
The sequence of powers of $10$ can be computed separately and ``zipped''
with the sequence of digits $d_{k}$. However, for floating-point
numbers, the sequence of powers of $10$ depends on the position of
the ``dot'' character. Methods such as \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8} cannot
compute a sequence whose next elements are not known in advance but
depend on previous elements via a custom function.

\subsection{Inductive definitions of aggregation functions\label{subsec:Inductive-definitions-of-aggregation-functions}}

\textbf{Mathematical induction\index{mathematical induction}} is
a general way of expressing the dependence of next values on previously
computed values. To define a function from sequence to a single value
(e.g.~an aggregation function \inputencoding{latin9}\lstinline!f:Seq[Int] => Int!\inputencoding{utf8})
by using mathematical induction, we need to specify two computations:
\begin{itemize}
\item (\textbf{\index{mathematical induction!base case}}The \textbf{base
case} of the induction.) We need to specify what value the function
\inputencoding{latin9}\lstinline!f!\inputencoding{utf8} returns for
an empty sequence, \inputencoding{latin9}\lstinline!Seq()!\inputencoding{utf8}.
If the function is only defined for non-empty sequences, we need to
specify what the function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
returns for a one-element sequence such as \inputencoding{latin9}\lstinline!Seq(x)!\inputencoding{utf8},
with any \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}.
\item (\textbf{\index{mathematical induction!inductive step}}The \textbf{inductive
step}.) Assuming that the function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
is already computed for some sequence \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}
(the \textbf{\index{mathematical induction!inductive assumption}inductive
assumption}), how to compute the function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
for a sequence with one more element \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}?
The sequence with one more element is written as \inputencoding{latin9}\lstinline!xs ++ Seq(x)!\inputencoding{utf8}.
So, we need to specify how to compute \inputencoding{latin9}\lstinline!f(xs ++ Seq(x))!\inputencoding{utf8}
assuming that \inputencoding{latin9}\lstinline!f(xs)!\inputencoding{utf8}
is already known.
\end{itemize}
Once these two computations are specified, the function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
is defined (and can in principle be computed) for an arbitrary input
sequence. This is how induction works in mathematics, and it works
in the same way in functional programming. With this approach, the
inductive definition of the method \inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8}
looks like this:
\begin{itemize}
\item The sum of an empty sequence is $0$. That is, \inputencoding{latin9}\lstinline!Seq().sum = 0!\inputencoding{utf8}.
\item If the result is already known for a sequence \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8},
and we have a sequence that has one more element \inputencoding{latin9}\lstinline!x!\inputencoding{utf8},
the new result is equal to \inputencoding{latin9}\lstinline!xs.sum + x!\inputencoding{utf8}.
In code, this is \inputencoding{latin9}\lstinline!(xs ++ Seq(x)).sum = xs.sum + x!\inputencoding{utf8}.
\end{itemize}
The inductive definition of the function \inputencoding{latin9}\lstinline!digitsToInt!\inputencoding{utf8}
is:
\begin{itemize}
\item For an empty sequence of digits, \inputencoding{latin9}\lstinline!Seq()!\inputencoding{utf8},
the result is \inputencoding{latin9}\lstinline!0!\inputencoding{utf8}.
This is a convenient base case, even if we never call \inputencoding{latin9}\lstinline!digitsToInt!\inputencoding{utf8}
on an empty sequence.
\item If \inputencoding{latin9}\lstinline!digitsToInt(xs)!\inputencoding{utf8}
is already known for a sequence \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}
of digits, and we have a sequence \inputencoding{latin9}\lstinline!xs ++ Seq(x)!\inputencoding{utf8}
with one more digit \inputencoding{latin9}\lstinline!x!\inputencoding{utf8},
then\inputencoding{latin9}
\begin{lstlisting}
digitsToInt(xs ++ Seq(x)) = digitsToInt(xs) * 10 + x
\end{lstlisting}
\inputencoding{utf8}\end{itemize}
Let us write inductive definitions for methods such as \inputencoding{latin9}\lstinline!.length!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.max!\inputencoding{utf8}, and \inputencoding{latin9}\lstinline!.count!\inputencoding{utf8}:
\begin{itemize}
\item The length of a sequence:
\begin{itemize}
\item for an empty sequence, \inputencoding{latin9}\lstinline!Seq().length = 0!\inputencoding{utf8}
\item if \inputencoding{latin9}\lstinline!xs.length!\inputencoding{utf8}
is known then \inputencoding{latin9}\lstinline!(xs ++ Seq(x)).length = xs.length + 1!\inputencoding{utf8}
\end{itemize}
\item Maximum element of a sequence (undefined for empty sequences):
\begin{itemize}
\item for a one-element sequence, \inputencoding{latin9}\lstinline!Seq(x).max = x!\inputencoding{utf8} 
\item if \inputencoding{latin9}\lstinline!xs.max!\inputencoding{utf8} is
known then \inputencoding{latin9}\lstinline!(xs ++ Seq(x)).max = math.max(xs.max, x)!\inputencoding{utf8}
\end{itemize}
\item Count the sequence elements satisfying a predicate \inputencoding{latin9}\lstinline!p!\inputencoding{utf8}:
\begin{itemize}
\item for an empty sequence, \inputencoding{latin9}\lstinline!Seq().count(p) = 0!\inputencoding{utf8}
\item if \inputencoding{latin9}\lstinline!xs.count(p)!\inputencoding{utf8}
is known then \inputencoding{latin9}\lstinline!(xs ++ Seq(x)).count(p) = xs.count(p) + c!\inputencoding{utf8},
where \inputencoding{latin9}\lstinline!c = 1!\inputencoding{utf8}
when \inputencoding{latin9}\lstinline!p(x) == true!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!c = 0!\inputencoding{utf8} otherwise
\end{itemize}
\end{itemize}
There are two main ways of translating mathematical induction into
code. The first way is to write a recursive function. The second way
is to use a standard library function, such as \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!reduce!\inputencoding{utf8}.
Most often it is better to use the standard library functions, but
sometimes the code is more transparent when using explicit recursion.
So let us consider each of these ways in turn.

\subsection{Implementing functions by recursion}

A \textbf{recursive function\index{recursive function}} is any function
that calls itself somewhere within its own body. The call to itself
is the \textbf{recursive call}.

When the body of a recursive function is evaluated, it may repeatedly
call itself with different arguments until the result value can be
computed \emph{without} any recursive calls. The last recursive call
corresponds to the base case of the induction. It is an error if the
base case is never reached, as in this example:\inputencoding{latin9}
\begin{lstlisting}
scala> def infiniteLoop(x: Int): Int = infiniteLoop(x+1)
infiniteLoop: (x: Int)Int

scala> infiniteLoop(2) // You will need to press Ctrl-C to stop this.
\end{lstlisting}
\inputencoding{utf8}
We translate mathematical induction into code by first writing a condition
to decide whether we are in the base case or in the inductive step.
As an example, consider how we would define \inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8}
by recursion. The base case returns \inputencoding{latin9}\lstinline!0!\inputencoding{utf8},
and the inductive step returns a value computed from the recursive
call:\inputencoding{latin9}
\begin{lstlisting}
def sum(s: Seq[Int]): Int = if (s == Seq()) 0 else {
  val x = s.head // To split s = Seq(x) ++ xs, compute x
  val xs = s.tail //  and xs.
  sum(prev) + next // Call sum(...) recursively.
}
\end{lstlisting}
\inputencoding{utf8}In this example, we use the \inputencoding{latin9}\lstinline!if/else!\inputencoding{utf8}
expression to separate the base case from the inductive step. In the
inductive step, we split the given sequence \inputencoding{latin9}\lstinline!s!\inputencoding{utf8}
into a single-element sequence \inputencoding{latin9}\lstinline!Seq(x)!\inputencoding{utf8},
the ``head'' of \inputencoding{latin9}\lstinline!s!\inputencoding{utf8},
and the remainder (``tail'') sequence \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}.
So, we split \inputencoding{latin9}\lstinline!s!\inputencoding{utf8}
as \inputencoding{latin9}\lstinline!s = Seq(x) ++ xs!\inputencoding{utf8}
rather than as \inputencoding{latin9}\lstinline!s = xs ++ Seq(x)!\inputencoding{utf8}. 

For computing the sum of a numerical sequence, the order of summation
does not matter. However, the order of operations \emph{will} matter
for many other computational tasks. We need to choose whether the
inductive step should split the sequence as \inputencoding{latin9}\lstinline!s = Seq(x) ++ xs!\inputencoding{utf8}
or as \inputencoding{latin9}\lstinline!s = xs ++ Seq(x)!\inputencoding{utf8},
according to the task at hand.

Consider the implementation of \inputencoding{latin9}\lstinline!digitsToInt!\inputencoding{utf8}
according to the inductive definition shown in the previous subsection:\inputencoding{latin9}
\begin{lstlisting}
def digitsToInt(s: Seq[Int]): Int = if (s == Seq()) 0 else {
  val x = s.last  // To split s = xs ++ Seq(x), compute x
  val xs = s.take(s.length - 1) //  and xs.
  digitsToInt(xs) * 10 + x // Call digitstoInt(...) recursively.
}
\end{lstlisting}
\inputencoding{utf8}In this example, it is important to split the sequence \inputencoding{latin9}\lstinline!s = xs ++ Seq(x)!\inputencoding{utf8}
in this order, and not in the order \inputencoding{latin9}\lstinline!Seq(x) ++ xs!\inputencoding{utf8}.
The reason is that digits increase their numerical value from right
to left, so we need to multiply the value of the \emph{left} subsequence,
\inputencoding{latin9}\lstinline!digitsToInt(xs)!\inputencoding{utf8},
by $10$, in order to compute the correct result.

These examples show how mathematical induction is converted into recursive
code. This approach often works but has two technical problems. The
first problem is that the code will fail due to the ``stack overflow''
when the input sequence \inputencoding{latin9}\lstinline!s!\inputencoding{utf8}
is long enough. In the next subsection, we will see how this problem
is solved (at least in some cases) using ``tail recursion''. The
second problem is that each inductively defined function repeats the
code for checking the base case and the code for splitting the sequence
\inputencoding{latin9}\lstinline!s!\inputencoding{utf8} into the
subsequence \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}
and the extra element \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}.
This repeated common code can be put into a library function, and
the Scala library provides such functions. We will look at using them
in Section~\ref{subsec:implementing-generic-aggregation-foldleft}.

\subsection{Tail recursion\label{subsec:Tail-recursion}}

The code of \inputencoding{latin9}\lstinline!lengthS!\inputencoding{utf8}
will fail for large enough sequences. To see why, consider an inductive
definition of the \inputencoding{latin9}\lstinline!.length!\inputencoding{utf8}
method as a function \inputencoding{latin9}\lstinline!lengthS!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def lengthS(s: Seq[Int]): Int =
  if (s == Seq()) 0
  else 1 + lengthS(s.tail)

scala> lengthS((1 to 1000).toList)
res0: Int = 1000

scala> val s = (1 to 100000).toList
s: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, ...

scala> lengthS(s)
java.lang.StackOverflowError
  at .lengthS(<console>:12)
  at .lengthS(<console>:12)
  at .lengthS(<console>:12)
  at .lengthS(<console>:12)
...
\end{lstlisting}
\inputencoding{utf8}The problem is not due to insufficient main memory: we \emph{are}
able to compute and hold in memory the sequence \inputencoding{latin9}\lstinline!s!\inputencoding{utf8}.
The problem is with the code of the function \inputencoding{latin9}\lstinline!lengthS!\inputencoding{utf8}.
This function calls itself \emph{inside} an expression \inputencoding{latin9}\lstinline!1 + lengthS(...)!\inputencoding{utf8}.
So we can visualize how the computer evaluates this code: \inputencoding{latin9}
\begin{lstlisting}
lengthS(Seq(1, 2, ..., 100000))
  = 1 + lengthS(Seq(2, ..., 100000))
  = 1 + (1 + lengthS(Seq(3, ..., 100000)))
  = ...
\end{lstlisting}
\inputencoding{utf8}The function body of \inputencoding{latin9}\lstinline!lengthS!\inputencoding{utf8}
will evaluate the inductive step, that is, the ``\inputencoding{latin9}\lstinline!else!\inputencoding{utf8}''
part of the ``\inputencoding{latin9}\lstinline!if/else!\inputencoding{utf8}'',
about $100000$ times. Each time, the sub-expression with nested computations
\inputencoding{latin9}\lstinline!1+(1+(...))!\inputencoding{utf8}
will get larger. This intermediate sub-expression needs to be held
somewhere in memory, until at some point the function body goes into
the base case and returns a value. When that happens, the entire intermediate
sub-expression will contain about $100000$ nested function calls
still waiting to be evaluated. This sub-expression is held in a special
area of memory called \textbf{\index{stack memory}stack memory},
where the not-yet-evaluated nested function calls are held in the
order of their calls, as if on a ``stack''. Due to the way computer
memory is managed, the stack memory has a fixed size and cannot grow
automatically. So, when the intermediate expression becomes large
enough, it causes an overflow of the stack memory, and the program
may crash.

A way to solve this problem is to use a trick called \textbf{tail
recursion\index{tail recursion}}. Using tail recursion means rewriting
the code so that all recursive calls occur at the end positions (at
the ``tails'') of the function body. In other words, each recursive
call must be \emph{itself} the last computation in the function body.
Recursive calls cannot be placed inside other computations. 

As an example, we can rewrite the code of \inputencoding{latin9}\lstinline!lengthS!\inputencoding{utf8}
in this way:\inputencoding{latin9}
\begin{lstlisting}
def lengthT(s: Seq[Int], res: Int): Int =
  if (s == Seq()) res
  else lengthT(s.tail, 1 + res)
\end{lstlisting}
\inputencoding{utf8}In this code, one of the branches of the \inputencoding{latin9}\lstinline!if/else!\inputencoding{utf8}
returns a fixed value without doing any recursive calls, while the
other branch returns the result of recursive call to \inputencoding{latin9}\lstinline!lengthT(...)!\inputencoding{utf8}.
In the code of \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8},
recursive calls do not occur within sub-expressions such as \inputencoding{latin9}\lstinline!1 + lengthT(...)!\inputencoding{utf8},
unlike in the code of \inputencoding{latin9}\lstinline!lengthS!\inputencoding{utf8}. 

It is not a problem that the recursive call to \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}
has some sub-expressions such as \inputencoding{latin9}\lstinline!1+res!\inputencoding{utf8}
as its arguments, because all these sub-expressions will be computed
\emph{before} \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}
is recursively called. The recursive call to \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}
is the \emph{last} computation performed by this branch of the \inputencoding{latin9}\lstinline!if/else!\inputencoding{utf8}.
This shows that the code of \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}
is tail-recursive.

A tail-recursive function can have many \inputencoding{latin9}\lstinline!if/else!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!match/case!\inputencoding{utf8}
branches, with or without recursive calls; but all recursive calls
must be always the last expressions returned.

The Scala compiler has a feature for checking automatically that a
function's code is tail-recursive: the \inputencoding{latin9}\lstinline!@tailrec!\inputencoding{utf8}
annotation. If a function with a \inputencoding{latin9}\lstinline!@tailrec!\inputencoding{utf8}
annotation is not tail-recursive, or is not recursive at all, the
program will not compile.\inputencoding{latin9}
\begin{lstlisting}
@tailrec def lengthT(s: Seq[Int], res: Int): Int = 
  if (s == Seq()) res
  else lengthT(s.tail, 1 + res)
\end{lstlisting}
\inputencoding{utf8}Let us trace the evaluation of this function on a short example:\inputencoding{latin9}
\begin{lstlisting}
lengthT(Seq(1,2,3), 0)
  = lengthT(Seq(2, 3), 1 + 0) // = lengthT(Seq(2, 3), 1)
  = lengthT(Seq(3), 1 + 1) // = lengthT(Seq(3), 2)
  = lengthT(Seq(), 1 + 2) // = lengthT(Seq(), 3)
  = 3
\end{lstlisting}
\inputencoding{utf8}The sub-expressions such as \inputencoding{latin9}\lstinline!1 + 2!\inputencoding{utf8}
are computed each time \emph{before} each recursive call to \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}.
Because of that, sub-expressions do not grow within the stack memory.
This is the main benefit of tail recursion.

How did we rewrite the code of \inputencoding{latin9}\lstinline!lengthS!\inputencoding{utf8}
to obtain the tail-recursive code of \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}?
An important difference between \inputencoding{latin9}\lstinline!lengthS!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}
is the additional argument, \inputencoding{latin9}\lstinline!res!\inputencoding{utf8},
called the \textbf{accumulator argument}\index{accumulator argument}\index{recursion!accumulator argument}.
This argument is equal to an intermediate result of the computation.
The next intermediate result (\inputencoding{latin9}\lstinline!1 + res!\inputencoding{utf8})
is computed and passed on to the next recursive call via the accumulator
argument. In the base case of the recursion, the function now returns
the accumulated result, \inputencoding{latin9}\lstinline!res!\inputencoding{utf8},
rather than \inputencoding{latin9}\lstinline!0!\inputencoding{utf8},
because at that time the computation is finished.

Rewriting code by adding an accumulator argument to achieve tail recursion
is called the \textbf{accumulator technique} or the ``accumulator
trick''.\index{accumulator trick}\index{recursion!accumulator trick}

One consequence of using the accumulator trick is that the function
\inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8} now
always needs a value for the accumulator argument. However, our goal
is to implement a function such as \inputencoding{latin9}\lstinline!length(s)!\inputencoding{utf8}
with just one argument, \inputencoding{latin9}\lstinline!s:Seq[Int]!\inputencoding{utf8}.
We can define \inputencoding{latin9}\lstinline!length(s) = lengthT(s, ???)!\inputencoding{utf8}
if we supply an initial accumulator value. The correct initial value
for the accumulator is \inputencoding{latin9}\lstinline!0!\inputencoding{utf8},
since in the base case (an empty sequence \inputencoding{latin9}\lstinline!s!\inputencoding{utf8})
we need to return \inputencoding{latin9}\lstinline!0!\inputencoding{utf8}.

So, a tail-recursive implementation of \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}
requires us to define \emph{two} functions: the tail-recursive \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}
and an ``adapter'' function that will set the initial value of the
accumulator argument. To emphasize that \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}
is a helper function, one could define it \emph{inside} the adapter
function:\inputencoding{latin9}
\begin{lstlisting}
def length[A](s: Seq[A]): Int = {
  @tailrec def lengthT(s: Seq[A], res: Int): Int = {
    if (s == Seq()) res
    else lengthT(s.tail, 1 + res)
  }
  lengthT(s, 0)
}
\end{lstlisting}
\inputencoding{utf8}With this code, users will not be able to call \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}
directly, since it is only visible within the body of the \inputencoding{latin9}\lstinline!length!\inputencoding{utf8}
function.

Another possibility in Scala is to use a \textbf{default value\index{default value}}
for the \inputencoding{latin9}\lstinline!res!\inputencoding{utf8}
argument:\inputencoding{latin9}
\begin{lstlisting}
@tailrec def length[A](s: Seq[A], res: Int = 0): Int = 
  if (s == Seq()) res
  else length(s.tail, 1 + res)
\end{lstlisting}
\inputencoding{utf8}In Scala, giving a default value for a function argument is the same
as defining \emph{two} functions: one with that argument and one without.
For example, the syntax\inputencoding{latin9}
\begin{lstlisting}
def f(x: Int, y: Boolean = false): Int = ... // Function body.
\end{lstlisting}
\inputencoding{utf8}is equivalent to defining two functions (with the same name),\inputencoding{latin9}
\begin{lstlisting}
def f(x: Int, y: Boolean) = ... // Function body.
def f(x: Int): Int = f(Int, false)
\end{lstlisting}
\inputencoding{utf8}Using a default argument value, we can define the tail-recursive helper
function and the adapter function at once, making the code shorter.

The accumulator trick works in a large number of cases, but it may
be far from obvious how to introduce the accumulator argument, what
its initial value must be, and how to define the induction step for
the accumulator. In the example with the \inputencoding{latin9}\lstinline!lengthT!\inputencoding{utf8}
function, the accumulator trick works because of the following mathematical
property of the expression being computed:
\[
1+\left(1+\left(1+\left(...+1\right)\right)\right)=\left(\left(\left(1+1\right)+1\right)+...\right)+1\quad.
\]
This property is called the \textbf{\index{associativity law!of addition}associativity
law} of addition. Due to this law, the computation can be rearranged
so that additions associate to the left. In code, it means that intermediate
expressions are computed immediately before making the recursive calls;
this avoids the growth of the intermediate expressions. 

Usually, the accumulator trick works because some associativity law
is present. In that case, we are able to rearrange the order of recursive
calls so that these calls always occur outside all other sub-expressions,
– that is, in tail positions. However, not all computations obey a
suitable associativity law. Even if a code rearrangement exists, it
may not be immediately obvious how to find it.

As an example, consider a tail-recursive re-implementation of the
function \inputencoding{latin9}\lstinline!digitsToInt!\inputencoding{utf8}
from the previous subsection, where the recursive call is within a
sub-expression \inputencoding{latin9}\lstinline!digitsToInt(xs) * 10 + x!\inputencoding{utf8}.
To transform the code into a tail-recursive form, we need to rearrange
the main computation,
\[
r=d_{n-1}+10*\left(d_{n-2}+10*\left(d_{n-3}+10*\left(...d_{0}\right)\right)\right)\quad,
\]
so that the operations group to the left. We can do this by rewriting
$r$ as
\[
r=\left(\left(d_{0}*10+d_{1}\right)*10+...\right)*10+d_{n-1}\quad.
\]
It follows that the digit sequence \inputencoding{latin9}\lstinline!s!\inputencoding{utf8}
must be split into the \emph{leftmost} digit and the rest, \inputencoding{latin9}\lstinline!s = s.head ++ s.tail!\inputencoding{utf8}.
So, a tail-recursive implementation of the above formula is\inputencoding{latin9}
\begin{lstlisting}
@tailrec def fromDigits(s: Seq[Int], res: Int = 0): Int =
  // `res` is the accumulator.
  if (s == Seq()) res
  else fromDigits(s.tail, 10 * res + s.head)
\end{lstlisting}
\inputencoding{utf8}
Despite a certain similarity between this code and the code of \inputencoding{latin9}\lstinline!digitsToInt!\inputencoding{utf8}
from the previous subsection, the implementation \inputencoding{latin9}\lstinline!fromDigits!\inputencoding{utf8}
cannot be directly derived from the inductive definition of \inputencoding{latin9}\lstinline!digitsToInt!\inputencoding{utf8}.
One needs a separate proof that \inputencoding{latin9}\lstinline!fromDigits(s, 0)!\inputencoding{utf8}
computes the same result as \inputencoding{latin9}\lstinline!digitsToInt(s)!\inputencoding{utf8}.
The proof follows from the following property.

\subsubsection{Statement \label{subsec:Statement-fromdigitsT-equals-fromdigits}\ref{subsec:Statement-fromdigitsT-equals-fromdigits}}

For any \inputencoding{latin9}\lstinline!xs: Seq[Int]!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!r: Int!\inputencoding{utf8},
we have\inputencoding{latin9}
\begin{lstlisting}
fromDigits(xs, r) = digitsToInt(xs) + r * math.pow(10, s.length)
\end{lstlisting}
\inputencoding{utf8}

\subparagraph{Proof}

We prove this by induction. %
\begin{comment}
It is quicker to write this proof in a mathematical notation instead
of the Scala code syntax.
\end{comment}
Let us use a short notation for sequences, $\left[1,2,3\right]$ instead
of \inputencoding{latin9}\lstinline!Seq(1, 2, 3)!\inputencoding{utf8},
and temporarily write $d(s)$ instead of \inputencoding{latin9}\lstinline!digitsToInt(s)!\inputencoding{utf8}
and $f(s,r)$ instead of \inputencoding{latin9}\lstinline!fromDigitsT(s, r)!\inputencoding{utf8}.
Then an inductive definition of $f(s,r)$ is
\begin{equation}
f([],r)=r\quad,\quad\quad f([x]\negmedspace+\negthickspace+s,r)=f(s,10*r+x)\quad.\label{eq:stmt-fromdigitsT-expand-f}
\end{equation}
Denoting by $\left|s\right|$ the length of a sequence $s$, we reformulate
Statement~\ref{subsec:Statement-fromdigitsT-equals-fromdigits} as
\begin{equation}
f(s,r)=d(s)+r*10^{\left|s\right|}\quad,\label{eq:stmt-fromdigitsT-reformulated}
\end{equation}

We prove Eq.~(\ref{eq:stmt-fromdigitsT-reformulated}) by induction.
To prove the base case $s=\left[\right]$, we have $f(\left[\right],r)=r$
and $d(\left[\right])+r*10^{0}=r$ since $d(\left[\right])=0$ and
$\left|s\right|=0$. The resulting equality $r=r$ proves the base
case. 

To prove the inductive step, we assume that Eq.~(\ref{eq:stmt-fromdigitsT-reformulated})
holds for a given sequence $s$; then we need to prove that
\begin{equation}
f([x]\negmedspace+\negthickspace+s,r)=d([x]\negmedspace+\negthickspace+s)+r*10^{\left|s\right|+1}\quad.\label{eq:stmt-need-to-prove-step}
\end{equation}
To prove this, we transform the left-hand side and the right-hand
side separately, hoping that we will obtain the same expression. The
left-hand side of Eq.~(\ref{eq:stmt-need-to-prove-step}):
\begin{align*}
 & f([x]\negmedspace+\negthickspace+s,r)\\
{\color{greenunder}\text{use Eq.~(\ref{eq:stmt-fromdigitsT-expand-f})}:}\quad & =f(s,10*r+x)\\
{\color{greenunder}\text{use Eq.~(\ref{eq:stmt-fromdigitsT-reformulated})}:}\quad & =d(s)+\left(10*r+x\right)*10^{\left|s\right|}\quad.
\end{align*}
The right-hand side of Eq.~(\ref{eq:stmt-need-to-prove-step}) contains
$d([x]\negmedspace+\negthickspace+s)$, which we somehow need to simplify.
Assuming that $d(s)$ correctly calculates a number from its digits,
we can use the basic property of decimal notation, which is that a
digit $x$ in front of $n$ other digits has the value $x*10^{n}$.
This property can be formulated as
\begin{equation}
d([x]\negmedspace+\negthickspace+s)=x*10^{\left|s\right|}+d(s)\quad.\label{stmt-from-digits-property}
\end{equation}
So, the right-hand side of Eq.~(\ref{eq:stmt-need-to-prove-step})
can be rewritten as
\begin{align*}
 & d([x]\negmedspace+\negthickspace+s)+r*10^{\left|s\right|+1}\\
{\color{greenunder}\text{use Eq.~(\ref{stmt-from-digits-property})}:}\quad & =x*10^{\left|s\right|}+d(s)+r*10^{\left|s\right|+1}\\
{\color{greenunder}\text{factor out }10^{\left|s\right|}:}\quad & =d(s)+\left(10*r+x\right)*10^{\left|s\right|}\quad.
\end{align*}
Now we have transformed both sides of Eq.~(\ref{eq:stmt-need-to-prove-step})
to the same expression.

We have not yet proved that the function $d$ satisfies the property
in Eq.~(\ref{stmt-from-digits-property}). The proof uses induction
and begins by writing the code of $d$ in a short notation,
\begin{equation}
d(\left[\right])=0\quad,\quad\quad d(s\negmedspace+\negthickspace+[y])=d(s)*10+y\quad.\label{eq:stmt-fromdigits-code-of-d}
\end{equation}
The base case is Eq.~(\ref{stmt-from-digits-property}) with $s=[]$.
It is proved by
\[
x=d([]\negmedspace+\negthickspace+[x])=d([x]\negmedspace+\negthickspace+[])=x*10^{0}+d(\left[\right])=x\quad.
\]
The induction step assumes Eq.~(\ref{stmt-from-digits-property})
for a given $x$ and a given sequence $s$, and needs to prove that
for any $y$, the same property holds with $s\negmedspace+\negthickspace+[y]$
instead of $s$:
\begin{equation}
d([x]\negmedspace+\negthickspace+s\negmedspace+\negthickspace+[y])=x*10^{\left|s\right|+1}+d(s\negmedspace+\negthickspace+[y])\quad.\label{eq:stmt-from-digits-induction-step}
\end{equation}
The left-hand side of Eq.~(\ref{eq:stmt-from-digits-induction-step})
is transformed into its right-hand side like this:
\begin{align*}
 & d([x]\negmedspace+\negthickspace+s\negmedspace+\negthickspace+[y])\\
{\color{greenunder}\text{use Eq.~(\ref{eq:stmt-fromdigits-code-of-d})}:}\quad & =d([x]\negmedspace+\negthickspace+s)*10+y\\
{\color{greenunder}\text{use Eq.~(\ref{stmt-from-digits-property})}:}\quad & =\left(x*10^{\left|s\right|}+d(s)\right)*10+y\\
{\color{greenunder}\text{expand parentheses}:}\quad & =x*10^{\left|s\right|+1}+d(s)*10+y\\
{\color{greenunder}\text{use Eq.~(\ref{eq:stmt-fromdigits-code-of-d})}:}\quad & =x*10^{\left|s\right|+1}+d(s\negmedspace+\negthickspace+[y])\quad.
\end{align*}
This demonstrates Eq.~(\ref{eq:stmt-from-digits-induction-step})
and so concludes the proof.

\subsection{Implementing generic aggregation (\texttt{foldLeft})\label{subsec:implementing-generic-aggregation-foldleft}}

An \textbf{aggregation}\index{aggregation} converts a sequence of
values into a single value. In general, the type of the result value
may be different from the type of elements in the sequence. To describe
this general situation, we introduce type parameters, \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!B!\inputencoding{utf8}, so that
the input sequence is of type \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8}
and the aggregated value is of type \inputencoding{latin9}\lstinline!B!\inputencoding{utf8}.
Then an inductive definition of any aggregation function \inputencoding{latin9}\lstinline!f: Seq[A] => B!\inputencoding{utf8}
looks like this:
\begin{itemize}
\item (Base case.) For an empty sequence, \inputencoding{latin9}\lstinline!f(Seq()) = b0!\inputencoding{utf8}
where \inputencoding{latin9}\lstinline!b0:B!\inputencoding{utf8}
is a given value.
\item (Induction step.) Assuming that \inputencoding{latin9}\lstinline!f(xs) = b!\inputencoding{utf8}
is already computed, we define \inputencoding{latin9}\lstinline!f(xs ++ Seq(x)) = g(x, b)!\inputencoding{utf8}
where \inputencoding{latin9}\lstinline!g!\inputencoding{utf8} is
a given function with type signature \inputencoding{latin9}\lstinline!g:(A, B) => B!\inputencoding{utf8}.
\end{itemize}
Then the code implementing \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
is written using recursion:\inputencoding{latin9}
\begin{lstlisting}
def f[A, B](s: Seq[A]): B =
  if (s == Seq()) b0
  else g(s.last, f(s.take(s.length - 1)))
\end{lstlisting}
\inputencoding{utf8}We can now refactor this code into a generic utility function, by
making \inputencoding{latin9}\lstinline!b0!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!g!\inputencoding{utf8} into parameters.
A possible implementation is\inputencoding{latin9}
\begin{lstlisting}
def f[A, B](s: Seq[A], b: B, g: (A, B) => B): B =
  if (s == Seq()) b
  else g(s.last, f(s.take(s.length - 1), b, g)
\end{lstlisting}
\inputencoding{utf8}However, this implementation is not tail-recursive. Applying \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
to a sequence of, say, three elements, \inputencoding{latin9}\lstinline!Seq(x, y, z)!\inputencoding{utf8},
will create an intermediate expression \inputencoding{latin9}\lstinline!g(z, g(y, g(x, b)))!\inputencoding{utf8}.
This expression will grow with the length of \inputencoding{latin9}\lstinline!s!\inputencoding{utf8},
which is not acceptable. To rearrange the computation into a tail-recursive
form, we need to start the base case at the innermost call \inputencoding{latin9}\lstinline!g(x, b)!\inputencoding{utf8},
then compute \inputencoding{latin9}\lstinline!g(y, g(x, b))!\inputencoding{utf8}
and continue. In other words, we need to traverse the sequence starting
from its \emph{leftmost} element \inputencoding{latin9}\lstinline!x!\inputencoding{utf8},
rather than starting from the right. So, instead of splitting the
sequence \inputencoding{latin9}\lstinline!s!\inputencoding{utf8}
into \inputencoding{latin9}\lstinline!s.last ++ s.take(s.length - 1)!\inputencoding{utf8}
as we did in the code of \inputencoding{latin9}\lstinline!f!\inputencoding{utf8},
we need to split \inputencoding{latin9}\lstinline!s!\inputencoding{utf8}
into \inputencoding{latin9}\lstinline!s.head ++ s.tail!\inputencoding{utf8}.
Let us also exchange the order of the arguments of \inputencoding{latin9}\lstinline!g!\inputencoding{utf8},
in order to be more consistent with the way this code is implemented
in the Scala library. The resulting code is now tail-recursive:\inputencoding{latin9}
\begin{lstlisting}
@tailrec def leftFold[A, B](s: Seq[A], b: B, g: (B, A) => B): B =
  if (s == Seq()) b
  else leftFold(s.tail, g(b, s.head), g)
\end{lstlisting}
\inputencoding{utf8}This function is called a ``left fold'' because it aggregates (or
``folds'') the sequence starting from the leftmost element.

In this way, we have defined a general method of computing any inductively
defined aggregation function on a sequence. The function \inputencoding{latin9}\lstinline!leftFold!\inputencoding{utf8}
implements the logic of aggregation\index{aggregation} defined via
mathematical induction. Using \inputencoding{latin9}\lstinline!leftFold!\inputencoding{utf8},
we can write concise implementations of methods such as \inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!.max!\inputencoding{utf8}, and
of many other similar aggregation methods. The method \inputencoding{latin9}\lstinline!leftFold!\inputencoding{utf8}
already contains all the code necessary to set up the base case and
the induction step. The programmer just needs to specify the expressions
for the initial value \inputencoding{latin9}\lstinline!b!\inputencoding{utf8}
and for the updater function \inputencoding{latin9}\lstinline!g!\inputencoding{utf8}.

As a first example, let us use \inputencoding{latin9}\lstinline!leftFold!\inputencoding{utf8}
for implementing the \inputencoding{latin9}\lstinline!.sum!\inputencoding{utf8}
method:\inputencoding{latin9}
\begin{lstlisting}
def sum(s: Seq[Int]): Int = leftFold(s, 0, { (x, y) => x + y })
\end{lstlisting}
\inputencoding{utf8}To understand in detail how \inputencoding{latin9}\lstinline!leftFold!\inputencoding{utf8}
works, let us trace the evaluation of this function when applied to
\inputencoding{latin9}\lstinline!Seq(1, 2, 3)!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
sum(Seq(1, 2, 3)) = leftFold(Seq(1, 2, 3), 0, g)
  // Here, g = { (x, y) => x + y }, so g(x, y) = x + y
  = leftFold(Seq(2, 3), g(0, 1), g) // g (0, 1) = 1
  = leftFold(Seq(2, 3), 1, g) // now expand the code of leftFold
  = leftFold(Seq(3), g(1, 2), g) // g(1, 2) = 3; expand the code
  = leftFold(Seq(), g(3, 3), g) // g(3, 3) = 6; expand the code
  = 6
\end{lstlisting}
\inputencoding{utf8}The second argument of \inputencoding{latin9}\lstinline!leftFold!\inputencoding{utf8}
is the accumulator argument. The initial value of the accumulator
is specified when first calling \inputencoding{latin9}\lstinline!leftFold!\inputencoding{utf8}.
At each iteration, the new accumulator value is computed by calling
the updater function \inputencoding{latin9}\lstinline!g!\inputencoding{utf8},
which uses the previous accumulator value and the value of the next
sequence element.

To visualize the process of evaluation, it is convenient to write
a table showing the sequence elements and the accumulator values as
they are updated:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{Current element }\inputencoding{latin9}\lstinline!x!\inputencoding{utf8} & \textbf{Old accumulator value} & \textbf{New accumulator value}\tabularnewline
\hline 
\hline 
\inputencoding{latin9}\lstinline!1!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!0!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!1!\inputencoding{utf8}\tabularnewline
\hline 
\inputencoding{latin9}\lstinline!2!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!1!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!3!\inputencoding{utf8}\tabularnewline
\hline 
\inputencoding{latin9}\lstinline!3!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!3!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!6!\inputencoding{utf8}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

In general, the type of the accumulator value can be different from
the type of the sequence elements. An example is an implementation
of \inputencoding{latin9}\lstinline!count!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def count[A](s: Seq[A], p: A => Boolean): Int =
  leftFold(s, 0, { (x, y) => x + (if (p(y)) 1 else 0) })
\end{lstlisting}
\inputencoding{utf8}The accumulator is of type \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8},
while the sequence elements can have an arbitrary type, parameterized
by \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}. The aggregation
function \inputencoding{latin9}\lstinline!leftFold!\inputencoding{utf8}
works in the same way for all types of accumulators and all types
of sequence elements.

In Scala's standard library, the \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
method has a different type signature and, in particular, requires
its arguments to be in separate argument groups. For comparison, the
implementation of \inputencoding{latin9}\lstinline!sum!\inputencoding{utf8}
using our \inputencoding{latin9}\lstinline!leftFold!\inputencoding{utf8}
function is\inputencoding{latin9}
\begin{lstlisting}
def sum(s: Seq[Int]): Int = leftFold(s, 0, { (x, y) => x + y })
\end{lstlisting}
\inputencoding{utf8}With the Scala library's \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
method, the code is written as\inputencoding{latin9}
\begin{lstlisting}
def sum(s: Seq[Int]): Int = s.foldLeft(0){ (x, y) => x + y }
\end{lstlisting}
\inputencoding{utf8}This syntax makes it more convenient to write nameless functions as
arguments, since the updater argument of \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
is separated from other arguments by curly braces. We will use the
standard \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
method from now on; the \inputencoding{latin9}\lstinline!leftFold!\inputencoding{utf8}
function was implemented only as an illustration.

The method \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
is available in the Scala standard library for all collections, including
dictionaries and sets. It is safe to use \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8},
in the sense that no stack overflows will occur even for very large
sequences.

The Scala library contains several other methods similar to \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8},
such as \inputencoding{latin9}\lstinline!.foldRight!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.reduce!\inputencoding{utf8}.
(However, \inputencoding{latin9}\lstinline!.foldRight!\inputencoding{utf8}
is not tail-recursive!)

\subsection{Solved examples: using \texttt{foldLeft}\index{solved examples}}

It is important to gain experience using the \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
method.

\subsubsection{Example \label{subsec:Example-1-max-foldleft}\ref{subsec:Example-1-max-foldleft}}

Use \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
for implementing the \inputencoding{latin9}\lstinline!max!\inputencoding{utf8}
function for integer sequences. Return the special value \inputencoding{latin9}\lstinline!Int.MinValue!\inputencoding{utf8}
for empty sequences.

\subparagraph{Solution:}

Write an inductive formulation of the \inputencoding{latin9}\lstinline!max!\inputencoding{utf8}
function:
\begin{itemize}
\item (Base case.) For an empty sequence, return \inputencoding{latin9}\lstinline!Int.MinValue!\inputencoding{utf8}.
\item (Inductive step.) If \inputencoding{latin9}\lstinline!max!\inputencoding{utf8}
is already computed on a sequence \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8},
say \inputencoding{latin9}\lstinline!max(xs) = b!\inputencoding{utf8},
the value of \inputencoding{latin9}\lstinline!max!\inputencoding{utf8}
on a sequence \inputencoding{latin9}\lstinline!xs ++ Seq(x)!\inputencoding{utf8}
is \inputencoding{latin9}\lstinline!math.max(b,x)!\inputencoding{utf8}. 
\end{itemize}
Now we can write the code:

\inputencoding{latin9}\begin{lstlisting}
def max(s: Seq[Int]): Int = 
  s.foldLeft(Int.MinValue){ (b, x) => math.max(b, x) }
\end{lstlisting}
\inputencoding{utf8}If we are sure that the function will never be called on empty sequences,
we can implement \inputencoding{latin9}\lstinline!max!\inputencoding{utf8}
in a simpler way by using the \inputencoding{latin9}\lstinline!.reduce!\inputencoding{utf8}
method:\inputencoding{latin9}
\begin{lstlisting}
def max(s: Seq[Int]): Int = s.reduce { (x, y) => math.max(x, y) }
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-2-count-foldleft}\ref{subsec:Example-2-count-foldleft}}

Implement the \inputencoding{latin9}\lstinline!count!\inputencoding{utf8}
method on sequences of type \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8}.

\subparagraph{Solution:}

Using the inductive definition of the function \inputencoding{latin9}\lstinline!count!\inputencoding{utf8}
as shown in Section~\ref{subsec:Inductive-definitions-of-aggregation-functions},
we can write the code as

\inputencoding{latin9}\begin{lstlisting}
def count[A](s: Seq[A], p: A => Boolean): Int =
  s.foldLeft(0){ (b, x) => b + (if (p(x)) 1 else 0) }
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-3-digitstoint-foldleft}\ref{subsec:Example-3-digitstoint-foldleft}}

Implement the function \inputencoding{latin9}\lstinline!digitsToInt!\inputencoding{utf8}
using \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}.

\subparagraph{Solution:}

The inductive definition of \inputencoding{latin9}\lstinline!digitsToInt!\inputencoding{utf8}
is directly translated into code:

\inputencoding{latin9}\begin{lstlisting}
def digitsToInt(d: Seq[Int]): Int = d.foldLeft(0){ (n, x) => n * 10 + x }
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-3-digitstoint-foldleft-1}\ref{subsec:Example-3-digitstoint-foldleft-1}}

For a given non-empty sequence \inputencoding{latin9}\lstinline!xs: Seq[Double]!\inputencoding{utf8},
compute the minimum, the maximum, and the mean as a tuple $\left(x_{\min},x_{\max},x_{\text{mean}}\right)$.
The sequence should be traversed only once, i.e.~we may call \inputencoding{latin9}\lstinline!xs.foldLeft!\inputencoding{utf8}
only once.

\subparagraph{Solution:}

Without the requirement of using a single traversal, we would write\inputencoding{latin9}
\begin{lstlisting}
(xs.min, xs.max, xs.sum / xs.length)
\end{lstlisting}
\inputencoding{utf8}However, this code traverses \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}
at least three times, since each of the aggregations \inputencoding{latin9}\lstinline!xs.min!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!xs.max!\inputencoding{utf8}, and
\inputencoding{latin9}\lstinline!xs.sum!\inputencoding{utf8} iterates
over \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}. We
need to combine the four inductive definitions of \inputencoding{latin9}\lstinline!min!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!max!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!sum!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!length!\inputencoding{utf8}
into a single inductive definition of some function. What is the type
of that function's return value? We need to accumulate intermediate
values of \emph{all four} numbers (\inputencoding{latin9}\lstinline!min!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!max!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!sum!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!length!\inputencoding{utf8})
in a tuple. So the required type of the accumulator is \inputencoding{latin9}\lstinline!(Double, Double, Double, Double)!\inputencoding{utf8}.
To avoid repeating a very long type expression, we can define a type
alias\index{type alias} for it, say, \inputencoding{latin9}\lstinline!D4!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> type D4 = (Double, Double, Double, Double)
defined type alias D4 
\end{lstlisting}
\inputencoding{utf8}The updater function must update each of the four numbers according
to the definitions of their inductive steps:\inputencoding{latin9}
\begin{lstlisting}
def update(p: D4, x: Double): D4 = p match {
  case (min, max, sum, length) =>
   (math.min(x, min), math.max(x, max), x + sum, length + 1)
}
\end{lstlisting}
\inputencoding{utf8}Now we can write the code of the required function:\inputencoding{latin9}
\begin{lstlisting}
def f(xs: Seq[Double]): (Double, Double, Double) = {
  val init: D4 = (Double.PositiveInfinity, Double.NegativeInfinity, 0, 0)
  val (min, max, sum, length) = xs.foldLeft(init)(update)
  (min, max, sum/length)
}

scala> f(Seq(1.0, 1.5, 2.0, 2.5, 3.0))
res0: (Double, Double, Double) = (1.0,3.0,2.0)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-4-digitstodouble-foldleft}\ref{subsec:Example-4-digitstodouble-foldleft}{*}}

Implement the function \inputencoding{latin9}\lstinline!digitsToDouble!\inputencoding{utf8}
using \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}.
The argument is of type \inputencoding{latin9}\lstinline!Seq[Char]!\inputencoding{utf8}.
For example,\inputencoding{latin9}
\begin{lstlisting}
digitsToDouble(Seq('3', '4', '.', '2', '5')) = 34.25
\end{lstlisting}
\inputencoding{utf8}Assume that all characters are either digits or the dot character
(so, negative numbers are not supported).

\subparagraph{Solution:}

The evaluation of a \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
on a sequence of digits will visit the sequence from left to right.
The updating function should work the same as in \inputencoding{latin9}\lstinline!digitsToInt!\inputencoding{utf8}
until a dot character is found. After that, we need to change the
updating function. So, we need to remember whether a dot character
has been seen. The only way for \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
to ``remember'' any data is to hold that data in the accumulator
value. We can choose the type of the accumulator according to our
needs. So, for this task we can choose the accumulator to be a \emph{tuple}
that contains, for instance, the floating-point result constructed
so far and a \inputencoding{latin9}\lstinline!Boolean!\inputencoding{utf8}
flag showing whether we have already seen the dot character.

To visualize what \inputencoding{latin9}\lstinline!digitsToDouble!\inputencoding{utf8}
must do, let us consider how the evaluation of \inputencoding{latin9}\lstinline!digitsToDouble(Seq('3', '4', '.', '2', '5'))!\inputencoding{utf8}
should go. We can write a table showing the intermediate result at
each iteration. This will hopefully help us figure out what the accumulator
and the updater function $g(...)$ must be:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{Current digit $c$} & \textbf{Previous result $n$} & \textbf{New result $n'=g(n,c)$}\tabularnewline
\hline 
\hline 
\inputencoding{latin9}\lstinline!'3'!\inputencoding{utf8} & $0.0$ & $3.0$\tabularnewline
\hline 
\inputencoding{latin9}\lstinline!'4'!\inputencoding{utf8} & $3.0$ & $34.0$\tabularnewline
\hline 
\inputencoding{latin9}\lstinline!'.'!\inputencoding{utf8} & $34.0$ & $34.0$\tabularnewline
\hline 
\inputencoding{latin9}\lstinline!'2'!\inputencoding{utf8} & $34.0$ & $34.2$\tabularnewline
\hline 
\inputencoding{latin9}\lstinline!'5'!\inputencoding{utf8} & $34.2$ & $34.25$\tabularnewline
\hline 
\end{tabular}
\par\end{center}

Until the dot character is found, the updater function multiplies
the previous result by $10$ and adds the current digit. After the
dot character, the updater function must add to the previous result
the current digit divided by a factor that represents increasing powers
of $10$. In other words, the update computation $n'=g(n,c)$ must
be defined by these formulas:
\begin{itemize}
\item Before the dot character: $g(n,c)=n*10+c$.
\item After the dot character: $g(n,c)=n+\frac{c}{f}$, where $f$ is $10$,
$100$, $1000$, etc., for each subsequent digit.
\end{itemize}
The updater function $g$ has only two arguments: the current digit
and the previous accumulator value. So, the changing factor $f$ must
be \emph{part} \emph{of} the accumulator value, and must be multiplied
by $10$ at each digit after the dot. If the factor $f$ is not a
part of the accumulator value, the function $g$ will not have enough
information for computing the next accumulator value correctly. So,
the updater computation must be $n'=g(n,c,f)$, not $n'=g(n,c)$.

For this reason, we choose the accumulator type as a tuple \inputencoding{latin9}\lstinline!(Double, Boolean, Double)!\inputencoding{utf8}
where the first number is the result $n$ computed so far, the \inputencoding{latin9}\lstinline!Boolean!\inputencoding{utf8}
flag indicates whether the dot was already seen, and the third number
is $f$, that is, the power of $10$ by which the current digit will
be divided if the dot was already seen. Initially, the accumulator
tuple will be equal to \inputencoding{latin9}\lstinline!(0.0, false, 10.0)!\inputencoding{utf8}.
Then the updater function is implemented like this:\inputencoding{latin9}
\begin{lstlisting}
def update(acc: (Double, Boolean, Double), c: Char): (Double, Boolean, Double) =
acc match { case (n, flag, factor) =>
  if (c == '.') (n, true, factor) // Set flag to `true` if dot character.
  else {
    val digit = c - '0'
    if (flag) // This digit is after the dot. Update `factor`.
      (n + digit/factor, flag, factor * 10)
    else // This digit is before the dot.
      (n * 10 + digit, flag, factor)
  }
}
\end{lstlisting}
\inputencoding{utf8}Now we can implement \inputencoding{latin9}\lstinline!digitsToDouble!\inputencoding{utf8}
as follows,\inputencoding{latin9}
\begin{lstlisting}
def digitsToDouble(d: Seq[Char]): Double = {
  val initAccumulator = (0.0, false, 10.0)
  val (n, _, _) = d.foldLeft(initAccumulator)(update)
  n
}

scala> digitsToDouble(Seq('3', '4', '.', '2', '5'))
res0: Double = 34.25
\end{lstlisting}
\inputencoding{utf8}The result of calling \inputencoding{latin9}\lstinline!d.foldLeft!\inputencoding{utf8}
is a tuple \inputencoding{latin9}\lstinline!(n, flag, factor)!\inputencoding{utf8},
in which only the first part, \inputencoding{latin9}\lstinline!n!\inputencoding{utf8},
is needed. In Scala's pattern matching expressions, the underscore
symbol is used to denote the pattern variables whose values are not
needed in the subsequent code. We could extract the first part using
the accessor method \inputencoding{latin9}\lstinline!._1!\inputencoding{utf8},
but the code is more readable if we show all parts of the tuple as
\inputencoding{latin9}\lstinline!(n, _, _)!\inputencoding{utf8}.

\subsubsection{Example \label{subsec:Example-foldleft-6}\ref{subsec:Example-foldleft-6}}

Implement the \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
method for sequences by using \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}.
The input sequence should be of type \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8},
and the output sequence of type \inputencoding{latin9}\lstinline!Seq[B]!\inputencoding{utf8},
where \inputencoding{latin9}\lstinline!A!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!B!\inputencoding{utf8} are type
parameters. Here are the required type signature of the function and
a sample test:\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](xs: Seq[A])(f: A => B): Seq[B] = ???

scala> map(List(1, 2, 3)){ x => x * 10 }
res0: Seq[Int] = List(10, 20, 30)
\end{lstlisting}
\inputencoding{utf8}

\subparagraph{Solution:}

The required code should build a new sequence by applying the function
\inputencoding{latin9}\lstinline!f!\inputencoding{utf8} to each element.
How can we build a new sequence using \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}?
The evaluation of \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
consists of iterating over the input sequence and accumulating some
result value, which is updated at each iteration. Since the result
of a \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
is always equal to the last computed accumulator value, it follows
that the new sequence should \emph{be} the accumulator value. So,
we need to update the accumulator by appending the value \inputencoding{latin9}\lstinline!f(x)!\inputencoding{utf8},
where \inputencoding{latin9}\lstinline!x!\inputencoding{utf8} is
the current element of the input sequence. We can append elements
to sequences using the \inputencoding{latin9}\lstinline!:+!\inputencoding{utf8}
operation:\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](xs: Seq[A])(f: A => B): Seq[B] =
  xs.foldLeft(Seq[B]()){ (acc, x) => acc :+ f(x) }
\end{lstlisting}
\inputencoding{utf8}The operation \inputencoding{latin9}\lstinline!acc :+ f(x)!\inputencoding{utf8}
is equivalent to \inputencoding{latin9}\lstinline!acc ++ Seq(f(x))!\inputencoding{utf8}
but is shorter to write.

\subsubsection{Example \label{subsec:Example-foldleft-7}\ref{subsec:Example-foldleft-7}}

Implement a function \inputencoding{latin9}\lstinline!toPairs!\inputencoding{utf8}
that converts a sequence of type \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8}
to a sequence of pairs, \inputencoding{latin9}\lstinline!Seq[(A, A)]!\inputencoding{utf8},
by putting together each pair of adjacent elements. If the initial
sequence has an odd number of elements, a given default value of type
\inputencoding{latin9}\lstinline!A!\inputencoding{utf8} is used:\inputencoding{latin9}
\begin{lstlisting}
def toPairs[A](xs: Seq[A], default: A): Seq[(A, A)] = ???

scala> toPairs(Seq(1, 2, 3, 4, 5, 6), -1)
res0: Seq[(Int, Int)] = List((1,2), (3,4), (5,6))

scala> toPairs(Seq("a", "b", "c"), "<nothing>")
res1: Seq[(String, String)] = List((a,b), (c,<nothing>)) 
\end{lstlisting}
\inputencoding{utf8}

\subparagraph{Solution:}

We need to use \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
to accumulate a sequence of pairs. However, we iterate over elements
of the input sequence one by one. So, a new pair can be added only
once every two iterations. The accumulator needs to hold the information
about the current iteration being even or odd. For odd-numbered iterations,
the accumulator also needs to store the previous element that is still
waiting for its pair. Therefore, we choose the type of the accumulator
to be a tuple \inputencoding{latin9}\lstinline!(Seq[(A, A)], Seq(A))!\inputencoding{utf8}.
The first sequence is the intermediate result, and the second sequence
is the ``remainder'': it holds the previous element for odd-numbered
iterations and is empty for even-numbered iterations. Initially, the
accumulator should be empty. A trace of the accumulator updates is
shown in this table:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{Current element }\inputencoding{latin9}\lstinline!x!\inputencoding{utf8} & \textbf{Previous accumulator} & \textbf{Next accumulator}\tabularnewline
\hline 
\hline 
\inputencoding{latin9}\lstinline!"a"!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!(Seq(), Seq())!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!(Seq(), Seq("a"))!\inputencoding{utf8}\tabularnewline
\hline 
\inputencoding{latin9}\lstinline!"b"!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!(Seq(), Seq("a"))!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!(Seq(("a","b")), Seq())!\inputencoding{utf8}\tabularnewline
\hline 
\inputencoding{latin9}\lstinline!"c"!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!(Seq(("a","b")), Seq())!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!(Seq(("a","b")), Seq("c"))!\inputencoding{utf8}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

Now it becomes clear how to implement the updater function. The code
calls \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
and then performs some post-processing to make sure we create the
last pair in case the last iteration is odd-numbered, i.e.~when the
``remainder'' is not empty after \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
is finished. In this implementation, we use pattern matching to decide
whether a sequence is empty:\inputencoding{latin9}
\begin{lstlisting}
def toPairs[A](xs: Seq[A], default: A): Seq[(A, A)] = {
  type Acc = (Seq[(A, A)], Seq[A]) // Type alias, for brevity.
  def init: Acc = (Seq(), Seq())
  def updater(acc: Acc, x: A): Acc = acc match {
    case (result, Seq()) => (result, Seq(x))
    case (result, Seq(prev)) => (result ++ Seq((prev, x)), Seq())
  }
  val (result, remainder) = xs.foldLeft(init)(updater)
  // May need to append the last element to the result.
  remainder match {
    case Seq() => result
    case Seq(x) => result ++ Seq((x, default))
  }
}
\end{lstlisting}
\inputencoding{utf8}This code shows examples of partial functions that are applied safely.
One of these partial functions is used in the expression\inputencoding{latin9}
\begin{lstlisting}
remainder match {
  case Seq() => ...
  case Seq(a) => ...
}
\end{lstlisting}
\inputencoding{utf8}This code works when \inputencoding{latin9}\lstinline!remainder!\inputencoding{utf8}
is empty or has length $1$, but fails for longer sequences. So it
is safe to apply the partial function as long as it is used on sequences
of length at most $1$, which is indeed the case for the code of \inputencoding{latin9}\lstinline!toPairs!\inputencoding{utf8}.

\subsection{Exercises: Using \texttt{foldLeft}}

\subsubsection{Exercise \label{subsec:Exercise-2.2-foldleft-1}\ref{subsec:Exercise-2.2-foldleft-1}}

Implement a function \inputencoding{latin9}\lstinline!fromPairs!\inputencoding{utf8}
that performs the inverse transformation to the \inputencoding{latin9}\lstinline!toPairs!\inputencoding{utf8}
function defined in Example~\ref{subsec:Example-foldleft-7}. The
required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def fromPairs[A](xs: Seq[(A, A)]): Seq[A] = ???

scala> fromPairs(Seq((1, 2), (3, 4)))
res0: Seq[Int] = List(1, 2, 3, 4)
\end{lstlisting}
\inputencoding{utf8}
Hint: This can be done with \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
or with \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}.

\subsubsection{Exercise \label{subsec:Exercise-2.2-foldleft-2}\ref{subsec:Exercise-2.2-foldleft-2}}

Implement the \inputencoding{latin9}\lstinline!flatten!\inputencoding{utf8}
method for sequences by using \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}.
The required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def flatten[A](xxs: Seq[Seq[A]]): Seq[A] = ???

scala> flatten(Seq(Seq(1, 2, 3), Seq(), Seq(4)))
res0: Seq[Int] = List(1, 2, 3, 4)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:Exercise-2.2-foldleft-3}\ref{subsec:Exercise-2.2-foldleft-3}}

Use \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
to implement the \inputencoding{latin9}\lstinline!zipWithIndex!\inputencoding{utf8}
method for sequences. The required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def zipWithIndex[A](xs: Seq[A]): Seq[(A, Int)] = ???

scala> zipWithIndex(Seq("a", "b", "c", "d"))
res0: Seq[String] = List((a, 0), (b, 1), (c, 2), (d, 3))
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:Exercise-2.2-foldleft-4}\ref{subsec:Exercise-2.2-foldleft-4}}

Use \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
to implement a function \inputencoding{latin9}\lstinline!filterMap!\inputencoding{utf8}
that combines \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}
for sequences. The required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def filterMap[A, B](xs: Seq[A])(pred: A => Boolean)(f: A => B): Seq[B] = ???

scala> filterMap(Seq(1, 2, 3, 4)) { x => x > 2 } { x => x * 10 }
res0: Seq[Int] = List(30, 40)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:Exercise-2.2-foldleft-5}\ref{subsec:Exercise-2.2-foldleft-5}{*}}

Split a sequence into subsequences (``batches'') of length not larger
than a given maximum length $n$. The required type signature and
a sample test are:\inputencoding{latin9}
\begin{lstlisting}
def batching[A](xs: Seq[A], size: Int): Seq[Seq[A]] = ???

scala> batching(Seq("a", "b", "c", "d"), 2)
res0: Seq[Seq[String]] = List(List(a, b), List(c, d))

scala> batching(Seq(1, 2, 3, 4, 5, 6, 7), 3)
res1: Seq[Seq[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7))
\end{lstlisting}
\inputencoding{utf8}\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
def batching[A](xs: Seq[A], size: Int): Seq[Seq[A]] = {  
  type Acc = (Seq[Seq[A]], Seq[A], Int)
  val init: Acc = ((Seq(), Seq(), 0))
  val (result, rem, _) = xs.foldLeft(init){ case ((seq, rem, len), x) =>
    val newLen = len + 1
    if (newLen > size) (seq ++ Seq(rem), Seq(x), 1)
    else (seq, rem ++ Seq(x), newLen)
  }
  result ++ Seq(rem)
}
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{subsec:Exercise-2.2-foldleft-5-1}\ref{subsec:Exercise-2.2-foldleft-5-1}{*}}

Split a sequence into batches by ``weight'' computed via a given
function. The total weight of items in any batch should not be larger
than a given maximum weight. The required type signature and a sample
test:\inputencoding{latin9}
\begin{lstlisting}
def byWeight[A](xs: Seq[A], maxW: Double)(w: A => Double): Seq[Seq[A]] = ???

scala> byWeight((1 to 10).toList, 5.75){ x => math.sqrt(x) }
res0: Seq[Seq[Int]] = List(List(1, 2, 3), List(4, 5), List(6, 7), List(8), List(9), List(10))
\end{lstlisting}
\inputencoding{utf8}\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
def weightBatching[A](xs: Seq[A], maxW: Double)(w: A => Double): Seq[Seq[A]] = {  
  type Acc = (Seq[Seq[A]], Seq[A], Double)
  val init: Acc = ((Seq(), Seq(), 0.0))
  val (result, rem, _) = xs.foldLeft(init) { case ((seq, rem, weight), x) =>
    val wx = w(x)
    if (wx > maxW) (seq ++ Seq(rem, Seq(x)), Seq(), 0.0)
    else {
      val newWeight = weight + wx
      if (newWeight > maxW) (seq ++ Seq(rem), Seq(x), wx)
      else (seq, rem ++ Seq(x), newWeight)
    }
  }
  result ++ Seq(rem)
}
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{subsec:Exercise-2.2-foldleft-6}\ref{subsec:Exercise-2.2-foldleft-6}{*}}

Use \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
to implement a \inputencoding{latin9}\lstinline!groupBy!\inputencoding{utf8}
function. The required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def groupBy[A, K](xs: Seq[A])(by: A => K): Map[K, Seq[A]] = ???

scala> groupBy(Seq(1, 2, 3, 4, 5)){ x => x % 2 }
res0: Map[Int, Seq[Int]] = Map(1 -> List(1, 3, 5), 0 -> List(2, 4))
\end{lstlisting}
\inputencoding{utf8}
Hints: 

The accumulator should be of type \inputencoding{latin9}\lstinline!Map[K, Seq[A]]!\inputencoding{utf8}. 

To work with dictionaries, you will need to use the methods \inputencoding{latin9}\lstinline!.getOrElse!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.updated!\inputencoding{utf8}.
The method \inputencoding{latin9}\lstinline!.getOrElse!\inputencoding{utf8}
fetches a value from a dictionary by key, and returns the given default
value if the dictionary does not contain that key:\inputencoding{latin9}
\begin{lstlisting}
scala> Map("a" -> 1, "b" -> 2).getOrElse("a", 300)
res0: Int = 1

scala> Map("a" -> 1, "b" -> 2).getOrElse("c", 300)
res1: Int = 300
\end{lstlisting}
\inputencoding{utf8}The method \inputencoding{latin9}\lstinline!.updated!\inputencoding{utf8}
produces a new dictionary that contains a new value for the given
key, whether or not that key already exists in the dictionary:\inputencoding{latin9}
\begin{lstlisting}
scala> Map("a" -> 1, "b" -> 2).updated("c", 300) // Key is new.
res0: Map[String,Int] = Map(a -> 1, b -> 2, c -> 300)

scala> Map("a" -> 1, "b" -> 2).updated("a", 400) // Key already exists.
res1: Map[String,Int] = Map(a -> 400, b -> 2) 
\end{lstlisting}
\inputencoding{utf8}\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
def groupBy[A, K](xs: Seq[A])(by: A => K): Map[K, Seq[A]] = {  
  val init: Map[K, Seq[A]] = Map()
  xs.foldLeft(init) { (res, x) =>
    val key = by(x)
    val seq = res.getOrElse(key, Seq()) ++ Seq(x)
    res.updated(key, seq)
  }
}
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\section{Converting a single value into a sequence\label{sec:ch2Converting-a-single}}

An aggregation converts or ``folds'' a sequence into a single value;
the opposite operation (``unfolding'') converts a single value into
a sequence. An example of this task is to compute the sequence of
decimal digits for a given integer:\inputencoding{latin9}
\begin{lstlisting}
def digitsOf(x: Int): Seq[Int] = ???

scala> digitsOf(2405)
res0: Seq[Int] = List(2, 4, 0, 5)
\end{lstlisting}
\inputencoding{utf8}We cannot implement this function using \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8}, or \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8},
because these methods may be applied only if we \emph{already have}
a sequence. A new sequence can be created, e.g., via the expression
\inputencoding{latin9}\lstinline!(1 to n)!\inputencoding{utf8}, but
we do not know in advance how long the required sequence must be.
The length of the required sequence is determined by a condition that
we cannot easily evaluate in advance.

A general ``unfolding'' operation requires us to build a sequence
whose length is not determined in advance. This kind of sequence is
called an \textbf{\index{stream}stream}. A stream is a sequence whose
elements are computed only when necessary (unlike sequences such as
a \inputencoding{latin9}\lstinline!List!\inputencoding{utf8} or an
\inputencoding{latin9}\lstinline!Array!\inputencoding{utf8}, whose
elements are all computed in advance and stored). The unfolding operation
will keep computing the next element; this creates a stream. We can
then apply \inputencoding{latin9}\lstinline!.takeWhile!\inputencoding{utf8}
to the stream, in order to stop it when a certain condition holds.
Finally, if required, the truncated stream may be converted to a list
or to another type of sequence. In this way, we can generate a sequence
of initially unknown length according to the given requirements.

A general stream-producing function \inputencoding{latin9}\lstinline!Stream.iterate!\inputencoding{utf8}
is available in the Scala library. This function has two arguments,
the initial value and a function that computes the next value from
the previous one:\inputencoding{latin9}
\begin{lstlisting}
scala> Stream.iterate(2){ x => x + 10 }
res0: Stream[Int] = Stream(2, ?)
\end{lstlisting}
\inputencoding{utf8}The stream is ready to start computing the next elements of the sequence
(so far, only the first element, \inputencoding{latin9}\lstinline!2!\inputencoding{utf8},
has been computed). In order to see the next elements, we need to
stop the stream at a finite size and then convert the result to a
list:\inputencoding{latin9}
\begin{lstlisting}
scala> Stream.iterate(2){ x => x + 10 }.take(6).toList
res1: List[Int] = List(2, 12, 22, 32, 42, 52)
\end{lstlisting}
\inputencoding{utf8}If we try to evaluate \inputencoding{latin9}\lstinline!.toList!\inputencoding{utf8}
on a stream without first limiting its size via \inputencoding{latin9}\lstinline!.take!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!.takeWhile!\inputencoding{utf8},
the program will keep producing more and more elements of the stream,
until it runs out of memory and crashes.

Streams are similar to sequences, and methods such as \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
are also defined for streams. For instance, we can use the method
\inputencoding{latin9}\lstinline!.drop!\inputencoding{utf8} that
skips a given number of initial elements:\inputencoding{latin9}
\begin{lstlisting}
scala> Seq(10, 20, 30, 40, 50).drop(3)
res2: Seq[Int] = List(40, 50)

scala> Stream.iterate(2){ x => x + 10 }.drop(3)
res3: Stream[Int] = Stream(32, ?)
\end{lstlisting}
\inputencoding{utf8}This example shows that in order to evaluate \inputencoding{latin9}\lstinline!.drop(3)!\inputencoding{utf8},
the stream had to compute its elements up to \inputencoding{latin9}\lstinline!32!\inputencoding{utf8}
(but the subsequent elements are still not computed).

To figure out the code for \inputencoding{latin9}\lstinline!digitsOf!\inputencoding{utf8},
we first write this function as a mathematical formula. To compute
the sequence of digits for, say, $n=2405$, we need to divide $n$
repeatedly by $10$, getting a sequence $n_{k}$ of intermediate numbers
($n_{0}=2405$, $n_{1}=240$, ...) and the corresponding sequence
of last digits, $n_{k}\text{ mod }10$ (in this example: $5$, $0$,
...). The sequence $n_{k}$ is defined using mathematical induction:
\begin{itemize}
\item Base case: $n_{0}=n$, where $n$ is the given initial integer.
\item Inductive step: $n_{k+1}=\left\lfloor \frac{n_{k}}{10}\right\rfloor \ \text{for}\ k=1,2,...$
\end{itemize}
Here $\left\lfloor \frac{n_{k}}{10}\right\rfloor $ is the mathematical
notation for the integer division by $10$. 

Let us trace the evaluation of the sequence $n_{k}$ for $n=2405$:
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline 
$k=$ & $0$ & $1$ & $2$ & $3$ & $4$ & $5$ & $6$\tabularnewline
\hline 
$n_{k}=$ & $2405$ & $240$ & $24$ & $2$ & $0$ & $0$ & $0$\tabularnewline
\hline 
$n_{k}\text{ mod }10=$ & $5$ & $0$ & $4$ & $2$ & $0$ & $0$ & $0$\tabularnewline
\hline 
\end{tabular}
\par\end{center}

The numbers $n_{k}$ will remain all zeros after $k=4$. It is clear
that the useful part of the sequence is before it becomes all zeros.
In this example, the sequence $n_{k}$ needs to be stopped at $k=4$.
The sequence of digits then becomes $\left[5,0,4,2\right]$, and we
need to reverse it to obtain $\left[2,4,0,5\right]$. For reversing
a sequence, the Scala library has the standard method \inputencoding{latin9}\lstinline!.reverse!\inputencoding{utf8}.
So the code is\inputencoding{latin9}
\begin{lstlisting}
def digitsOf(n: Int): Seq[Int] =
  if (n == 0) Seq(0) else { // n == 0 is a special case.
    Stream.iterate(n) { nk => nk / 10 }
      .takeWhile { nk => nk != 0 }
      .map { nk => nk % 10 }
      .toList.reverse
  }
\end{lstlisting}
\inputencoding{utf8}By writing nameless functions such as \inputencoding{latin9}\lstinline!{ nk => nk % 10 }!\inputencoding{utf8}
in a shorter syntax such as \inputencoding{latin9}\lstinline!(_ % 10)!\inputencoding{utf8},
we can shorten the code of \inputencoding{latin9}\lstinline!digitsOf!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def digitsOf(n: Int): Seq[Int] =
  if (n == 0) Seq(0) else { // n == 0 is a special case.
    Stream.iterate(n)(_ / 10)
      .takeWhile(_ != 0)
      .map(_ % 10)
      .toList.reverse
  }
\end{lstlisting}
\inputencoding{utf8}
The type signature of the method \inputencoding{latin9}\lstinline!Stream.iterate!\inputencoding{utf8}
can be written as\inputencoding{latin9}
\begin{lstlisting}
def iterate[A](init: A)(next: A => A): Stream[A]
\end{lstlisting}
\inputencoding{utf8}This shows how \inputencoding{latin9}\lstinline!Stream.iterate!\inputencoding{utf8}
constructs a sequence defined by mathematical induction. The base
case is the first value, \inputencoding{latin9}\lstinline!init!\inputencoding{utf8},
and the inductive step is a function, \inputencoding{latin9}\lstinline!next!\inputencoding{utf8},
that computes the next element from the previous one. It is a flexible
way of generating sequences whose length is not determined in advance.

\section{Transforming a sequence into another sequence}

We have seen methods such as \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8} that
transform sequences into sequences. However, these methods cannot
express a general transformation where the elements of the new sequence
are defined by induction, depending on previous elements. An example
of a task of this kind is to compute the partial sums of a given sequence
$x_{i}$: 
\[
b_{k}=\sum_{i=0}^{k-1}x_{i}\quad.
\]
This formula defines $b_{0}=0$, $b_{1}=x_{0}$, $b_{2}=x_{0}+x_{1}$,
$b_{3}=x_{0}+x_{1}+x_{2}$, etc. A definition via mathematical induction
may be written like this,
\begin{itemize}
\item (Base case.) $b_{0}=0$.
\item (Induction step.) Given $b_{k}$, we define $b_{k+1}=b_{k}+x_{k}$
for $k=0,1,2,...$
\end{itemize}
The Scala library method \inputencoding{latin9}\lstinline!.scanLeft!\inputencoding{utf8}
implements a general sequence-to-sequence transformation defined in
this way. The code implementing the partial sums is\inputencoding{latin9}
\begin{lstlisting}
def partialSums(xs: Seq[Int]): Seq[Int] = xs.scanLeft(0){ (x, y) => x + y }

scala> partialSums(Seq(1, 2, 3, 4))
res0: Seq[Int] = List(0, 1, 3, 6, 10)
\end{lstlisting}
\inputencoding{utf8}The first argument of \inputencoding{latin9}\lstinline!.scanLeft!\inputencoding{utf8}
is the base case, and the second argument is an updater function describing
the induction step. In general, the type of elements of the second
sequence is different from that of the first sequence. The updater
function takes an element of the first sequence and a previous element
of the second sequence, and returns the next element of the second
sequence. Note that the result of \inputencoding{latin9}\lstinline!.scanLeft!\inputencoding{utf8}
is one element longer than the original sequence, because the base
case provides an initial value.

Until now, we have seen that \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
is sufficient to re-implement almost every method that work on sequences,
such as \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}, or
\inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}. The
method \inputencoding{latin9}\lstinline!.scanLeft!\inputencoding{utf8}
can be also implemented via \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}.
In the implementation, the accumulator contains the previous element
of the second sequence together with a growing fragment of that sequence,
which is updated as we iterate over the first sequence. The code (shown
here only as illustration) is\inputencoding{latin9}
\begin{lstlisting}
def scanLeft[A, B](xs: Seq[A])(b0: B)(next: (B, A) => B): Seq[B] = {
  val init: (B, Seq[B]) = (b0, Seq(b0))
  val (_, result) = xs.foldLeft(init){ case ((b, seq), x) =>
    val newB = next(b, x)
    (newB, seq ++ Seq(newB))
  }
  result
}
\end{lstlisting}
\inputencoding{utf8}To define the (nameless) updater function for \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8},
we used the Scala feature that makes it easier to define functions
with several arguments containing tuples. In our case, the updater
function in \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
has two arguments: the first is a tuple \inputencoding{latin9}\lstinline!(B, Seq[B])!\inputencoding{utf8},
the second is a value of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}.
The pattern matching expression \inputencoding{latin9}\lstinline!{ case ((b, seq), x) => ... }!\inputencoding{utf8}
appears to match against a nested tuple\index{tuples!nested}. In
reality, this expression matches the two arguments of the updater
function and, at the same time, destructures the tuple argument as
\inputencoding{latin9}\lstinline!(b, seq)!\inputencoding{utf8}. 

\section{Summary}

We have seen a broad overview of translating mathematical induction
into Scala code. What problems can we solve now?
\begin{itemize}
\item Compute mathematical expressions involving arbitrary recursion.
\item Use the accumulator trick to enforce tail recursion.
\item Use arbitrary inductive (i.e.\ recursive) formulas to:
\begin{itemize}
\item convert sequences to single values (``aggregation'');
\item create new sequences from single values;
\item transform existing sequences into new sequences.
\end{itemize}
\end{itemize}
Table~\ref{tab:Implementing-mathematical-induction} summarizes Scala
methods implementing those tasks.

\begin{table}
\begin{centering}
\begin{tabular}{|c|c|}
\hline 
\textbf{Definition via mathematical induction} & \textbf{Scala code example}\tabularnewline
\hline 
\hline 
$f(\left[\right])=b~;~~f(s\negmedspace+\negthickspace+[x])=g(f(s),x)$ & \inputencoding{latin9}\lstinline!f(xs) = xs.foldLeft(b)(g)!\inputencoding{utf8}\tabularnewline
\hline 
$x_{0}=b~;~~x_{k+1}=g(x_{k})$ & \inputencoding{latin9}\lstinline!xs = Stream.iterate(b)(g)!\inputencoding{utf8}\tabularnewline
\hline 
$y_{0}=b~;~~y_{k+1}=g(y_{k},x_{k})$ & \inputencoding{latin9}\lstinline!ys = xs.scanLeft(b)(g)!\inputencoding{utf8}\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{Implementing mathematical induction.\label{tab:Implementing-mathematical-induction}}
\end{table}

Using these methods, any iterative calculation is implemented by translating
mathematical induction directly into code. In the functional programming
paradigm, the programmer does not need to write any loops or check
any array indices. Instead, the programmer reasons about sequences
as mathematical values: ``Starting from this value, we get that sequence,
then transform it into this other sequence,'' etc. This is a powerful
way of working with sequences, dictionaries, and sets. Many kinds
of programming errors (such as an incorrect array index) are avoided
from the outset, and the code is shorter and easier to read than conventional
code written using loops.

\paragraph*{What tasks are not possible with these tools?}

We cannot implement a non-tail-recursive function without stack overflow
(i.e.~without unlimited growth of intermediate expressions). The
accumulator trick does not always work! In some cases, it is impossible
to implement tail recursion in a given recursive computation. An example
of such a computation is the ``merge-sort'' algorithm where the
function body must contain two recursive calls within a single expression.
(It is impossible to rewrite \emph{two} recursive calls as one!) 

What if our recursive code cannot be transformed into tail-recursive
code via the accumulator trick, but the depth of the recursion is
so large that stack overflows are possible? We must then use more
advanced tricks (for instance, the ``continuation-passing\index{continuation-passing}''
or ``trampolines\index{trampolines}'') that convert non-tail-recursive
code into iterative code without stack overflows. These tricks are
beyond the scope of this chapter.

\subsection{Solved examples\index{solved examples}}

\subsubsection{Example \label{subsec:ch2Example-seq-1}\ref{subsec:ch2Example-seq-1}}

Compute the smallest $n$ such that $f(f(f(...f(1)...)\geq1000$,
where the function $f$ is applied $n$ times. Write this as a function
taking $f$, $1$, and $1000$ as arguments. Test with $f(x)=2x+1$.

\subparagraph{Solution:}

We define a stream of values $\left[1,f(1),f(f(1)),...\right]$ and
use \inputencoding{latin9}\lstinline!.takeWhile!\inputencoding{utf8}
to stop the stream when the given condition holds. The \inputencoding{latin9}\lstinline!.length!\inputencoding{utf8}
method then gives the length of the resulting sequence: \inputencoding{latin9}
\begin{lstlisting}
scala> Stream.iterate(1)(x => 2*x+1).takeWhile(x => x < 1000).toList
res0: List[Int] = List(1, 3, 7, 15, 31, 63, 127, 255, 511)

scala> Stream.iterate(1)(x => 2*x+1).takeWhile(x => x < 1000).length
res1: Int = 9
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:ch2Example-seq-2}\ref{subsec:ch2Example-seq-2}}

\textbf{(a)} For a given stream of integers, compute the stream of
the largest values seen so far.

\textbf{(b)} Compute the stream of $k$ largest values seen so far
($k$ is a given integer parameter).

\subparagraph{Solution:}

We cannot use \inputencoding{latin9}\lstinline!.max!\inputencoding{utf8}
or sort the entire stream, since the length of the stream is not known
in advance. So we need to use \inputencoding{latin9}\lstinline!.scanLeft!\inputencoding{utf8},
which will build the output stream one element at a time.

\textbf{(a)} Maintain the largest value seen so far in the accumulator
of the \inputencoding{latin9}\lstinline!.scanLeft!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def maxSoFar(xs: Stream[Int]): Stream[Int] =
  xs.scanLeft(xs.head){ case (max, x) => math.max(max, x) }
    .drop(1)
\end{lstlisting}
\inputencoding{utf8}We use \inputencoding{latin9}\lstinline!.drop(1)!\inputencoding{utf8}
to remove the initial value, \inputencoding{latin9}\lstinline!xs.head!\inputencoding{utf8},
because it is not useful for our result but is necessary for the definition
of \inputencoding{latin9}\lstinline!.scanLeft!\inputencoding{utf8}.

To test this function, let us define a stream whose values go up and
down:\inputencoding{latin9}
\begin{lstlisting}
scala> val s = Stream.iterate(0)(x => 1 - 2*x)
s: Stream[Int] = Stream(0, ?)

scala> s.take(10).toList
res0: List[Int] = List(0, 1, -1, 3, -5, 11, -21, 43, -85, 171)

scala> maxSoFar(s).take(10).toList
res1: List[Int] = List(0, 1, 1, 3, 3, 11, 11, 43, 43, 171)
\end{lstlisting}
\inputencoding{utf8}
\textbf{(b)} We again use \inputencoding{latin9}\lstinline!.scanLeft!\inputencoding{utf8},
where now the accumulator needs to keep the largest $k$ values seen
so far. There are two ways of maintaining this accumulator: First,
to have a sequence of $k$ values that we sort and truncate each time.
Second, to use a specialized data structure such as a priority queue
that automatically keeps values sorted and its length bounded. For
the purposes of this tutorial, let us avoid using specialized data
structures:\inputencoding{latin9}
\begin{lstlisting}
def maxKSoFar(xs: Stream[Int], k: Int): Stream[Seq[Int]] = {
  // The initial value of the accumulator is an empty Seq() of type Seq[Int].
  xs.scanLeft(Seq[Int]()) { case (seq, x) =>
  // Sort in the descending order, and take the first k values.
    (seq :+ x).sorted.reverse.take(k)
  }.drop(1) // Skip the useless first value.
}

scala> maxKSoFar(s, 3).take(10).toList
res2: List[Seq[Int]] = List(List(0), List(1, 0), List(1, 0, -1), List(3, 1, 0), List(3, 1, 0), List(11, 3, 1), List(11, 3, 1), List(43, 11, 3), List(43, 11, 3), List(171, 43, 11)) 
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:ch2Example-seq-3}\ref{subsec:ch2Example-seq-3}}

Find the last element of a non-empty sequence. (Use \inputencoding{latin9}\lstinline!.reduce!\inputencoding{utf8}.)

\subparagraph{Solution:}

This function is available in the Scala library as the standard method
\inputencoding{latin9}\lstinline!.last!\inputencoding{utf8} on sequences.
Here we need to re-implement it using \inputencoding{latin9}\lstinline!.reduce!\inputencoding{utf8}.
Begin by writing an inductive definition:
\begin{itemize}
\item (Base case.) \inputencoding{latin9}\lstinline!last(Seq(x)) = x!\inputencoding{utf8}.
\item (Inductive step.) \inputencoding{latin9}\lstinline!last(Seq(x) ++ xs) = last(xs)!\inputencoding{utf8}
assuming \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}
is non-empty.
\end{itemize}
The \inputencoding{latin9}\lstinline!.reduce!\inputencoding{utf8}
method implements an inductive aggregation similarly to \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8},
except that for \inputencoding{latin9}\lstinline!.reduce!\inputencoding{utf8}
the base case is fixed – it always returns \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
for a 1-element sequence \inputencoding{latin9}\lstinline!Seq(x)!\inputencoding{utf8}.
This is exactly what we need here, so the inductive definition is
directly translated into code, with the updater function $g(x,y)=y$:\inputencoding{latin9}
\begin{lstlisting}
def last[A](xs: Seq[A]): A = xs.reduce { case (x, y) => y }
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:ch2Example-binary-search-seq-4}\ref{subsec:ch2Example-binary-search-seq-4}}

\textbf{(a)} Using tail recursion, implement the binary search algorithm
in a given sorted sequence \inputencoding{latin9}\lstinline!xs: Seq[Int]!\inputencoding{utf8}
as a function returning the index of the requested number \inputencoding{latin9}\lstinline!n!\inputencoding{utf8}
(assume that \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}
contains the number \inputencoding{latin9}\lstinline!n!\inputencoding{utf8}):\inputencoding{latin9}
\begin{lstlisting}
def binSearch(xs: Seq[Int], goal: Int): Int = ???

scala> binSearch(Seq(1, 3, 5, 7), 5)
res0: Int = 2
\end{lstlisting}
\inputencoding{utf8}
\textbf{(b)} Re-implement \inputencoding{latin9}\lstinline!binSearch!\inputencoding{utf8}
using \inputencoding{latin9}\lstinline!Stream.iterate!\inputencoding{utf8}
instead of explicit recursion.

\subparagraph{Solution:}

\textbf{(a)} The well-known binary search algorithm splits the array
into two halves and may continue the search recursively in one of
the halves. We need to write the solution as a tail-recursive function
with an additional accumulator argument. So we expect that the code
should look like this,\inputencoding{latin9}
\begin{lstlisting}
def binSearch(xs: Seq[Int], goal: Int, acc: _ = ???): Int = {
  if (???are we done???) acc
  else {
    // Determine which half of the sequence contains `goal`.
    // Then update the accumulator accordingly.
    val newAcc = ???
    binSearch(xs, goal, newAcc) // Tail-recursive call.
  }
}
\end{lstlisting}
\inputencoding{utf8}It remains to determine the type and the initial value of the accumulator,
as well as the code for updating it.

The information required for the recursive call is the remaining segment
of the sequence where the target number is present. This segment is
defined by two indices $i$, $j$ representing the left and the right
bounds of the sub-sequence, such that the target element is $x_{n}$
with $x_{i}\leq x_{n}<x_{j-1}$. It follows that the accumulator should
be a pair of two integers $\left(i,j\right)$. The initial value of
the accumulator is the pair $\left(0,N\right)$ where $N$ is the
length of the entire sequence. The search is finished when $i+1=j$.
We can now write the corresponding code, where for convenience we
introduce \emph{two} accumulator values:\inputencoding{latin9}
\begin{lstlisting}
@tailrec def binSearch(xs: Seq[Int], goal: Int)(left: Int = 0,
                       right: Int = xs.length): Int = {
  // Check whether `goal` is at one of the boundaries.
  if (right - left <= 1 || xs(left) == goal) left
  else {
    val middle = (left + right) / 2
    // Determine which half of the array contains `target`.
    // Update the accumulator accordingly.
    val (newLeft, newRight) =
      if (goal < xs(middle)) (left, middle)
      else (middle, right)
    binSearch(xs, goal)(newLeft, newRight) // Tail-recursive call.
  }
}

scala> binSearch(0 to 10, 3)() // Default accumulator values.
res0: Int = 3
\end{lstlisting}
\inputencoding{utf8}Here we used a feature of Scala that allows us to use \inputencoding{latin9}\lstinline!xs.length!\inputencoding{utf8}
as a default value for the argument \inputencoding{latin9}\lstinline!right!\inputencoding{utf8}
of \inputencoding{latin9}\lstinline!binSearch!\inputencoding{utf8}.
This is possible only because \inputencoding{latin9}\lstinline!right!\inputencoding{utf8}
is in a different \textbf{argument group}\index{argument group} from
\inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}. In Scala,
values in an argument group may depend on arguments given in a \emph{previous}
argument group. However, the code\inputencoding{latin9}
\begin{lstlisting}
def binSearch(xs: Seq[Int], goal: Int, left: Int = 0, right: Int = xs.length)
\end{lstlisting}
\inputencoding{utf8}will generate an error: the arguments in the same argument group cannot
depend on each other. (The error will say \inputencoding{latin9}\lstinline!not found: value xs!\inputencoding{utf8}.)

\textbf{(b)} We can visualize the binary search as a procedure that
generates a sequence of progressively tighter bounds for the location
of \inputencoding{latin9}\lstinline!goal!\inputencoding{utf8}. The
initial bounds are \inputencoding{latin9}\lstinline!(0, xs.length)!\inputencoding{utf8},
and the final bounds are \inputencoding{latin9}\lstinline!(k, k+1)!\inputencoding{utf8}
for some \inputencoding{latin9}\lstinline!k!\inputencoding{utf8}.
We can generate the sequence of bounds using \inputencoding{latin9}\lstinline!Stream.iterate!\inputencoding{utf8}
and stop the sequence when the bounds become sufficiently tight. To
make the use of \inputencoding{latin9}\lstinline!.takeWhile!\inputencoding{utf8}
more convenient, we add an extra sequence element where the bounds
\inputencoding{latin9}\lstinline!(k, k)!\inputencoding{utf8} are
equal. The code becomes\inputencoding{latin9}
\begin{lstlisting}
def binSearch(xs: Seq[Int], goal: Int): Int = {
  type Acc = (Int, Int)
  val init: Acc = (0, xs.length)
  val updater: Acc => Acc = { case (left, right) =>
    if (right - left <= 1) (left, left) // Extra element.
    else if (xs(left) == goal) (left, left + 1)
    else {
      val middle = (left + right) / 2
      // Determine which half of the array contains `target`.
      // Update the accumulator accordingly.
      if (goal < xs(middle)) (left, middle)
      else (middle, right)
    }
  }
  Stream.iterate(init)(updater)
    .takeWhile{ case (left, right) => right > left }
    .last._1 // Take the `left` boundary from the last element.
}
\end{lstlisting}
\inputencoding{utf8}This code is clearer because recursion is delegated to \inputencoding{latin9}\lstinline!Stream.iterate!\inputencoding{utf8},
and we only need to write the ``business logic'' (i.e.~the base
case and the inductive step) of our function. 

\subsubsection{Example \label{subsec:ch2sumdigitsExample-seq-5}\ref{subsec:ch2sumdigitsExample-seq-5}}

For a given positive \inputencoding{latin9}\lstinline!n:Int!\inputencoding{utf8},
compute the sequence $\left[s_{0},s_{1},s_{2},...\right]$ defined
by $s_{0}=SD(n)$ and $s_{k}=SD(s_{k-1})$ for $k>0$, where $SD(x)$
is the sum of the decimal digits of the integer $x$, e.g. $SD(123)=6$.
Stop the sequence $s_{i}$ when the numbers begin repeating. For example,
$SD(99)=18$, $SD(18)=9$, $SD(9)=9$. So, for $n=99$, the sequence
$s_{i}$ must be computed as $\left[99,18,9\right]$.

Hint: use \inputencoding{latin9}\lstinline!Stream.iterate!\inputencoding{utf8};
compute the decimal digits in the reverse order since the sum will
be the same.

\subparagraph{Solution:}

We need to implement a function \inputencoding{latin9}\lstinline!sdSeq!\inputencoding{utf8}
having the type signature\inputencoding{latin9}
\begin{lstlisting}
def sdSeq(n: Int): Seq[Int]
\end{lstlisting}
\inputencoding{utf8}First we need to implement $SD(x)$. The sum of digits is obtained
by almost the same code as in Section~\ref{sec:ch2Converting-a-single}:\inputencoding{latin9}
\begin{lstlisting}
def SD(n: Int): Int = if (n == 0) 0 else
  Stream.iterate(n)(_ / 10).takeWhile(_ != 0).map(_ % 10).sum
\end{lstlisting}
\inputencoding{utf8}Now we can try evaluating $SD$ on some numbers to see its behavior:\inputencoding{latin9}
\begin{lstlisting}
scala> (1 to 15).toList.map(SD)
res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6)
\end{lstlisting}
\inputencoding{utf8}It is clear that $SD(n)<n$ as long as $n\geq10$. So the sequence
elements $s_{i}$ will not repeat until they become smaller than $10$,
and then they will always repeat. This seems to be an easy way of
stopping the sequence. Let us try that:\inputencoding{latin9}
\begin{lstlisting}
scala> Stream.iterate(99)(SD).takeWhile(x => x >= 10).toList
res1: List[Int] = List(99, 18)
\end{lstlisting}
\inputencoding{utf8}We are missing the last element of the sequence, $SD(18)=9$, because
\inputencoding{latin9}\lstinline!.takeWhile!\inputencoding{utf8}
stops the sequence too early. In order to obtain the correct sequence,
we need to compute one more element. To fix this, we can generate
a stream of \emph{pairs}:\inputencoding{latin9}
\begin{lstlisting}
scala> Stream.iterate((0, 99)){ case (prev, x) => (x, SD(x)) }.
  takeWhile{ case (prev, x) => prev >= 10 || x >= 10 }.toList
res2: List[(Int, Int)] = List((0,99), (99,18), (18,9))
\end{lstlisting}
\inputencoding{utf8}This looks right; it remains to remove the first parts of the tuples:\inputencoding{latin9}
\begin{lstlisting}
def sdSeq(n: Int): Seq[Int] =
  Stream.iterate((0, n)){ case (prev, x) => (x, SD(x)) } // Stream[(Int, Int)]
    .takeWhile{ case (prev, x) => prev >= 10 || x >= 10 } // Stream[(Int, Int)]
    .map(_._2) // Stream[Int]
    .toList // List[Int]

scala> sdSeq(99)
res3: Seq[Int] = List(99, 18, 9)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:ch2Example-seq-6}\ref{subsec:ch2Example-seq-6}}

For a given stream $\left[s_{0},s_{1},s_{2},...\right]$ of type \inputencoding{latin9}\lstinline!Stream[T]!\inputencoding{utf8},
compute the ``half-speed'' stream $h=\left[s_{0},s_{0},s_{1},s_{1},s_{2},s_{2},...\right]$.
(The half-speed sequence $h$ can be defined by the formula $s_{k}=h_{2k}=h_{2k+1}$.)

\subparagraph{Solution:}

We use \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
to replace each element $s_{i}$ by a sequence containing two copies
of $s_{i}$. Let us try this on a sample sequence:\inputencoding{latin9}
\begin{lstlisting}
scala> Seq(1,2,3).map( x => Seq(x, x))
res0: Seq[Seq[Int]] = List(List(1, 1), List(2, 2), List(3, 3))
\end{lstlisting}
\inputencoding{utf8}The result is almost what we need, except we need to \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
the nested list:\inputencoding{latin9}
\begin{lstlisting}
scala> Seq(1,2,3).map( x => Seq(x, x)).flatten
res1: Seq[Seq[Int]] = List(1, 1, 2, 2, 3, 3)
\end{lstlisting}
\inputencoding{utf8}The composition of \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
is \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8},
so the final code is\inputencoding{latin9}
\begin{lstlisting}
def halfSpeed[T](str: Stream[T]): Stream[T] = str.flatMap(x => Seq(x, x))

scala> halfSpeed(Seq(1,2,3).toStream)
res2: Stream[Int] = Stream(1, ?)

scala> halfSpeed(Seq(1,2,3).toStream).toList
res3: List[Int] = List(1, 1, 2, 2, 3, 3)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:ch2Example-seq-7}\ref{subsec:ch2Example-seq-7}}

Stop a given stream $\left[s_{0},s_{1},s_{2},...\right]$ at a place
$k$ where the sequence repeats itself; that is, an element $s_{k}$
equals some earlier element $s_{i}$ with $i<k$.

\subparagraph{Solution:}

The trick is to create a half-speed sequence $h_{i}$ out of $s_{i}$
and then find an index $k>0$ such that $h_{k}=s_{k}$. (The condition
$k>0$ is needed because we will always have $h_{0}=s_{0}$.) If we
find such an index $k$, it would mean that either $s_{k}=s_{k/2}$
or $s_{k}=s_{\left(k-1\right)/2}$; in either case, we will have found
an element $s_{k}$ that equals an earlier element. 

As an example, take $s=\left[1,3,5,7,9,3,5,7,9,...\right]$ and compute
the half-speed sequence $h=\left[1,1,3,3,5,5,7,7,9,9,3,3,...\right]$.
Looking for an index $k>0$ such that $h_{k}=s_{k}$, we find that
$s_{7}=h_{7}=7$. This is indeed an element of $s_{i}$ that repeats
an earlier element (although $s_{7}$ is not the first such repetition).

There are in principle two ways of finding an index $k>0$ such that
$h_{k}=s_{k}$: First, to iterate over a list of indices $k=1,2,...$
and evaluate the condition $h_{k}=s_{k}$ as a function of $k$. Second,
to build a sequence of pairs $\left(h_{i},s_{i}\right)$ and use \inputencoding{latin9}\lstinline!.takeWhile!\inputencoding{utf8}
to stop at the required index. In the present case, we cannot use
the first way because we do not have a fixed set of indices to iterate
over. Also, the condition $h_{k}=s_{k}$ cannot be directly evaluated
as a function of $k$ because $s$ and $h$ are streams that compute
elements on demand, not lists whose elements are computed in advance
and ready to be used. 

So the code must iterate over a stream of pairs $\left(h_{i},s_{i}\right)$:\inputencoding{latin9}
\begin{lstlisting}
def stopRepeats[T](str: Stream[T]): Stream[T] = {
  val halfSpeed = str.flatMap(x => Seq(x, x))
  val result = halfSpeed.zip(str) // Stream[(T, T)]
  .drop(1) // Enforce the condition k > 0.
  .takeWhile { case (h, s) => h != s } // Stream[(T, T)]
  .map(_._2) // Stream[T]
  str.head +: result // Prepend the first element that was dropped.
}

scala> stopRepeats(Seq(1, 3, 5, 7, 9, 3, 5, 7, 9).toStream).toList
res0: List[Int] = List(1, 3, 5, 7, 9, 3, 5)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:ch2Example-seq-8}\ref{subsec:ch2Example-seq-8}}

Reverse each word in a string, but keep the order of words:\inputencoding{latin9}
\begin{lstlisting}
def revWords(s: String): String = ???

scala> revWords("A quick brown fox")
res0: String = A kciuq nworb xof
\end{lstlisting}
\inputencoding{utf8}

\subparagraph{Solution:}

The standard method \inputencoding{latin9}\lstinline!.split!\inputencoding{utf8}
converts a string into an array of words:\inputencoding{latin9}
\begin{lstlisting}
scala> "pa re ci vo mu".split(" ")
res0: Array[String] = Array(pa, re, ci, vo, mu)
\end{lstlisting}
\inputencoding{utf8}Each word is reversed with \inputencoding{latin9}\lstinline!.reverse!\inputencoding{utf8};
the resulting array is concatenated into a string with \inputencoding{latin9}\lstinline!.mkString!\inputencoding{utf8}.
So the code is\inputencoding{latin9}
\begin{lstlisting}
def revWords(s: String): String = s.split(" ").map(_.reverse).mkString(" ")
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:ch2Example-seq-10}\ref{subsec:ch2Example-seq-10}}

Remove adjacent repeated characters from a string:\inputencoding{latin9}
\begin{lstlisting}
def noDups(s: String): String = ???

scala> noDups("abbcdeeeeefddgggggh")
res0: String = abcdefdgh
\end{lstlisting}
\inputencoding{utf8}

\subparagraph{Solution:}

A string is automatically converted into a sequence of characters
when we use methods such as \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!.zip!\inputencoding{utf8} on
it. So, we can use \inputencoding{latin9}\lstinline!s.zip(s.tail)!\inputencoding{utf8}
to get a sequence of pairs $\left(s_{k},s_{k+1}\right)$ where $c_{k}$
is the $k$-th character of the string $s$. Now we can use \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}
to remove the elements $s_{k}$ for which $s_{k+1}=s_{k}$:\inputencoding{latin9}
\begin{lstlisting}
scala> val s = "abbcd"
s: String = abbcd

scala> s.zip(s.tail).filter { case (sk, skPlus1) => sk != skPlus1 }
res0: IndexedSeq[(Char, Char)] = Vector((a,b), (b,c), (c,d))
\end{lstlisting}
\inputencoding{utf8}It remains to convert this sequence of pairs into the string \inputencoding{latin9}\lstinline!"abcd"!\inputencoding{utf8}.
One way of doing this is to project the sequence of pairs onto the
second parts of the pairs,\inputencoding{latin9}
\begin{lstlisting}
scala> res0.map(_._2).mkString
res1: String = bcd
\end{lstlisting}
\inputencoding{utf8}We just need to add the first character, \inputencoding{latin9}\lstinline!'a'!\inputencoding{utf8}.
The resulting code is\inputencoding{latin9}
\begin{lstlisting}
def noDups(s: String): String = if (s == "") "" else {
  val pairs = s.zip(s.tail).filter { case (x, y) => x != y }
  pairs.head._1 +: pairs.map(_._2).mkString
}
\end{lstlisting}
\inputencoding{utf8}The method \inputencoding{latin9}\lstinline!+:!\inputencoding{utf8}
prepends an element to a sequence, so \inputencoding{latin9}\lstinline!x +: xs!\inputencoding{utf8}
is equivalent to \inputencoding{latin9}\lstinline!Seq(x) ++ xs!\inputencoding{utf8}.

\subsubsection{Example \label{subsec:ch2Example-seq-9}\ref{subsec:ch2Example-seq-9}}

\textbf{(a)} Count the occurrences of each distinct word in a string:\inputencoding{latin9}
\begin{lstlisting}
def countWords(s: String): Map[String, Int] = ???

scala> countWords("a quick a quick a fox")
res0: Map[String, Int] = Map("a" -> 3, "quick" -> 2, "fox" -> 1)
\end{lstlisting}
\inputencoding{utf8}\textbf{(b)} Count the occurrences of each distinct element in a sequence
of type \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8}.

\subparagraph{Solution:}

\textbf{(a)} We split the string into an array of words via \inputencoding{latin9}\lstinline!s.split(" ")!\inputencoding{utf8},
and apply a \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
to that array, since the computation is a kind of aggregation over
the array of words. The accumulator of the aggregation will be the
dictionary of word counts for all the words seen so far:\inputencoding{latin9}
\begin{lstlisting}
def countWords(s: String): Map[String, Int] = {
  val init: Map[String, Int] = Map()
  s.split(" ").foldLeft(init) { (dict, word) =>
    val newCount = dict.getOrElse(word, 0) + 1
    dict.updated(word, newCount)
  }
}
\end{lstlisting}
\inputencoding{utf8}\textbf{(b)} The main code of \inputencoding{latin9}\lstinline!countWords!\inputencoding{utf8}
does not depend on the fact that words are of type \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}.
It will work in the same way for any other type of keys for the dictionary.
So we keep the same code and define the type signature of the function
to contain a type parameter \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def countValues[A](xs: Seq[A]): Map[A, Int] =
  xs.foldLeft(Map[A, Int]()) { (dict, word) =>
    val newCount = dict.getOrElse(word, 0) + 1
    dict.updated(word, newCount)
  }

scala> countValues(Seq(100, 100, 200, 100, 200, 200, 100))
res0: Map[Int,Int] = Map(100 -> 4, 200 -> 3)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:ch2Example-seq-10-1}\ref{subsec:ch2Example-seq-10-1}}

For a given sequence of type \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8},
find the longest subsequence that does not contain any adjacent duplicate
values.

\inputencoding{latin9}\begin{lstlisting}
def longestNoDups[A](xs: Seq[A]): Seq[A] = ???

scala> longestNoDups(Seq(1, 2, 2, 5, 4, 4, 4, 8, 2, 3, 3))
res0: Seq[Int] = List(4, 8, 2, 3)
\end{lstlisting}
\inputencoding{utf8}

\subparagraph{Solution:}

This is a dynamic programming problem. Many such problems are solved
with a single \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}.
The accumulator represents the current ``state'' of the dynamic
programming solution, and the ``state'' is updated with each new
element of the input sequence.

To obtain the solution, we first need to determine the type of the
accumulator value, or the ``state''. The task is to find the longest
subsequence without adjacent duplicates. So the accumulator should
represent the longest subsequence found so far, as well as any required
extra information about other subsequences that might grow as we iterate
over the elements of \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}.
What is this extra information in our case? 

Imagine that we wanted to build set of \emph{all} subsequences without
adjacent duplicates. In the example where the input sequence is $\left[1,2,2,5,4,4,4,8,2,3,3\right]$,
this set of subsequences should be $\left\{ \left[1,2\right],\left[2,5,4\right],\left[4,8,2,3\right]\right\} $.
We can build this set incrementally in the accumulator value of a
\inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}.
To visualize how this set would be built, consider the partial result
after seeing the first $8$ elements of the input sequence, $\left[1,2,2,5,4,4,4,8\right]$.
The partial set of non-repeating subsequences is $\left\{ \left[1,2\right],\left[2,5,4\right],\left[4,8\right]\right\} $.
As we add another element, $2$, we update the partial set to $\left\{ \left[1,2\right],\left[2,5,4\right],\left[4,8,2\right]\right\} $.

It is now clear that the subsequence $\left[1,2\right]$ has no chance
of being the longest subsequence, since $\left[2,5,4\right]$ is already
longer. However, we do not yet know whether $\left[2,5,4\right]$
or $\left[4,8,2\right]$ is the winner, because the subsequence $\left[4,8,2\right]$
could still grow and become the longest one (and it does become $\left[4,8,2,3\right]$
later). At this point, we need to keep both of these two subsequences
in the accumulator, but we may already discard $\left[1,2\right]$.

We have deduced that the accumulator needs to keep only \emph{two}
sequences: the first sequence is already terminated and will not grow,
the second sequence ends with the current element and may yet grow.
The initial value of the accumulator is empty. The first subsequence
is discarded when it becomes shorter than the second. The code can
be written now:\inputencoding{latin9}
\begin{lstlisting}
def longestNoDups[A](xs: Seq[A]): Seq[A] = {
  val init: (Seq[A], Seq[A]) = (Seq(), Seq())
  val (first, last) = xs.foldLeft(init) { case ((first, current), x) =>
    // If `current` is empty, `x` cannot be repeated.
    val xWasRepeated = current != Seq() && current.last == x
    val firstIsLongerThanCurrent = first.length > current.length
    // Compute the new pair `(first, current)`.
    // Keep `first` only if it is longer; otherwise replace it by `current`.
    val newFirst = if (firstIsLongerThanCurrent) first else current
    // Append `x` to `current` if `x` is not repeated.
    val newCurrent = if (xWasRepeated) Seq(x) else current :+ x
    (newFirst, newCurrent)
  }
  // Return the longer of the two subsequences; prefer `first`.
  if (first.length >= last.length) first else last
}
\end{lstlisting}
\inputencoding{utf8}

\subsection{Exercises\index{exercises}}

\subsubsection{Exercise \label{subsec:ch2Exercise-seq-1}\ref{subsec:ch2Exercise-seq-1}}

Compute the sum of squared digits of a given integer; e.g., \inputencoding{latin9}\lstinline!dsq(123) = 14!\inputencoding{utf8}
(see Example~\ref{subsec:ch2sumdigitsExample-seq-5}). Generalize
the solution to take an arbitrary function \inputencoding{latin9}\lstinline!f : Int => Int!\inputencoding{utf8}
as a parameter, instead of the squaring operation. The type signature
and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def digitsMapSum(x: Int)(f: Int => Int): Int = ???

scala> digitsMap(123){ x => x * x }
res0: Int = 14

scala> digitsMap(123){ x => x * x * x }
res1: Int = 36
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:ch2Exercise-seq-2}\ref{subsec:ch2Exercise-seq-2}}

Compute the \textbf{Collatz sequence\index{Collatz sequence}} $c_{i}$
as a stream defined by
\[
c_{0}=n\quad;\quad\quad c_{k+1}=\begin{cases}
\frac{c_{k}}{2} & \text{if }c_{k}\text{ is even,}\\
3c_{k}+1 & \text{if }c_{k}\text{ is odd.}
\end{cases}
\]
Stop the stream when it reaches $1$ (\href{https://en.wikipedia.org/wiki/Collatz_conjecture}{as one would expect}
it will).

\subsubsection{Exercise \label{subsec:ch2Exercise-seq-3}\ref{subsec:ch2Exercise-seq-3}}

For a given integer $n$, compute the sum of cubed digits, then the
sum of cubed digits of the result, etc.; stop the resulting sequence
when it repeats itself, and so determine whether it ever reaches $1$.
(Use Exercise~\ref{subsec:ch2Exercise-seq-1}.)\inputencoding{latin9}
\begin{lstlisting}
def cubes(n: Int): Stream[Int] = ???

scala> cubes(123).take(10).toList
res0: List[Int] = List(123, 36, 243, 99, 1458, 702, 351, 153, 153, 153)

scala> cubes(2).take(10).toList
res1: List[Int] = List(2, 8, 512, 134, 92, 737, 713, 371, 371, 371)

scala> cubes(4).take(10).toList
res2: List[Int] = List(4, 64, 280, 520, 133, 55, 250, 133, 55, 250)

def cubesReach1(n: Int): Boolean = ???

scala> cubesReach1(10)
res3: Boolean = true

scala> cubesReach1(4)
res4: Boolean = false
\end{lstlisting}
\inputencoding{utf8}\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
def digitsOf(n: Int): Seq[Int] = Stream.iterate(n)(_ / 10).takeWhile(_ != 0).map(_ % 10).toList
def cubeDigits(n: Int): Int = digitsOf(n).map(x => x*x*x).sum
def cubes(n: Int): Stream[Int] = Stream.iterate(n)(cubeDigits)
def stopRepeats[T](str: Stream[T]): Stream[T] = {
  val halfSpeed = str.flatMap(x => Seq(x, x))
  val result = halfSpeed.zip(str).drop(1).takeWhile{ case (h, s) => h != s }.map(_._2)
  if (result.isEmpty) str.take(1) else str
}
def cubesReach1(n: Int): Boolean = stopRepeats(cubes(n)).contains(1)
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{subsec:ch2Exercise-seq-4}\ref{subsec:ch2Exercise-seq-4}}

For \inputencoding{latin9}\lstinline!a!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!b!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!c!\inputencoding{utf8} of type \inputencoding{latin9}\lstinline!Set[Int]!\inputencoding{utf8},
compute the set of all sets of the form \inputencoding{latin9}\lstinline!Set(x, y, z)!\inputencoding{utf8}
where \inputencoding{latin9}\lstinline!x!\inputencoding{utf8} is
from \inputencoding{latin9}\lstinline!a!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!y!\inputencoding{utf8}
from \inputencoding{latin9}\lstinline!b!\inputencoding{utf8}, and
\inputencoding{latin9}\lstinline!z!\inputencoding{utf8} from \inputencoding{latin9}\lstinline!c!\inputencoding{utf8}.
The required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def prod3(a: Set[Int], b: Set[Int], c: Set[Int]): Set[Set[Int]] = ???

scala> prod3(Set(1,2), Set(3), Set(4,5))
res0: Set[Set[Int]] = Set(Set(1,3,4), Set(1,3,5), Set(2,3,4), Set(2,3,5))
\end{lstlisting}
\inputencoding{utf8}
Hint: use \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}.%
\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
def prod3(a: Set[Int], b: Set[Int], c: Set[Int]): Set[Set[Int]] =     a.flatMap(x => b.flatMap(y => c.map(z => Set(x, y, z))))
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{subsec:ch2Exercise-seq-5}\ref{subsec:ch2Exercise-seq-5}{*}}

Same task as in Exercise~\ref{subsec:ch2Exercise-seq-4} for a set
of sets, i.e.~given a \inputencoding{latin9}\lstinline!Set[Set[Int]]!\inputencoding{utf8}
instead of just three sets \inputencoding{latin9}\lstinline!a!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!b!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!c!\inputencoding{utf8}.
The required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def prodSet(si: Set[Set[Int]]): Set[Set[Int]] = ???

scala> prodSet(Set(Set(1,2), Set(3), Set(4,5), Set(6)))
res0: Set[Set[Int]] = Set(Set(1,3,4,6),Set(1,3,5,6),Set(2,3,4,6),Set(2,3,5,6))
\end{lstlisting}
\inputencoding{utf8}
Hint: use \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}.%
\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
def prodSet(sets: Set[Set[Int]]): Set[Set[Int]] =     sets.foldLeft(Set[Set[Int]](Set())) {
      // Combine each of results so far with each element in current set
      case (accumSet: Set[Set[Int]], currSet: Set[Int]) =>
        for {
          s <- accumSet
          i <- currSet
        } yield s + i
      }
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{subsec:ch2Exercise-seq-4-1}\ref{subsec:ch2Exercise-seq-4-1}{*}}

In a sorted array \inputencoding{latin9}\lstinline!xs:Array[Int]!\inputencoding{utf8}
where no values are repeated, find all pairs of values whose sum equals
a given number $n$. Use tail recursion. A possible type signature
and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def pairs(goal: Int, xs: Array[Int]): Set[(Int, Int)] = ???

scala> pairs(10, Array(1, 2, 3, 4, 5, 6, 7, 8))()
res0: Set[(Int, Int)] = Set((2,8), (3,7), (4,6), (5,5))
\end{lstlisting}
\inputencoding{utf8}\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
@tailrec def pairs(goal: Int, xs: Array[Int])(res: Set[(Int, Int)] = Set(), left: Int = 0, right: Int = xs.length): Set[(Int, Int)] = if (left == right) res else {
  val sum = xs(left) + xs(right - 1)
  val (newLeft, newRight, newRes) = if (sum == goal) (left + 1, right, res + ((xs(left), xs(right - 1)))) else if (sum < goal) (left + 1, right, res) else (left, right - 1, res)
  pairs(goal, xs)(newRes, newLeft, newRight)
}
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{subsec:ch2Exercise-seq-6}\ref{subsec:ch2Exercise-seq-6}}

Reverse a sentence's word order, but keep the words unchanged:\inputencoding{latin9}
\begin{lstlisting}
def revSentence(s: String): String = ???

scala> revSentence("A quick brown fox")
res0: String = "fox brown quick A"
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:ch2revdigits-Exercise-seq-7}\ref{subsec:ch2revdigits-Exercise-seq-7}}

Reverse an integer's digits (see Example~\ref{subsec:ch2sumdigitsExample-seq-5})
as shown:\inputencoding{latin9}
\begin{lstlisting}
def revDigits(n: Int): Int = ???

scala> revDigits(12345)
res0: Int = 54321
\end{lstlisting}
\inputencoding{utf8}A \textbf{\index{palindrome number}palindrome number} is an integer
\inputencoding{latin9}\lstinline!n!\inputencoding{utf8} such that
\inputencoding{latin9}\lstinline!revDigits(n) == n!\inputencoding{utf8}.
Write a function \inputencoding{latin9}\lstinline!Int => Boolean!\inputencoding{utf8}
that checks whether a given positive integer is a palindrome.%
\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
def digitsOf(n: Int): Seq[Int] = Stream.iterate(n)(_ / 10).takeWhile(_ != 0).map(_ % 10).toList
def revDigits(n: Int): Int = digitsOf(n).foldLeft(0){case (acc, d) => acc*10+d }
def isPalindrome(n: Int): Boolean = revDigits(n) == n
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{subsec:ch2Exercise-seq-8}\ref{subsec:ch2Exercise-seq-8}}

Starting from a given integer \inputencoding{latin9}\lstinline!n!\inputencoding{utf8},
compute \inputencoding{latin9}\lstinline!revDigits(n) + n!\inputencoding{utf8};
the function \inputencoding{latin9}\lstinline!revDigits!\inputencoding{utf8}
was defined in Exercise~\ref{subsec:ch2revdigits-Exercise-seq-7}.
Check whether the result is a palindrome integer. If it is not, repeat
the same operation until a palindrome number is found, and return
that number. The required type signature and a test:\inputencoding{latin9}
\begin{lstlisting}
def findPalindrome(n: Int): Int = ???

scala> findPalindrome(123)
res0: Int = 444

scala> findPalindrome(83951)
res1: Int = 869363968
\end{lstlisting}
\inputencoding{utf8}\begin{comment}
Solution:\inputencoding{latin9}
\begin{lstlisting}
def findPalindrome(n: Int): Int = Stream.iterate(n){x => x + revDigits(x)}.filter(isPalindrome).take(1).toList.head
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{subsec:ch2Exercise-seq-8-1}\ref{subsec:ch2Exercise-seq-8-1}}

\textbf{(a)} For a given integer interval $\left[n_{1},n_{2}\right]$,
find the largest integer $k\in\left[n_{1},n_{2}\right]$ such that
the decimal representation of $k$ does \emph{not} contain any of
the digits $3$, $5$, or $7$. \textbf{(b)} For a given integer interval
$\left[n_{1},n_{2}\right]$, find the integer $k\in\left[n_{1},n_{2}\right]$
with the largest sum of decimal digits. \textbf{(c)} A positive integer
$n$ is called a \textbf{perfect number\index{perfect number}} if
it is equal to the sum of its divisors (other integers $k$ such that
$k<n$ and $n/k$ is an integer). For example, $6$ is a perfect number
because its divisors are $1$, $2$, and $3$, and $1+2+3=6$, while
$8$ is not a perfect number because its divisors are $1$, $2$,
and $4$, and $1+2+4=7\neq8$. Write a function that determines whether
a given number $n$ is perfect. Determine all perfect numbers up to
one million.

\subsubsection{Exercise \label{subsec:ch2Exercise-seq-9}\ref{subsec:ch2Exercise-seq-9}}

Remove adjacent repeated elements from a sequence of type \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8}
when they are repeated more than $k$ times. Repetitions up to $k$
times should remain unchanged. The required type signature and a sample
test:\inputencoding{latin9}
\begin{lstlisting}
def removeDups[A](s: Seq[A], k: Int): Seq[A] = ???

scala> removeDups(Seq(1, 1, 1, 1, 5, 2, 2, 5, 5, 5, 5, 5, 1), 3)
res0: Seq[Int] = List(1, 1, 1, 5, 2, 2, 5, 5, 5, 1)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:ch2Exercise-seq-11}\ref{subsec:ch2Exercise-seq-11}}

\textbf{(a)} Remove repeated elements (whether adjacent or not) from
a sequence of type \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8}.
(This re-implements the standard method \inputencoding{latin9}\lstinline!.distinct!\inputencoding{utf8}.)

\textbf{(b)} For a sequence of type \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8},
remove all elements that are repeated (whether adjacent or not) more
than $k$ times:\inputencoding{latin9}
\begin{lstlisting}
def removeK[A](k: Int, xs: Seq[A]): Seq[A] = ???

scala> removeK(2, Seq("a", "b", "a", "b", "b", "c", "b", "a"))
res0: Seq[String] = List(a, b, a, b, c)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:ch2Exercise-seq-10}\ref{subsec:ch2Exercise-seq-10}{*}}

For a given sequence \inputencoding{latin9}\lstinline!xs:Seq[Double]!\inputencoding{utf8},
find a subsequence that has the largest sum of values. The sequence
\inputencoding{latin9}\lstinline!xs!\inputencoding{utf8} is not sorted,
and its values may be positive or negative. The required type signature
and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def maxsub(xs: Seq[Double]): Seq[Double] = ???

scala> maxsub(Seq(1.0, -1.5, 2.0, 3.0, -0.5, 2.0, 1.0, -10.0, 2.0))
res0: Seq[Double] = List(2.0, 3.0, -0.5, 2.0, 1.0)
\end{lstlisting}
\inputencoding{utf8}
Hint: use dynamic programming and \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}.

\subsubsection{Exercise \label{subsec:ch2Exercise-seq-12}\ref{subsec:ch2Exercise-seq-12}{*}}

Find all common integers between two sorted sequences:\inputencoding{latin9}
\begin{lstlisting}
def commonInt(xs: Seq[Int], ys: Seq[Int]): Seq[Int] = ??? // Use tail recursion.

scala> commonInt(Seq(1, 3, 5, 7), Seq(2, 3, 4, 6, 7, 8))
res0: Seq[Int] = List(3, 7)
\end{lstlisting}
\inputencoding{utf8}

\section{Discussion}

\subsection{Total and partial functions}

In Scala, functions can be total or partial. A \textbf{\index{total function}total}
function will always compute a result value, while a \textbf{\index{partial function}partial}
function may fail to compute its result for certain values of its
arguments.

A simple example of a partial function in Scala is the \inputencoding{latin9}\lstinline!.max!\inputencoding{utf8}
method: it only works for non-empty sequences. Trying to evaluate
it on an empty sequence generates an error called an ``exception\index{exception}'':\inputencoding{latin9}
\begin{lstlisting}[mathescape=false]
scala> Seq(1).tail
res0: Seq[Int] = List()
scala> res0.max
java.lang.UnsupportedOperationException: empty.max
  at scala.collection.TraversableOnce$class.max(TraversableOnce.scala:229)
  at scala.collection.AbstractTraversable.max(Traversable.scala:104)
  ... 32 elided 
\end{lstlisting}
\inputencoding{utf8}This kind of error may crash the entire program at run time. Unlike
the type errors\index{type error} we saw before, which occur at compilation
time (i.e.~before the program can start), \textbf{run-time errors}\index{run-time error}
occur while the program is running, and only when some partial function
happens to get an incorrect input. The incorrect input may occur at
any point after the program started running, which may crash the entire
program in the middle of a long computation.

So, it seems clear that we should write code that does not generate
such errors. For instance, it is safe to apply \inputencoding{latin9}\lstinline!.max!\inputencoding{utf8}
to a sequence if we know that it is non-empty.

Sometimes, a function that uses pattern matching turns out to be a
partial function because its pattern matching code fails on certain
input data. 

If a pattern matching expression fails, the code will throw an exception
and stop running. In functional programming, we usually want to avoid
this situation because it makes it much harder to reason about program
correctness. In most cases, programs can be written to avoid the possibility
of match errors. An example of an unsafe pattern matching expression
is\inputencoding{latin9}
\begin{lstlisting}[mathescape=false]
def h(p: (Int, Int)): Int = p match { case (x, 0) => x }

scala> h( (1,0) )
res0: Int = 1

scala> h( (1,2) )
 scala.MatchError: (1,2) (of class scala.Tuple2$mcII$sp)
  at .h(<console>:12)
  ... 32 elided 
\end{lstlisting}
\inputencoding{utf8}Here the pattern contains a pattern variable \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
and a constant \inputencoding{latin9}\lstinline!0!\inputencoding{utf8}.
This pattern only matches tuples whose second part is equal to \inputencoding{latin9}\lstinline!0!\inputencoding{utf8}.
If the second argument is nonzero, a match error occurs and the program
crashes. So, \inputencoding{latin9}\lstinline!h!\inputencoding{utf8}
is a partial function.

Pattern matching failures never happen if we match a tuple of correct
size with a pattern such as \inputencoding{latin9}\lstinline!(x, y, z)!\inputencoding{utf8},
because pattern variables will always match whatever values the tuple
has. So, pattern matching with a pattern such as \inputencoding{latin9}\lstinline!(x, y, z)!\inputencoding{utf8}
is \textbf{infallible}\index{pattern matching!infallible} (never
fails at run time) when applied to a tuple with $3$ elements.

Another way in which pattern matching can be made infallible is by
including a pattern that matches everything:\inputencoding{latin9}
\begin{lstlisting}
p match {
  case (x, 0) => ... // This only matches some tuples.
  case _ => ... // This matches everything.
}
\end{lstlisting}
\inputencoding{utf8}If the first pattern \inputencoding{latin9}\lstinline!(x, 0)!\inputencoding{utf8}
fails to match the value of \inputencoding{latin9}\lstinline!p!\inputencoding{utf8},
the second pattern will be tried (and will always succeed). When a
\inputencoding{latin9}\lstinline!match!\inputencoding{utf8} expression
has several \inputencoding{latin9}\lstinline!case!\inputencoding{utf8}
patterns, the patterns are tried in the order they are written. So,
a match expression can be made infallible by adding a ``match-all''
underscore pattern.

\subsection{Scope and shadowing of pattern matching variables\label{subsec:Scope-and-shadowing-variables}}

Pattern matching introduces \textbf{locally scoped\index{local scope}}
variables – that is, variables defined only on the right-hand side
of the pattern match expression. As an example, consider this code:\inputencoding{latin9}
\begin{lstlisting}
def f(x: (Int, Int)): Int = x match { case (x, y) => x + y }

scala> f( (2,4) )
res0: Int = 6
\end{lstlisting}
\inputencoding{utf8}The argument of \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
is the variable \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
of a tuple type \inputencoding{latin9}\lstinline!(Int,Int)!\inputencoding{utf8},
but there is also a pattern variable \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
in the case expression. The pattern variable \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
matches the first part of the tuple and has type \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}.
Because variables are locally scoped, the pattern variable \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
is only defined within the expression \inputencoding{latin9}\lstinline!x + y!\inputencoding{utf8}.
The argument \inputencoding{latin9}\lstinline!x:(Int,Int)!\inputencoding{utf8}
is a completely different variable whose value has a different type.

The code works correctly but is confusing to read because of the name
clash between the two quite different variables, both named \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}.
Another negative consequence of the name clash is that the argument
\inputencoding{latin9}\lstinline!x:(Int,Int)!\inputencoding{utf8}
\emph{is invisible} within the case expression: if we write ``\inputencoding{latin9}\lstinline!x!\inputencoding{utf8}''
in that expression, we will get the pattern variable \inputencoding{latin9}\lstinline!x:Int!\inputencoding{utf8}.
One says that the argument \inputencoding{latin9}\lstinline!x:(Int,Int)!\inputencoding{utf8}
has been \index{shadowed name}\textbf{shadowed} by the pattern variable
\inputencoding{latin9}\lstinline!x!\inputencoding{utf8}.

The problem is easy to correct: we can give the pattern variable some
other name. Since the pattern variable is locally scoped, it can be
renamed within its scope without having to change any other code.
A completely equivalent code is\inputencoding{latin9}
\begin{lstlisting}
def f(x: (Int, Int)): Int = x match { case (a, b) => a + b }

scala> f( (2,4) )
res0: Int = 6
\end{lstlisting}
\inputencoding{utf8}

\subsection{Lazy values and sequences: Iterators and streams\label{subsec:Lazy-values-iterators-and-streams}}

We have used streams to create sequences whose length is not known
in advance. An example is a stream containing a sequence of increasing
positive integers:\inputencoding{latin9}
\begin{lstlisting}
scala> val p = Stream.iterate(1)(_ + 1)
p: Stream[Int] = Stream(1, ?)
\end{lstlisting}
\inputencoding{utf8}At this point, we have not defined a stopping condition for this stream.
In some sense, streams are ``infinite'' sequences, although in practice
a stream is always finite because computers cannot run infinitely
long. Also, computers cannot store infinitely many values in memory. 

To be more precise, streams are ``not fully computed'' rather than
``infinite''. The main difference between arrays and streams is
that a stream's elements are computed on demand and not initially
available (except perhaps for the first element), while an array's
elements are all computed in advance and are available immediately.
Generally, there are four possible ways a value could be available:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{Availability} & \textbf{Explanation} & \textbf{Example Scala code}\tabularnewline
\hline 
\hline 
``eager'' & computed in advance & \inputencoding{latin9}\lstinline!val x = f(123)!\inputencoding{utf8}\tabularnewline
\hline 
``lazy'' & computed upon first request & \inputencoding{latin9}\lstinline!lazy val y = f(123)!\inputencoding{utf8}\tabularnewline
\hline 
``on-call'' & computed each time it is requested & \inputencoding{latin9}\lstinline!def z = f(123)!\inputencoding{utf8}\tabularnewline
\hline 
``never'' & cannot be computed due to errors & \inputencoding{latin9}\lstinline!val (x, y) = "abc" !\inputencoding{utf8}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

A \textbf{lazy value\index{lazy value}} (declared as \inputencoding{latin9}\lstinline!lazy val!\inputencoding{utf8}
in Scala) is computed only when used in some other expression. Once
computed, a lazy value stays in memory and will not be re-computed.

An ``on-call'' value is re-computed every time it is used. In Scala,
this is the behavior of a \inputencoding{latin9}\lstinline!def!\inputencoding{utf8}
declaration.

Most collection types in Scala (such as \inputencoding{latin9}\lstinline!List!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!Array!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!Set!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!Map!\inputencoding{utf8}) are
\textbf{eager}\index{eager collection}: all the elements inside these
collections are already evaluated. A stream can be seen as a \textbf{lazy\index{lazy collection}}
\textbf{collection}. Values in a stream are computed only when first
needed; after that, they remain in memory and will not be computed
again:\inputencoding{latin9}
\begin{lstlisting}
scala> val str = Stream.iterate(1)(_ + 1)
str: Stream[Int] = Stream(1, ?)

scala> str.take(10).toList
res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> str
res1: Stream[Int] = Stream(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ?)
\end{lstlisting}
\inputencoding{utf8}
In many cases, it is not necessary to keep previous values of a sequence
in memory. For example, consider the computation\inputencoding{latin9}
\begin{lstlisting}
scala> (1L to 1000000000L).sum
res0: Long = 500000000500000000
\end{lstlisting}
\inputencoding{utf8}We do not actually need to keep a billion numbers in memory if we
only want to compute their sum. Indeed, the computation just shown
does \emph{not} keep all the numbers in memory. The same computation
fails if we use a list or a stream:\inputencoding{latin9}
\begin{lstlisting}
scala> (1L to 1000000000L).toStream.sum
java.lang.OutOfMemoryError: GC overhead limit exceeded
\end{lstlisting}
\inputencoding{utf8}The code \inputencoding{latin9}\lstinline!(1L to 1000000000L).sum!\inputencoding{utf8}
works because the operation \inputencoding{latin9}\lstinline!(1 to n)!\inputencoding{utf8}
produces a sequence whose elements are computed whenever needed but
do not remain in memory. This can be seen as a sequence with the ``on-call''
availability of elements. Sequences of this sort are called \textbf{iterators}\index{iterator}.
Here are some examples:\inputencoding{latin9}
\begin{lstlisting}
scala> 1 to 5
res0: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5)

scala> 1 until 5
res1: scala.collection.immutable.Range = Range(1, 2, 3, 4)
\end{lstlisting}
\inputencoding{utf8}The types \inputencoding{latin9}\lstinline!Range!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Range.Inclusive!\inputencoding{utf8}
are defined in the Scala standard library and are iterators. They
behave as collections and support the usual methods (\inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}, etc.),
but they do not store previously computed values in memory.

\paragraph{The \texttt{.view} method}

Eager collections such as \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!Array!\inputencoding{utf8} can
be converted to iterators by using the \inputencoding{latin9}\lstinline!.view!\inputencoding{utf8}
method. This is necessary when intermediate collections consume too
much memory when fully evaluated. For example, consider the computation
of Example~\ref{subsec:tuples-Example7} where we used \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
to replace each element of an initial sequence by three new numbers
before computing \inputencoding{latin9}\lstinline!.max!\inputencoding{utf8}
of the resulting collection. If instead of three new numbers we wanted
to compute \emph{three} \emph{million} new numbers each time, the
intermediate collection created by \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
would require too much memory, and the computation would crash:\inputencoding{latin9}
\begin{lstlisting}
scala> (1 to 10).flatMap(x => 1 to 3000000).max
java.lang.OutOfMemoryError: GC overhead limit exceeded
\end{lstlisting}
\inputencoding{utf8}Even though the range expression \inputencoding{latin9}\lstinline!(1 to 10)!\inputencoding{utf8}
produces an iterator, a subsequent \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
operation creates an intermediate collection that is too large for
our computer's memory. We can use \inputencoding{latin9}\lstinline!.view!\inputencoding{utf8}
to avoid this:\inputencoding{latin9}
\begin{lstlisting}
scala> (1 to 10).view.flatMap(x => 1 to 3000000).max
res0: Int = 3000000
\end{lstlisting}
\inputencoding{utf8}The choice between using streams and using iterators is dictated by
the memory considerations. Except for that, streams and iterators
behave similarly to other sequences. We may write programs in the
map/reduce style, applying the standard methods such as \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}, etc.,
to streams and iterators. Mathematical reasoning about sequences is
the same, whether they are eager, lazy, or on-call.

\paragraph{The broken \texttt{Iterator} class}

The Scala library contains a class called \inputencoding{latin9}\lstinline!Iterator!\inputencoding{utf8},
which has methods such as \inputencoding{latin9}\lstinline!Iterator.iterate!\inputencoding{utf8}
and other methods similar to \inputencoding{latin9}\lstinline!Stream!\inputencoding{utf8}.
However, \inputencoding{latin9}\lstinline!Iterator!\inputencoding{utf8}
actually not an ``iterator'' in the sense I explained. It cannot
be treated as a \emph{value} in the mathematical sense\index{Scala's Iterator is broken}:\inputencoding{latin9}
\begin{lstlisting}
scala> val iter = (1 until 10).toIterator
iter: Iterator[Int] = non-empty iterator

scala> iter.toList // Look at the elements of `iter`.
res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> iter.toList // Look at these elements again...??
res1: List[Int] = List()

scala> iter
res2: Iterator[Int] = empty iterator
\end{lstlisting}
\inputencoding{utf8}Evaluating the expression \inputencoding{latin9}\lstinline!iter.toList!\inputencoding{utf8}
two times produces a \emph{different} result the second time! Also,
we see that \inputencoding{latin9}\lstinline!iter!\inputencoding{utf8}
became ``empty'' after the first use.

This situation is impossible in mathematics: if $x$ is some value,
such as $100$, and $f$ is some function, such as $f(x)=\sqrt{x}$,
then $f(x)$ will be the same, $f(100)=\sqrt{100}=10$, no matter
how many times we compute $f(x)$. For instance, we can compute $f(x)+f(x)=20$
and obtain the correct result. The number $x=100$ does not ``become
empty'' after the first use; its value remains the same. This behavior
is called the \textbf{\index{value semantics}value semantics} of
numbers. One says that integers ``are values'' in the mathematical
sense. Alternatively, one says that numbers are \textbf{immutable\index{immutable value},}
i.e.~cannot be changed. (What would it mean to ``modify'' the number
$10$?)

In programming, a type has value semantics if any computation applied
to it always gives the same result. Usually, this means that the type
contains immutable data. We can see that Scala's \inputencoding{latin9}\lstinline!Range!\inputencoding{utf8}
has value semantics and is immutable:\inputencoding{latin9}
\begin{lstlisting}
scala> val x = 1 until 10
x: scala.collection.immutable.Range = Range(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> x.toList
res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> x.toList
res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9) 
\end{lstlisting}
\inputencoding{utf8}Collections such as \inputencoding{latin9}\lstinline!List!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!Map!\inputencoding{utf8}, or \inputencoding{latin9}\lstinline!Stream!\inputencoding{utf8}
are immutable. Some elements of a \inputencoding{latin9}\lstinline!Stream!\inputencoding{utf8}
may not be evaluated yet, but this does not affect its value semantics:\inputencoding{latin9}
\begin{lstlisting}
scala> val str = (1 until 10).toStream
str: scala.collection.immutable.Stream[Int] = Stream(1, ?)

scala> str.toList
res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> str.toList
res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9) 
\end{lstlisting}
\inputencoding{utf8}Iterators produced by applying \inputencoding{latin9}\lstinline!.view!\inputencoding{utf8}
also have value semantics:\inputencoding{latin9}
\begin{lstlisting}
scala> val v = (1 until 10).view
v: scala.collection.SeqView[Int,IndexedSeq[Int]] = SeqView(...)

scala> v.toList
res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> v.toList
res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end{lstlisting}
\inputencoding{utf8}
Due to the lack of value semantics, programs written using \inputencoding{latin9}\lstinline!Iterator!\inputencoding{utf8}
cannot use the tools of mathematical reasoning. \index{Scala's Iterator is broken}This
makes it easy to write wrong code that looks correct! 

To illustrate the problem, let us re-implement Example~\ref{subsec:ch2Example-seq-7}
by keeping the same code but using \inputencoding{latin9}\lstinline!Iterator!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!Stream!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def stopRepeatsBad[T](iter: Iterator[T]): Iterator[T] = {
  val halfSpeed = iter.flatMap(x => Seq(x, x))
  halfSpeed.zip(iter) // Do not prepend the first element. It won't help.
  .drop(1)
  .takeWhile { case (h, s) => h != s }
  .map(_._2)
}

scala> stopRepeatsBad(Seq(1, 3, 5, 7, 9, 3, 5, 7, 9).toIterator).toList
res0: List[Int] = List(5, 9, 3, 7, 9)
\end{lstlisting}
\inputencoding{utf8}The result $\left[5,9,3,7,9\right]$ is incorrect, but not in an obvious
way: the sequence \emph{was} stopped at a repetition, as we expected,
but some of the elements of the given sequence are missing (while
other elements are present). It is difficult to debug a program when
it produces numbers that are \emph{partially} correct! 

The error in this code occurs in the expression \inputencoding{latin9}\lstinline!halfSpeed.zip(iter)!\inputencoding{utf8}
due to the fact that \inputencoding{latin9}\lstinline!halfSpeed!\inputencoding{utf8}
was itself defined via \inputencoding{latin9}\lstinline!iter!\inputencoding{utf8}.
The result is that \inputencoding{latin9}\lstinline!iter!\inputencoding{utf8}
is \emph{used twice} in this code, which leads to errors because \inputencoding{latin9}\lstinline!iter!\inputencoding{utf8}
is not immutable and does not behave as a value. Creating an \inputencoding{latin9}\lstinline!Iterator!\inputencoding{utf8}
and using it twice in the same expression can even fail with an exception:\inputencoding{latin9}
\begin{lstlisting}
scala> val s = (1 until 10).toIterator
s: Iterator[Int] = non-empty iterator

scala> val t = s.zip(s).toList
java.util.NoSuchElementException: next on empty iterator
\end{lstlisting}
\inputencoding{utf8}It is surprising and counter-intuitive that a variable cannot be used
twice! We expect code such as \inputencoding{latin9}\lstinline!s.zip(s)!\inputencoding{utf8}
to work correctly even though the variable \inputencoding{latin9}\lstinline!s!\inputencoding{utf8}
is used twice. When we read the expression \inputencoding{latin9}\lstinline!s.zip(s)!\inputencoding{utf8},
we imagine a given sequence \inputencoding{latin9}\lstinline!s!\inputencoding{utf8}
being ``zipped'' with itself. So we reason that \inputencoding{latin9}\lstinline!s.zip(s)!\inputencoding{utf8}
should produce a sequence of pairs. But Scala's \inputencoding{latin9}\lstinline!Iterator!\inputencoding{utf8}
is not immutable, which breaks the usual ways of mathematical reasoning
about code.\index{Scala's Iterator is broken}

An \inputencoding{latin9}\lstinline!Iterator!\inputencoding{utf8}
can be converted to a \inputencoding{latin9}\lstinline!Stream!\inputencoding{utf8}
using the \inputencoding{latin9}\lstinline!.toStream!\inputencoding{utf8}
method. This restores the value semantics, since streams are values:\inputencoding{latin9}
\begin{lstlisting}
scala> val iter = (1 until 10).toIterator
iter: Iterator[Int] = non-empty iterator

scala> val str = iter.toStream
str: Stream[Int] = Stream(1, ?)

scala> str.toList
res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> str.toList
res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> str.zip(str).toList
res2: List[(Int, Int)] = List((1,1), (2,2), (3,3), (4,4), (5,5), (6,6), (7,7), (8,8), (9,9)) 
\end{lstlisting}
\inputencoding{utf8}
Instead of \inputencoding{latin9}\lstinline!Iterator!\inputencoding{utf8},
we can use \inputencoding{latin9}\lstinline!Stream!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.view!\inputencoding{utf8} when
lazy or on-call collections are required. 
