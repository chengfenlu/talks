#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% Better formatting of tables.
%\usepackage{booktabs}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.0pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}

\usepackage{pstricks}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.
\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt,utf8
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7in
\paperheight 9in
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Success,Failure,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The formal logic of types I.
 Disjunctive types
\end_layout

\begin_layout Standard
Disjunctive types describe values that belong to a disjoint set of alternatives.
 
\end_layout

\begin_layout Standard
To see how Scala implements disjunctive types, we need to begin by looking
 at 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Scala's case classes
\end_layout

\begin_layout Subsection
Case classes as 
\begin_inset Quotes eld
\end_inset

named tuple
\begin_inset Quotes erd
\end_inset

 types
\end_layout

\begin_layout Standard
It is often helpful to use names for the different parts of a tuple.
 Suppose that some program represents the size and the color of socks with
 the tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, String)
\end_layout

\end_inset

.
 What if the same tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, String)
\end_layout

\end_inset

 is used in another place in the program to mean the amount paid and the
 name of the payee? A programmer could mix the two values by mistake, and
 it would be hard to find out why the program incorrectly computes, say,
 the total amount paid.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def totalAmountPaid(ps: Seq[(Double, String)]): Double = ps.map(_._1).sum
\end_layout

\begin_layout Plain Layout

val x = (10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

) // Sock size and color.
\end_layout

\begin_layout Plain Layout

val y = (25.0, 
\begin_inset Quotes eld
\end_inset

friend
\begin_inset Quotes erd
\end_inset

) // Payment amount and payee.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(List(x, y)) // Nonsense.
\end_layout

\begin_layout Plain Layout

res0: Double = 35.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We would prevent this kind of mistake if we could use two 
\emph on
different
\emph default
 types, with names such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

, for the two kinds of data.
 There are  three basic ways of defining a new named type in Scala that
 replaces a tuple: using a type alias, using a case class, and using an
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
opaque type
\end_layout

\end_inset

opaque type.
 
\end_layout

\begin_layout Standard
Opaque types (hiding a given type under a new name) is a feature that will
 become standard in a future version of Scala 3; so let us focus on type
 aliases and case classes.
\end_layout

\begin_layout Standard
A 
\series bold
type alias
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type alias
\end_layout

\end_inset

 is an alternative name for an existing (already defined) type.
 We could use type aliases in our example to add clarity to the code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type MySockTuple = (Double, String)
\end_layout

\begin_layout Plain Layout

type PaymentTuple = (Double, String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val s: MySockTuple = (10.5, "white")
\end_layout

\begin_layout Plain Layout

s: MySockTuple = (10.5,white)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val p: PaymentTuple = (25.0, "friend")
\end_layout

\begin_layout Plain Layout

p: PaymentTuple = (25.0,friend)
\end_layout

\end_inset

But the mix-up error is not prevented:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> totalAmountPaid(List(s, p)) // Nonsense again.
\end_layout

\begin_layout Plain Layout

res1: Double = 35.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Scala's 
\series bold
case classes
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
case class
\end_layout

\end_inset

 can be seen as 
\begin_inset Quotes eld
\end_inset

tuples with names
\begin_inset Quotes erd
\end_inset

.
 A case class is equivalent to a tuple type that has a name that we choose
 when we define the case class.
 Also, each part of the case class will have a separate name that we must
 choose.
 This is how to define case classes for the example with socks and payments:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySock(size: Double, color: String)
\end_layout

\begin_layout Plain Layout

case class Payment(amount: Double, name: String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val sock = MySock(10.5, "white")
\end_layout

\begin_layout Plain Layout

sock: MySock = MySock(10.5,white)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val paid = Payment(25.0, "friend")
\end_layout

\begin_layout Plain Layout

paid: Payment = Payment(25.0,friend)                                  ^ 
\end_layout

\end_inset

The new types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

 were defined.
 Values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 are written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

, which is similar to writing the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 except for adding the name 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To access the parts of a case class, we use the part names:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> sock.size
\end_layout

\begin_layout Plain Layout

res2: Double = 10.5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> paid.amount
\end_layout

\begin_layout Plain Layout

res3: Double = 25.0
\end_layout

\end_inset

The mix-up error is now a type error flagged by the compiler:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def totalAmountPaid(ps: Seq[Payment]): Double = ps.map(_.amount).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(List(paid, paid))
\end_layout

\begin_layout Plain Layout

res4: Double = 50.0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(List(sock, paid))
\end_layout

\begin_layout Plain Layout

<console>:19: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : MySock
\end_layout

\begin_layout Plain Layout

 required: Payment
\end_layout

\begin_layout Plain Layout

       totalAmountPaid(List(sock, paid))
\end_layout

\begin_layout Plain Layout

                            ^
\end_layout

\end_inset

A function whose argument is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 cannot be applied to an argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

 or of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, String)
\end_layout

\end_inset

.
 Case classes with different names are 
\emph on
different types
\emph default
, even if they contain the same types of parts.
 
\end_layout

\begin_layout Standard
Just as tuples can have any number of parts, case classes can have any number
 of parts, but the part names must be distinct, for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Person(firstName: String, lastName: String, age: Int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val einstein = Person("Albert", "Einstein", 140)
\end_layout

\begin_layout Plain Layout

einstein: Person = Person(Albert,Einstein,140)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> einstein.firstName
\end_layout

\begin_layout Plain Layout

res5: String = Albert
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> einstein.age
\end_layout

\begin_layout Plain Layout

res6: Int = 140
\end_layout

\end_inset

This data type carries the same information as a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String, String, Int)
\end_layout

\end_inset

.
 However, the declaration of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Person
\end_layout

\end_inset

 gives the programmer several methods that make working with the tuple's
 data more convenient.
\end_layout

\begin_layout Standard
Some (or all) part names may be specified when creating a case class value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val poincare = Person(firstName = "Henri", lastName = "Poincaré",
 165)
\end_layout

\begin_layout Plain Layout

poincare: Person = Person(Henri,Poincaré,165)
\end_layout

\end_inset

It is a type error to use wrong types with a case class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

<console>:13: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : Int(140)
\end_layout

\begin_layout Plain Layout

 required: String
\end_layout

\begin_layout Plain Layout

       val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

                      ^
\end_layout

\begin_layout Plain Layout

<console>:13: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : String("Albert")
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\begin_layout Plain Layout

       val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

                                       ^
\end_layout

\end_inset

Here, the error is due to an incorrect order of parts when creating a case
 class value.
 However, parts can be specified in any order when using part names:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p = Person(age = 140, lastName = "Einstein", firstName = "Albert")
\end_layout

\begin_layout Plain Layout

p: Person = Person(Albert,Einstein,140)
\end_layout

\end_inset

A part of a case class can have the type of another case class, creating
 a 
\begin_inset Quotes eld
\end_inset

nested
\begin_inset Quotes erd
\end_inset

 type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class BagOfSocks(sock: MySock, count: Int)
\end_layout

\begin_layout Plain Layout

val bag = BagOfSocks(MySock(10.5, "white"), 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> bag.socks.size
\end_layout

\begin_layout Plain Layout

res7: Double = 10.5
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Case classes with type parameters
\end_layout

\begin_layout Standard
Generally, type classes can be defined with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type parameter
\end_layout

\end_inset

type parameters.
 As an example, consider a generalization of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 where, in addition to the size and color, a 
\begin_inset Quotes eld
\end_inset

sock
\begin_inset Quotes erd
\end_inset

 may hold another value.
 We could define several specialized case classes,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySockInt(size: Double, color: String, value: Int)
\end_layout

\begin_layout Plain Layout

case class MySockBoolean(size: Double, color: String, value: Boolean)
\end_layout

\end_inset

but it is better to define a single parameterized case class
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySockX[A](size: Double, color: String, value: A)
\end_layout

\end_inset

that works for every type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 When we create values of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

, we will use a specific type, for instance
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = MySockX(10.5, "white", 123)
\end_layout

\begin_layout Plain Layout

s: MySockX[Int] = MySockX(10.5,white,123) 
\end_layout

\end_inset

Here, the type variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 was automatically set to a specific type, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Specific types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 will be used by each specific value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[A]
\end_layout

\end_inset

, but we can write code working with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[A]
\end_layout

\end_inset

 
\series bold
parametrically
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
parametric code
\end_layout

\end_inset

, that is, keeping the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in the code.
 For example, a function that checks whether a sock of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[A]
\end_layout

\end_inset

 fits my foot can be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fitsMe[A](sock: MySockX[A]): Boolean = sock.size >= 10.5 && sock.size <=
 11.0
\end_layout

\end_inset

This function is defined for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 at once, because its code works in the same way regardless of the type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Scala will set the type parameter automatically:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fitsMe(MySockX(10.5, 
\begin_inset Quotes eld
\end_inset

blue
\begin_inset Quotes erd
\end_inset

, List(1,2,3))) // Parameter A = List[Int]
\end_layout

\begin_layout Plain Layout

res0: Boolean = true
\end_layout

\end_inset

In this case it is clear that the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 must be set to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

, and we may omit the type parameter when calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fitsMe
\end_layout

\end_inset

.
 When types become more complicated, it may be helpful to avoid type errors
 by specifying the values of type parameters.
 For example, here is a type error due to a mismatch between the type parameter
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 used in the 
\begin_inset Quotes eld
\end_inset

sock
\begin_inset Quotes erd
\end_inset

 value, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

, and the type parameter in the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fitsMe
\end_layout

\end_inset

, specified as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
\end_layout

\begin_layout Plain Layout

<console>:15: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : List[Int]
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\begin_layout Plain Layout

       fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
\end_layout

\begin_layout Plain Layout

                                             ^ 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Case classes may have several type parameters, and the types of the parts
 may use these type parameters.
 Here is an artificial example of a case class using type parameters in
 different ways,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Complicated[A,B,C,D](x: (A, A), y: (B, Int) => A, z: C => C)
\end_layout

\end_inset

This case class contains parts of different types that use the type parameters
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 in tuples and functions.
 The type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

 is not used at all; this is allowed as well.
\end_layout

\begin_layout Subsection
Tuples with one part and with zero parts
\end_layout

\begin_layout Standard
Let us compare tuples and case classes more systematically.
\end_layout

\begin_layout Standard
Parts of a case class are accessed by name with a dot syntax, for example
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sock.color
\end_layout

\end_inset

.
 Parts of a tuple are accessed with the accessors such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x._1
\end_layout

\end_inset

.
 This syntax is the same as that for a case class whose parts have names
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_2
\end_layout

\end_inset

, etc.
 So, it appears that tuple parts 
\emph on
do
\emph default
 have names in Scala, although those names are always automatically assigned
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_2
\end_layout

\end_inset

, etc.
 It turns out that tuple types also have automatically assigned names in
 Scala; these names are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple2
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple3
\end_layout

\end_inset

, etc., and they correspond to parameterized types, since each part of the
 tuple may be of any type.
 So, a tuple type expression such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, String)
\end_layout

\end_inset

 is just a special syntax for the parameterized type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple2[Int, String]
\end_layout

\end_inset

.
 One could define the tuple types as case classes like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Tuple2[A, B](_1: A, _2: B)
\end_layout

\begin_layout Plain Layout

case class Tuple3[A, B, C](_1: A, _2: B, _3: C)
\end_layout

\begin_layout Plain Layout

// And so on with Tuple4, Tuple5, ...
\end_layout

\end_inset

if these types were not already defined in the Scala library.
\end_layout

\begin_layout Standard
Proceeding systematically, we ask whether tuple types can have just one
 part or even no parts.
 Indeed, Scala defines 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple1[A]
\end_layout

\end_inset

 as a tuple with a single part.
 (This type is occasionally useful in practice.) 
\end_layout

\begin_layout Standard
The tuple with zero parts exists as well, and is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 (rather than 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple0
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

).
 At first sight, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type may appear to be completely useless; it is a tuple that contains 
\emph on
no
\emph default
 elements.
 The syntax for the value of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type is the empty tuple, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 It is clear that there is 
\emph on
only one
\emph default
 value, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, of this type; this explains the name 
\begin_inset Quotes eld
\end_inset

unit
\begin_inset Quotes erd
\end_inset

.
 It turns out, however, that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type is important in functional programming, and it is used as a type 
\emph on
guaranteed
\emph default
 to have only a single distinct value.
 This chapter will show some examples of using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
\end_layout

\begin_layout Standard
Case classes can be defined similarly to the one-part and zero-part tuples
 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class B(z: Int) // Tuple with one part.
\end_layout

\begin_layout Plain Layout

case class C() // Tuple with no parts.
\end_layout

\end_inset

Let us summarize the correspondence between tuples and case classes:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tuples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Case classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(123, "xyz"): Tuple2[Int, String]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class A(x: Int, y: String)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(123,): Tuple1[Int]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class B(z: Int)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(): Unit
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Scala has a special syntax for empty case class
\begin_inset Index idx
status open

\begin_layout Plain Layout
empty case class
\end_layout

\end_inset

es:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case object C // Similar to `case class C()`.
\end_layout

\end_inset

There are two main differences between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object C
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

 cannot have type parameters, while we may define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C[X, Y, Z]()
\end_layout

\end_inset

 if needed.
\end_layout

\begin_layout Itemize
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

 is allocated in memory only once, while new values of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 will be allocated in memory each time 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C()
\end_layout

\end_inset

 is evaluated.
\end_layout

\begin_layout Standard
Other than that, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object C
\end_layout

\end_inset

 have the same meaning: a named tuple with zero parts, which we may also
 call a 
\begin_inset Quotes eld
\end_inset

named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Index true 1 ""
status open

\begin_layout Plain Layout
named Unit
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 type.
 In this book, I will not use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

s because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class
\end_layout

\end_inset

es are more general.
\end_layout

\begin_layout Subsection
Pattern matching for case classes
\end_layout

\begin_layout Standard
Scala performs pattern matching in two situations:
\end_layout

\begin_layout Itemize
destructuring definition: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

val $pattern$ = ...
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

case $pattern$ => ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Case classes can be used in both situations.
 Here is an example of a destructuring definition, used to implement a function
 whose argument is of case class type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BagOfSocks
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySock(size: Double, color: String)
\end_layout

\begin_layout Plain Layout

case class BagOfSocks(sock: MySock, count: Int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def printBag(bag: BagOfSocks): String = {
\end_layout

\begin_layout Plain Layout

  val BagOfSocks(MySock(size, color), count) = bag // Destructure the `bag`.
\end_layout

\begin_layout Plain Layout

  s
\begin_inset Quotes eld
\end_inset

Bag has $count $color socks of size $size
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val bag = BagOfSocks(MySock(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

), 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> printBag(bag)
\end_layout

\begin_layout Plain Layout

res0: String = Bag has 6 white socks of size 10.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An example of using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fitsMe(bag: BagOfSocks): Boolean = bag match {
\end_layout

\begin_layout Plain Layout

  case BagOfSocks(MySock(size, _), _) => size >= 10.5 && size <= 11.0
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the implementation of this function, we match the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bag
\end_layout

\end_inset

 value against the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BagOfSocks(MySock(size, _), _)
\end_layout

\end_inset

.
 This pattern will always match and will define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

 as the pattern variable of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The syntax for pattern matching expressions that use case classes is similar
 to the syntax for pattern matching of tuples, except for the presence of
 the 
\emph on
names
\emph default
 of the case classes.
 For example, if we remove the type names from the pattern
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case BagOfSocks(MySock(size, _), _) => ...
\end_layout

\end_inset

we obtain the nested tuple pattern 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case ((size, _), _) => ...
\end_layout

\end_inset

that could be used for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((Double, String), Int)
\end_layout

\end_inset

.
 We see that case classes behave in many ways exactly as named tuple types.
 
\end_layout

\begin_layout Standard
Scala's 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset

 got their name from their use in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions.
 It is usually more convenient to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions with case classes than to use destructuring.
\end_layout

\begin_layout Section
Disjunctive types
\end_layout

\begin_layout Subsection
Motivation and first examples
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Motivation-and-first-examples"

\end_inset


\end_layout

\begin_layout Standard
In many situations, it is useful to have several different shapes of data
 within the same type.
 As a first example, suppose we are looking for real roots of a quadratic
 equation 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

.
 There are three cases: no real roots, one real root, and two real roots.
 It would be convenient if we had a type, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

, that means 
\begin_inset Quotes eld
\end_inset

the real roots of a quadratic equation
\begin_inset Quotes erd
\end_inset

.
 Inside that type, we can distinguish between the three cases, but outside
 it looks like a single type, so that it is easier to work with.
\end_layout

\begin_layout Standard
Another example is the binary search algorithm that looks for an integer
 
\begin_inset Formula $x$
\end_inset

 in a sorted array.
 There are two cases: the algorithm either finds the index of 
\begin_inset Formula $x$
\end_inset

 or determines that the array does not contain 
\begin_inset Formula $x$
\end_inset

.
 It is convenient if the algorithm could return a single value of a type,
 say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

, that represents 
\emph on
either
\emph default
 an index at which 
\begin_inset Formula $x$
\end_inset

 is found, 
\emph on
or
\emph default
 the absence of an index.
\end_layout

\begin_layout Standard
More generally, we may have computations that 
\emph on
either
\emph default
 return a value 
\emph on
or
\emph default
 generate an error and fail to produce a result.
 It is then convenient to return a value of type, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

, that could represent 
\emph on
either
\emph default
 a correct result 
\emph on
or
\emph default
 an error message.
 
\end_layout

\begin_layout Standard
In certain computer games, one has different types of 
\begin_inset Quotes eld
\end_inset

rooms
\begin_inset Quotes erd
\end_inset

, each room having certain properties depending on its type, – some rooms
 are dangerous because of monsters, other rooms contain useful objects,
 certain rooms allow you to finish the game, and so on.
 We want to represent all the different kinds of rooms uniformly, as a type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Room
\end_layout

\end_inset

, so that each 
\begin_inset Quotes eld
\end_inset

room value
\begin_inset Quotes erd
\end_inset

 automatically stores the correct properties in each case.
\end_layout

\begin_layout Standard
In all these situations, data comes in several mutually exclusive shapes.
 This data can be represented by a single type only if that type is able
 to describe a mutually exclusive set of cases:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 must be either the empty tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 or a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 must be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or the empty tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 must be either an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 value or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 message
\end_layout

\begin_layout Standard
We see that the empty tuple, also known as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, is convenient to use in this representation! It is also helpful to
 assign names to each of the cases:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

no roots
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

one root
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

two roots
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

index
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

not found
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset Quotes eld
\end_inset

error message
\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Scala's case classes provide exactly what we need here – 
\emph on
named tuples
\emph default
 with zero, one, two and more parts, and so it is natural to use case classes
 instead of tuples:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class NoRoots()
\end_layout

\end_inset

, or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class OneRoot(x: Double)
\end_layout

\end_inset

, or of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class TwoRoots(x: Double, y: Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Index(Int)
\end_layout

\end_inset

 or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class None()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Value(x: Int)
\end_layout

\end_inset

 or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Error(message: String)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our three examples are now described as types that select one case class
 out of a given set.
 The only remaining question is how Scala defines such types.
 For instance, the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 somehow needs to indicate that the case classes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

 are exactly the three alternatives described by the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
 The Scala syntax for this definition looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class NoRoots() extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class OneRoot(x: Double) extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class TwoRoots(x: Double, y: Double) extends RootsOfQ
\end_layout

\end_inset

In the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

, we we have two cases:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait SearchResult
\end_layout

\begin_layout Plain Layout

final case class Index(i: Int) extends SearchResult
\end_layout

\begin_layout Plain Layout

final case class NotFound() extends SearchResult
\end_layout

\end_inset

The definition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 type can be parameterized, so that we can describe results of any type
 (but error messages are always of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Result[A]
\end_layout

\begin_layout Plain Layout

final case class Value[A](x: A) extends Result[A]
\end_layout

\begin_layout Plain Layout

final case class Error[A](message: String) extends Result[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sealed trait
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

final case class
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 syntax defines a type that represents a choice of one case class from a
 fixed set of case classes.
 This kind of type is called the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type
\end_layout

\end_inset

disjunctive type
\series default
 in this book.
 
\end_layout

\begin_layout Subsection
Solved examples: Pattern matching with disjunctive types
\end_layout

\begin_layout Standard
Our first examples of disjunctive types are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[A]
\end_layout

\end_inset

 defined in the previous section.
 We will now look at the Scala syntax for 
\emph on
creating
\emph default
 values of disjunctive types and for 
\emph on
using
\emph default
 the created values.
\end_layout

\begin_layout Standard
Consider the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 that has three case classes (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

).
 The only way of creating a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is to create a value of one of these case classes.
 This is done by writing expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(2.0)
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(1.0, -1.0)
\end_layout

\end_inset

.
 Scala will accept these expressions as having the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x: RootsOfQ = OneRoot(2.0)
\end_layout

\begin_layout Plain Layout

x: RootsOfQ = OneRoot(2.0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:RootsOfQ
\end_layout

\end_inset

, how can we use it, say, as a function argument? The main tool for working
 with values of disjunctive types is pattern matching with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression needs to have one or more patterns, so that all possible cases
 of the disjunctive type are matched.
 If we only need to recognize a specific case of a disjunctive type, we
 can match all other cases with an underscore:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> x match {
\end_layout

\begin_layout Plain Layout

  case OneRoot(r) => s
\begin_inset Quotes erd
\end_inset

have one root $r
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case _          => 
\begin_inset Quotes eld
\end_inset

have something else
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

res0: String = have one root 2.0
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression represents a choice over possible values of a given type.
 Note the similarity with this code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int): Int = x match {
\end_layout

\begin_layout Plain Layout

  case 0    => println(s"error: must be nonzero"); -1
\end_layout

\begin_layout Plain Layout

  case 1    => println(s"error: must be greater than 1"); -1
\end_layout

\begin_layout Plain Layout

  case _    => x
\end_layout

\begin_layout Plain Layout

} // 0 and 1 are some possible values of type Int.
\end_layout

\end_inset

The values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

 are possible values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, just as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(1.0)
\end_layout

\end_inset

 is a possible value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
 As a rule, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions will contain a complete list of possibilities to match.
 If the list of cases is incomplete, the Scala compiler will print a warning
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def g(x: RootsOfQ): String = x match {
\end_layout

\begin_layout Plain Layout

     |    case OneRoot(r) => s"have one root $r"
\end_layout

\begin_layout Plain Layout

     | }
\end_layout

\begin_layout Plain Layout

<console>:14: warning: match may not be exhaustive.
\end_layout

\begin_layout Plain Layout

It would fail on the following inputs: NoRoots(), TwoRoots(_, _)
\end_layout

\begin_layout Plain Layout

       def g(x: RootsOfQ): String = x match {
\end_layout

\begin_layout Plain Layout

                                    ^
\end_layout

\begin_layout Plain Layout

g: (x: RootsOfQ)String
\end_layout

\end_inset

This code defines a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial function
\end_layout

\end_inset

partial function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 that can be applied only to values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(...)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Let us look at more examples of using the disjunctive types we just defined.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-rootsofq-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a sequence of quadratic equations, compute the sequence that contains
 their real roots as values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Define a case class representing a quadratic equation 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class QEqu(b: Double, c: Double)
\end_layout

\end_inset

The following function determines how many real roots an equation has:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def solve(quadraticEqu: QEqu): RootsOfQ = {
\end_layout

\begin_layout Plain Layout

   val QEqu(b, c) = quadraticEqu // Destructure QEqu.
\end_layout

\begin_layout Plain Layout

   val d = b * b / 4 - c
\end_layout

\begin_layout Plain Layout

   if (d > 0) {
\end_layout

\begin_layout Plain Layout

     val s = math.sqrt(d)
\end_layout

\begin_layout Plain Layout

     TwoRoots(b / 2 - s, b / 2 + s)
\end_layout

\begin_layout Plain Layout

   } else if (d == 0.0) OneRoot(b / 2)
\end_layout

\begin_layout Plain Layout

   else NoRoots()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Test this function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> solve(QEqu(1,1))
\end_layout

\begin_layout Plain Layout

res1: RootsOfQ = NoRoots()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> solve(QEqu(1,-1))
\end_layout

\begin_layout Plain Layout

res2: RootsOfQ = TwoRoots(-0.6180339887498949,1.618033988749895) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> solve(QEqu(6,9))
\end_layout

\begin_layout Plain Layout

res3: RootsOfQ = OneRoot(3.0) 
\end_layout

\end_inset

We can now solve this example via this code,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map(solve)
\end_layout

\end_inset

If the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve
\end_layout

\end_inset

 is not used often, we may want to write it inline:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map { case QEqu(b, c)
 =>
\end_layout

\begin_layout Plain Layout

  (b * b / 4 - c) match {
\end_layout

\begin_layout Plain Layout

    case d if d > 0   =>
\end_layout

\begin_layout Plain Layout

      val s = math.sqrt(d)
\end_layout

\begin_layout Plain Layout

      TwoRoots(b / 2 - s, b / 2 + s)
\end_layout

\begin_layout Plain Layout

    case 0.0          => OneRoot(b / 2)
\end_layout

\begin_layout Plain Layout

    case _            => NoRoots()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code illustrates some features of Scala syntax.
 We can use the partial function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case QEqu(b, c) => ...
 }
\end_layout

\end_inset

 directly as the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 instead of defining this function separately.
 This avoids the need to destructure 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

QEqu
\end_layout

\end_inset

 at a separate step.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 expression is replaced by an 
\begin_inset Quotes eld
\end_inset

embedded
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
embedded `if`
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 within the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression, which is easier to read.
 Test the final code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> findRoots(Seq(QEqu(1,1), QEqu(2,1)))
\end_layout

\begin_layout Plain Layout

res4: Seq[RootsOfQ] = List(NoRoots(), OneRoot(1.0)) 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-rootsofq"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a sequence of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

, compute the sequence that contains only the single roots.
 Example test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> singleRoots(Seq(TwoRoots(-1, 1), OneRoot(3.0), OneRoot(1.0), NoRoots()))
\end_layout

\begin_layout Plain Layout

res5: Seq[Double] = List(3.0, 1.0) 
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 to the sequence of roots:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] = rs.filter {
\end_layout

\begin_layout Plain Layout

  case OneRoot(x) => true
\end_layout

\begin_layout Plain Layout

  case _          => false
\end_layout

\begin_layout Plain Layout

}.map { case OneRoot(x) => x }
\end_layout

\end_inset

In the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 operation, we only need to cover the one-root case because the other two
 possibilities have been 
\begin_inset Quotes eld
\end_inset

filtered out
\begin_inset Quotes erd
\end_inset

 by the preceding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 operation.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-searchresult"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-searchresult"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement binary search returning a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

.
 We will modify the binary search implementation from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-binary-search-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b) so that it returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NotFound
\end_layout

\end_inset

 value when appropriate.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The code from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-binary-search-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b) will return 
\emph on
some
\emph default
 index even if the given number is not present in the array: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> binSearch(Array(1, 3, 5, 7), 5)
\end_layout

\begin_layout Plain Layout

res6: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> binSearch(Array(1, 3, 5, 7), 4)
\end_layout

\begin_layout Plain Layout

res7: Int = 1
\end_layout

\end_inset

When the number is not present, the array's element at the computed index
 will not be equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

goal
\end_layout

\end_inset

.
 We can return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NotFound
\end_layout

\end_inset

 in that case.
 The new code can be written as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression for clarity:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def safeBinSearch(xs: Seq[Int], goal: Int): SearchResult = binSearch(xs,
 goal) match {
\end_layout

\begin_layout Plain Layout

  case n if xs(n) == goal   => Index(n) 
\end_layout

\begin_layout Plain Layout

  case _                    => NotFound()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> safeBinSearch(Array(1, 3, 5, 7), 5)
\end_layout

\begin_layout Plain Layout

res8: SearchResult = Index(2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> safeBinSearch(Array(1, 3, 5, 7), 4)
\end_layout

\begin_layout Plain Layout

res9: SearchResult = NotFound()
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-resultA"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

 to implement safe arithmetic where a division by zero or a square root
 of a negative number will give an error message.
 Define arithmetic operations directly for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

; abandon computations if an error occurs.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing the square root:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sqrt(rx: Result[Int]): Result[Int] = rx match {
\end_layout

\begin_layout Plain Layout

  case Value(x) if x >= 0  => Value(math.sqrt(x).toInt)
\end_layout

\begin_layout Plain Layout

  case Value(x)            => Error(s
\begin_inset Quotes eld
\end_inset

error: sqrt($x)
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

  case Error(m)            => Error(m) // Keep the error message.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The square root is computed only if we have the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value(x)
\end_layout

\end_inset

 case, and only if 
\begin_inset Formula $x\geq0$
\end_inset

.
 If the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rx
\end_layout

\end_inset

 was already an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Error
\end_layout

\end_inset

 case, we keep the error message and perform no further operations.
\end_layout

\begin_layout Standard
To implement the addition operation, we need a bit more work:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) => Value(x + y)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)        => Error(m) // On any error, do no further computati
ons.
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code illustrates nested patterns that match the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(rx, ry)
\end_layout

\end_inset

 against various possibilities.
 In this way, the code is clearer than it would be if written with nested
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 expressions.
\end_layout

\begin_layout Standard
Implementing the multiplication operation results in almost the same code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def mul(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) => Value(x * y)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)        => Error(m)
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To avoid the repetition of code, we may define a general function that 
\begin_inset Quotes eld
\end_inset

promotes
\begin_inset Quotes erd
\end_inset

 operations on integers to operations on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

 types:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def do2(rx: Result[Int], ry: Result[Int])(op: (Int, Int) => Int): Result[Int]
 =
\end_layout

\begin_layout Plain Layout

  (rx, ry) match {
\end_layout

\begin_layout Plain Layout

    case (Value(x), Value(y)) => Value(op(x, y))
\end_layout

\begin_layout Plain Layout

    case (Error(m), _)        => Error(m)
\end_layout

\begin_layout Plain Layout

    case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

Now we can easily 
\begin_inset Quotes eld
\end_inset

promote
\begin_inset Quotes erd
\end_inset

 any binary operation that never generates an error to an operation on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sub(rx: Result[Int], ry: Result[Int]): Result[Int] = do2(rx, ry){ (x,
 y) => x - y }
\end_layout

\end_inset

 Custom code is still needed for operations that may generate errors:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def div(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) if y != 0 => Value(x / y)
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y))            => Error(s
\begin_inset Quotes eld
\end_inset

error: $x / $y
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)        => Error(m)
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can now test the new 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

 on simple calculations:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> add(Value(1), Value(2))
\end_layout

\begin_layout Plain Layout

res10: Result[Int] = Value(3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> div(add(Value(1), Value(2)), Value(0))
\end_layout

\begin_layout Plain Layout

res11: Result[Int] = Error(error: 3 / 0)
\end_layout

\end_inset

We see that indeed all further computations are abandoned once an error
 occurs.
 An error message shows only the immediate calculation that generated the
 error.
 For instance, the error message for 
\begin_inset Formula $20+\frac{1}{0}$
\end_inset

 never mentions 
\begin_inset Formula $20$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> add(Value(20), div(Value(1), Value(0)))
\end_layout

\begin_layout Plain Layout

res12: Result[Int] = Error(error: 1 / 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> add(sqrt(Value(-1)), Value(10))
\end_layout

\begin_layout Plain Layout

res13: Result[Int] = Error(error: sqrt(-1))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Standard disjunctive types: 
\family typewriter
Option
\family default
, 
\family typewriter
Either
\family default
, 
\family typewriter
Try
\end_layout

\begin_layout Standard
The Scala library defines the disjunctive types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 because they are used often.
 
\end_layout

\begin_layout Paragraph

\family typewriter
Option
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type is a disjunctive type with two cases: the empty tuple and a one-element
 tuple.
 The names of the two case classes are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some
\end_layout

\end_inset

.
 If the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type were not already defined in the standard library, one could define
 it with the code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Option[T]
\end_layout

\begin_layout Plain Layout

final case object None extends Option[Nothing]
\end_layout

\begin_layout Plain Layout

final case class Some[T](t: T) extends Option[T]
\end_layout

\end_inset

This code is similar to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Motivation-and-first-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

 except that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 has a type parameter instead of a fixed type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 Another difference is the use of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

 for the empty case instead of an empty case class, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None()
\end_layout

\end_inset

.
 Since Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

s cannot have type parameters, the type parameter in the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 must be set to the special type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

, which is a type with 
\emph on
no
\emph default
 values.
\end_layout

\begin_layout Standard
An alternative (implemented in libraries such as 
\family typewriter
scalaz
\family default
) is to define 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class None[T]() extends Option[T]
\end_layout

\end_inset

and write the empty option value as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None()
\end_layout

\end_inset

.
 In that implementation, the empty option also has a type parameter.
\end_layout

\begin_layout Standard
Several consequences follow from the Scala standard library's decision to
 define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 without a type parameter.
 One consequence is that the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 can be reused as a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 for any type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val y: Option[Int] = None
\end_layout

\begin_layout Plain Layout

y: Option[Int] = None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val z: Option[String] = None
\end_layout

\begin_layout Plain Layout

z: Option[String] = None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Typical usage of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 is for situations where a value may be either present or missing, especially
 when the missing value is 
\emph on
not an error
\emph default
.
 The missing-value case is then represented by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(...)
\end_layout

\end_inset

 represents the case where a value is present.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Example-option-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-option-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Suppose that information about subscribers to a certain online service must
 contain a name and an email address, but a telephone number is optional.
 To represent this information, we may define a case class like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Subscriber(name: String, email: String, phone: Option[Long])
\end_layout

\end_inset

What if we represent the missing telephone number by a special integer value
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-1
\end_layout

\end_inset

, which allows us to use the simpler type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

? The disadvantage is that we need to remember to check for this special
 value in every function that takes the telephone number as an argument.
 Looking at a function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sendSMS(phone: Long)
\end_layout

\end_inset

 in a different place in the code, another software developer might forget
 that the telephone number is actually optional.
 The type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sendSMS(phone: Option[Long])
\end_layout

\end_inset

 unambiguously indicates to everyone that the telephone number might be
 missing.
\end_layout

\begin_layout Standard
Pattern-matching code involving 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 needs two cases:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def getDigits(phone: Option[Long]): Option[Seq[Long]] = phone match {
\end_layout

\begin_layout Plain Layout

  case None               => None // Do nothing.
\end_layout

\begin_layout Plain Layout

  case Some(number)       => Some(digitsOf(number))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Here we used the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsOf
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ch2Converting-a-single"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Note that the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 is used with different types on the two sides of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case None => None
\end_layout

\end_inset

, namely 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Seq[Long]]
\end_layout

\end_inset

.
 Since these types are declared in the type signature of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getDigits
\end_layout

\end_inset

, the Scala compiler is able to deduce the correct types of all expressions
 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 construction.
 This allows us to write shorter pattern-matching code.
\end_layout

\begin_layout Standard
If we now need to compute the number of digits, we can write
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def numberOfDigits(phone: Option[Long]): Option[Long] = getDigits(phone)
 match {
\end_layout

\begin_layout Plain Layout

  case None               => None // Do nothing.
\end_layout

\begin_layout Plain Layout

  case Some(digits)       => Some(digits.length)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is often useful to perform some computation when an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 value is not empty, and to leave it empty otherwise.
 Rather than keep repeating this kind of code, we can implement this logic
 as a function that takes the computation as a parameter: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def doComputation(x: Option[Long], f: Long => Long): Option[Long] = x match
 {
\end_layout

\begin_layout Plain Layout

  case None               => None // Do nothing.
\end_layout

\begin_layout Plain Layout

  case Some(i)            => Some(f(i))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It is then natural to generalize this function to arbitrary types using
 type parameters, rather than a fixed type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

.
 The result is a function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B] = {
\end_layout

\begin_layout Plain Layout

  case None               => None // Do nothing.
\end_layout

\begin_layout Plain Layout

  case Some(a)            => Some(f(a))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fmap(digitsOf)(Some(4096))
\end_layout

\begin_layout Plain Layout

res0: Option[Seq[Long]] = Some(List(4, 0, 9, 6))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fmap(digitsOf)(None)
\end_layout

\begin_layout Plain Layout

res1: Option[Seq[Long]] = None
\end_layout

\end_inset

One can say that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 operation 
\begin_inset Quotes eld
\end_inset

lifts
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

raises
\begin_inset Quotes erd
\end_inset

 a given function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

 to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A] => Option[B]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The Scala library implements an equivalent function as a method on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 class, with the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(f)
\end_layout

\end_inset

 rather than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(x)
\end_layout

\end_inset

.
 We can concisely rewrite the previous code using the library methods as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def getDigits(phone: Option[Long]): Option[Seq[Long]] = phone.map(digitsOf)
\end_layout

\begin_layout Plain Layout

def numberOfDigits(phone: Option[Long]): Option[Long] = phone.map(digitsOf).map(_.l
ength)
\end_layout

\end_inset

We see that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 operation for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type is analogous to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 operation for sequences.
 
\end_layout

\begin_layout Standard
The similarity between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 is made clearer if we imagine 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 to be a sequence whose length is restricted to be either 
\begin_inset Formula $0$
\end_inset

 or 
\begin_inset Formula $1$
\end_inset

.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 can have all the operations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

, except the operations such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.concat
\end_layout

\end_inset

 that may increase the length of the sequence.
 The admissible operations defined on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 include 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.forall
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.exists
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunction-Example-Option-flatMap"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunction-Example-Option-flatMap"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a phone number as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

, extract the country code if it is present.
 (Assume that the country code is any digits in front of the 
\begin_inset Formula $10$
\end_inset

-digit number; for the phone number 
\begin_inset Formula $18004151212$
\end_inset

, the country code is 
\begin_inset Formula $1$
\end_inset

.) The result must be again of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
If the phone number is a positive integer 
\begin_inset Formula $n$
\end_inset

, we may compute the country code simply as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n / 10000000000L
\end_layout

\end_inset

.
 However, if the result is zero, we should return an empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 (i.e.
\begin_inset space ~
\end_inset

the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

) rather than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
 To implement this logic, we may begin by writing this code,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone match {
\end_layout

\begin_layout Plain Layout

  case None => None
\end_layout

\begin_layout Plain Layout

  case Some(n) =>
\end_layout

\begin_layout Plain Layout

    val countryCode = n / 10000000000L
\end_layout

\begin_layout Plain Layout

    if (countryCode != 0L) Some(countryCode) else None 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We may notice that we have reimplemented the design pattern similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 in this code, namely 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, else do a computation
\begin_inset Quotes erd
\end_inset

.
 So we may try to rewrite the code as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone.map { n =>
\end_layout

\begin_layout Plain Layout

    val countryCode = n / 10000000000L
\end_layout

\begin_layout Plain Layout

    if (countryCode != 0L) Some(countryCode) else None 
\end_layout

\begin_layout Plain Layout

} // Type error: the result is Option[Option[Long]].
\end_layout

\end_inset

But this code will not compile: we are returning an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

 within a function that we raise using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, so the resulting type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[Long]]
\end_layout

\end_inset

.
 To convert it to the required 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

, we may use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

, and since this follows a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, we can rewrite the code using a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 operation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone.flatMap { n =>
\end_layout

\begin_layout Plain Layout

    val countryCode = n / 10000000000L
\end_layout

\begin_layout Plain Layout

    if (countryCode != 0L) Some(countryCode) else None 
\end_layout

\begin_layout Plain Layout

} // Types are correct now.
\end_layout

\end_inset

Another way of implementing this code is to notice the design pattern 
\begin_inset Quotes eld
\end_inset

if condition does not hold, return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, otherwise keep the value
\begin_inset Quotes erd
\end_inset

.
 For an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type, this is equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 operation.
 So the final code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = 
\end_layout

\begin_layout Plain Layout

  phone.map(_ / 10000000000L).filter(_ != 0L)
\end_layout

\end_inset

Test it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> countryCode(Some(18004151212L))
\end_layout

\begin_layout Plain Layout

res0: Option[Long] = Some(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> countryCode(Some(8004151212L))
\end_layout

\begin_layout Plain Layout

res1: Option[Long] = None
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunction-Example-Option-getOrElse"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunction-Example-Option-getOrElse"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Continue with the phone number example, and suppose that we have a new requireme
nt: if the country code is not present, we need return the default country
 code 
\begin_inset Formula $1$
\end_inset

.
 This is an often used design pattern: 
\begin_inset Quotes eld
\end_inset

if empty, substitute a default value
\begin_inset Quotes erd
\end_inset

.
 The Scala library has the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.getOrElse
\end_layout

\end_inset

 for this purpose:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Some(100).getOrElse(1)
\end_layout

\begin_layout Plain Layout

res2: Int = 100
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> None.getOrElse(1)
\end_layout

\begin_layout Plain Layout

res3: Int = 1
\end_layout

\end_inset

So we can implement the new requirement as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> countryCode(Some(8004151212L)).getOrElse(1L)
\end_layout

\begin_layout Plain Layout

res4: Long = 1
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Using 
\family typewriter
Option
\family default
 with collections
\end_layout

\begin_layout Standard
Many Scala library methods return an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 as a result.
 The main examples are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.find
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.headOption
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.lift
\end_layout

\end_inset

 for sequences, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.get
\end_layout

\end_inset

 for dictionaries.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.find
\end_layout

\end_inset

 method returns the first element satisfying a predicate:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).find(_ > 5)
\end_layout

\begin_layout Plain Layout

res0: Option[Int] = Some(6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (1 to 10).find(_ > 10) // No element is > 10.
\end_layout

\begin_layout Plain Layout

res1: Option[Int] = None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.lift
\end_layout

\end_inset

 method returns the element of a sequence at a given index:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (10 to 100).lift(0)
\end_layout

\begin_layout Plain Layout

res2: Option[Int] = Some(10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (10 to 100).lift(1000) // No element at index 1000.
\end_layout

\begin_layout Plain Layout

res3: Option[Int] = None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.headOption
\end_layout

\end_inset

 method returns the first element of a sequence, unless the sequence is
 empty.
 This is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.lift(0)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1,2,3).headOption
\end_layout

\begin_layout Plain Layout

res4: Option[Int] = Some(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(1,2,3).filter(_ > 10).headOption
\end_layout

\begin_layout Plain Layout

res5: Option[Int] = None
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.find(p)
\end_layout

\end_inset

 method computes the same result as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter(p).headOption
\end_layout

\end_inset

, but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.find(p)
\end_layout

\end_inset

 may be more efficient.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.get
\end_layout

\end_inset

 method for a dictionary returns the value if it exists for a given key,
 and returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 if the key is not in the dictionary:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b").get(10)
\end_layout

\begin_layout Plain Layout

res6: Option[String] = Some(a)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b").get(30)
\end_layout

\begin_layout Plain Layout

res7: Option[String] = None 
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.get
\end_layout

\end_inset

 method provides safe by-key access to dictionaries, unlike the direct access
 method that may fail:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b")(10)
\end_layout

\begin_layout Plain Layout

res8: String = a 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b")(30)
\end_layout

\begin_layout Plain Layout

java.util.NoSuchElementException: key not found: 30
\end_layout

\begin_layout Plain Layout

  at scala.collection.MapLike$class.default(MapLike.scala:228)
\end_layout

\begin_layout Plain Layout

  at scala.collection.AbstractMap.default(Map.scala:59)
\end_layout

\begin_layout Plain Layout

  ...
 32 elided
\end_layout

\end_inset

Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.lift
\end_layout

\end_inset

 provides safe by-index access to collections, unlike the direct access
 that may fail:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(10,20,30)(0)
\end_layout

\begin_layout Plain Layout

res9: Int = 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(10,20,30)(5)
\end_layout

\begin_layout Plain Layout

java.lang.IndexOutOfBoundsException: 5
\end_layout

\begin_layout Plain Layout

  at scala.collection.LinearSeqOptimized$class.apply(LinearSeqOptimized.scala:65)
\end_layout

\begin_layout Plain Layout

  at scala.collection.immutable.List.apply(List.scala:84)
\end_layout

\begin_layout Plain Layout

  ...
 32 elided
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
Either
\end_layout

\begin_layout Standard
The standard disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 has two type parameters and is often used for computations that may report
 errors.
 By convention, the 
\emph on
first
\emph default
 type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

) is the type of error, and the 
\emph on
second
\emph default
 type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

) is the type of the (non-error) result.
 The names of the two cases are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

.
 A possible definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Either[A, B]
\end_layout

\begin_layout Plain Layout

final case class  Left[A, B](value: A) extends Either[A, B]
\end_layout

\begin_layout Plain Layout

final case class Right[A, B](value: B) extends Either[A, B]
\end_layout

\end_inset

By convention, a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 is used to represent an error, and a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 is used to represent a valid result.
\end_layout

\begin_layout Standard
As an example, the following function substitutes a default value and logs
 the error information given by an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def logError(x: Either[String, Int], default: Int): Int = x match {
\end_layout

\begin_layout Plain Layout

  case Left(error) => println(s"Got error: $error"); default
\end_layout

\begin_layout Plain Layout

  case Right(res) => res
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> logError(Right(123), -1)
\end_layout

\begin_layout Plain Layout

res1: Int = 123
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> logError(Left("bad result"), -1)
\end_layout

\begin_layout Plain Layout

Got error: bad result
\end_layout

\begin_layout Plain Layout

res2: Int = -1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Why use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 for computations that may fail? A failing computation such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1/0
\end_layout

\end_inset

 could return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 to indicate that the result is not available.
 However, the result is not an optional value that may be missing; usually
 the result is required, and if it is not available, we need to know exactly
 
\emph on
which
\emph default
 error occurred.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type provides the possibility to store information about the error, which
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 does not provide.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type generalizes the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Motivation-and-first-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with an arbitrary error type instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 We have seen its usage in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where the design pattern was 
\begin_inset Quotes eld
\end_inset

if value is present, do a computation, otherwise keep the error
\begin_inset Quotes erd
\end_inset

.
 This design pattern is implemented by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Right(1).map(_ + 1)
\end_layout

\begin_layout Plain Layout

res0: Either[Nothing, Int] = Right(2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Left[String, Int]("error").map(_ + 1)
\end_layout

\begin_layout Plain Layout

res1: Either[String, Int] = Left(
\begin_inset Quotes eld
\end_inset

error
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 was filled in by the Scala compiler because we did not specify the full
 type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 in the first line.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.fold
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.getOrElse
\end_layout

\end_inset

 are also defined for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 class, with the same convention that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(...)
\end_layout

\end_inset

 values represent error information.
\begin_inset Foot
status open

\begin_layout Plain Layout
These methods are defined in Scala 2.12 or a later version.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Exceptions and 
\family typewriter
Try
\end_layout

\begin_layout Standard
When computations fail for any reason, Scala generates an 
\series bold
exception
\begin_inset Index idx
status open

\begin_layout Plain Layout
exception
\end_layout

\end_inset


\series default
 instead of returning a value.
 An exception means that a value cannot be computed because the evaluation
 of the expression stopped without returning a result.
\end_layout

\begin_layout Standard
For instance, an exception will be generated when the resulting data cannot
 be stored in memory because the memory is full (as we saw in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Lazy-values-iterators-and-streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

), or if a stack overflow occurs during the computation (as we saw in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Tail-recursion"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We have also seen exceptions occur due to programmer's error – when a pattern
 matching operation fails, when a requested key does not exist in a dictionary,
 or when the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.head
\end_layout

\end_inset

 operation is applied to an empty list.
\end_layout

\begin_layout Standard
We could call these two kinds of exceptions 
\begin_inset Quotes eld
\end_inset

planned
\begin_inset Index idx
status open

\begin_layout Plain Layout
planned exception
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

unplanned
\begin_inset Index idx
status open

\begin_layout Plain Layout
unplanned exception
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
A 
\series bold
planned
\series default
 exception is generated by programmer's code using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 operation,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> throw new Exception("this is a test...
 this is only a test")
\end_layout

\begin_layout Plain Layout

java.lang.Exception: this is a test...
 this is only a test
\end_layout

\begin_layout Plain Layout

  ...
 42 elided
\end_layout

\end_inset

The Scala library contains a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 operation in various places, such as in the code for applying the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.head
\end_layout

\end_inset

 operation to an empty sequence, as well as in other situations where exceptions
 are generated due to programmer's errors.
 These exceptions are generated deliberately and in well-defined situations.
 Although these exceptions indicate errors, these errors can be fixed and
 the program evaluation can proceed.
\end_layout

\begin_layout Standard
For example, many Java libraries will generate exceptions when function
 arguments have unexpected values, when a network download takes too long
 or fails to make a network connection, when a file is not found or cannot
 be read, and in many other situations.
 All these error situations are 
\begin_inset Quotes eld
\end_inset

planned
\begin_inset Quotes erd
\end_inset

 exceptions because they are generated explicitly by library code such as
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw new Exception(
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

.
 The programmer's code is expected to catch these exceptions, to fix the
 problem, and to continue the evaluation of the program.
 
\end_layout

\begin_layout Standard
An 
\series bold
unplanned
\series default
 exception is generated by the Java runtime system when critical errors
 occur, such as an out-of-memory error.
 It is rare that a programmer writes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val y = f(x)
\end_layout

\end_inset

 while 
\emph on
expecting
\emph default
 that an out-of-memory exception will sometimes occur at that point.
 An unplanned exception indicates a serious and unforeseen problem with
 memory or other critically important resources such as the operating system's
 threads and file handles.
 Such a problem usually cannot be fixed and prevents the program from evaluating
 any further.
 It is reasonable that the program evaluation should immediately stop (or
 
\begin_inset Quotes eld
\end_inset

crash
\begin_inset Quotes erd
\end_inset

 as programmers say) after such an error.
\end_layout

\begin_layout Standard
Planned exceptions make programs significantly harder to write correctly.
 It is often hard to indicate explicitly all the possible exceptions that
 a given library function may 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 in its code or in the code of some other libraries on which it depends.
 Instead of using exceptions, Scala programmers can write functions that
 return a disjunctive type such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, describing both the correct result and a possible error condition.
 Users of these functions will need to do pattern matching on the results,
 which indicates unambiguously both the possible presence of errors and
 the kinds of errors.
\end_layout

\begin_layout Standard
However, the programmer will often need to use Java libraries (or Scala
 libraries) that generate planned exceptions.
 To help write code for these situations, the Scala library contains a utility
 function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 and a disjunctive type also called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

.
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try[A]
\end_layout

\end_inset

 can be seen as equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Throwable, A]
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Throwable
\end_layout

\end_inset

 is the parent type of all exceptions (i.e.
\begin_inset space ~
\end_inset

any value that can appear under a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 operation).
 The two parts of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try[A]
\end_layout

\end_inset

 are called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Success[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Failure
\end_layout

\end_inset

 (instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type).
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try(expr)
\end_layout

\end_inset

 will catch all exceptions thrown while the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 is evaluated.
 If the evaluation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 succeeded and returned a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

, the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try(expr)
\end_layout

\end_inset

 will be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Success(x)
\end_layout

\end_inset

.
 Otherwise it will be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Failure(t)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t:Throwable
\end_layout

\end_inset

 is the value associated with the generated exception.
 That value Here is an example of using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import scala.util.{Try,Success,Failure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Try(1/0)
\end_layout

\begin_layout Plain Layout

res0: Try[Int] = Failure(java.lang.ArithmeticException: / by zero)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Try(1+1)
\end_layout

\begin_layout Plain Layout

res1: Try[Int] = Success(2) 
\end_layout

\end_inset

Unlike computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1/0
\end_layout

\end_inset

 without an enclosing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try()
\end_layout

\end_inset

, the computation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try(1/0)
\end_layout

\end_inset

 does not generate any exceptions and will not crash the program.
 Any computation that may throw an exception can be enclosed in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try()
\end_layout

\end_inset

, and the exception will be caught and contained within the disjunctive
 type.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 are defined for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 class similarly to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type.
\end_layout

\begin_layout Standard
Another useful method is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toOption
\end_layout

\end_inset

; it will discard the error information.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Try(1/0).toOption
\end_layout

\begin_layout Plain Layout

res2: Option[Int] = None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Try(1+1).toOption
\end_layout

\begin_layout Plain Layout

res3: Option[Int] = Some(2)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Lists and trees: recursive disjunctive types
\end_layout

\begin_layout Standard
Recursion is a translation of mathematical induction into code.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
What problems can we solve now?
\end_layout

\begin_layout Itemize
Represent values from disjoint domains as a single disjunctive type.
\end_layout

\begin_layout Itemize
Use disjunctive types in collections safely.
\end_layout

\begin_layout Itemize
Use disjunctive types instead of exceptions to indicate failures.
\end_layout

\begin_layout Standard
The following examples and exercises illustrate the use of disjunctive types.
\end_layout

\begin_layout Subsection
Solved examples
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

DayOfWeek
\end_layout

\end_inset

 representing the seven days.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Since there is no information other than the label on each day, we use empty
 case classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Sunday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Monday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Tuesday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Wednesday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Thursday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Friday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Saturday() extends DayOfWeek
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Modify 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

DayOfWeek
\end_layout

\end_inset

 so that the values additionally represent a restaurant name and total amount
 for Fridays and a wake-up time on Saturdays.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
For the days where additional information is given, we use non-empty case
 classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Sunday() extends DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Monday() extends DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Tuesday() extends DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Wednesday() extends DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Thursday() extends DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Friday(restaurant: String, amount: Int) extends DayOfWeekWithBa
nquets
\end_layout

\begin_layout Plain Layout

final case class Saturday(wakeUpAt: java.time.LocalTime) extends DayOfWeekWithBanq
uets
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-rootsofq-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type that describes real roots of the equation 
\begin_inset Formula $ax^{2}+bx+c=0$
\end_inset

 where 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

 are arbitrary real numbers.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by solving the equation and enumerating all possible cases.
 It may happen that 
\begin_inset Formula $a=b=c=0$
\end_inset

, and then all 
\begin_inset Formula $x$
\end_inset

 are roots.
 If 
\begin_inset Formula $a=b=0$
\end_inset

 but 
\begin_inset Formula $c\neq0$
\end_inset

, the equation is 
\begin_inset Formula $c=0$
\end_inset

, which has no roots.
 If 
\begin_inset Formula $a=0$
\end_inset

 but 
\begin_inset Formula $b\neq0$
\end_inset

, the equation becomes 
\begin_inset Formula $bx+c=0$
\end_inset

, having a single root.
 If 
\begin_inset Formula $a\neq0$
\end_inset

 and 
\begin_inset Formula $b^{2}>4ac$
\end_inset

, we have two distinct real roots.
 If 
\begin_inset Formula $a\neq0$
\end_inset

 and 
\begin_inset Formula $b^{2}=4ac$
\end_inset

, we have one real root.
 If 
\begin_inset Formula $b^{2}<4ac$
\end_inset

, we have no real roots.
 The resulting type definition can be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class AllRoots() extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class ConstNoRoots() extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class Linear(x: Double) extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class NoRealRoots() extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class OneRootQ(x: Double) extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class TwoRootsQ(x: Double, y: Double) extends RootsOfQ2
\end_layout

\end_inset

This disjunctive type contains six parts, among which three parts are empty
 tuples and two parts have a single-element tuple; but this is not a useless
 redundancy.
 It would be a loss of information to reuse the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Linear
\end_layout

\end_inset

 for the case 
\begin_inset Formula $a=0$
\end_inset

, 
\begin_inset Formula $b\neq0$
\end_inset

 and for the case 
\begin_inset Formula $a\neq0$
\end_inset

, 
\begin_inset Formula $b^{2}=4ac$
\end_inset

, or to reuse 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

 for representing the three different no-roots cases.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rootAverage
\end_layout

\end_inset

 that computes the average value of all real roots of a general quadratic
 equation, where the roots are represented by the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ2
\end_layout

\end_inset

 defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The required type signature is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val rootAverage: RootsOfQ2 => Option[Double] = ???
\end_layout

\end_inset

The function should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 if the average is undefined.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The average is defined only in cases 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Linear
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRootQ
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRootsQ
\end_layout

\end_inset

.
 All other cases must result in an empty option.
 We implement this via pattern matching:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val rootAverage: RootsOfQ2 => Option[Double] = { roots =>
\end_layout

\begin_layout Plain Layout

  roots match {
\end_layout

\begin_layout Plain Layout

    case Linear(x) => Some(x)
\end_layout

\begin_layout Plain Layout

    case OneRootQ(x) => Some(x)
\end_layout

\begin_layout Plain Layout

    case TwoRootsQ(x, y) => Some((x + y) * 0.5)
\end_layout

\begin_layout Plain Layout

    case _ => None
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We do not need to enumerate all other cases since the underscore pattern,
 
\begin_inset Formula $\_$
\end_inset

, matches everything that the previous cases did not match.
\end_layout

\begin_layout Standard
The often-used code pattern of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x match { case ...
 }
\end_layout

\end_inset

 can be shortened to simply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case ...}
\end_layout

\end_inset

.
 The code then becomes
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val rootAverage: RootsOfQ2 => Option[Double] = {
\end_layout

\begin_layout Plain Layout

  case Linear(x) => Some(x)
\end_layout

\begin_layout Plain Layout

  case OneRootQ(x) => Some(x)
\end_layout

\begin_layout Plain Layout

  case TwoRootsQ(x, y) => Some((x + y) * 0.5)
\end_layout

\begin_layout Plain Layout

  case _ => None
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Test it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(NoRealRoots(),OneRootQ(1.0), TwoRootsQ(1.0, 2.0), AllRoots()).map(rootAve
rage)
\end_layout

\begin_layout Plain Layout

res0: Seq[Option[Double]] = List(None, Some(1.0), Some(1.5), None)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Generate 
\begin_inset Formula $100$
\end_inset

 quadratic equations 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

 with random coefficients 
\begin_inset Formula $b$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

 (uniformly distributed between 
\begin_inset Formula $-1$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

) and compute the mean of the largest real roots from all these equations.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We use the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

QEqu
\end_layout

\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve
\end_layout

\end_inset

 function from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 First, we create a sequence of equations with random coefficients using
 the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq.fill
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def random(): Double = scala.util.Random.nextDouble() * 2 - 1
\end_layout

\begin_layout Plain Layout

val coeffs: Seq[QEqu] = Seq.fill(100)(QEqu(random(), random()))
\end_layout

\end_inset

We can now use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve
\end_layout

\end_inset

 function to compute all roots:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val solutions: Seq[RootsOfQ] = coeffs.map(solve)
\end_layout

\end_inset

For each set of roots, we compute the largest root:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val largest: Seq[Option[Double]] = solutions.map {
\end_layout

\begin_layout Plain Layout

  case OneRoot(x) => Some(x)
\end_layout

\begin_layout Plain Layout

  case TwoRoots(x, y) => Some(math.max(x, y))
\end_layout

\begin_layout Plain Layout

  case _ => None
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

largest: Seq[Option[Double]] = List(None, Some(0.9346072365885472), Some(1.1356234
869160806), Some(0.9453181931646322), Some(1.1595052441078866), None, Some(0.576225
2742788), Some(1.1896332718057907), None...
\end_layout

\end_inset

It remains to remove the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 values and to compute the mean of the resulting sequence.
 This operation is used often, so the Scala library defines the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 method that works for sequences of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 values:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> largest.flatten
\end_layout

\begin_layout Plain Layout

res0: Seq[Double] = List(0.9346072365885472, 1.1356234869160806, 0.9453181931646322
, 1.1595052441078866, 0.5762252742788, 1.1896332718057907...
\end_layout

\end_inset

Now we can compute the mean of the last sequence.
 Since the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 operation is preceded by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, we can replace it by a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

.
 The final code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val largest = Seq.fill(100)(QEqu(random(), random()))
\end_layout

\begin_layout Plain Layout

  .map(solve)
\end_layout

\begin_layout Plain Layout

  .flatMap {
\end_layout

\begin_layout Plain Layout

    case OneRoot(x) => Some(x)
\end_layout

\begin_layout Plain Layout

    case TwoRoots(x, y) => Some(math.max(x, y))
\end_layout

\begin_layout Plain Layout

    case _ => None
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> largest.sum / largest.size
\end_layout

\begin_layout Plain Layout

res1: Double = 0.7682649774589514
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = ???
\end_layout

\end_inset

The function should preserve as much information as possible.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by pattern matching on the argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
\end_layout

\begin_layout Plain Layout

  case None => ???
\end_layout

\begin_layout Plain Layout

  case Some(eab: Either[A, B]) => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

: Either[A, B]
\end_layout

\end_inset

 was written only for clarity; it is not required here because the Scala
 compiler can deduce the type of the pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eab
\end_layout

\end_inset

 from the fact that we are matching a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Either[A, B]]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
What expression will we compute in the first case? We need to return a value
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Option[B]]
\end_layout

\end_inset

.
 A value of that type must be either a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

, or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:Option[B]
\end_layout

\end_inset

, where the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 must be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(z)
\end_layout

\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z:B
\end_layout

\end_inset

.
 However, in our case the code is of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case None => ???
\end_layout

\end_inset

, and we cannot produce any values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z:B
\end_layout

\end_inset

 since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are arbitrary, unknown types.
 The only remaining possibility is to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = None
\end_layout

\end_inset

, and so the code must be
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

  case None => Right(None) // No other choice here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the second case, we clearly need to pattern match on the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eab
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

  case Some(eab: Either[A, B]) = eab match {
\end_layout

\begin_layout Plain Layout

    case Left(a) => ???
\end_layout

\begin_layout Plain Layout

    case Right(b) => ???
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

It remains to figure out what expressions to compute in each case.
 In the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a) => ???
\end_layout

\end_inset

, we have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, and we need to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Option[B]]
\end_layout

\end_inset

.
 We again follow the same argument: we can return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:Option[B]
\end_layout

\end_inset

.
 At this point, we do have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, but not of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 So we have two possibilities: to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

 as before.
 If we decide to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

, the code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
\end_layout

\begin_layout Plain Layout

  case None => Right(None) // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Some(eab) => eab match {
\end_layout

\begin_layout Plain Layout

    case Left(a) => Left(a) // Could also return Right(None) here.
\end_layout

\begin_layout Plain Layout

    case Right(b) => ???
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Let us consider the choice of whether to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

 in the line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Left(a) => 
\end_layout

\end_inset

.
 Both choices will satisfy the required return type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Option[B]]
\end_layout

\end_inset

.
 However, if we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

 in that line, we will ignore the given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

, which is a loss of information.
 Returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 will preserve more information, which is likely to be more useful.
\end_layout

\begin_layout Standard
Similarly, in the last line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Right(b) => ???
\end_layout

\end_inset

, we have a choice of returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(Some(b))
\end_layout

\end_inset

.
 The first choice ignores the given value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b:B
\end_layout

\end_inset

.
 Since we want to preserve information as much as possible, we make the
 second choice.
 The final code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
\end_layout

\begin_layout Plain Layout

  case None => Right(None)
\end_layout

\begin_layout Plain Layout

  case Some(eab) => eab match {
\end_layout

\begin_layout Plain Layout

    case Left(a) => Left(a)
\end_layout

\begin_layout Plain Layout

    case Right(b) => Right(Some(b))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with the type signature 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = ???
\end_layout

\end_inset

The function should preserve as much information as possible.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by pattern matching on the argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => ???
\end_layout

\begin_layout Plain Layout

  case ??? => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the first case, we have values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b:B
\end_layout

\end_inset

, and we are required to return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[(A, B)]
\end_layout

\end_inset

.
 A value of that type is either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((x,y))
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:B
\end_layout

\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are arbitrary types, we cannot produce new values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 from scratch.
 The only way to satisfy the required type is to set 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x=a
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y=b
\end_layout

\end_inset

, returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((a, b))
\end_layout

\end_inset

.
 Now we have two choices: to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((a, b))
\end_layout

\end_inset

 or to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 Returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 would unnecessarily lose information; so we write
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => Some((a, b))
\end_layout

\begin_layout Plain Layout

  case (Some(a), None) => ???
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the next line, we are given a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

 but no values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Now we cannot return a value of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((x, y))
\end_layout

\end_inset

 because we cannot produce a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:B
\end_layout

\end_inset

.
 Given only a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

, the only computable value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[(A, B)]
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => Some((a, b))
\end_layout

\begin_layout Plain Layout

  case (Some(a), None) => None // No other choice here.
\end_layout

\begin_layout Plain Layout

  case (None, Some(b)) => ???
\end_layout

\begin_layout Plain Layout

  case (None, None) => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Writing out the remaining cases, we find that in all those cases we have
 no choice other than returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 So we can simplify the code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => Some((a, b))
\end_layout

\begin_layout Plain Layout

  case _ => None // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exercises
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

CellState
\end_layout

\end_inset

 representing the visual state of one cell in the 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Minesweeper"
target "https://en.wikipedia.org/wiki/Minesweeper_(video_game)"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 game: A cell can be either closed (showing nothing), or show a bomb, or
 be open and show the number of bombs in neighbor cells.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Seq[CellState]]
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, counting the total number of cells with zero neighbor bombs shown.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootOfLinear
\end_layout

\end_inset

 representing all possibilities for the solution of the equation 
\begin_inset Formula $ax+b=0$
\end_inset

 for arbitrary real 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

.
 (The possibilities are: no roots; one root; all 
\begin_inset Formula $x$
\end_inset

 are roots.) Implement the solution as a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve1
\end_layout

\end_inset

 with type signature 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def solve1: ((Double, Double)) => RootOfLinear = ???
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(Double, Double)]
\end_layout

\end_inset

 containing pairs 
\begin_inset Formula $\left(a,b\right)$
\end_inset

 of the coefficients of 
\begin_inset Formula $ax+b=0$
\end_inset

, produce a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Double]
\end_layout

\end_inset

 containing the roots of that equation when a unique root exists.
 Use the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootOfLinear
\end_layout

\end_inset

 and the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve1
\end_layout

\end_inset

 defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Subscriber
\end_layout

\end_inset

 was defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-option-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Subscriber]
\end_layout

\end_inset

, compute the sequence of email addresses for all subscribers that did 
\emph on
not
\emph default
 give their phone numbers.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
In the following exercises, the goal is to implement a function that preserves
 as much information as possible and has a given type signature.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[(A, B)] => (Option[A], Option[B]) = ???
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: Either[A, B] => (Option[A], Option[B]) = ???
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f3[A,B,C]: Either[A, Either[B,C]] => Either[Either[A,B], C] = ???
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
now let's look at disjunctive types 
\end_layout

\begin_layout Plain Layout
and try to access this error value when actually I'm in the right disjunctive
 in the second part of the disjunctive because the error is not defined
 in this Cobra that I am just showing in the scope only the rest is defined
 so these case expressions have limited scope so this expression from the
 first case until the second it is one scope and within this scope the error
 variable is defined outside it is not defined and similarly for this so
 if we call this function on the value such as write 123 then this function
 will match the first case will not match so then the second case will match
 and the result will be returned so this will be the value it returns then
 the match is performed line by line so if the first line that matches gives
 you this expression and that's it not no further lines are evaluated so
 log error of left bad result will match this because it matches the symbol
 the left and then error will be the variable equal to the value of it will
 be equal to bad result and so it'll print got error bad result and then
 it will return -1 so case X Russians that choose among possible values
 of a given type when this type is a disjunctive and here is another way
 of using case expressions with types that don't look like a disjunctive
 like int where you say if so I say X which is an argument of this function
 X match and then I enumerate certain cases 0 1 and then all other cases
 so if if 0 does not match if one does not match then this case this line
 will be evaluated and then this pattern matches everything is just a variable
 so this rest will be equal to this X since we matched it and so then the
 same X will be returned so you could think about integers as a type that
 has different values like 0 1 and others there are possible values of this
 type and so you could use case expression also for those so case expression
 is not limited to disjunctive types or case classes integer is not defined
 as a disjunctive type because it has long parts of disjunctive but it has
 different values and so just to know to the similarity between this code
 and this code the case expressions in the partial function enumerate possible
 values of the function and so here also I'm not limited to just writing
 two cases lines here case left error case rightness I could write anything
 I want like for example case left and then empty string instead of error
 here and that will only match when X has that value left of empty string
 then on the next line I could say case left of something else and won't
 match only when X is net this is just to what you know that the case expression
s are more powerful than just matching the two parts of a disjunctive they're
 matching anything these patterns can have many conditions and this can
 be complicated so either is a example of disjunctive but there are more
 general disjunctives like for example well if I want to have a disjunctive
 between three different domains do I have to do either of either so that
 is not convenient now in in principle what I want is something like this
 I want to just say this type or this type or let's say this type or this
 type or this type this is a disjunctive I want to be able to define these
 junctions like this but Scala does not have this syntax there are some
 libraries like these libraries that provide syntax similar to this one
 but I don't want to go into these libraries that are more advanced right
 now I want to use the standard syntax in Scala which is sufficient for
 most purposes in the more ordinary applications of functional programming
 which is most of its applications today later I won't talk about those
 libraries and see what they offer but for now let's use the long syntax
 which is available in Scala and this is the syntax okay this is quite long
 to represent what I would ideally write like this if I if I compare this
 with that my type is a name of the type the type has disjunctive of three
 domains the first domain is a list of integers so the first domain here
 has a name all domains must have a name in the disjunctive is a label so
 here in this context the name would be implicit something like underscore
 one or something but in this syntax in the long syntax the domain has to
 be explicit so your name is have list int it has one part so it's a tuple
 of one with name have list int and the part is named X let's say then I
 have to write this keyword extends my type and in this way I say that this
 case class is part of a disjunctive which I'm going to define now so my
 type is the name of the entire disjunctive and these are the names of its
 three parts the labels and these are the names of the tuple parts so each
 domain is a tuple with names case class as I explained is a tuple with
 names so this disjunctive has two lists the names for everything for every
 part of the disjunctive and for every part of each tuple finally these
 keywords sealed final case class trait these keywords are necessary in
 Scala and what they do is they make sure that you cannot by mistake change
 this disjunctive later because that would be a difficult bug that some
 other part of the program changes this disjunctive and then adds some more
 stuff to it let's see some other domain and then your case matches stop
 working because you don't know that somebody added domains you have your
 case State case expressions like this pattern matching and you expect three
 domains in your disjunctive so you write it like this but somebody adds
 a different domain and this stops working this will crash if if that word
 if that happens so to prevent that you say that my trait called my type
 is sealed so no so only the ones the the domains of the disjunctive that
 are listed next to it in the file well not necessarily next day but in
 the same file only those exist and no others may be defined later at any
 time similarly the case passes are final so they cannot be extended later
 as the result the syntax is quite long you have to write a lot of stuff
 just to express this kind of disjunctive of three domains but you write
 it only once and using it is quite short is not so bad at all so for example
 first I create a value of this type so this could be a result of some computati
on with conditions if some condition holds then the values have socks with
 some socks values and otherwise it's have list int with some list int value
 so this is computed and then somebody wants to find out what that X was
 and they don't know this could be in a different part of the code and this
 could be even in a different library and so you have to match on the three
 domains of the disjunctive that's how you write it you put pattern variables
 in the case classes so these nine names don't have to be the same as these
 they can be for convenience but they don't have to be I'm just specifically
 selecting all different names just to show you that these are arbitrary
 names they don't have to be the same and then you write expressions here
 that will be evaluated in each of these cases and this expression for example
 is allowed to use this LST but not this and all that because the scope
 is is limited so the scope of definition of this LST is only this expression
 the scope of definition of pmq is only this expression if you try to use
 P and Q here the compiler would say cannot find symbol or something like
 that if very often used disjunctive type is called option here is how I
 would implement option in a very simple way it has a disjunctive of two
 domains one domain is a tuple with one element of type T or T is a type
 parameter and the second domain is a tuple of zero elements or unit type
 which is represented as a case object this is just a keyword in skeleton
 doesn't really mean anything different from a tuple with no elements or
 a unit type and you notice here it extends option with type parameter nothing
 nothing is a special type that has no values at all so this is used to
 signal that this is an empty tuple it does not have any values inside so
 we cannot use any type for parameter here but we must specify the parameter
 so we use this special type nothing all of this is defined in the standard
 library of skeleton nothing option some none so some and none are the two
 labels on the two domains of the disjunctive now in order to use it you
 do pattern match for instance like this here's a function that performs
 safe divided divides X by Y but your turns an option of double and so option
 list is a disjunctive and option parameterize by the type double is a disjuncti
ve of of either double or nothing so no value rather unit is the type or
 empty tuple if you prefer is a type that does not carry any value of type
 double in it and so here's how you define a function that computes this
 it checks the condition and if Y is 0 you return none which is this label
 otherwise you return value X divided by Y labeled by the name and a single
 Sun now the symbol is a label on the second part or here on the first part
 of the disjunctive and here's how I would use it so I would say safe divide
 one divided by Q maybe Q is zero maybe not but I then match so this returns
 an option of double I match the option with two cases some X and none so
 these are the two parts of the disjunctive and I mention them and so if
 I have some X then I multiply that some whatever previous result by that
 X and otherwise I returned previous result so this is a kind of a default
 value that I return when I don't get anything out of this function this
 function returns none which is a valid result of type option double mini
 Scala library functions return an option type such as find returns so find
 looks in a collection and returns an option if it found then it returns
 some of the value and if it did not find it returns none had option is
 the first element of the collection but if it's an empty sequence there
 is no head element no first element so it returns none otherwise it returns
 some with the value of the first element and similarly these primary functions
 which you can look up in the library or in IntelliJ these functions return
 option and the final note is that option has many functions or methods
 defined on it in a sense option is like a collection it's like sequence
 of tea so option of tea is very much like sequence of tea in terms of what
 you can do with it you can see with sequins you cannot do this match because
 sequence is not a disjunctive between nan and Sun but sequence has map
 flatmap filter exists and so on all of this is also defined on an option
 and you can understand this in a simple way if you imagine that the sequence
 is like a container and that sequence of tea is like a container where
 or let's say array of teas and another kind of sequence it's like a container
 where you have 0 or more elements of type T so this container holds values
 of type T it can can hold no values empty array or empty sequence or it
 could hold one value or two values and so on option is like a container
 that can only hold 0 or 1 values of this type T it cannot hold two so it's
 like a very limited sequence the sequence that can only be of length 0
 or 1 otherwise it looks like a sequence so it has a map a function flat
 map filter and so on so what for example it's a map on an option I will
 show you when we go through the worked examples how that works map on the
 collection let's say on array of integers you can do a map with a function
 that maps integers to strings say in some way and then you map and you
 get an array of strings where each element is transformed by that function
 option will behave in a very similar way you do a map with an option and
 every element in an option will be transformed using the function you specify
 however option can only contain at most one element so it can be empty
 which is this disjunctive part or it can be non-empty containing one element
 of type T one value of type T so it's kind of a very limited simple-minded
 collection but otherwise it's similar to collection we will see how that
 works in the examples so with the tools we just learned what problems can
 we solve we can represent values from disjoint sets or domains as a single
 type and we can use these values to define functions on them or functions
 producing them and use also these values in collections as elements of
 collections or in any other way we can these are types so there's no restrictio
n on how you can use them so let's go through some examples now the first
 example is to define a disjunctive type day of week it represents the seven
 days of the week let me go to this example so here's what it would look
 like so all these keywords here in IntelliJ you see in bold blue dark blue
 seal the trade final case object.extend so these are keywords of Scala and
 everything else is our labels that we introduced so day of week is the
 name of this entire type the entire disjunctive type it has seven domains
 and these domains don't carry any values so these are just empty tuples
 and the syntax for them is to say case object and then you don't you don't
 write this this is a mistake you should know right that empty tuple empty
 tuple is written like this indeed but you don't have to write it here so
 the syntax is such that you don't write it left so when you put a name
 on an empty tuple then it's called a case object and then you don't write
 parenthesis so here's how we define the type how will we use the type like
 this will define values a and B let's say of this type and assign these
 values so we define Monday and Saturday just like this we don't have to
 do anything else we don't have to say new new Monday there's no numa there's
 only one Monday because that's a label of the domain and a disjunctive
 is no no sense in that to say new Monday cannot have different Monday's
 they're all the same it's a label on the disjunctive now if I don't do
 this and just say well a eCos Monday then Scala will actually not know
 that I want a to be of this type color we'll think but it has typed Monday
 type so monday dot type is just ask our feature that I'm not going to use
 right now it is a more advanced feature so with these disjunctive types
 it is a good idea to write type annotations Scala it can be too smart about
 what I want to do and so it is better if I do this but it would not be
 an error if I did it that way if I put just any without type annotation
 probably my code was to work just some types will become weird now suppose
 I want to print now how to print this well actually case classes and case
 objects already have a two-string method defined on them so I can just
 print like this with string interpolation and this will run and I will
 get the string printed after we implement the function so that this test
 can pass so how do we implement this function this function is supposed
 to give us a boolean which is true when the day of the week of Saturday
 and false otherwise so we do this by pattern matching since the type is
 a disjunctive so we need to match on the label of the disjunctive or in
 the scala language we match on the case class or case object so we say
 Dean match and then you see there's this red case close as expected sure
 and then there's this thing which I can click it says generate case closes
 for variants of sealed type now in the scholarly in which this means this
 was a sealed trait that I defined and it has seven variants or disjoint
 domains in my understanding and so if I click this IntelliJ will fill in
 the code actually not sure why is doing it like this because it's from
 from another from from another example I guess it's a bit confused but
 it allowed me to delete what was not necessary so it generated most of
 the code so now I need to put the expressions that I'm going to return
 in each case so if this day is Saturday I need to return true otherwise
 I need to return false now there's a lot of I could say false false a lot
 of work like this so I'm going to be more clever and I'm going to do this
 and when it puts Saturday first and then if there is anything else I'm
 going to return false so let's say playing this so in this way I'm expressing
 my intention much more clearly so Saturday true I do otherwise anything
 else false so there's one little thing so this will work but we can run
 this test and this will work there's one little detail here so green notice
 what is printed E is Monday B is Saturday so this is the string that I
 printed here with interpolation so a was Monday and it can be it's already
 printable so this is a convenience that scholar gives now the little detail
 I was talking about is that intelligence says Declaration is never used
 so I declared the variable X but I never actually used it there's a syntax
 which looks like this it needs to be used in this case to make it more
 clear like I said this still works this is not a mistake to do a variable
 that you don't have to use a variable here and never actually included
 anywhere so to left it unused it's not a mistake but it is a little misleading
 because you're introducing a variable and so I'm looking for its use maybe
 I don't find one so this syntax means it's a very that matches anything
 just like X no conditions and on it variable watches anything and I don't
 need its name I'm not going to use that variable so the underscore in this
 situation means that it's a pattern variable that I'm not going to use
 so I don't need its name and it matches everything and my tests are that
 a and B so a was Monday B was Saturday they they pass let's go to the second
 example [Music] modified day a week so that the values additionally represent
 a restaurant name and total amount for Friday's and a wake-up time on Saturdays
 so what does it mean I want additional values on list on this disjunctive
 on on the domains in the disjunctive I want these domains to be not just
 empty tuples as I did before here but for Friday I want a domain that represent
s a string which is restaurant name and an amount paid so here's what I
 do i make Friday and Saturday case classes instead of case objects and
 then I am free to add parts in there with different types so field called
 restaurant name and type string and its own so I can do that and similarly
 for Saturday now I think I made I haven't finished this so this is supposed
 to be wake up time so I think I want to do a local date time from the Javadoc
 time library and that's a wake up time so this is it so basically I have
 easily added more data but only for these two days so these they still
 have no no data so if if the day of the week is Monday then I didn't go
 to restaurant and in pain thing and and so so now let's define some test
 data they have weakness Monday now if I want to define Friday as day a
 week then I have to specify the parts of this case class or the fields
 with names now here's what I'm doing is like this and now I have defined
 the value of type day of week I can still print it and then I want to define
 a function that will tell me how much I paid on a given day of the week
 now notice on those days I didn't pay anything on only a Friday okay because
 I go out so this function will return an option double and this option
 will be none or empty option for all the days except Friday because there
 is nothing to be paid and on Friday I will return this amount notice this
 is cleaner than returning zero for other days I could return just double
 here instead of option double and I hope with a subsidy a zero on those
 days but this is cleaner what if somehow the amount paid was zero for some
 reason let's say I went to restaurant and I had a coupon and I didn't have
 to pay anything I was free so my amount paid was actually zero but I did
 go to a restaurant so that information is not lost if I'm returning option
 double and if if I give Friday's day of the week I will get a non-empty
 option with a value of type double inside it and that value could be zero
 or anything else I don't use any special values to denote the absence of
 amount paid the type denotes it's the option type that's why it's so useful
 that's why it's used so much in the library let's implement this function
 again we do ng match and again I'm going to fill in and see what it tells
 me oh great this is because I have two different case classes and case
 objects and traits defined and with the same name in the same file so IntelliJ
 is a bit confused I have defined them in the scope of this test so they
 are completely safe and invisible in the other test but IntelliJ is not
 able to see that okay I'm just going to correct this by hand not a lot
 on work alright and Friday and Saturday are actually correct now all right
 so now if I'm on Friday case then I need to return some amount paid so
 sum is the constructor for the domain of option that is not empty so I
 call this a constructor because this looks like I'm calling a function
 which is called sum on a value so it's like a constructor and the word
 constructor will be used and quite frequently there's a type constructor
 and there is a value constructor let's talk about how to implement this
 function will discuss the Constructors later alright so in all other cases
 I have to return none so I have to return none here here okay I'm bored
 I don't want to write on this code so I say first case is return this and
 in every other case I don't know what that is I don't I don't need to know
 I returned on this is how I want to write it and also here this declaration
 is never used I'm going to put underscore so now this is how I would run
 the code also run this symbol to be nicer so I have a special intelligent
 shortcut to insert this symbol and the symbol is exactly the same as this
 combination so there's no difference it's just pure aesthetics I like this
 symbol this is the way to write this kind of code and it clearly says here's
 a disjunct into disjunctive domain which we match and specify different
 possibilities one possibility is that it's a Friday so sub domain of the
 disjunctive that is labeled as Friday with these two values in it and then
 I return that otherwise for any other domain I return them so let's run
 this test and see what it prints because we printed here Monday and Friday
 right so here's what it prints interesting a is Monday B is Friday of McDonald'
s and 23.14 so this is the way scallop Prince case classes this is the default
 way to print case classes so you don't have to write code for your own
 printing function or to string function the function to string is already
 defined in a reasonable way it may not be what you want to Princeton your
 users but for debugging - this is pretty good let us continue the next
 example is to define a disjunctive type roots of quadratic it represents
 real valued roots of the equation x squared plus bx plus c equals 0 for
 arbitrary real B&C and there are three cases no real roots two real equal
 roots two unequal real roots notice I make this quadratic equation non
 degenerate so that it always has the term x squared if I said ax squared
 plus BX plus C there could be a case when a is zero and then we'll have
 a linear equation so in this particular example I chose it to be like this
 for simplicity and then we want to implement a solve function solve to
 or solve quadratic which takes a tuple of two coefficients B and C and
 returns the this value of this disjunctive type which is a roots whatever
 situation of this it returns that value and that value represents a disjunctive
 of these three cases no real roots 2 equals 2 M equals and conceptional
 conceptually this is easy to think about you call this function you get
 the value and then you can imagine it and see what the situation is if
 you feel like it how do we implement that let's take a look so I define
 sealed straight roots of quadratic final case object no real roots extends
 the roots of quadratic so I say again all this all this final extends and
 sealed trait these are scholar keywords this is kind of verbose but you
 just only write this once for every disjunctive and you never look at this
 more than once so that's to me that's acceptable although I would prefer
 for example that everything is sealed by default and everything else gives
 me everything is final by default but I would prefer that that I don't
 have to say final all the time but it's okay it's not so bad for the value
 it gives us is that we can represent arbitrary disjunctives of types when
 this case case classes and other types so there are three domains in the
 disjunctive as we were over told no real roots and that has no values obviously
 no roots so we say this is an empty tuple and that is represented by a
 case object also this case object doesn't have to be a new keyword in principle
 so but that's what scholar requires just remember that this needs to be
 everything like that second domain is when the roots are equal then there
 is only one number to store and that number is X and so the third domain
 is when there are two unequal roots and when there are two numbers to store
 all right so we have defined a disjunctive type and now we define a function
 solve - it takes a tuple of its coefficients a B and C and returns the
 roots of quadratic so how does it work I always say we I chose this syntax
 just to be a little the pure side of things you know value I could say
 this is a well functions are values right so I could say this is a well
 since I don't have any type parameters here I can do it well if I had type
 parameters I would need to do a death alright as I say here okay so there's
 a Val the function takes a tuple of double double as its argument so what
 will define this function we say in case BC we we do a case because this
 is the way to use tuples as arguments in Scala so this is a syntax if I
 don't say case not sure it will be healthy so you see this function has
 only one argument this one argument has of it has type tuple of double
 double and so that's why I need to do a match on that one argument so I
 already need a match right right here okay so here's what I do my B and
 C are these two coefficients so I determine the discriminant and if it's
 greater than 0 then I have two different roots which are given by this
 well-known formula and then so I just for clarity I define names x1 and
 x2 temporarily and return to roots X 1 St here if discriminant is zero
 I don't need to define any names temporarily it's too easy to not say just
 equal root of minus B over 200k in here I could also put these two expressions
 directly into the constructor of two roots case class but this is more
 clear in this clearer in this in this way finally if the discriminant is
 negative there are no real notes so in this way I return a value of this
 type I construct this value as an element of one of the three possible
 domains each domain having its own values in there so this is a disjunctive
 of empty to pull to pull of one and tuple of two but I put names on them
 so now it's much more readable it's clear what I'm doing and easy to check
 for mistakes so let's now check that this works so here's what I do i define
 a sequence of tuples just so that i can check at once [Music] all these
 equations so this is the equation x squared minus 2x plus 1 equals 0 so
 this equation has a double root X equal 1 obviously now this equation is
 x squared plus X plus 1 equals 0 and it has no reloads its roots are complex
 this equation is x squared minus X still to come zero it has two real roots
 different two different railroads so in this way I check all three possible
 domains and all three possible cases and so I have a sequence of these
 three two bulls and I map over the sequence with the functions of two which
 takes a tuple and returns roots of connecticut the result is a sequence
 of roots of contradict so then I check that the sequence is equal to what
 I expect the first one has roots only one root x equals one the second
 one has no real roots a third one has two different real roots so that's
 test passes and it shows that we have implemented our function correctly
 now notice that this function returns a value doesn't bail out or generate
 errors it always returns a value this value has three different domains
 in some domain there's no result another domain there's some result so
 this is the way to have deal with complicated logic and complicating domains
 in functional programming your model is domain with types so you make a
 type that represents everything you want to say as much as possible and
 then you write code with it so you see it's quite easy to write code with
 this there are no special values there is no flag boolean flag that would
 be true or false when you have roots or you don't have words you don't
 do any of this it's much more visual and clear when your code exactly says
 what's happening there are no hidden flags hidden special values this is
 the advantage of using disjunctive types actually this is one of the main
 advantages over using some other methods of representing complicated data
 next example is that we want to define a function called route average
 which is from roots of quadratic in to option double that computes the
 average value of all real roots returning none if the average is undefined
 so it means if there's no roots that we return otherwise we return the
 average problem so how do we implement this the test is already written
 so for example route average of this should be 0 son 0 so it's option right
 so a non empty option has the form some zero empty option has the firm
 none so these are the two domains of the option and so you you have to
 always have to write the sum and this none this is a bit verbose if you
 have a lot of those values but you need to think about how to reduce the
 velocity but you always have to write specific values like this if you
 have equal roots then average is the same as this one value otherwise you
 get none so how do you implement well you say roots and then you say generate
 case closes I'm just lazy and then clearly if we are in this domain then
 it's not here it is some X there the sum of x + y / - not that we're done
 no way to make a mistake you see your boolean Flags - check nothing no
 way to make a mistake very safe code finally what do we do now we generate
 100 random coefficients B and C and compute the mean of Route average for
 all of them let's do that so first we make a function get random that generates
 a random number so let's say between minus 1 and the one who generates
 a uniformly distributed random numbers for simplicity and we prepare a
 sequence of coefficients by filling 100 random numbers now each get random
 will be a new number it is actually good style in Scala to make these functions
 syntactically different from values so that you see that this function
 actually computes something new every time it's not just a value because
 I could I could call this random could you name it and then if I don't
 write these parentheses then it looks like a value it looks like it's going
 to be the same every time but it's right now it's not a new random number
 so to emphasize that the style convention often in Scala is that you do
 the empty parenthesis just kind of a function of 0 arguments which you
 can also think of a function of an empty tuple as an argument but in Scala
 is actually different you have functions with zero arguments in Scala which
 are different from functions of single argument that's an empty tuple Scala
 is a bit redundant in this way and this is because it has to maintain compatibi
lity with Java but is never a big problem so the syntax helps if you use
 it in a way that is suggestive so we make these coefficients we get a sequence
 of random numbers and then we map over the sequence with the functions
 of two that we implemented just previously the result will be a sequence
 of this roots of quadratic that we have so each element of the sequence
 could have different configuration of roots in or roots at one or two rows
 and it's all in this type because this is a disjunctive tab now we compute
 averages so solutions we map over that sequence with root n rooster remember
 the function wrote average takes roots of quadratic and returns option
 double so when we map with this function over sequence of roots of quadratic
 we get a sequence of option double each element being transformed now that's
 not what we want though we now we want to compute average of the sequence
 but it's a sequence of option double so some of them are none some of them
 are not known how do we get all the ones that are not none to take the
 average of them so I will show you several attempts to do that in the first
 attempt is to filter the averages by retaining those that are not null
 no not none so we do this with a filter with this matching expression which
 is actually working but it still gives you a sequence of option of double
 it does not eliminate the option type and that's kind of bothersome so
 there are two ways in which you can do it more easily and more safely one
 way is to use this flatten function on sequence so it's a special case
 when you have so flattened usually what it does is that you get from a
 sequence of sequences you get the sequence so usually for example so usually
 the sequence of sequence of T and you get from it sequence of T but also
 it works with sequence of option of T and you get from it sequence of T
 so this usually what flattens do is just flatten does is just every sequence
 here is concatenated and you get one big sequence now if you think that
 option is like a sequence of at most one element you can do the same operation
 you can concatenate all those options that are not empty discard those
 that are empty and you get a sequence so that's what flatten does and that's
 exactly what we need to do here we have a sequence of optional double and
 we need to discard those that are empty and get a sequence of double as
 a result so that's what flattening does as another way of achieving the
 same result is to use the collect function collect function is quite useful
 because you can do partial function here and match and transform things
 and transform types also so here I transform type so this is an option
 type option of double and this is double so I have transformed the type
 and the collect function will check that this case actually matches and
 four empty options it will not match and they will be discarded so that
 is how these functions work very useful functions in this case flatten
 would be my preferred option my preferred way of implementing it because
 it is shorter and very clear I just want to discard all know all empty
 options and that's what flatten does but if I have some more complicated
 transformation discarding some elements while transforming others and flatten
 is only defined for this special case sequence of option for example flatten
 is not defined for an option of sequence or for some others such things
 then I use collect so but anyway we can run this test now and either result
 one or result two will compute exactly the same thing [Music] let's see
 what is Prince for yeah interesting some interesting number every root
 fine so this is our result the final worked example for this tutorial is
 slightly different so far we have been computing things now we want to
 implement a function with a fully parametric type which is given like this
 what does this function do it takes a tuple of two options and returns
 an option of a tuple now actually I forgot the double parenthesis in this
 type signature this must be double parenthesis and in my code I believe
 it is like here a a function that takes a tuple you must have double parenthesi
s because in scala the syntax is that the first pair of parenthesis designates
 the arguments of the function so we can have one or more arguments and
 each argument could be a tuple or not also so if you have just one argument
 that's a tuple and you must do this double parenthesis so I should have
 done it here too I will check I will correct this in my slides let's look
 at the implementation so I start with a test so if I had such a function
 of type two co-option int option string let's say into option of tuple
 in string how would I check that this works correctly for example if both
 options are non-empty then I want to return a non-empty option of the of
 the pair but if if just one of them is empty I cannot return the pair I
 cannot have a pair because I don't have the other value and so I must return
 none for the entire option of tuple so this is the only way that this function
 can work and this test then checks that this is so so it returns none in
 all cases except when both of these options are non empty so here's the
 implementation one implementation of this function what's reason about
 it to see how this implementation can be new right well firstly we say
 they said these are the two arguments so let's match on the first argument
 the matching of the argument has let me delete this perhaps and write the
 code again by reasoning about what needs to be done so obviously maybe
 a is a option of a sec maybe is a empty option maybe not empty so maybe
 we have a name will be not so we need to match to do the case closes I
 generate them so then let me call this a just for clarity okay so now I
 have two cases either a is non-empty or NES empty if it is empty I know
 what to do there is nothing else to do except to return empty option of
 this type because if I were to return non-empty option of this type I would
 have to supply both a and B but I don't have B sorry I don't have a my
 a option is empty there is no way for me to get an a value of type a because
 I don't know what that type is I'm not given a value of type a and I cannot
 create it from nothing so I must return none in case that the option a
 is non-empty I have hope that maybe also B is present so let's see if that
 is so we'll be dimensional let me again generate cases so it calls value
 B all right so if B is present then I can actually return a and B in the
 tuple so I'm supposed to return an option of tuple and so I return non
 empty option some with tuple as the value and here I again must return
 none there's no away so basically my implementation is more or less fixed
 except that of course I could return none here as well and the type would
 be still correct it will be a very uninteresting implementation but always
 returns none whatever the arguments and this the only interesting implementatio
n is this one now by interesting what I mean is if does not discard all
 the information in the arguments it discards some sometimes some information
 sometimes but it doesn't always discard everything so this implementation
 is is non-trivial and it's the most information preserving one and therefore
 the most interesting now this code actually it is correct I have tests
 below that call my check function on this one so I can check that this
 is correct but this is verbose all this match case and then case none goes
 to none case Nando's no all of that is quite verbose and if I wanted to
 modify logic here I would have to modify a lot of things so remember that
 option is like sequences it has a map function defined on it you have map
 method I use the word method and function interchangeably not in scholar
 there is a difference methods are those things defined with the syntax
 in a class and functions are values of function type that cannot be used
 with this syntax again this is a legacy of Java Java does not does not
 have functions at all it only has methods so Scala must have methods too
 and yet scholar wants to have functions function values so this is a compromise
 we have both in Scala have methods and we have functions for the purposes
 of functional programming methods are just like functions so I use the
 words functions and methods interchangeably it's just that this syntax
 must be different if map were a function not a method then the syntax would
 be map both you may be a F something like that and it's exactly similar
 map logically speaking has two arguments maybe a and F but the syntax is
 that map is written in between with the daughter actually there is an alternati
ve syntax like this without without Dalton without parentheses but I don't
 like that syntax so much sometimes I use it but only when it is really
 in easy to read and what's happening so let me remove this what I wanted
 to show it is that this code is so common and it's exactly equivalent to
 this code if you have the school that matches on the option so maybe a
 this option some type and you imagine it and if it's not empty then you
 return the non-empty option with some transformed value and if it's empty
 or returned empty this is exactly the same as doing a map on a collection
 if a collection is empty you return an empty collection again and if it's
 not empty then you take each element and you transform it with the function
 and then you return a collection having those transformed elements an option
 being a collection with just one element only needs one such transformation
 to be performed at most and so this code is exactly the same as this code
 so let's take that code and simplify it instead of maybe be match we just
 have now we can write let me write this as a comment so this actually let
 me let me copy the entire piece that I'm going to simplify and do it step
 by step looking at this template here so whenever I have this pattern sum
 of X going to sum of f of X not going to none I just do a map so I have
 this pattern right here maybe be not just like that so instead of this
 I say maybe B dot map and then the function is from B to the tuple a B
 and that takes care of this thing so now the code is much shorter it has
 this shape and it's but it still has the same pattern match son to their
 son and or to option none - none so let's do maybe a dot map and then a
 going to this so the entire code was replaced by this does it actually
 work so let's go and see what happens with this implementation which I
 called f2 well where I wrote what we just saw maybe a dot map it's going
 to maybe be that map why going to tuple x1 exactly what we ended up with
 you know after renaming of variables let me remove that now actually it's
 not quite right because the type of this thing is option of option of a
 b c this.type is option after mapping we have an option and then this has
 a type a so we map X of type a into an option of something and the result
 is going to be option of option let me write a comment explaining how this
 happened I have option of a then I do map with a function that goes from
 a to optional B or action of tuple a B and the result is going to be C
 this a is going to be replaced by this through the map function so result
 is going to be the type option of option of a B and that's what IntelliJ
 tells us if I delete this that's what it knows the type is so we need to
 transform this to an ordinary option how do we transform well this is the
 whole whole logic here if both of them are non empty only then we'll get
 a non empty option at the end so that is what flatten does a collection
 of empty collections gives you an empty collection after flattening so
 we just use and that's it now that works so that's a valid way of doing
 it but it's not the best because there's this pattern which is map followed
 by flatten and this pattern also seems to be very very often used and so
 in the standard library there is a method called flat map which is the
 same as map followed by flatten and so actually the code that you could
 write would be this now it is it is questionable whether this code is easy
 to read or easier to read than this I would actually say this code is a
 little easier to read because of things in app and happened here's a flat
 map and map there are other ways of making this much easier to read and
 to write which I'll talk about later this is the for yield block notation
 but for now it is important right all of these things by hand all of the
 maps flat maps and so on and to follow the types follow to see how the
 types are transformed IntelliJ sometimes gives you help here for example
 I tell if I press command and then hover my mouse over symbols it gives
 me some information about their types and definitions so it tells me that
 for example this is an option of being this is a map that takes a function
 and returns an of option of B and [Music] these types are not always clear
 here what is this 8 to be for example b2b I'm not sure what ageism not
 be is this oops this is certainly a contrived example of such a function
 but is this type a please this type B but actually this is not the types
 we're using we're using option a and so on so IntelliJ is not always right
 when you do this on the map but tell J is right when you do control shift
 p1 symbols so that for example is always right what option B so to make
 a long story short you need to start with code like this and then simplify
 it and make it shorter and then gradually you will start thinking in terms
 of these map flatmap and so on so that it is much easier for you to think
 in terms of transformations on an option collection and so on rather than
 transformations done on individual elements it's very important to follow
 how types change so let me let me try to rewrite this function in in a
 longer fashion here and this is what you might do initially when you start
 learning about functional programming code like this is very short it is
 not very readable so what you can do is you can say first of all you can
 make these functions multiline by putting curly braces around them and
 then you can introduce intermediate values for example Wow C equals this
 and then you return C it's the same right you call this value C and right
 away that is your expression but now you can see what type it is so it's
 option LV and you do option return like click on the keyboard to add the
 type annotation and so it tells you that this is actually an option of
 a B that information was not obvious here when you look at this code but
 you can make this easier for me to understand so first maybe B has type
 option of B you map it like this and it becomes option of a B maybe what's
 what's rename this X into a and that's why into B so that it becomes easier
 to read and then also here you are not sure what are you what your return
 it but flat map tells you flat map takes a function from a to option B
 returns option B well actually this is confusing because your B is not
 therapy so there be here is defined in the standard library somewhere it's
 not your B so the definition of flat map is this there's some be here there's
 some a here it's not what you wanted it's not your B and what your a so
 that is a bit confusion so let's do the same trick here well result equals
 this return result and now let's add a type annotation to this okay so
 now if you didn't do flat map let's remove this type annotation and add
 it again you could do control shift P to see what it is or you can just
 put it into the code to document that you at this point you got a gallery
 of this type so these transformations each of them will change the type
 of values and it's nice to see what type it is to check that that's exactly
 what you want now obviously we want an option of a B and not an option
 option of a B so we need to flatten it so now let me see what that is so
 in this way you can go step by step within each of these transformations
 and see what types then generate and having if you have done this enough
 times initially it will take time and you you have many steps and at the
 end you will see it becomes easier so here are some more exercises for
 you to work with disjoint disjunctive types case classes and collections
 of them and implement some functions like like these also with fully parametric
 types and so these functions are usually obvious what is meant so for example
 option of a pair goes into a pair of options obviously this option is empty
 then you must return to empty options here and if this option is not empty
 then it makes sense to return to non-empty options in order to maximize
 information and similarly here for either if you have either of a B that
 could be a and then you can return here and non-empty optional a but you
 must return empty option of B and vice versa in order to not lose information
 and in this example also if you have either a either B C so for example
 you could have a and then what they return while you return the left version
 of either and the left version of this either with a inside so in this
 way you can always see what kind of value it makes sense to return in order
 to not lose information good luck with these exercises 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Disjunctive types as mathematical sets
\end_layout

\begin_layout Standard
To understand the properties of disjunctive types from the mathematical
 point of view, consider a function whose argument is a disjunctive type,
 such as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def isDoubleRoot(r: RootsOfQ) = ...
\end_layout

\end_inset

The type of the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r:RootsOfQ
\end_layout

\end_inset

 represents the mathematical domain of the function, that is, the set of
 admissible values of the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

.
 We could imagine a function on a 
\emph on
disjoint
\emph default
 domain, for example 
\begin_inset Formula $r$
\end_inset

 is either a point on a line or a point on a surface, where the surface
 is completely separate from the line.
 Such domains are called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
disjoint domain
\end_layout

\end_inset

disjoint
\series default
 because the line and the surface have no common points.
\end_layout

\begin_layout Standard
The set of real roots of a quadratic equation 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

 is an example of a disjoint domain containing three parts: the no-roots
 case, the one-root case where the root is represented by a single number
 
\begin_inset Formula $x$
\end_inset

, and the two-roots case where the roots are represented by a pair of numbers
 
\begin_inset Formula $\left(x,y\right)$
\end_inset

.
 Geometrically, a number 
\begin_inset Formula $x$
\end_inset

 is pictured as a point on a line (a one-dimensional space), and pair of
 numbers 
\begin_inset Formula $\left(x,y\right)$
\end_inset

 is pictured as a point on a Cartesian plane (a two-dimensional space).
 The no-roots case corresponds to a zero-dimensional space, which is pictured
 as a single point (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RootsOfQ-disjoint-domain"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
begin{pdfpic}
\end_layout

\begin_layout Plain Layout

   
\backslash
newrgbcolor{lightpastel}{0.90 0.93 0.87}
\end_layout

\begin_layout Plain Layout

   
\backslash
psset{unit=0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{pspicture}(0,0)(1,1)
\end_layout

\begin_layout Plain Layout

      
\backslash
pscircle*(0.3,0.5){0.005}
\end_layout

\begin_layout Plain Layout

      
\backslash
psline{->}(0.5,0.2)(0.5,0.8)
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.535,0.77){$x$}
\end_layout

\begin_layout Plain Layout

      
\backslash
pspolygon[fillstyle=solid,fillcolor=lightpastel](0.8,0.8)(0.8,0.3)(0.7,0.2)(0.7,0.7)(0.8,
0.8)
\end_layout

\begin_layout Plain Layout

      
\backslash
psline{->}(0.7,0.2)(0.775,0.275)
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.67,0.28){$x$} 
\backslash
rput(0.79,0.24){$y$}
\end_layout

\begin_layout Plain Layout

      
\backslash
psline{->}(0.7,0.2)(0.7,0.3)
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.30,0.45){
\backslash
smaller
\backslash
texttt{NoRoots()}}
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.49,0.85){
\backslash
smaller
\backslash
texttt{OneRoot(x)}}
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.75,0.15){
\backslash
smaller
\backslash
texttt{TwoRoots(x, y)}}
\end_layout

\begin_layout Plain Layout

   
\backslash
end{pspicture}
\end_layout

\begin_layout Plain Layout

%
\backslash
end{pdfpic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The disjoint domain represented by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 type.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:RootsOfQ-disjoint-domain"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the mathematical notation, a one-dimensional real space is denoted by
 
\begin_inset Formula $\mathbb{R}$
\end_inset

, a two-dimensional space by 
\begin_inset Formula $\mathbb{R}^{2}$
\end_inset

, and a zero-dimensional space may be denoted by 
\begin_inset Formula $\mathbb{R}^{0}$
\end_inset

.
 
\end_layout

\begin_layout Standard
At first sight, we may think that the mathematical representation of the
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is a union of the three sets, 
\begin_inset Formula $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}$
\end_inset

.
 But an ordinary union of sets would not work for two reasons.
 First, usually one considers that a point is a subset of a line, and a
 line is a subset of a plance, so 
\begin_inset Formula $\mathbb{R}^{0}\subset\mathbb{R}^{1}\subset\mathbb{R}^{2}$
\end_inset

 and therefore 
\begin_inset Formula $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}=\mathbb{R}^{2}$
\end_inset

.
 Even if we somehow avoided this conclusion, we would still confuse several
 sets of the same type since 
\begin_inset Formula $\mathbb{R}^{1}\cup\mathbb{R}^{1}=\mathbb{R}^{1}$
\end_inset

.
 We need to distinguish the parts of the union unambiguously, even if some
 parts have the same type.
 The disjunctive type shown in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 cannot be correctly represented by the mathematical set 
\begin_inset Formula 
\[
\mathbb{R}^{0}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}
\]

\end_inset

because this set is mathematically equivalent to 
\begin_inset Formula $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}$
\end_inset

, which is not the set we need.
\end_layout

\begin_layout Standard
In the Scala code, each part of a disjunctive type must be distinguished
 by a unique name such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

.
 To represent this mathematically, we need to attach a distinct label to
 each part of the union.
 Labels are symbols without any special meaning, so we can just say that
 labels are Scala identifiers.
 So, we will use sets of pairs such as 
\begin_inset Formula $(\text{\texttt{OneRoot}},x)_{x\in\mathbb{R}^{1}}$
\end_inset

 to represent the parts of the union, and write
\begin_inset Formula 
\[
\text{\texttt{RootsOfQ}}=(\text{\texttt{NoRoots}},u)_{u\in\mathbb{R}^{0}}\cup(\text{\texttt{OneRoot}},x)_{x\in\mathbb{R}^{1}}\cup(\text{\texttt{TwoRoots}},\left(x,y\right))_{\left(x,y\right)\in\mathbb{R}^{2}}\quad.
\]

\end_inset

This kind of labeled union is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjoint union
\end_layout

\end_inset


\series bold
disjoint union
\series default
.
 Each element of the disjoint union has a label that clearly identifies
 the part of the union.
 If we use disjoint unions, we cannot confuse different parts of the union
 even if they all have the same type, because labels are required to be
 distinct.
 Because of the different labels, any two values from different parts of
 the union cannot possibly be equal.
\end_layout

\begin_layout Standard
Disjoint unions are not often explicitly denoted in mathematics, but they
 are needed in software engineering because real-life data often has that
 form.
\end_layout

\begin_layout Paragraph
Named 
\family typewriter
Unit
\end_layout

\begin_layout Standard
At first sight, it may seem confusing that the zero-dimensional space is
 represented by a set containing 
\emph on
one
\emph default
 point.
 Why should we not use an empty set (rather than a set with one point) to
 represent the case where the equation has no real roots? The reason is
 that we are required to represent not only the values of the roots but
 also the information 
\emph on
about
\emph default
 the existence of the roots.
 The case with no real roots needs to be represented by some 
\emph on
value
\emph default
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
 This value cannot be missing, which would happen if we used an empty set
 to represent the no-roots case.
 It is natural to use the named empty tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

 to represent this case, since we used a named tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(x, y)
\end_layout

\end_inset

 to represent the case of two roots.
\end_layout

\begin_layout Standard
The set containing a single point corresponds to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type in Scala because this type has only one distinct value, written as
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 A case class with no parts, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, has only one distinct value, written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

.
 We see that case classes with no parts are quite similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 except for an added name.
 For this reason, they can be considered as 
\begin_inset Quotes eld
\end_inset

named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 types.
\end_layout

\begin_layout Subsection
Disjunctive types in other programming languages
\end_layout

\begin_layout Standard
Disjunctive types (and the associated pattern matching) turns out to be
 one of the defining features of functional programming languages.
 Programming languages that were not designed for functional programming
 do not support this feature, while ML, OCaml, Haskell, F#, Scala, Swift,
 Elm, and PureScript support disjunctive types as part of the language design.
 
\end_layout

\begin_layout Standard
It is remarkable that the named tuple types (or 
\begin_inset Quotes eld
\end_inset

records
\begin_inset Quotes erd
\end_inset

) are present in almost every programming language, while disjunctive types
 are present almost exclusively in languages specifically designed for the
 functional programming paradigm.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset href
LatexCommand href
name "this Wikipedia page"
target "https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(basic_instructions)#Other_types"
literal "false"

\end_inset

 for a detailed comparison between programming languages.
 Ada and Pascal are the only older languages that provided disjunctive types
 without other features of the FP paradigm.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

union
\end_layout

\end_inset

 types in C and C++ are not disjunctive types because it is not possible
 to determine which part of the union is being represented.
 A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

union
\end_layout

\end_inset

 declaration in C looks like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

union { int x; double y; long z; } di;
\end_layout

\end_inset

The problem is that the parts of the union are not labeled.
 So, it is impossible to determine or to verify which part of the union
 is represented by a given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

di
\end_layout

\end_inset

.
 This leads to coding errors that are hard to track.
\end_layout

\begin_layout Standard
Older programming languages such as C, C++, and Java had 
\begin_inset Quotes eld
\end_inset

enumeration
\begin_inset Quotes erd
\end_inset

 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset

) types), which are a limited form of disjunctive types.
 An 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset

 type declaration in Java looks like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

enum Color { RED, GREEN, BLUE; } 
\end_layout

\end_inset

This is equivalent to a labeled union of three 
\emph on
empty
\emph default
 tuples,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Color
\end_layout

\begin_layout Plain Layout

final case class RED() extends Color
\end_layout

\begin_layout Plain Layout

final case class GREEN() extends Color
\end_layout

\begin_layout Plain Layout

final case class BLUE() extends Color
\end_layout

\end_inset

If the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset

 construction were 
\begin_inset Quotes eld
\end_inset

enriched
\begin_inset Quotes erd
\end_inset

 with extra data, so that each tuple could be non-empty, we would obtain
 disjunctive types.
 A definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 would then look like this: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// This is not valid in Java!
\end_layout

\begin_layout Plain Layout

enum RootsOfQ {
\end_layout

\begin_layout Plain Layout

  NoRoots; OneRoot(x: Double); TwoRoots(x: Double, y: Double);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

A future version of Scala 3 will have a shorter syntax for disjunctive types
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://dotty.epfl.ch/docs/reference/enums/adts.html"
target "https://dotty.epfl.ch/docs/reference/enums/adts.html"
literal "false"

\end_inset


\end_layout

\end_inset

 that indeed looks like an 
\begin_inset Quotes eld
\end_inset

enriched 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

enum RootsOfQ {
\end_layout

\begin_layout Plain Layout

  case NoRoots
\end_layout

\begin_layout Plain Layout

  case OneRoot(x: Double)
\end_layout

\begin_layout Plain Layout

  case TwoRoots(x: Double, y: Double)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For comparison, here is the OCaml and the Haskell syntax for a disjunctive
 type equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{* OCaml *}
\end_layout

\begin_layout Plain Layout

type RootsOfQ = NoRoots | OneRoot of float | TwoRoots of float*float
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Haskell
\end_layout

\begin_layout Plain Layout

data RootsOfQ = NoRoots | OneRoot Double | TwoRoots (Double,Double)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Disjunctions and conjunctions in formal logic
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctions-and-conjunctions"

\end_inset


\end_layout

\begin_layout Standard
In formal logic, a 
\series bold
proposition
\begin_inset Index idx
status open

\begin_layout Plain Layout
proposition in logic
\end_layout

\end_inset


\series default
 is a statement that may be proven true or false.
 A 
\series bold
disjunction
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunction in logic
\end_layout

\end_inset


\series default
 of propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 is denoted by 
\begin_inset Formula $A\vee B\vee C$
\end_inset

 and is true if only if 
\emph on
at least one
\emph default
 of the propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 is true.
 A 
\series bold
conjunction
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
conjunction in logic
\end_layout

\end_inset

 of propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 is denoted by 
\begin_inset Formula $A\wedge B\wedge C$
\end_inset

 and is true if only if 
\emph on
all
\emph default
 of the propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 are true.
\end_layout

\begin_layout Standard
There is a similarity between a disjunctive data type and a logical 
\emph on
disjunction
\emph default
 of propositions.
 A value of the disjunctive data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 can be constructed only if we have at least one of the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(x)
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(x, y)
\end_layout

\end_inset

 for some specific 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

.
 To save words, denote by 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 the logical proposition 
\begin_inset Quotes eld
\end_inset

this 
\begin_inset Formula ${\cal C}$
\end_inset

ode 
\begin_inset Formula ${\cal H}$
\end_inset

as a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, where 
\begin_inset Quotes eld
\end_inset

this code
\begin_inset Quotes erd
\end_inset

 refers to a particular expression or function in our program.
 So, the proposition 
\begin_inset Quotes eld
\end_inset

a function can return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is denoted by 
\begin_inset Formula ${\cal CH}(\text{\texttt{RootsOfQ}})$
\end_inset

.
 We can then write the sentence about 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 as the logical formula
\begin_inset Formula 
\[
{\cal CH}(\text{\texttt{RootsOfQ}})={\cal CH}(\text{\texttt{NoRoots}})\vee{\cal CH}(\text{\texttt{OneRoot}})\vee{\cal CH}(\text{\texttt{TwoRoots}})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
There is also a a similarity between logical 
\emph on
conjunctions
\emph default
 and a named tuple type.
 Consider the named tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(x: Double, y: Double)
\end_layout

\end_inset

.
 When can we have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

? Only when we have two values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 Writing this statement as a formula, we get
\begin_inset Formula 
\[
{\cal CH}(\text{\texttt{TwoRoots}})={\cal CH}(\text{\texttt{Double}})\wedge{\cal CH}(\text{\texttt{Double}})\quad.
\]

\end_inset

Now, in logic we have the simplification
\begin_inset Formula 
\[
{\cal CH}(\text{\texttt{Double}})\wedge{\cal CH}(\text{\texttt{Double}})={\cal CH}(\text{\texttt{Double}})\quad.
\]

\end_inset

However, no such simplification will be available for an arbitrary tuple
 such as 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Data3(x: Int, y: String, z: Double)
\end_layout

\end_inset

For this type, we will have the statement
\begin_inset Formula 
\[
{\cal CH}(\text{\texttt{Data3}})={\cal CH}(\text{\texttt{Int}})\wedge{\cal CH}(\text{\texttt{String}})\wedge{\cal CH}(\text{\texttt{Double}})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We find that disjunctive types are related to logical disjunctions in the
 same way as tuples are related to logical conjunctions.
 This is the main motivation behind the name 
\begin_inset Quotes eld
\end_inset

disjunctive types
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The correspondence between disjunctions, conjunctions, and data types is
 explained in more detail in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:3-3-The-formal-logic-curry-howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For now, note that the operations of conjunction and disjunction are not
 sufficient to produce all possible logical expressions.
 To obtain a complete logic, it is also necessary to have a logical negation
 
\begin_inset Formula $\neg A$
\end_inset

 (
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 is not true
\begin_inset Quotes erd
\end_inset

) or, equivalently, a logical implication 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $A$
\end_inset

 is true than 
\begin_inset Formula $B$
\end_inset

 is true
\begin_inset Quotes erd
\end_inset

).
 It turns out that the logical implication is related to the function types
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
 In the next chapter, we will study the function types in more depth.
\end_layout

\end_body
\end_document
