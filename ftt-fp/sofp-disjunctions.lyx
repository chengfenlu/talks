#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% Better formatting of tables.
%\usepackage{booktabs}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.0pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}

\usepackage{pstricks} % Illustrations.

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.
\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt,utf8
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7in
\paperheight 9in
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Success,Failure,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The formal logic of types I.
 Disjunctive types
\end_layout

\begin_layout Standard
Disjunctive types describe values that belong to a disjoint set of alternatives.
 
\end_layout

\begin_layout Standard
To see how Scala implements disjunctive types, we need to begin by looking
 at 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Scala's case classes
\end_layout

\begin_layout Subsection
Tuple types with names
\end_layout

\begin_layout Standard
It is often helpful to use names for the different parts of a tuple.
 Suppose that some program represents the size and the color of socks with
 the tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, String)
\end_layout

\end_inset

.
 What if the same tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, String)
\end_layout

\end_inset

 is used in another place in the program to mean the amount paid and the
 payee? A programmer could mix the two values by mistake, and it would be
 hard to find out why the program incorrectly computes, say, the total amount
 paid.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def totalAmountPaid(ps: Seq[(Double, String)]): Double = ps.map(_._1).sum
\end_layout

\begin_layout Plain Layout

val x = (10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

)       // Sock size and color.
\end_layout

\begin_layout Plain Layout

val y = (25.0, 
\begin_inset Quotes eld
\end_inset

restaurant
\begin_inset Quotes erd
\end_inset

)  // Payment amount and payee.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(Seq(x, y)) // Nonsense.
\end_layout

\begin_layout Plain Layout

res0: Double = 35.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We would prevent this kind of mistake if we could use two 
\emph on
different
\emph default
 types, with names such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

, for the two kinds of data.
 There are  three basic ways of defining a new named type in Scala: using
 a type alias, using a class (or 
\begin_inset Quotes eld
\end_inset

trait
\begin_inset Quotes erd
\end_inset

), and using an 
\begin_inset Index idx
status open

\begin_layout Plain Layout
opaque type
\end_layout

\end_inset

opaque type.
 
\end_layout

\begin_layout Standard
Opaque types (hiding a type under a new name) is a feature of a future version
 of Scala 3; so we focus on type aliases and case classes.
\end_layout

\begin_layout Standard
A 
\series bold
type alias
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type alias
\end_layout

\end_inset

 is an alternative name for an existing (already defined) type.
 We could use type aliases in our example to add clarity to the code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type MySockTuple = (Double, String)
\end_layout

\begin_layout Plain Layout

type PaymentTuple = (Double, String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val s: MySockTuple = (10.5, "white")
\end_layout

\begin_layout Plain Layout

s: MySockTuple = (10.5,white)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val p: PaymentTuple = (25.0, "restaurant")
\end_layout

\begin_layout Plain Layout

p: PaymentTuple = (25.0,restaurant)
\end_layout

\end_inset

But the mix-up error is not prevented:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> totalAmountPaid(Seq(s, p)) // Nonsense again.
\end_layout

\begin_layout Plain Layout

res1: Double = 35.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Scala's 
\series bold
case classes
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
case class
\end_layout

\end_inset

 can be seen as 
\begin_inset Quotes eld
\end_inset

tuples with names
\begin_inset Quotes erd
\end_inset

.
 A case class is equivalent to a tuple type that has a name that we choose
 when we define the case class.
 Also, each part of the case class will have a separate name that we must
 choose.
 This is how to define case classes for the example with socks and payments:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySock(size: Double, color: String)
\end_layout

\begin_layout Plain Layout

case class Payment(amount: Double, name: String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val sock = MySock(10.5, "white")
\end_layout

\begin_layout Plain Layout

sock: MySock = MySock(10.5,white)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val paid = Payment(25.0, "restaurant")
\end_layout

\begin_layout Plain Layout

paid: Payment = Payment(25.0,restaurant)                                
  ^ 
\end_layout

\end_inset

The new types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

 were defined.
 Values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 are written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

, which is similar to writing the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 except for adding the name 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 in front of the tuple.
\end_layout

\begin_layout Standard
To access the parts of a case class, we use the part names:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> sock.size
\end_layout

\begin_layout Plain Layout

res2: Double = 10.5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> paid.amount
\end_layout

\begin_layout Plain Layout

res3: Double = 25.0
\end_layout

\end_inset

The mix-up error is now a type error flagged by the compiler:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def totalAmountPaid(ps: Seq[Payment]): Double = ps.map(_.amount).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(Seq(paid, paid))
\end_layout

\begin_layout Plain Layout

res4: Double = 50.0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(Seq(sock, paid))
\end_layout

\begin_layout Plain Layout

<console>:19: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : MySock
\end_layout

\begin_layout Plain Layout

 required: Payment
\end_layout

\begin_layout Plain Layout

       totalAmountPaid(Seq(sock, paid))
\end_layout

\begin_layout Plain Layout

                            ^
\end_layout

\end_inset

A function whose argument is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 cannot be applied to an argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

 or of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, String)
\end_layout

\end_inset

.
 Case classes with different names are 
\emph on
different types
\emph default
, even if they contain the same types of parts.
 
\end_layout

\begin_layout Standard
Just as tuples can have any number of parts, case classes can have any number
 of parts, but the part names must be distinct, for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Person(firstName: String, lastName: String, age: Int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val einstein = Person("Albert", "Einstein", 140)
\end_layout

\begin_layout Plain Layout

einstein: Person = Person(Albert,Einstein,140)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> einstein.firstName
\end_layout

\begin_layout Plain Layout

res5: String = Albert
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> einstein.age
\end_layout

\begin_layout Plain Layout

res6: Int = 140
\end_layout

\end_inset

This data type carries the same information as a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String, String, Int)
\end_layout

\end_inset

.
 However, the declaration of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Person
\end_layout

\end_inset

 gives the programmer several features that make working with the tuple's
 data more convenient and less error-prone.
\end_layout

\begin_layout Standard
Some (or all) part names may be specified when creating a case class value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val poincare = Person(firstName = "Henri", lastName = "Poincaré",
 165)
\end_layout

\begin_layout Plain Layout

poincare: Person = Person(Henri,Poincaré,165)
\end_layout

\end_inset

It is a type error to use wrong types with a case class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

<console>:13: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : Int(140)
\end_layout

\begin_layout Plain Layout

 required: String
\end_layout

\begin_layout Plain Layout

       val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

                      ^
\end_layout

\begin_layout Plain Layout

<console>:13: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : String("Albert")
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\begin_layout Plain Layout

       val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

                                       ^
\end_layout

\end_inset

Here, the error is due to an incorrect order of parts when creating a case
 class value.
 However, parts can be specified in any order when using part names:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p = Person(age = 140, lastName = "Einstein", firstName = "Albert")
\end_layout

\begin_layout Plain Layout

p: Person = Person(Albert,Einstein,140)
\end_layout

\end_inset

A part of a case class can have the type of another case class, creating
 a type similar to a nested tuple:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class BagOfSocks(sock: MySock, count: Int)
\end_layout

\begin_layout Plain Layout

val bag = BagOfSocks(MySock(10.5, "white"), 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> bag.sock.size
\end_layout

\begin_layout Plain Layout

res7: Double = 10.5
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Case classes with type parameters
\end_layout

\begin_layout Standard
Type classes can be defined with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type parameter
\end_layout

\end_inset

type parameters.
 As an example, consider a generalization of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 where, in addition to the size and color, an 
\begin_inset Quotes eld
\end_inset

extended sock
\begin_inset Quotes erd
\end_inset

 holds another value.
 We could define several specialized case classes,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySock_Int(size: Double, color: String, value: Int)
\end_layout

\begin_layout Plain Layout

case class MySock_Boolean(size: Double, color: String, value: Boolean)
\end_layout

\end_inset

but it is better to define a single parameterized case class
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySockX[A](size: Double, color: String, value: A)
\end_layout

\end_inset

that works for every type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 We can now create values of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

 containing a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

value
\end_layout

\end_inset

 of any type,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = MySockX(10.5, "white", 123)
\end_layout

\begin_layout Plain Layout

s: MySockX[Int] = MySockX(10.5,white,123) 
\end_layout

\end_inset

We see that the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 was automatically set to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Each time we create a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

, a specific type will have to be used instead of the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 In other words, we can only create values of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[Int]
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[String]
\end_layout

\end_inset

, etc.
 If we want to be explicit, we may write
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = MySockX[String](10.5, "white", 
\begin_inset Quotes eld
\end_inset

last pair
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

s: MySockX[String] = MySockX(10.5,white,last pair) 
\end_layout

\end_inset

However, we can write code working with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[A]
\end_layout

\end_inset

 
\series bold
parametrically
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
parametric code
\end_layout

\end_inset

, that is, keeping the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in the code.
 For example, a function that checks whether a sock of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[A]
\end_layout

\end_inset

 fits my foot can be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fitsMe[A](sock: MySockX[A]): Boolean = sock.size >= 10.5 && sock.size <=
 11.0
\end_layout

\end_inset

This function is defined for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 at once, because its code works in the same way regardless of what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is.
 Scala will set the type parameter automatically:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fitsMe(MySockX(10.5, 
\begin_inset Quotes eld
\end_inset

blue
\begin_inset Quotes erd
\end_inset

, List(1,2,3))) // Parameter A = List[Int]
\end_layout

\begin_layout Plain Layout

res0: Boolean = true
\end_layout

\end_inset

This code forces the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 to be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

, and so we may omit the type parameter of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fitsMe
\end_layout

\end_inset

.
 When types become more complicated, it may be helpful to prevent type errors
 by specifying the values of some type parameters.
 For example, here is a type error due to a mismatch between the type parameter
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 used in the 
\begin_inset Quotes eld
\end_inset

sock
\begin_inset Quotes erd
\end_inset

 value, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

, and the type parameter in the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fitsMe
\end_layout

\end_inset

, specified as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
\end_layout

\begin_layout Plain Layout

<console>:15: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : List[Int]
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\begin_layout Plain Layout

       fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
\end_layout

\begin_layout Plain Layout

                                             ^ 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Case classes may have several type parameters, and the types of the parts
 may use these type parameters.
 Here is an artificial example of a case class using type parameters in
 different ways,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Complicated[A,B,C,D](x: (A, A), y: (B, Int) => A, z: C => C)
\end_layout

\end_inset

This case class contains parts of different types that use the type parameters
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 in tuples and functions.
 The type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

 is not used at all; this is allowed.
\end_layout

\begin_layout Standard
A type with type parameters, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Complicated
\end_layout

\end_inset

, is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type constructor
\end_layout

\end_inset


\series bold
type constructor
\series default
.
 A type constructor 
\begin_inset Quotes eld
\end_inset

constructs
\begin_inset Quotes erd
\end_inset

 a new type, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[Int]
\end_layout

\end_inset

, from a given type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 In our code, we cannot have values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

 without setting the type parameter.
 So, it is important to distinguish the type constructor, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

, from a type we can use in our code, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[Int]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Tuples with one part and with zero parts
\end_layout

\begin_layout Standard
Let us compare tuples and case classes more systematically.
\end_layout

\begin_layout Standard
Parts of a case class are accessed by name with a dot syntax, for example
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sock.color
\end_layout

\end_inset

.
 Parts of a tuple are accessed with the accessors such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x._1
\end_layout

\end_inset

.
 This syntax is the same as that for a case class whose parts have names
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_2
\end_layout

\end_inset

, etc.
 So, it appears that tuple parts 
\emph on
do
\emph default
 have names in Scala, although those names are always automatically chosen
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_2
\end_layout

\end_inset

, etc.
 Tuple types are also automatically named in Scala as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple2
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple3
\end_layout

\end_inset

, etc., and they are parameterized, since each part of the tuple may be of
 any chosen type.
 A tuple type expression such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, String)
\end_layout

\end_inset

 is just a special syntax for the parameterized type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple2[Int, String]
\end_layout

\end_inset

.
 One could define the tuple types as case classes like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Tuple2[A, B](_1: A, _2: B)
\end_layout

\begin_layout Plain Layout

case class Tuple3[A, B, C](_1: A, _2: B, _3: C)
\end_layout

\begin_layout Plain Layout

// And so on with Tuple4, Tuple5, ...
\end_layout

\end_inset

if these types were not already defined in the Scala library.
\end_layout

\begin_layout Standard
Proceeding systematically, we ask whether tuple types can have just one
 part or even no parts.
 Indeed, Scala defines 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple1[A]
\end_layout

\end_inset

 as a tuple with a single part.
 (This type is occasionally used in practice.) 
\end_layout

\begin_layout Standard
The tuple with zero parts also exists and is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 (rather than 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple0
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

).
 The syntax for the value of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type is the empty tuple, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 It is clear that there is 
\emph on
only one
\emph default
 value, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, of this type; this explains the name 
\begin_inset Quotes eld
\end_inset

unit
\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
At first sight, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type may appear to be completely useless: it is a tuple that contains 
\emph on
no
\emph default
 
\emph on
data
\emph default
.
 It turns out, however, that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type is important in functional programming, and it is used as a type 
\emph on
guaranteed
\emph default
 to have only a single distinct value.
 This chapter will show some examples of using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
\end_layout

\begin_layout Standard
Case classes may have one part or zero parts, similarly to the one-part
 and zero-part tuples:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class B(z: Int)  // Tuple with one part.
\end_layout

\begin_layout Plain Layout

case class C()        // Tuple with no parts.
\end_layout

\end_inset

Let us summarize the correspondence between tuples and case classes:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tuples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Case classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(123, "xyz"): Tuple2[Int, String]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class A(x: Int, y: String)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(123,): Tuple1[Int]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class B(z: Int)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(): Unit
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Scala has a special syntax for empty case class
\begin_inset Index idx
status open

\begin_layout Plain Layout
empty case class
\end_layout

\end_inset

es:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case object C // Similar to `case class C()`.
\end_layout

\end_inset

There are two main differences between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object C
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

 cannot have type parameters, while we may define, if needed, a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C[X, Y, Z]()
\end_layout

\end_inset

 with type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

 is allocated in memory only once, while new values of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 will be allocated in memory each time 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C()
\end_layout

\end_inset

 is evaluated.
\end_layout

\begin_layout Standard
Other than that, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object C
\end_layout

\end_inset

 have the same meaning: a named tuple with zero parts, which we may also
 view as a 
\begin_inset Quotes eld
\end_inset

named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Index true 1 ""
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 type.
 In this book, I will not use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

s because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class
\end_layout

\end_inset

es are more general.
\end_layout

\begin_layout Subsection
Pattern matching for case classes
\end_layout

\begin_layout Standard
Scala performs pattern matching in two situations:
\end_layout

\begin_layout Itemize
destructuring definition: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

val $pattern$ = ...
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

case $pattern$ => ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Case classes can be used in both situations.
 A destructuring definition can be used in a function whose argument is
 of case class type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BagOfSocks
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySock(size: Double, color: String)
\end_layout

\begin_layout Plain Layout

case class BagOfSocks(sock: MySock, count: Int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def printBag(bag: BagOfSocks): String = {
\end_layout

\begin_layout Plain Layout

  val BagOfSocks(MySock(size, color), count) = bag // Destructure the `bag`.
\end_layout

\begin_layout Plain Layout

  s
\begin_inset Quotes eld
\end_inset

Bag has $count $color socks of size $size
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val bag = BagOfSocks(MySock(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

), 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> printBag(bag)
\end_layout

\begin_layout Plain Layout

res0: String = Bag has 6 white socks of size 10.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An example of using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fitsMe(bag: BagOfSocks): Boolean = bag match {
\end_layout

\begin_layout Plain Layout

  case BagOfSocks(MySock(size, _), _) => size >= 10.5 && size <= 11.0
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the implementation of this function, we match the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bag
\end_layout

\end_inset

 value against the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BagOfSocks(MySock(size, _), _)
\end_layout

\end_inset

.
 This pattern will always match and will define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

 as a pattern variable of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The syntax for pattern matching expressions with case classes is similar
 to the syntax for pattern matching of tuples, except for the presence of
 the 
\emph on
names
\emph default
 of the case classes.
 For example, removing the case class names from the pattern
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case BagOfSocks(MySock(size, _), _) => ...
\end_layout

\end_inset

we obtain the nested tuple pattern 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case ((size, _), _) => ...
\end_layout

\end_inset

that could be used for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((Double, String), Int)
\end_layout

\end_inset

.
 We see that case classes behave in many ways exactly as tuple types with
 names.
 
\end_layout

\begin_layout Standard
Scala's 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset

 got their name from their use in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions.
 It is usually more convenient to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions with case classes than to use destructuring.
\end_layout

\begin_layout Section
Disjunctive types
\end_layout

\begin_layout Subsection
Motivation and first examples
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Motivation-and-first-examples"

\end_inset


\end_layout

\begin_layout Standard
In many situations, it is useful to have several different shapes of data
 within the same type.
 As a first example, suppose we are looking for real roots of a quadratic
 equation 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

.
 There are three cases: no real roots, one real root, and two real roots.
 It is convenient to have a type, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

, that means 
\begin_inset Quotes eld
\end_inset

the real roots of a quadratic equation
\begin_inset Quotes erd
\end_inset

.
 Inside that type, we distinguish between the three cases, but outside it
 looks like a single type.
\end_layout

\begin_layout Standard
Another example is the binary search algorithm that looks for an integer
 
\begin_inset Formula $x$
\end_inset

 in a sorted array.
 There are two cases: the algorithm either finds the index of 
\begin_inset Formula $x$
\end_inset

 or determines that the array does not contain 
\begin_inset Formula $x$
\end_inset

.
 It is convenient if the algorithm could return a single value of a type,
 say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

, that represents 
\emph on
either
\emph default
 an index at which 
\begin_inset Formula $x$
\end_inset

 is found, 
\emph on
or
\emph default
 the absence of an index.
\end_layout

\begin_layout Standard
More generally, we may have computations that 
\emph on
either
\emph default
 return a value 
\emph on
or
\emph default
 generate an error and fail to produce a result.
 It is then convenient to return a value of type, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

, that represents either a correct result or an error message.
 
\end_layout

\begin_layout Standard
In certain computer games, one has different types of 
\begin_inset Quotes eld
\end_inset

rooms
\begin_inset Quotes erd
\end_inset

, each room having certain properties depending on its type.
 Some rooms are dangerous because of monsters, other rooms contain useful
 objects, certain rooms allow you to finish the game, and so on.
 We want to represent all the different kinds of rooms uniformly, as a type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Room
\end_layout

\end_inset

, so that a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Room
\end_layout

\end_inset

 automatically stores the correct properties in each case.
\end_layout

\begin_layout Standard
In all these situations, data comes in several mutually exclusive shapes.
 This data can be represented by a single type if that type is able to describe
 a mutually exclusive set of cases:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 must be either the empty tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, or a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 must be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or the empty tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 must be either an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 value or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 message
\end_layout

\begin_layout Standard
We see that the empty tuple, also known as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, is convenient to use in this representation! It is also helpful to
 assign names to each of the cases:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

no roots
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

one root
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

two roots
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

index
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

not found
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset Quotes eld
\end_inset

error message
\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Scala's case classes provide exactly what we need here – 
\emph on
named tuples
\emph default
 with zero, one, two and more parts, and so it is natural to use case classes
 instead of tuples:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class NoRoots()
\end_layout

\end_inset

, or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class OneRoot(x: Double)
\end_layout

\end_inset

, or of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class TwoRoots(x: Double, y: Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Index(Int)
\end_layout

\end_inset

 or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class NotFound()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Value(x: Int)
\end_layout

\end_inset

 or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Error(message: String)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our three examples are now described as types that select one case class
 out of a given set.
 It remains to see how Scala defines such types.
 For instance, the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 needs to indicate that the case classes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

 are exactly the three alternatives described by the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
 The Scala syntax for that definition looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class NoRoots() extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class OneRoot(x: Double) extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class TwoRoots(x: Double, y: Double) extends RootsOfQ
\end_layout

\end_inset

In the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

, we have two cases:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait SearchResult
\end_layout

\begin_layout Plain Layout

final case class Index(i: Int) extends SearchResult
\end_layout

\begin_layout Plain Layout

final case class NotFound() extends SearchResult
\end_layout

\end_inset

The definition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 type can be parameterized, so that we can describe results of any type
 (but error messages are always of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Result[A]
\end_layout

\begin_layout Plain Layout

final case class Value[A](x: A) extends Result[A]
\end_layout

\begin_layout Plain Layout

final case class Error[A](message: String) extends Result[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sealed trait
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

final case class
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 syntax defines a type that represents a choice of one case class from a
 fixed set of case classes.
 This kind of type is called a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type
\end_layout

\end_inset

disjunctive type
\series default
 in this book.
 
\end_layout

\begin_layout Subsection
Solved examples: Pattern matching with disjunctive types
\end_layout

\begin_layout Standard
Our first examples of disjunctive types are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[A]
\end_layout

\end_inset

 defined in the previous section.
 We will now look at the Scala syntax for creating values of disjunctive
 types and for using the created values.
\end_layout

\begin_layout Standard
Consider the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 having three case classes (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

).
 The only way of creating a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is to create a value of one of these case classes.
 This is done by writing expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(2.0)
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(1.0, -1.0)
\end_layout

\end_inset

.
 Scala will accept these expressions as having the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x: RootsOfQ = OneRoot(2.0)
\end_layout

\begin_layout Plain Layout

x: RootsOfQ = OneRoot(2.0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:RootsOfQ
\end_layout

\end_inset

, how can we use it, say, as a function argument? The main tool for working
 with values of disjunctive types is pattern matching with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions.
 In Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:2-Mathematical-induction"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we used pattern matching to destructure tuples with syntax such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case (x, y) => ...
 }
\end_layout

\end_inset

.
 We will now see how to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions with disjunctive types.
 The main difference is that we may have to write 
\emph on
more than one
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 pattern in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 expression, because we need to match several possible cases of the disjunctive
 type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(r: RootsOfQ): String = r match {
\end_layout

\begin_layout Plain Layout

  case NoRoots()       => 
\begin_inset Quotes eld
\end_inset

no real roots
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case OneRoot(r)      => s
\begin_inset Quotes eld
\end_inset

one real root: $r
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case TwoRoots(x, y)  => s
\begin_inset Quotes erd
\end_inset

real roots: ($x, $y)
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f(x)
\end_layout

\begin_layout Plain Layout

res0: String = 
\begin_inset Quotes eld
\end_inset

one real root: 2.0
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

If we only need to recognize a specific case of a disjunctive type, we can
 match all other cases with an underscore:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> x match {
\end_layout

\begin_layout Plain Layout

  case OneRoot(r)   => s
\begin_inset Quotes erd
\end_inset

one real root: $r
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case _            => 
\begin_inset Quotes eld
\end_inset

have something else
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

res1: String = one real root: 2.0
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression represents a choice over possible values of a given type.
 Note the similarity with this code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int): Int = x match {
\end_layout

\begin_layout Plain Layout

  case 0    => println(s"error: must be nonzero"); -1
\end_layout

\begin_layout Plain Layout

  case 1    => println(s"error: must be greater than 1"); -1
\end_layout

\begin_layout Plain Layout

  case _    => x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

 are some possible values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, just as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(1.0)
\end_layout

\end_inset

 is a possible value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
 When used with disjunctive types, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions will usually contain a complete list of possibilities.
 If the list of cases is incomplete, the Scala compiler will print a warning:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def g(x: RootsOfQ): String = x match {
\end_layout

\begin_layout Plain Layout

     |    case OneRoot(r) => s"one real root: $r"
\end_layout

\begin_layout Plain Layout

     | }
\end_layout

\begin_layout Plain Layout

<console>:14: warning: match may not be exhaustive.
\end_layout

\begin_layout Plain Layout

It would fail on the following inputs: NoRoots(), TwoRoots(_, _)
\end_layout

\begin_layout Plain Layout

       def g(x: RootsOfQ): String = x match {
\end_layout

\begin_layout Plain Layout

                                    ^
\end_layout

\end_inset

This code defines a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial function
\end_layout

\end_inset


\emph on
partial
\emph default
 function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 that can be applied only to values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(...)
\end_layout

\end_inset

 and will fail for other values.
\end_layout

\begin_layout Standard
Let us look at more examples of using the disjunctive types we just defined.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-rootsofq-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a sequence of quadratic equations, compute a sequence containing their
 real roots as values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Define a case class representing a quadratic equation 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class QEqu(b: Double, c: Double)
\end_layout

\end_inset

The following function determines how many real roots an equation has:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def solve(quadraticEqu: QEqu): RootsOfQ = {
\end_layout

\begin_layout Plain Layout

   val QEqu(b, c) = quadraticEqu // Destructure QEqu.
\end_layout

\begin_layout Plain Layout

   val d = b * b / 4 - c
\end_layout

\begin_layout Plain Layout

   if (d > 0) {
\end_layout

\begin_layout Plain Layout

     val s = math.sqrt(d)
\end_layout

\begin_layout Plain Layout

     TwoRoots(b / 2 - s, b / 2 + s)
\end_layout

\begin_layout Plain Layout

   } else if (d == 0.0) OneRoot(b / 2)
\end_layout

\begin_layout Plain Layout

   else NoRoots()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Test this function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> solve(QEqu(1,1))
\end_layout

\begin_layout Plain Layout

res1: RootsOfQ = NoRoots()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> solve(QEqu(1,-1))
\end_layout

\begin_layout Plain Layout

res2: RootsOfQ = TwoRoots(-0.6180339887498949,1.618033988749895) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> solve(QEqu(6,9))
\end_layout

\begin_layout Plain Layout

res3: RootsOfQ = OneRoot(3.0) 
\end_layout

\end_inset

We can now implement the required function,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map(solve)
\end_layout

\end_inset

If the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve
\end_layout

\end_inset

 is not used often, we may want to write it inline:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map { case QEqu(b, c)
 =>
\end_layout

\begin_layout Plain Layout

  (b * b / 4 - c) match {
\end_layout

\begin_layout Plain Layout

    case d if d > 0   =>
\end_layout

\begin_layout Plain Layout

      val s = math.sqrt(d)
\end_layout

\begin_layout Plain Layout

      TwoRoots(b / 2 - s, b / 2 + s)
\end_layout

\begin_layout Plain Layout

    case 0.0          => OneRoot(b / 2)
\end_layout

\begin_layout Plain Layout

    case _            => NoRoots()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code uses some features of Scala syntax.
 We can use the partial function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case QEqu(b, c) => ...
 }
\end_layout

\end_inset

 directly as the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 instead of defining this function separately.
 This avoids having to destructure 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

QEqu
\end_layout

\end_inset

 at a separate step.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 expression is replaced by an 
\begin_inset Quotes eld
\end_inset

embedded
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
embedded `if`
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 within the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression, which is easier to read.
 Test the final code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> findRoots(Seq(QEqu(1,1), QEqu(2,1)))
\end_layout

\begin_layout Plain Layout

res4: Seq[RootsOfQ] = List(NoRoots(), OneRoot(1.0)) 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-rootsofq"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a sequence of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

, compute a sequence containing only the single roots.
 Example test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> singleRoots(Seq(TwoRoots(-1, 1), OneRoot(3.0), OneRoot(1.0), NoRoots()))
\end_layout

\begin_layout Plain Layout

res5: Seq[Double] = List(3.0, 1.0) 
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 to the sequence of roots:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] = rs.filter {
\end_layout

\begin_layout Plain Layout

  case OneRoot(x) => true
\end_layout

\begin_layout Plain Layout

  case _          => false
\end_layout

\begin_layout Plain Layout

}.map { case OneRoot(x) => x }
\end_layout

\end_inset

In the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 operation, we need to cover only the one-root case because the other two
 possibilities have been 
\begin_inset Quotes eld
\end_inset

filtered out
\begin_inset Quotes erd
\end_inset

 by the preceding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 operation.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-searchresult"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-searchresult"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement binary search returning a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

.
 We will modify the binary search implementation from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-binary-search-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b) so that it returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NotFound
\end_layout

\end_inset

 value when appropriate.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The code from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-binary-search-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b) will return 
\emph on
some
\emph default
 index even if the given number is not present in the array: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> binSearch(Array(1, 3, 5, 7), goal = 5)
\end_layout

\begin_layout Plain Layout

res6: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> binSearch(Array(1, 3, 5, 7), goal = 4)
\end_layout

\begin_layout Plain Layout

res7: Int = 1
\end_layout

\end_inset

When the number is not present, the array's element at the computed index
 will not be equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

goal
\end_layout

\end_inset

.
 We should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NotFound()
\end_layout

\end_inset

 in that case.
 The new code can be written as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression for clarity:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def safeBinSearch(xs: Seq[Int], goal: Int): SearchResult =
\end_layout

\begin_layout Plain Layout

  binSearch(xs, goal) match {
\end_layout

\begin_layout Plain Layout

    case n if xs(n) == goal   => Index(n) 
\end_layout

\begin_layout Plain Layout

    case _                    => NotFound()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

To test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> safeBinSearch(Array(1, 3, 5, 7), 5)
\end_layout

\begin_layout Plain Layout

res8: SearchResult = Index(2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> safeBinSearch(Array(1, 3, 5, 7), 4)
\end_layout

\begin_layout Plain Layout

res9: SearchResult = NotFound()
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-resultA"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

 to implement 
\begin_inset Quotes eld
\end_inset

safe integer arithmetic
\begin_inset Quotes erd
\end_inset

, where a division by zero or a square root of a negative number will give
 an error message.
 Define arithmetic operations directly for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

; abandon computations if an error occurs.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing the square root:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sqrt(r: Result[Int]): Result[Int] = r match {
\end_layout

\begin_layout Plain Layout

  case Value(x) if x >= 0  => Value(math.sqrt(x).toInt)
\end_layout

\begin_layout Plain Layout

  case Value(x)            => Error(s
\begin_inset Quotes eld
\end_inset

error: sqrt($x)
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

  case Error(m)            => Error(m) // Keep the error message.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The square root is computed only if we have the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value(x)
\end_layout

\end_inset

 case, and only if 
\begin_inset Formula $x\geq0$
\end_inset

.
 If the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

 was already an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Error
\end_layout

\end_inset

 case, we keep the error message and perform no further operations.
\end_layout

\begin_layout Standard
To implement the addition operation, we need a bit more work:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) => Value(x + y)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)        => Error(m) // Keep the error message.
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code illustrates nested patterns that match the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(rx, ry)
\end_layout

\end_inset

 against various possibilities.
 In this way, the code is clearer than code written with nested 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 expressions.
\end_layout

\begin_layout Standard
Implementing the multiplication operation results in almost the same code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def mul(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) => Value(x * y)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)        => Error(m)
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To avoid repetition, we may define a general function that 
\begin_inset Quotes eld
\end_inset

promotes
\begin_inset Quotes erd
\end_inset

 operations on integers to operations on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

 types:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def do2(rx: Result[Int], ry: Result[Int])(op: (Int, Int) => Int): Result[Int]
 =
\end_layout

\begin_layout Plain Layout

  (rx, ry) match {
\end_layout

\begin_layout Plain Layout

    case (Value(x), Value(y)) => Value(op(x, y))
\end_layout

\begin_layout Plain Layout

    case (Error(m), _)        => Error(m)
\end_layout

\begin_layout Plain Layout

    case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

Now we can easily 
\begin_inset Quotes eld
\end_inset

promote
\begin_inset Quotes erd
\end_inset

 any binary operation that never generates an error to an operation on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sub(rx: Result[Int], ry: Result[Int]): Result[Int] =
\end_layout

\begin_layout Plain Layout

  do2(rx, ry){ (x, y) => x - y }
\end_layout

\end_inset

 Custom code is still needed for operations that may generate errors:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def div(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) if y != 0  => Value(x / y)
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y))            => Error(s
\begin_inset Quotes eld
\end_inset

error: $x / $y
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)                   => Error(m)
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))                   => Error(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can now test the new 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

 on simple calculations:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> add(Value(1), Value(2))
\end_layout

\begin_layout Plain Layout

res10: Result[Int] = Value(3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> div(add(Value(1), Value(2)), Value(0))
\end_layout

\begin_layout Plain Layout

res11: Result[Int] = Error(error: 3 / 0)
\end_layout

\end_inset

We see that indeed all further computations are abandoned once an error
 occurs.
 An error message shows only the immediate calculation that generated the
 error.
 For instance, the error message for 
\begin_inset Formula $20+1/0$
\end_inset

 never mentions 
\begin_inset Formula $20$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> add(Value(20), div(Value(1), Value(0)))
\end_layout

\begin_layout Plain Layout

res12: Result[Int] = Error(error: 1 / 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> add(sqrt(Value(-1)), Value(10))
\end_layout

\begin_layout Plain Layout

res13: Result[Int] = Error(error: sqrt(-1))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Standard disjunctive types: 
\family typewriter
Option
\family default
, 
\family typewriter
Either
\family default
, 
\family typewriter
Try
\end_layout

\begin_layout Standard
The Scala library defines the disjunctive types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 because they are used often.
 We now look at each of them in turn.
\end_layout

\begin_layout Paragraph

\family typewriter
Option
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type is a disjunctive type with two cases: the empty tuple and a one-element
 tuple.
 The names of the two case classes are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some
\end_layout

\end_inset

.
 If the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type were not already defined in the standard library, one could define
 it with the code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Option[T]
\end_layout

\begin_layout Plain Layout

final case object None extends Option[Nothing]
\end_layout

\begin_layout Plain Layout

final case class Some[T](t: T) extends Option[T]
\end_layout

\end_inset

This code is similar to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Motivation-and-first-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

 except that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 has a type parameter instead of a fixed type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 Another difference is the use of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

 for the empty case instead of an empty case class, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None()
\end_layout

\end_inset

.
 Since Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

s cannot have type parameters, the type parameter in the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 must be set to the special type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

, which is a type with 
\emph on
no
\emph default
 values (also known as the 
\series bold
void
\series default
 type
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
An alternative (implemented in libraries such as 
\family typewriter
scalaz
\family default
) is to define 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class None[T]() extends Option[T]
\end_layout

\end_inset

and write the empty option value as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None()
\end_layout

\end_inset

.
 In that implementation, the empty option also has a type parameter.
\end_layout

\begin_layout Standard
Several consequences follow from the Scala library's decision to define
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 without a type parameter.
 One consequence is that the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 can be reused as a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 for any type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val y: Option[Int] = None
\end_layout

\begin_layout Plain Layout

y: Option[Int] = None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val z: Option[String] = None
\end_layout

\begin_layout Plain Layout

z: Option[String] = None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Typically, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 is used in situations where a value may be either present or missing, especiall
y when a missing value is 
\emph on
not an error
\emph default
.
 The missing-value case is represented by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(x)
\end_layout

\end_inset

 means that a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is present.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Example-option-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-option-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Suppose that information about subscribers to a certain online service must
 contain a name and an email address, but a telephone number is optional.
 To represent this information, we may define a case class like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Subscriber(name: String, email: String, phone: Option[Long])
\end_layout

\end_inset

What if we represent the missing telephone number by a special value such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-1
\end_layout

\end_inset

 and use the simpler type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

? The disadvantage is that we would need to 
\emph on
remember
\emph default
 to check for the special value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-1
\end_layout

\end_inset

 in all functions that take the telephone number as an argument.
 Looking at a function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sendSMS(phone: Long)
\end_layout

\end_inset

 at a different place in the code, a programmer might forget that the telephone
 number is actually optional.
 In contrast, the type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sendSMS(phone: Option[Long])
\end_layout

\end_inset

 unambiguously indicates that the telephone number might be missing and
 helps the programmer to remember that case.
\end_layout

\begin_layout Standard
Pattern-matching code involving 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 needs two cases:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def getDigits(phone: Option[Long]): Option[Seq[Long]] = phone match {
\end_layout

\begin_layout Plain Layout

  case None               => None   // Do nothing.
\end_layout

\begin_layout Plain Layout

  case Some(number)       => Some(digitsOf(number))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Here we used the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsOf
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ch2Converting-a-single"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
At the two sides of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case None => None
\end_layout

\end_inset

, the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 has different types, namely 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Seq[Long]]
\end_layout

\end_inset

.
 Since these types are declared in the type signature of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getDigits
\end_layout

\end_inset

, the Scala compiler is able to deduce the correct types of all expressions
 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 construction.
 This allows us to write shorter pattern-matching code, without explicit
 type annotations such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(None: Option[Long])
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
If we now need to compute the number of digits, we can write
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def numberOfDigits(phone: Option[Long]): Option[Long] = getDigits(phone)
 match {
\end_layout

\begin_layout Plain Layout

  case None               => None   // Do nothing.
\end_layout

\begin_layout Plain Layout

  case Some(digits)       => Some(digits.length)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These examples perform some computations when an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 value is not empty, and leave it empty otherwise.
 Rather than keep repeating this kind of code, we can implement this design
 pattern as a function that takes the computation as a parameter: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def doComputation(x: Option[Long], f: Long => Long): Option[Long] = x match
 {
\end_layout

\begin_layout Plain Layout

  case None               => None   // Do nothing.
\end_layout

\begin_layout Plain Layout

  case Some(i)            => Some(f(i))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It is then natural to generalize this function to arbitrary types using
 type parametersinstead of a fixed type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

.
 The resulting function is usually called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B] = {
\end_layout

\begin_layout Plain Layout

  case None               => None   // Do nothing.
\end_layout

\begin_layout Plain Layout

  case Some(a)            => Some(f(a))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fmap(digitsOf)(Some(4096))
\end_layout

\begin_layout Plain Layout

res0: Option[Seq[Long]] = Some(List(4, 0, 9, 6))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fmap(digitsOf)(None)
\end_layout

\begin_layout Plain Layout

res1: Option[Seq[Long]] = None
\end_layout

\end_inset

One can say that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 operation 
\begin_inset Quotes eld
\end_inset


\series bold
lifts
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
lifting
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 a given function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

 to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A] => Option[B]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The Scala library implements an equivalent function as a method on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 class, with the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(f)
\end_layout

\end_inset

 rather than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(x)
\end_layout

\end_inset

.
 We can concisely rewrite the previous code using the standard library methods
 as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def getDigits(phone: Option[Long]): Option[Seq[Long]] = phone.map(digitsOf)
\end_layout

\begin_layout Plain Layout

def numberOfDigits(phone: Option[Long]): Option[Long] = phone.map(digitsOf).map(_.l
ength)
\end_layout

\end_inset

We see that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 operation for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type is analogous to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 operation for sequences.
 
\end_layout

\begin_layout Standard
The similarity between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 is made clearer if we view 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 as a special kind of sequence whose length is restricted to be either 
\begin_inset Formula $0$
\end_inset

 or 
\begin_inset Formula $1$
\end_inset

.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 can have all the operations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

, except the operations such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.concat
\end_layout

\end_inset

 that may increase the length of the sequence.
 The standard operations defined on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 include 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.forall
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.exists
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunction-Example-Option-flatMap"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunction-Example-Option-flatMap"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a phone number as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

, extract the country code if it is present.
 (Assume that the country code is any digits in front of the 
\begin_inset Formula $10$
\end_inset

-digit number; for the phone number 
\begin_inset Formula $18004151212$
\end_inset

, the country code is 
\begin_inset Formula $1$
\end_inset

.) The result must be again of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
If the phone number is a positive integer 
\begin_inset Formula $n$
\end_inset

, we may compute the country code simply as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n / 10000000000L
\end_layout

\end_inset

.
 However, if the result of that division is zero, we should return an empty
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 (i.e.
\begin_inset space ~
\end_inset

the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

) rather than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
 To implement this logic, we may begin by writing this code,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone match {
\end_layout

\begin_layout Plain Layout

  case None      => None
\end_layout

\begin_layout Plain Layout

  case Some(n)   =>
\end_layout

\begin_layout Plain Layout

    val countryCode = n / 10000000000L
\end_layout

\begin_layout Plain Layout

    if (countryCode != 0L) Some(countryCode) else None 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We may notice that we have reimplemented the design pattern similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 in this code, namely 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, else do a computation
\begin_inset Quotes erd
\end_inset

.
 So we may try to rewrite the code as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone.map { n =>
\end_layout

\begin_layout Plain Layout

    val countryCode = n / 10000000000L
\end_layout

\begin_layout Plain Layout

    if (countryCode != 0L) Some(countryCode) else None 
\end_layout

\begin_layout Plain Layout

} // Type error: the result is Option[Option[Long]].
\end_layout

\end_inset

But this code will not compile: we are returning an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

 within a function lifted via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, so the resulting type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[Long]]
\end_layout

\end_inset

.
 To convert 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[Long]]
\end_layout

\end_inset

 to the required type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

, we may use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone.map { n =>
\end_layout

\begin_layout Plain Layout

    val countryCode = n / 10000000000L
\end_layout

\begin_layout Plain Layout

    if (countryCode != 0L) Some(countryCode) else None 
\end_layout

\begin_layout Plain Layout

}.flatten // Types are correct now.
\end_layout

\end_inset

Since the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 follows a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, we can rewrite the code using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone.flatMap { n =>
\end_layout

\begin_layout Plain Layout

    val countryCode = n / 10000000000L
\end_layout

\begin_layout Plain Layout

    if (countryCode != 0L) Some(countryCode) else None 
\end_layout

\begin_layout Plain Layout

} // Types are correct now.
\end_layout

\end_inset

Another way of implementing this example is to notice the design pattern
 
\begin_inset Quotes eld
\end_inset

if condition does not hold, return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, otherwise keep the value
\begin_inset Quotes erd
\end_inset

.
 For an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type, this is equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 operation, since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 returns an empty sequence when the predicate does not hold.
 So the final code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = 
\end_layout

\begin_layout Plain Layout

  phone.map(_ / 10000000000L).filter(_ != 0L)
\end_layout

\end_inset

Test it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> countryCode(Some(18004151212L))
\end_layout

\begin_layout Plain Layout

res0: Option[Long] = Some(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> countryCode(Some(8004151212L))
\end_layout

\begin_layout Plain Layout

res1: Option[Long] = None
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunction-Example-Option-getOrElse"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunction-Example-Option-getOrElse"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Add a new requirement to the phone number example: if the country code is
 not present, we should return the default country code 
\begin_inset Formula $1$
\end_inset

.
 This is an often used design pattern: 
\begin_inset Quotes eld
\end_inset

if empty, substitute a default value
\begin_inset Quotes erd
\end_inset

.
 The Scala library has the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.getOrElse
\end_layout

\end_inset

 for this purpose:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Some(100).getOrElse(1)
\end_layout

\begin_layout Plain Layout

res2: Int = 100
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> None.getOrElse(1)
\end_layout

\begin_layout Plain Layout

res3: Int = 1
\end_layout

\end_inset

So we can implement the new requirement as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> countryCode(Some(8004151212L)).getOrElse(1L)
\end_layout

\begin_layout Plain Layout

res4: Long = 1
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Using 
\family typewriter
Option
\family default
 with collections
\end_layout

\begin_layout Standard
Many Scala library methods return an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 as a result.
 The main examples are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.find
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.headOption
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.lift
\end_layout

\end_inset

 for sequences, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.get
\end_layout

\end_inset

 for dictionaries.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.find
\end_layout

\end_inset

 method returns the first element satisfying a predicate:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).find(_ > 5)
\end_layout

\begin_layout Plain Layout

res0: Option[Int] = Some(6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (1 to 10).find(_ > 10) // No element is > 10.
\end_layout

\begin_layout Plain Layout

res1: Option[Int] = None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.lift
\end_layout

\end_inset

 method returns the element of a sequence at a given index:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (10 to 100).lift(0)
\end_layout

\begin_layout Plain Layout

res2: Option[Int] = Some(10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (10 to 100).lift(1000) // No element at index 1000.
\end_layout

\begin_layout Plain Layout

res3: Option[Int] = None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.headOption
\end_layout

\end_inset

 method returns the first element of a sequence, unless the sequence is
 empty.
 This is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.lift(0)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1,2,3).headOption
\end_layout

\begin_layout Plain Layout

res4: Option[Int] = Some(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(1,2,3).filter(_ > 10).headOption
\end_layout

\begin_layout Plain Layout

res5: Option[Int] = None
\end_layout

\end_inset

Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.find(p)
\end_layout

\end_inset

 computes the same result as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter(p).headOption
\end_layout

\end_inset

, but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.find(p)
\end_layout

\end_inset

 may be more efficient.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.get
\end_layout

\end_inset

 method for a dictionary returns the value if it exists for a given key,
 and returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 if the key is not in the dictionary:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b").get(10)
\end_layout

\begin_layout Plain Layout

res6: Option[String] = Some(a)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b").get(30)
\end_layout

\begin_layout Plain Layout

res7: Option[String] = None 
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.get
\end_layout

\end_inset

 method provides safe by-key access to dictionaries, unlike the direct access
 method that may fail:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b")(10)
\end_layout

\begin_layout Plain Layout

res8: String = a 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b")(30)
\end_layout

\begin_layout Plain Layout

java.util.NoSuchElementException: key not found: 30
\end_layout

\begin_layout Plain Layout

  at scala.collection.MapLike$class.default(MapLike.scala:228)
\end_layout

\begin_layout Plain Layout

  at scala.collection.AbstractMap.default(Map.scala:59)
\end_layout

\begin_layout Plain Layout

  ...
 32 elided
\end_layout

\end_inset

Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.lift
\end_layout

\end_inset

 provides safe by-index access to collections, unlike the direct access
 that may fail:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(10,20,30)(0)
\end_layout

\begin_layout Plain Layout

res9: Int = 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(10,20,30)(5)
\end_layout

\begin_layout Plain Layout

java.lang.IndexOutOfBoundsException: 5
\end_layout

\begin_layout Plain Layout

  at scala.collection.LinearSeqOptimized$class.apply(LinearSeqOptimized.scala:65)
\end_layout

\begin_layout Plain Layout

  at scala.collection.immutable.List.apply(List.scala:84)
\end_layout

\begin_layout Plain Layout

  ...
 32 elided
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
Either
\end_layout

\begin_layout Standard
The standard disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 has two type parameters and is often used for computations that may report
 errors.
 By convention, the 
\emph on
first
\emph default
 type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

) is the type of error, and the 
\emph on
second
\emph default
 type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

) is the type of the (non-error) result.
 The names of the two cases are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

.
 A possible definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 may be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Either[A, B]
\end_layout

\begin_layout Plain Layout

final case class  Left[A, B](value: A) extends Either[A, B]
\end_layout

\begin_layout Plain Layout

final case class Right[A, B](value: B) extends Either[A, B]
\end_layout

\end_inset

By convention, a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 is used to represent an error, and a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 is used to represent a valid result.
\end_layout

\begin_layout Standard
As an example, the following function substitutes a default value and logs
 the error information:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def logError(x: Either[String, Int], default: Int): Int = x match {
\end_layout

\begin_layout Plain Layout

  case Left(error) => println(s"Got error: $error"); default
\end_layout

\begin_layout Plain Layout

  case Right(res) => res
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> logError(Right(123), -1)
\end_layout

\begin_layout Plain Layout

res1: Int = 123
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> logError(Left("bad result"), -1)
\end_layout

\begin_layout Plain Layout

Got error: bad result
\end_layout

\begin_layout Plain Layout

res2: Int = -1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Why use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 for computations that may fail? A failing computation such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1/0
\end_layout

\end_inset

 could return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 to indicate that the result is not available.
 However, the result is not an optional value that may be missing; usually
 the result is required, and if it is not available, we need to know exactly
 
\emph on
which
\emph default
 error occurred.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type provides the possibility to store information about the error, which
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 does not provide.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type generalizes the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Motivation-and-first-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with an arbitrary error type instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 We have seen its usage in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where the design pattern was 
\begin_inset Quotes eld
\end_inset

if value is present, do a computation, otherwise keep the error
\begin_inset Quotes erd
\end_inset

.
 This design pattern is implemented by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Right(1).map(_ + 1)
\end_layout

\begin_layout Plain Layout

res0: Either[Nothing, Int] = Right(2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Left[String, Int]("error").map(_ + 1)
\end_layout

\begin_layout Plain Layout

res1: Either[String, Int] = Left(
\begin_inset Quotes eld
\end_inset

error
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 was filled in by the Scala compiler because we did not specify the full
 type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 in the first line.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.fold
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.getOrElse
\end_layout

\end_inset

 are also defined for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 class, with the same convention that a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 value represents an error.
\begin_inset Foot
status open

\begin_layout Plain Layout
These methods are available in Scala 2.12 or a later version.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Exceptions and 
\family typewriter
Try
\end_layout

\begin_layout Standard
When computations fail for any reason, Scala generates an 
\series bold
exception
\begin_inset Index idx
status open

\begin_layout Plain Layout
exception
\end_layout

\end_inset


\series default
 instead of returning a value.
 An exception means that the evaluation of the expression was stopped without
 returning a result.
\end_layout

\begin_layout Standard
An exception is generated when the available memory is too small to store
 the resulting data (as we saw in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Lazy-values-iterators-and-streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

), or if a stack overflow occurs during the computation (as we saw in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Tail-recursion"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Exceptions may also occur due to programmer's error: when a pattern matching
 operation fails, when a requested key does not exist in a dictionary, or
 when the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.head
\end_layout

\end_inset

 operation is applied to an empty list.
\end_layout

\begin_layout Standard
Motivatd by these examples, one could distinguish 
\begin_inset Quotes eld
\end_inset

planned
\begin_inset Index idx
status open

\begin_layout Plain Layout
planned exception
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

unplanned
\begin_inset Index idx
status open

\begin_layout Plain Layout
unplanned exception
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 exceptions.
 
\end_layout

\begin_layout Standard
A 
\series bold
planned
\series default
 exception is generated by programmer's code via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> throw new Exception("this is a test...
 this is only a test")
\end_layout

\begin_layout Plain Layout

java.lang.Exception: this is a test...
 this is only a test
\end_layout

\begin_layout Plain Layout

  ...
 42 elided
\end_layout

\end_inset

The Scala library contains a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 operation in various places, such as in the code for applying the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.head
\end_layout

\end_inset

 method to an empty sequence, as well as in other situations where exceptions
 are generated due to programmer's errors.
 These exceptions are generated deliberately and in well-defined situations.
 Although these exceptions indicate errors, these errors are defined in
 advance and may be handled by the programmer.
\end_layout

\begin_layout Standard
For example, many Java libraries will generate exceptions when function
 arguments have unexpected values, when a network operation takes too long
 or fails to make a network connection, when a file is not found or cannot
 be read, and in many other situations.
 All these exceptoins are 
\begin_inset Quotes eld
\end_inset

planned
\begin_inset Quotes erd
\end_inset

 because they are generated explicitly by library code such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw new FileNotFoundException(...)
\end_layout

\end_inset

.
 The programmer's code is expected to catch these exceptions, to handle
 the problem, and to continue the evaluation of the program.
\end_layout

\begin_layout Standard
An 
\series bold
unplanned
\series default
 exception is generated by the Java runtime system when critical errors
 occur, such as an out-of-memory error.
 It is rare that a programmer writes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val y = f(x)
\end_layout

\end_inset

 while 
\emph on
expecting
\emph default
 that an out-of-memory exception will sometimes occur at that point.
 An unplanned exception indicates a serious and unforeseen problem with
 memory or another critically important resource, such as the operating
 system's threads or file handles.
 Such problems usually cannot be fixed and prevent the program from running
 any further.
 It is reasonable that the program evaluation should immediately stop (or
 
\begin_inset Quotes eld
\end_inset

crash
\begin_inset Quotes erd
\end_inset

 as programmers say) after such an error.
\end_layout

\begin_layout Standard
The use of planned exceptions assumes that the programmer will write code
 to handle each exception.
 This assumption makes it significantly harder to write programs correctly.
 It is hard to figure out and to keep in mind all the possible exceptions
 that a given library function may 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 in its code (or in the code of all other libraries on which it depends).
 Instead of using exceptions for indicating errors, Scala programmers can
 write functions that return a disjunctive type such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, describing both the correct result and a possible error condition.
 Users of these functions will need to do pattern matching on the results,
 which indicates unambiguously both the possible presence of errors and
 the kinds of errors that need to be handled.
\end_layout

\begin_layout Standard
However, the programmer will often need to use Java libraries (or Scala
 libraries) that use planned exceptions.
 To help write code for these situations, the Scala library contains a helper
 function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try()
\end_layout

\end_inset

 and a disjunctive type also called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

.
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try[A]
\end_layout

\end_inset

 can be seen as similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Throwable, A]
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Throwable
\end_layout

\end_inset

 is the general type of all exceptions (i.e.
\begin_inset space ~
\end_inset

values to which a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 operation can be applied).
 The two parts of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try[A]
\end_layout

\end_inset

 are called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Failure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Success[A]
\end_layout

\end_inset

 (instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[Throwable]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right[A]
\end_layout

\end_inset

 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type).
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try(expr)
\end_layout

\end_inset

 will catch all exceptions thrown while the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 is evaluated.
 If the evaluation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 succeeds and returns a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

, the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try(expr)
\end_layout

\end_inset

 will be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Success(x)
\end_layout

\end_inset

.
 Otherwise it will be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Failure(t)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t:Throwable
\end_layout

\end_inset

 is the value associated with the generated exception.
 Here is an example of using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import scala.util.{Try,Success,Failure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Try(1 / 0)
\end_layout

\begin_layout Plain Layout

res0: Try[Int] = Failure(java.lang.ArithmeticException: / by zero)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Try(1 + 1)
\end_layout

\begin_layout Plain Layout

res1: Try[Int] = Success(2) 
\end_layout

\end_inset

Unlike computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1/0
\end_layout

\end_inset

 without an enclosing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try()
\end_layout

\end_inset

, the computation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try(1/0)
\end_layout

\end_inset

 does not generate any exceptions and will not crash the program.
 Any computation that may throw an exception can be enclosed in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try()
\end_layout

\end_inset

, and the exception will be caught and contained within the disjunctive
 type.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 are defined for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 class similarly to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type.
\end_layout

\begin_layout Standard
Another useful method is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toOption
\end_layout

\end_inset

; it will discard the error information.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Try(1 / 0).toOption
\end_layout

\begin_layout Plain Layout

res2: Option[Int] = None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Try(1 + 1).toOption
\end_layout

\begin_layout Plain Layout

res3: Option[Int] = Some(2)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Lists and trees: recursive disjunctive types
\end_layout

\begin_layout Standard
Consider this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait NInt
\end_layout

\begin_layout Plain Layout

final case class One(x: Int) extends NInt
\end_layout

\begin_layout Plain Layout

final case class Two(n: NInt) extends NInt
\end_layout

\end_inset

We are defining a new disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NInt
\end_layout

\end_inset

, but the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Two
\end_layout

\end_inset

 uses the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NInt
\end_layout

\end_inset

 as if it were already defined.
 Scala allows us to write such definitions.
\end_layout

\begin_layout Standard
A type whose definition uses that same type is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
recursive type
\end_layout

\end_inset


\series bold
recursive type
\series default
.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NInt
\end_layout

\end_inset

 is a recursive disjunctive type.
\end_layout

\begin_layout Standard
We might imagine a disjunctive type with many case classes whose parts are
 recursively using the same type in complicated ways.
 What would this data type be useful for, and what kind of data does it
 represent? In general, this question is not easy to answer.
 For instance, the simple definition
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Bad(x: Bad)
\end_layout

\end_inset

is useless: to create a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bad
\end_layout

\end_inset

 we already need to have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bad
\end_layout

\end_inset

.
 This is an example of an infinite type recursion
\begin_inset Index idx
status open

\begin_layout Plain Layout
infinite type recursion
\end_layout

\end_inset

.
 We will never be able to create any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bad
\end_layout

\end_inset

, which means that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bad
\end_layout

\end_inset

 is effectively 
\series bold
void
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset


\series default
 (has no values, like the the special type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Recursive-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

 studies recursive types in more detail.
 For now, we will look at the main examples of recursive disjunctive types
 that are 
\emph on
known
\emph default
 to be useful.
 These examples are lists and trees.
\end_layout

\begin_layout Subsection
Lists
\end_layout

\begin_layout Standard
A list of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is either empty, or one value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, or two values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, etc.
 We can visualize the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 as a disjunctive type defined by
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait List[A]
\end_layout

\begin_layout Plain Layout

final case class List0[A]() extends List[A]
\end_layout

\begin_layout Plain Layout

final case class List1[A](x: A) extends List[A]
\end_layout

\begin_layout Plain Layout

final case class List2[A](x1: A, x2: A) extends List[A]
\end_layout

\begin_layout Plain Layout

??? // Need an infinitely long definition.
\end_layout

\end_inset

However, this definition is not practical – we cannot define a separate
 case class for a list of 
\emph on
each
\emph default
 possible length.
 Instead, we define the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 via mathematical induction in the length of the list:
\end_layout

\begin_layout Itemize
Base case: empty list, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class List0[A]()
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Inductive step: given a list of a previously defined length, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\begin_inset Formula $_{n-1}$
\end_inset

, define a new case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\begin_inset Formula $_{n}$
\end_inset

 describing a list with one more element of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So we could define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\begin_inset Formula $_{n}=\,$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(List
\end_layout

\end_inset


\begin_inset Formula $_{n-1}$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

, A)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Let us try to write this inductive definition as code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait ListI[A] // Inductive definition of a list.
\end_layout

\begin_layout Plain Layout

final case class List0[A]() extends ListI[A]
\end_layout

\begin_layout Plain Layout

final case class List1[A](prev: List0[A], x: A) extends ListI[A]
\end_layout

\begin_layout Plain Layout

final case class List2[A](prev: List1[A], x: A) extends ListI[A]
\end_layout

\begin_layout Plain Layout

??? // Still need an infinitely long definition.
\end_layout

\end_inset

To avoid writing an infinitely long type definition, we need to use a trick.
 Notice that all definitions of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List2
\end_layout

\end_inset

, etc., have a similar form (while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List0
\end_layout

\end_inset

 is not similar).
 We can replace all the definitions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List2
\end_layout

\end_inset

, etc., by a single recursive definition if we use the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

 itself inside the case class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait ListI[A] // Inductive definition of a list.
\end_layout

\begin_layout Plain Layout

final case class List0[A]() extends ListI[A]
\end_layout

\begin_layout Plain Layout

final case class ListN[A](prev: ListI[A], x: A) extends ListI[A]
\end_layout

\end_inset

The type definition has become recursive.
 For this trick to work, it is important that we use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

 and not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN[A]
\end_layout

\end_inset

 inside the definition 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN[A]
\end_layout

\end_inset

; if we did, we would have created an infinite type recursion
\begin_inset Index idx
status open

\begin_layout Plain Layout
infinite type recursion
\end_layout

\end_inset

 similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Bad
\end_layout

\end_inset

 shown above.
\end_layout

\begin_layout Standard
Since we obtained the type definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI
\end_layout

\end_inset

 via a trick, let us verify that the code actually defines the disjunctive
 type we wanted.
 
\end_layout

\begin_layout Standard
To create a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

, we must use one of the two available case classes.
 Using the first case class, we may create a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List0()
\end_layout

\end_inset

.
 Since this empty case class does not contain any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, it effectively represents an empty list (the base case of the induction).
 Using the second case class, we may create a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN(prev, x)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prev
\end_layout

\end_inset

 is some previously constructed value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

.
 This represents the induction step, because the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN
\end_layout

\end_inset

 is a named tuple containing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Now, the same consideration recursively applies to constructing the value
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prev
\end_layout

\end_inset

, which must be either an empty list or a pair containing another list and
 an element of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 The assumption that the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prev:ListI[A]
\end_layout

\end_inset

 is already constructed is equivalent to the inductive assumption that we
 already have a list of a previously defined length.
 So, we have verified that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

 implements the inductive definition shown above.
\end_layout

\begin_layout Standard
Examples of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI
\end_layout

\end_inset

 are the empty list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List0()
\end_layout

\end_inset

, a one-element list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN(List0(), x)
\end_layout

\end_inset

, and a two-element list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN(ListN(List0(), x), y)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To illustrate writing pattern-matching code using this type, let us implement
 the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def headOption[A]: ListI[A] => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case List0()               => None
\end_layout

\begin_layout Plain Layout

  case ListN(List0(), x)     => Some(x)
\end_layout

\begin_layout Plain Layout

  case ListN(prev, _)        => headOption(prev)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Scala library already defines the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

, but its case classes are named differently, and the second case class
 uses the name 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

::
\end_layout

\end_inset

 with an infix syntax and places 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 
\emph on
before
\emph default
 the previously constructed list,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait List[A]
\end_layout

\begin_layout Plain Layout

final case object Nil extends List[Nothing]
\end_layout

\begin_layout Plain Layout

final case class ::[A](head: A, tail: List[A]) extends List[A]
\end_layout

\end_inset

Because 
\begin_inset Quotes eld
\end_inset

operator-like
\begin_inset Quotes erd
\end_inset

 case class names, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

::
\end_layout

\end_inset

, support the infix syntax, we may write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head :: tail
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

::(head, tail)
\end_layout

\end_inset

.
 Pattern matching with the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 class looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def headOption[A]: List[A] => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case Nil            => None
\end_layout

\begin_layout Plain Layout

  case head :: tail   => Some(head)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Examples of values created using Scala's standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type are the empty list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

, a one-element list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x :: Nil
\end_layout

\end_inset

, and a two-element list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x :: y :: Nil
\end_layout

\end_inset

.
 We see that list values are easier to read in the standard syntax.
 The same syntax such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x :: y :: Nil
\end_layout

\end_inset

 is used both for creating values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 and for pattern-matching on such values.
 
\end_layout

\begin_layout Standard
The Scala library also defines the helper function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List()
\end_layout

\end_inset

, so that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List()
\end_layout

\end_inset

 is the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1, 2, 3)
\end_layout

\end_inset

 is the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 :: 2 :: 3 :: Nil
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Tail recursion with 
\family typewriter
List
\end_layout

\begin_layout Standard
Because the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type is defined by induction, it is straightforward to implement iterative
 computations with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type using recursion.
\end_layout

\begin_layout Standard
A first example is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function.
 We use reasoning by induction in order to figure out the implementation
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 The required type signature is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: List[A])(f: A => B): List[B] = ???
\end_layout

\end_inset

The base case is an empty list, and we return again an empty list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: List[A])(f: A => B): List[B] = xs match {
\end_layout

\begin_layout Plain Layout

  case Nil => Nil
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\end_inset

In the induction step, we have a pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(head, tail)
\end_layout

\end_inset

 in the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

::
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail:List[A]
\end_layout

\end_inset

.
 The pair can be pattern-matched with the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head :: tail
\end_layout

\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function should apply the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to the head value, which will give the first element of the resulting list.
 The remaining elements are computed by the induction assumption, i.e.
\begin_inset space ~
\end_inset

by a recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: List[A])(f: A => B): List[B] = xs match {
\end_layout

\begin_layout Plain Layout

  case Nil           => Nil
\end_layout

\begin_layout Plain Layout

  case head :: tail  => f(head) :: map(tail)(f) // Not tail-recursive.
\end_layout

\end_inset

While this implementation is straightforward and concise, it is not tail-recursi
ve.
 This will be a problem for large enough lists.
\end_layout

\begin_layout Standard
Instead of implementing the often-used methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 one by one, let us implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 because most of the other methods can be expressed via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The required type signature is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R = ???
\end_layout

\end_inset

Reasoning by induction, we start with the base case, where we have an empty
 list, and the only possibility is to return the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R = xs match {
\end_layout

\begin_layout Plain Layout

    case Nil            => init
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\end_inset

The induction step for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 says that, given the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail:List[A]
\end_layout

\end_inset

, we need to apply the updater function to the previous accumulator value.
 That value is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

.
 So we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 recursively to the tail of the list once we have the updated accumulator
 value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R =
\end_layout

\begin_layout Plain Layout

  xs match {
\end_layout

\begin_layout Plain Layout

    case Nil            => init
\end_layout

\begin_layout Plain Layout

    case head :: tail   => 
\end_layout

\begin_layout Plain Layout

      val newInit = f(init, head) // Update the accumulator.
\end_layout

\begin_layout Plain Layout

      foldLeft(tail)(newInit)(f) // Recursive call to foldLeft.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

This implementation is tail-recursive because the recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is the last expression returned in its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 branch.
\end_layout

\begin_layout Standard
Another instructive example is a function for reversing a list.
 The Scala library defines the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.reverse
\end_layout

\end_inset

 method for this task, but we will show an implementation using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
 The updater function 
\emph on
prepends
\emph default
 an element to a previous list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reverse[A](xs: List[A]): List[A] =
\end_layout

\begin_layout Plain Layout

  xs.foldLeft(Nil: List[A])((prev, x) => x :: prev)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> reverse(List(1, 2, 3))
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(3, 2, 1) 
\end_layout

\end_inset

Without the explicit type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil:List[A]
\end_layout

\end_inset

, the Scala compiler will decide that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Nothing]
\end_layout

\end_inset

, and the types will not match later in the code.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

 function can be used, in principle, to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 in a tail-recursive way.
 The idea is to first use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to accumulate transformed elements:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1, 2, 3).foldLeft(Nil:List[Int])((prev, x) => x*x :: prev)
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(9, 4, 1)
\end_layout

\end_inset

The result is a reversed 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map(x => x*x)
\end_layout

\end_inset

, so we reverse that:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: List[A])(f: A => B): List[B] =
\end_layout

\begin_layout Plain Layout

  xs.foldLeft(Nil: List[B])((prev, x) => f(x) :: prev).reverse
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> map(List(1, 2, 3))(x => x*x)
\end_layout

\begin_layout Plain Layout

res2: List[Int] = List(1, 4, 9)
\end_layout

\end_inset

This achieves stack safety at the cost of traversing the list twice.
 (This implementation is shown only as an example.
 The Scala library uses a low-level implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 for List, in order to achieve better performance.)
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Example-non-empty-list-foldLeft"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-non-empty-list-foldLeft"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A definition of the 
\series bold
non-empty list
\begin_inset Index idx
status open

\begin_layout Plain Layout
non-empty list
\end_layout

\end_inset


\series default
 is similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 except that the empty-list case is replaced by the 
\begin_inset Formula $1$
\end_inset

-element case:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait NEL[A]
\end_layout

\begin_layout Plain Layout

final case class Last[A](head: A) extends NEL[A]
\end_layout

\begin_layout Plain Layout

final case class More[A](head: A, tail: NEL[A]) extends NEL[A]
\end_layout

\end_inset

To make creating non-empty lists more convenient, we implement a conversion
 function from an ordinary list.
 Since the conversion function must guarantee that the result is a non-empty
 list, we give it two arguments:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toNEL[A](x: A, rest: List[A]): NEL[A] = rest match {
\end_layout

\begin_layout Plain Layout

  case Nil        => Last(x)
\end_layout

\begin_layout Plain Layout

  case y :: tail  => More(x, toNEL(y, tail))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This function is not tail-recursive.
 To test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> toNEL(1, List())
\end_layout

\begin_layout Plain Layout

res0: NEL[Int] = Last(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toNEL(1, List(2, 3))
\end_layout

\begin_layout Plain Layout

res1: NEL[Int] = More(1,More(2,Last(3)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head
\end_layout

\end_inset

 method is safe for non-empty lists:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def head[A]: NEL[A] => A = {
\end_layout

\begin_layout Plain Layout

  case Last(x)        => x
\end_layout

\begin_layout Plain Layout

  case More(x, _)     => x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can also implement a tail-recursive 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 function for non-empty lists:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def foldLeft[A, R](nel: NEL[A])(init: R)(f: (R, A) => R): R =
\end_layout

\begin_layout Plain Layout

  nel match {
\end_layout

\begin_layout Plain Layout

    case Last(x)        => f(init, x)
\end_layout

\begin_layout Plain Layout

    case More(x, tail)  => foldLeft(tail)(f(init, x))(f)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

To test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> foldLeft(More(1, More(2, Last(3))))(0)(_ + _)
\end_layout

\begin_layout Plain Layout

res2: Int = 6
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Example-non-empty-list"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-non-empty-list"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

 function for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reverse[A]: NEL[A] => NEL[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> reverse(toNEL(List(1, 2, 3)))
\end_layout

\begin_layout Plain Layout

res3: NEL[Int] = More(3, More(2, Last(1)))
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We will use recursion with the accumulator trick.
 The accumulator will be equal to a reversed initial portion of the list,
 and it is convenient to choose the accumulator type as an ordinary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
 The initial value of the accumulator can then be an empty list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def reverse[A](nel: NEL[A], acc: List[A] = Nil): NEL[A] =
\end_layout

\begin_layout Plain Layout

  nel match {
\end_layout

\begin_layout Plain Layout

    case Last(x)         => toNEL(x, acc)
\end_layout

\begin_layout Plain Layout

    case More(x, tail)   => reverse(tail, x :: acc)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> reverse(toNEL(1, List(2, 3)))
\end_layout

\begin_layout Plain Layout

res3: NEL[Int] = More(3, More(2, Last(1)))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Example-non-empty-list-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-non-empty-list-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 that converts a non-empty list of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

 into an ordinary Scala 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toList[A](nel: NEL[A]): List[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toList(More(1, More(2, Last(3))))
\end_layout

\begin_layout Plain Layout

res4: List[Int] = List(1, 2, 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Trees
\end_layout

\begin_layout Standard
We will consider four kinds of trees defined as recursive disjunctive types:
 binary trees, rose trees, homogeneous trees, and abstract syntax trees.
\end_layout

\begin_layout Standard
Examples of a 
\series bold
binary tree
\begin_inset Index idx
status open

\begin_layout Plain Layout
binary tree
\end_layout

\end_inset


\series default
 with leaves of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 can be visualized as 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[  [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 or 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

, where 
\begin_inset Formula $a_{i}$
\end_inset

 are some values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 An inductive definition says that a binary tree is either a leaf with a
 value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 or a branch containing two previously defined binary trees.
 Translating this definition into code, we get
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Tree2[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](a: A) extends Tree2[A]
\end_layout

\begin_layout Plain Layout

final case class Branch[A](x: Tree2[A], y: Tree2[A]) extends Tree2[A]
\end_layout

\end_inset

The tree 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[  [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 is created by the code 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Branch(Leaf("a1"), Branch(Leaf("a2"), Leaf("a3")))
\end_layout

\end_inset

while the tree 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 is created by the code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Branch(Branch(Leaf(
\begin_inset Quotes eld
\end_inset

a1
\begin_inset Quotes erd
\end_inset

),Branch(Leaf(
\begin_inset Quotes eld
\end_inset

a2
\begin_inset Quotes erd
\end_inset

), Leaf(
\begin_inset Quotes eld
\end_inset

a3
\begin_inset Quotes erd
\end_inset

))), Branch(Leaf(
\begin_inset Quotes eld
\end_inset

a4
\begin_inset Quotes erd
\end_inset

), Leaf(
\begin_inset Quotes eld
\end_inset

a5
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Recursive functions on trees are translated into concise code.
 For instance, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 on the tree structure is defined by
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldLeft[A, R](t: Tree2[A])(init: R)(f: (R, A) => R) = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)          => f(init, a)
\end_layout

\begin_layout Plain Layout

  case Branch(t1, t2)   =>
\end_layout

\begin_layout Plain Layout

    val r1 = foldLeft(t1)(init)(f) // Begin with the left branch.
\end_layout

\begin_layout Plain Layout

    foldLeft(t2)(r1)(f) // Continue with the right branch.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Note that this function cannot be made tail-recursive using the accumulator
 trick, because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 needs to call itself twice in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset

 case.
\end_layout

\begin_layout Subsection
Rose trees
\end_layout

\begin_layout Standard
A rose tree
\begin_inset Index idx
status open

\begin_layout Plain Layout
rose tree
\end_layout

\end_inset

 is similar to the binary tree except the branches contain a non-empty list
 of other trees.
 So the tree can fork into arbitrarily many branches at each node, rather
 than always into two branches as the binary tree does.
 Example shapes for a rose tree are 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ $a_2$ ] [ $a_3$ ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ $a_1$ ] [ $a_2$ ] [ $a_3$ ] [ $a_4$ ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A possible definition of the rose tree data type is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait TreeN[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](a: A) extends TreeN[A]
\end_layout

\begin_layout Plain Layout

final case class Branch[A](ts: NEL[TreeN[A]]) extends TreeN[A]
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Exercise-foldLeft-rose-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-foldLeft-rose-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 for a rose tree, using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

.
 Type signature and a test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldLeft[A, R](t: TreeN[A])(init: R)(f: (R, A) => R): R = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> foldLeft(Branch(More(Leaf(1), More(Leaf(2), Last(Leaf(3))))))(0)(_
 + _)
\end_layout

\begin_layout Plain Layout

res0: Int = 6
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Regular-shaped trees
\end_layout

\begin_layout Standard
Binary trees and rose trees may choose to branch or not to branch at any
 given node, resulting in structures that may have a different branching
 depth at different places, such as 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

.
 A 
\series bold
regular-shaped tree
\begin_inset Index idx
status open

\begin_layout Plain Layout
regular-shaped tree
\end_layout

\end_inset


\series default
 always branches in the same way at every place until a given depth, for
 example 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

, where the nodes at depth 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

 always branch into two, while nodes at depth 
\begin_inset Formula $2$
\end_inset

 never branch.
 The branching number is always fixed for a given type of a regular-shaped
 tree; in this example, the branching number is 
\begin_inset Formula $2$
\end_inset

.
\end_layout

\begin_layout Standard
How can we define a data type representing a regular-shaped tree? We need
 a tree that is either a single value, or a pair of values, or a pair of
 pairs, etc.
 Begin with the non-recursive (but, of course, impractical) definition
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RTree[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](x: A) extends RTree[A]
\end_layout

\begin_layout Plain Layout

final case class Branch1[A](xs: (A, A)) extends RTree[A]
\end_layout

\begin_layout Plain Layout

final case class Branch2[A](xs: ((A, A),(A, A))) extends RTree[A]
\end_layout

\begin_layout Plain Layout

??? // Need an infinitely long definition.
\end_layout

\end_inset

The case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch1
\end_layout

\end_inset

 describes a regular-shaped tree that branches until depth 
\begin_inset Formula $1$
\end_inset

, the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch2
\end_layout

\end_inset

 branches until depth 
\begin_inset Formula $2$
\end_inset

, and so on.
 Now, we cannot rewrite this definition as a recursive type because the
 case classes do not have the same structure.
 The non-trivial trick is to notice that each 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset


\begin_inset Formula $_{n}$
\end_inset

case class uses the previous case class's data structure 
\emph on
in the type parameter
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So we can rewrite this definition as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RTree[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](x: A) extends RTree[A]
\end_layout

\begin_layout Plain Layout

final case class Branch1[A](xs: Leaf[(A, A)]) extends RTree[A]
\end_layout

\begin_layout Plain Layout

final case class Branch2[A](xs: Branch1[(A, A)]) extends RTree[A]
\end_layout

\begin_layout Plain Layout

??? // Need an infinitely long definition.
\end_layout

\end_inset

Now we can use the type recursion trick: replace the previous 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset


\begin_inset Formula $_{n-1}$
\end_inset

 type in the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset


\begin_inset Formula $_{n}$
\end_inset

 by the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTree[...]
\end_layout

\end_inset

 .
 Now we finally obtain the type definition for a regular-shaped binary tree:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RTree[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](x: A) extends RTree[A]
\end_layout

\begin_layout Plain Layout

final case class Branch[A](xs: RTree[(A, A)]) extends RTree[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since we used some tricks to figure out the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTree[A]
\end_layout

\end_inset

, let us verify that this definition actually describes the recursive disjunctiv
e type we wanted.
 The only way to create a structure of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTree[A]
\end_layout

\end_inset

 is either to have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf[A]
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch[A]
\end_layout

\end_inset

.
 A value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf[A]
\end_layout

\end_inset

 is a correct regularly-shaped tree; it remains to consider the case of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch[A]
\end_layout

\end_inset

.
 To create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch[A]
\end_layout

\end_inset

 requires a previously created 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTree
\end_layout

\end_inset

 with values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 By the inductive assumption, the previuosly created 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTree[A]
\end_layout

\end_inset

 would have the correct shape.
 Now, it is clear that if we replace the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 by the pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A)
\end_layout

\end_inset

, a regular-shaped tree such as 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 remains regular-shaped and becomes one level deeper, 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ [ $a_1^{'}$ ] [ $a_1^{''}$ ] ] [ [ $a_2^{'}$ ] [ $a_2^{''}$ ]
 ] ] [ [ [ $a_3^{'}$ ] [ $a_3^{''}$ ] ] [ [ $a_4^{'}$ ] [ $a_4^{''}$ ] ]
  ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

.
 We see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTree[A]
\end_layout

\end_inset

 is indeed the correct definition of a regular-shaped binary tree.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Example-map-regular-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-map-regular-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a (non-tail-recursive) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for a regular-shaped binary tree.
 The required type signature and a test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](t: RTree[A])(f: A => B): RTree[B] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> map(Branch(Branch(Leaf(((1,2),(3,4))))))(_ * 10)
\end_layout

\begin_layout Plain Layout

res0: RTree[Int] = Branch(Branch(Leaf(((10,20),(30,40)))))
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by pattern-matching on the tree:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)      => ???
\end_layout

\begin_layout Plain Layout

  case Branch(xs)   => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The base case is clear: we need to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf(f(x))
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)      => Leaf(f(x))
\end_layout

\begin_layout Plain Layout

  case Branch(xs)   => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the inductive step, we are given a previous tree value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs:RTree[(A, A)]
\end_layout

\end_inset

.
 It is clear that we need to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 recursively to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)      => Leaf(f(x))
\end_layout

\begin_layout Plain Layout

  case Branch(xs)   => Branch(map(xs)(f)) // Type error!
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

However, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map(xs)(f)
\end_layout

\end_inset

 does not compile because the type of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is incorrect.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTree[(A, A)]
\end_layout

\end_inset

, the recursive call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map(xs)(f)
\end_layout

\end_inset

 requires 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: ((A, A)) => (B, B)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

.
 So we just need to substitute a function of the correct type instead of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 A function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, A)) => (B, B)
\end_layout

\end_inset

 will be obtained out of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 if we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to each part of the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A)
\end_layout

\end_inset

.
 The resulting code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)      => Leaf(f(x))
\end_layout

\begin_layout Plain Layout

  case Branch(xs)   => Branch(map(xs){ case (a1, a2) => (f(a1), f(a2)) })
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Exercise-foldLeft-regular-tree-depth"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-foldLeft-regular-tree-depth"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using tail recursion, compute the depth of a regular-shaped binary tree
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTree
\end_layout

\end_inset

.
 (An 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTree
\end_layout

\end_inset

 of depth 
\begin_inset Formula $n$
\end_inset

 has 
\begin_inset Formula $2^{n}$
\end_inset

 leaf values.) The required type signature and a test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def depth[A](t: RTree[A]): Int = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> depth(Branch(Branch(Leaf((("a","b"),("c","d"))))))
\end_layout

\begin_layout Plain Layout

res2: Int = 2
\end_layout

\end_inset


\begin_inset Note Comment
status open

\begin_layout Plain Layout
Solution:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def depth[A](t: RTree[A], acc: Int = 0): Int = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)    => acc
\end_layout

\begin_layout Plain Layout

  case Branch(xs) => depth(xs, 1 + acc)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Exercise-foldLeft-regular-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-foldLeft-regular-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Define a tail-recursive function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 for a regular-shaped binary tree.
 The required type signature and a test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldLeft[A, R](t: RTree[A])(init: R)(f: (R, A) => R): R = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> foldLeft(Branch(Branch(Leaf(((1,2),(3,4))))))(0)(_ + _)
\end_layout

\begin_layout Plain Layout

res0: Int = 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> foldLeft(Branch(Branch(Leaf((("a","b"),("c","d"))))))("")(_ + _)
\end_layout

\begin_layout Plain Layout

res1: String = abcd
\end_layout

\end_inset


\begin_inset Note Comment
status open

\begin_layout Plain Layout
Solution:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def foldLeft[A, R](t: RTree[A])(init: R)(f: (R, A) => R): R = t
 match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)    => f(init, x)
\end_layout

\begin_layout Plain Layout

  case Branch(xs) => foldLeft(xs)(init) { case (r, (a, b)) => f(f(r, a),
 b) } 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Abstract syntax trees
\end_layout

\begin_layout Standard
Expressions in formal languages are represented by abstract syntax trees.
 An 
\series bold
abstract syntax tree
\begin_inset Index idx
status open

\begin_layout Plain Layout
abstract syntax tree
\end_layout

\end_inset

 
\series default
(or 
\series bold
AST
\series default
 for short) is defined as either a leaf of one of the available leaf types,
 or a branch of one of the available branch types.
 All the available leaf and branch types must be specified as part of the
 definition of an AST.
 In other words, one must specify the data carried by leaves and branches,
 as well as the branching numbers.
\end_layout

\begin_layout Standard
To illustrate how ASTs are used, we rewrite Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset

 via an AST.
 We view Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a small programming sub-language that deals with 
\begin_inset Quotes eld
\end_inset

safe integers
\begin_inset Quotes erd
\end_inset

 and supports the 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

 operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sqrt
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Add
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Mul
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Div
\end_layout

\end_inset

.
 Example calculations in this sub-language are 
\begin_inset Formula $\sqrt{16}*(1+2)=12$
\end_inset

; 
\begin_inset Formula $20+1/0=\text{error}$
\end_inset

; 
\begin_inset Formula $10+\sqrt{-1}=\text{error}$
\end_inset

.
 
\end_layout

\begin_layout Standard
We can implement this sub-language in two stages.
 The first stage will create a data structure (an AST) that represents an
 unevaluated expression
\begin_inset Index idx
status open

\begin_layout Plain Layout
unevaluated expression
\end_layout

\end_inset

 in the sub-language.
 The second stage will evaluate that AST into a number or into an error
 message.
\end_layout

\begin_layout Standard
A straightforward way of defining a data structure for an AST is to use
 a disjunctive type whose cases describe all the possible operations of
 the sub-language.
 In our case, we will need one case for each of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sqrt
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Add
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Mul
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Div
\end_layout

\end_inset

, and an additional operation to create 
\begin_inset Quotes eld
\end_inset

safe integers
\begin_inset Quotes erd
\end_inset

 from ordinary integers.
 So we define the disjunctive type for 
\begin_inset Quotes eld
\end_inset

arithmetic sub-language expressions
\begin_inset Quotes erd
\end_inset

 as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Arith
\end_layout

\begin_layout Plain Layout

final case class Num(x: Int) extends Arith
\end_layout

\begin_layout Plain Layout

final case class Sqrt(x: Arith) extends Arith
\end_layout

\begin_layout Plain Layout

final case class Add(x: Arith, y: Arith) extends Arith
\end_layout

\begin_layout Plain Layout

final case class Mul(x: Arith, y: Arith) extends Arith
\end_layout

\begin_layout Plain Layout

final case class Div(x: Arith, y: Arith) extends Arith
\end_layout

\end_inset

It follows that a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Arith
\end_layout

\end_inset

 is either a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Num(x)
\end_layout

\end_inset

 for some integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, or an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Add(x, y)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 are previously defined 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Arith
\end_layout

\end_inset

 expressions, or another operation.
\end_layout

\begin_layout Standard
This type definition is similar to the binary tree type
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Tree
\end_layout

\begin_layout Plain Layout

final case class Leaf(x: Int) extends Tree
\end_layout

\begin_layout Plain Layout

final case class Branch(x: Tree, y: Tree) extends Tree
\end_layout

\end_inset

if we rename 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Num
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Add
\end_layout

\end_inset

.
 However, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Arith
\end_layout

\end_inset

 type contains 
\begin_inset Formula $4$
\end_inset

 different types of 
\begin_inset Quotes eld
\end_inset

branches
\begin_inset Quotes erd
\end_inset

, some with branching number 
\begin_inset Formula $1$
\end_inset

 and others with branching number 
\begin_inset Formula $2$
\end_inset

.
 
\end_layout

\begin_layout Standard
This example illustrates the structure of an AST: it is a tree of a general
 shape, where leaves and branches are chosen from a specified set of allowed
 possibilities.
 In this example, we have a single allowed type of leaf, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Num
\end_layout

\end_inset

, and 
\begin_inset Formula $4$
\end_inset

 allowed types of branches (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sqrt
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Add
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Mul
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Div
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
This completes the first stage of implementing the 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

 sub-language.
 Using the definition of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Arith
\end_layout

\end_inset

, we may now create expressions in the sub-language.
 For example, 
\begin_inset Formula $\sqrt{16}*(1+2)$
\end_inset

 is represented by
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x: Arith = Mul(Sqrt(Num(16)), Add(Num(1), Num(2)))
\end_layout

\begin_layout Plain Layout

x: Arith = Mul(Sqrt(Num(16)),Add(Num(1),Num(2))) 
\end_layout

\end_inset

We can picture 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as an abstract syntax tree
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[.
\backslash
texttt{Mul} [.
\backslash
texttt{Sqrt} [.
\backslash
texttt{Num} $16$ ] ] [.
\backslash
texttt{Add} [ [.
\backslash
texttt{Num} [ $1$ ] ] [.
\backslash
texttt{Num} [ $2$ ] ] ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The expressions 
\begin_inset Formula $20+1/0$
\end_inset

 and 
\begin_inset Formula $10*\sqrt{-1}$
\end_inset

 are represented by
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val y: Arith = Add(Num(20), Div(Num(1), Num(0)))
\end_layout

\begin_layout Plain Layout

y: Arith = Add(Num(20),Div(Num(1),Num(0)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val z: Arith = Add(Num(10), Sqrt(Num(-1)))
\end_layout

\begin_layout Plain Layout

z: Arith = Add(Num(10),Sqrt(Num(-1)))
\end_layout

\end_inset

As we see, the expressions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 
\emph on
remain
\emph default
 
\emph on
unevaluated
\emph default
; they are data structures that encode a tree of operations of the sub-language.
 These operations will be evaluated at the second stage of implementing
 the sub-language.
\end_layout

\begin_layout Standard
To evaluate the expressions in the 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

, we can write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

run: Arith => Either[String, Int]
\end_layout

\end_inset

.
 That function plays the role of an 
\series bold
interpreter
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
interpreter
\end_layout

\end_inset

 for the sub-language.
 The interpreter will decompose the expression tree and execute all the
 operations, taking care of possible errors.
 Instead of custom code written in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we can use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 operations defined for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type.
 For example, addition and multiplication of two 
\begin_inset Quotes eld
\end_inset

safe integers
\begin_inset Quotes erd
\end_inset

 is written as 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add(x: Either[String, Int], y: Either[String, Int]):
\end_layout

\begin_layout Plain Layout

    Either[String, Int] = x.flatMap { r1 => y.map(r2 => r1 + r2) }
\end_layout

\begin_layout Plain Layout

def mul(x: Either[String, Int], y: Either[String, Int]):
\end_layout

\begin_layout Plain Layout

    Either[String, Int] = x.flatMap { r1 => y.map(r2 => r1 * r2) }
\end_layout

\end_inset

while the 
\begin_inset Quotes eld
\end_inset

safe division
\begin_inset Quotes erd
\end_inset

 is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def div(x: Either[String, Int], y: Either[String, Int]):
\end_layout

\begin_layout Plain Layout

    Either[String, Int] = x.flatMap { r1 => y.flatMap(r2 =>
\end_layout

\begin_layout Plain Layout

  if (r2 == 0) Left(s
\begin_inset Quotes eld
\end_inset

error: $r1 / $r2
\begin_inset Quotes erd
\end_inset

) else Right(r1/r2) )
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

With this code, we can implement the interpreter as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def run: Arith => Either[String, Int] = {
\end_layout

\begin_layout Plain Layout

  case Num(x)     => Right(x)
\end_layout

\begin_layout Plain Layout

  case Sqrt(x)    => run(x).flatMap { r =>
\end_layout

\begin_layout Plain Layout

   if (r < 0) Left(s
\begin_inset Quotes eld
\end_inset

error: sqrt($r)
\begin_inset Quotes erd
\end_inset

) else
\end_layout

\begin_layout Plain Layout

       Right(math.sqrt(r).toInt)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  case Add(x, y)  => add(run(x), run(y))
\end_layout

\begin_layout Plain Layout

  case Mul(x, y)  => mul(run(x), run(y))
\end_layout

\begin_layout Plain Layout

  case Div(x, y)  => div(run(x), run(y))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Test with the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> run(x)
\end_layout

\begin_layout Plain Layout

res0: Either[String, Int] = Right(12)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> run(y)
\end_layout

\begin_layout Plain Layout

res1: Either[String, Int] = Left("error: 1 / 0")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> run(z)
\end_layout

\begin_layout Plain Layout

res2: Either[String, Int] = Left("error: sqrt(-1)")
\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
What problems can we solve now?
\end_layout

\begin_layout Itemize
Represent values from disjoint domains as a single disjunctive type.
\end_layout

\begin_layout Itemize
Use disjunctive types in collections safely.
\end_layout

\begin_layout Itemize
Use disjunctive types instead of exceptions to indicate failures.
\end_layout

\begin_layout Standard
The following examples and exercises illustrate the use of disjunctive types.
\end_layout

\begin_layout Subsection
Solved examples
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

DayOfWeek
\end_layout

\end_inset

 representing the seven days.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Since there is no information other than the label on each day, we use empty
 case classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Sunday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Monday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Tuesday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Wednesday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Thursday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Friday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Saturday() extends DayOfWeek
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Modify 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

DayOfWeek
\end_layout

\end_inset

 so that the values additionally represent a restaurant name and total amount
 for Fridays and a wake-up time on Saturdays.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
For the days where additional information is given, we use non-empty case
 classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Sunday() extends DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Monday() extends DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Tuesday() extends DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Wednesday() extends DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Thursday() extends DayOfWeekWithBanquets
\end_layout

\begin_layout Plain Layout

final case class Friday(restaurant: String, amount: Int) extends DayOfWeekWithBa
nquets
\end_layout

\begin_layout Plain Layout

final case class Saturday(wakeUpAt: java.time.LocalTime) extends DayOfWeekWithBanq
uets
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-rootsofq-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type that describes real roots of the equation 
\begin_inset Formula $ax^{2}+bx+c=0$
\end_inset

 where 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

 are arbitrary real numbers.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by solving the equation and enumerating all possible cases.
 It may happen that 
\begin_inset Formula $a=b=c=0$
\end_inset

, and then all 
\begin_inset Formula $x$
\end_inset

 are roots.
 If 
\begin_inset Formula $a=b=0$
\end_inset

 but 
\begin_inset Formula $c\neq0$
\end_inset

, the equation is 
\begin_inset Formula $c=0$
\end_inset

, which has no roots.
 If 
\begin_inset Formula $a=0$
\end_inset

 but 
\begin_inset Formula $b\neq0$
\end_inset

, the equation becomes 
\begin_inset Formula $bx+c=0$
\end_inset

, having a single root.
 If 
\begin_inset Formula $a\neq0$
\end_inset

 and 
\begin_inset Formula $b^{2}>4ac$
\end_inset

, we have two distinct real roots.
 If 
\begin_inset Formula $a\neq0$
\end_inset

 and 
\begin_inset Formula $b^{2}=4ac$
\end_inset

, we have one real root.
 If 
\begin_inset Formula $b^{2}<4ac$
\end_inset

, we have no real roots.
 The resulting type definition can be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class AllRoots() extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class ConstNoRoots() extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class Linear(x: Double) extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class NoRealRoots() extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class OneRootQ(x: Double) extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class TwoRootsQ(x: Double, y: Double) extends RootsOfQ2
\end_layout

\end_inset

This disjunctive type contains six parts, among which three parts are empty
 tuples and two parts have a single-element tuple; but this is not a useless
 redundancy.
 It would be a loss of information to reuse the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Linear
\end_layout

\end_inset

 for the case 
\begin_inset Formula $a=0$
\end_inset

, 
\begin_inset Formula $b\neq0$
\end_inset

 and for the case 
\begin_inset Formula $a\neq0$
\end_inset

, 
\begin_inset Formula $b^{2}=4ac$
\end_inset

, or to reuse 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

 for representing the three different no-roots cases.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rootAverage
\end_layout

\end_inset

 that computes the average value of all real roots of a general quadratic
 equation, where the roots are represented by the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ2
\end_layout

\end_inset

 defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The required type signature is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val rootAverage: RootsOfQ2 => Option[Double] = ???
\end_layout

\end_inset

The function should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 if the average is undefined.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The average is defined only in cases 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Linear
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRootQ
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRootsQ
\end_layout

\end_inset

.
 All other cases must result in an empty option.
 We implement this via pattern matching:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val rootAverage: RootsOfQ2 => Option[Double] = { roots =>
\end_layout

\begin_layout Plain Layout

  roots match {
\end_layout

\begin_layout Plain Layout

    case Linear(x)       => Some(x)
\end_layout

\begin_layout Plain Layout

    case OneRootQ(x)     => Some(x)
\end_layout

\begin_layout Plain Layout

    case TwoRootsQ(x, y) => Some((x + y) * 0.5)
\end_layout

\begin_layout Plain Layout

    case _               => None
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We do not need to enumerate all other cases since the underscore pattern,
 
\begin_inset Formula $\_$
\end_inset

, matches everything that the previous cases did not match.
\end_layout

\begin_layout Standard
The often-used code pattern of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x match { case ...
 }
\end_layout

\end_inset

 can be shortened to simply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case ...}
\end_layout

\end_inset

.
 The code then becomes
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val rootAverage: RootsOfQ2 => Option[Double] = {
\end_layout

\begin_layout Plain Layout

  case Linear(x)       => Some(x)
\end_layout

\begin_layout Plain Layout

  case OneRootQ(x)     => Some(x)
\end_layout

\begin_layout Plain Layout

  case TwoRootsQ(x, y) => Some((x + y) * 0.5)
\end_layout

\begin_layout Plain Layout

  case _               => None
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Test it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(NoRealRoots(),OneRootQ(1.0), TwoRootsQ(1.0, 2.0), AllRoots()).map(rootAve
rage)
\end_layout

\begin_layout Plain Layout

res0: Seq[Option[Double]] = List(None, Some(1.0), Some(1.5), None)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Generate 
\begin_inset Formula $100$
\end_inset

 quadratic equations 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

 with random coefficients 
\begin_inset Formula $b$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

 (uniformly distributed between 
\begin_inset Formula $-1$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

) and compute the mean of the largest real roots from all these equations.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We use the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

QEqu
\end_layout

\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve
\end_layout

\end_inset

 function from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 First, we create a sequence of equations with random coefficients using
 the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq.fill
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def random(): Double = scala.util.Random.nextDouble() * 2 - 1
\end_layout

\begin_layout Plain Layout

val coeffs: Seq[QEqu] = Seq.fill(100)(QEqu(random(), random()))
\end_layout

\end_inset

We can now use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve
\end_layout

\end_inset

 function to compute all roots:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val solutions: Seq[RootsOfQ] = coeffs.map(solve)
\end_layout

\end_inset

For each set of roots, we compute the largest root:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val largest: Seq[Option[Double]] = solutions.map {
\end_layout

\begin_layout Plain Layout

  case OneRoot(x)     => Some(x)
\end_layout

\begin_layout Plain Layout

  case TwoRoots(x, y) => Some(math.max(x, y))
\end_layout

\begin_layout Plain Layout

  case _              => None
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

largest: Seq[Option[Double]] = List(None, Some(0.9346072365885472), Some(1.1356234
869160806), Some(0.9453181931646322), Some(1.1595052441078866), None, Some(0.576225
2742788), Some(1.1896332718057907), None...
\end_layout

\end_inset

It remains to remove the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 values and to compute the mean of the resulting sequence.
 This operation is used often, so the Scala library defines the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 method that works for sequences of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 values:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> largest.flatten
\end_layout

\begin_layout Plain Layout

res0: Seq[Double] = List(0.9346072365885472, 1.1356234869160806, 0.9453181931646322
, 1.1595052441078866, 0.5762252742788, 1.1896332718057907...
\end_layout

\end_inset

Now we can compute the mean of the last sequence.
 Since the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 operation is preceded by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, we can replace it by a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

.
 The final code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val largest = Seq.fill(100)(QEqu(random(), random()))
\end_layout

\begin_layout Plain Layout

  .map(solve)
\end_layout

\begin_layout Plain Layout

  .flatMap {
\end_layout

\begin_layout Plain Layout

    case OneRoot(x)     => Some(x)
\end_layout

\begin_layout Plain Layout

    case TwoRoots(x, y) => Some(math.max(x, y))
\end_layout

\begin_layout Plain Layout

    case _              => None
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> largest.sum / largest.size
\end_layout

\begin_layout Plain Layout

res1: Double = 0.7682649774589514
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = ???
\end_layout

\end_inset

The function should preserve as much information as possible.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by pattern matching on the argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
\end_layout

\begin_layout Plain Layout

  case None                    => ???
\end_layout

\begin_layout Plain Layout

  case Some(eab: Either[A, B]) => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

: Either[A, B]
\end_layout

\end_inset

 was written only for clarity; it is not required here because the Scala
 compiler can deduce the type of the pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eab
\end_layout

\end_inset

 from the fact that we are matching a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Either[A, B]]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
What expression will we compute in the first case? We need to return a value
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Option[B]]
\end_layout

\end_inset

.
 A value of that type must be either a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

, or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:Option[B]
\end_layout

\end_inset

, where the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 must be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(z)
\end_layout

\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z:B
\end_layout

\end_inset

.
 However, in our case the code is of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case None => ???
\end_layout

\end_inset

, and we cannot produce any values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z:B
\end_layout

\end_inset

 since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are arbitrary, unknown types.
 The only remaining possibility is to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = None
\end_layout

\end_inset

, and so the code must be
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

  case None => Right(None) // No other choice here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the second case, we clearly need to pattern match on the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eab
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

  case Some(eab: Either[A, B]) = eab match {
\end_layout

\begin_layout Plain Layout

    case Left(a)   => ???
\end_layout

\begin_layout Plain Layout

    case Right(b)  => ???
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

It remains to figure out what expressions to compute in each case.
 In the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a) => ???
\end_layout

\end_inset

, we have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, and we need to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Option[B]]
\end_layout

\end_inset

.
 We again follow the same argument: we can return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:Option[B]
\end_layout

\end_inset

.
 At this point, we do have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, but not of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 So we have two possibilities: to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

 as before.
 If we decide to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

, the code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
\end_layout

\begin_layout Plain Layout

  case None       => Right(None) // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Some(eab)  => eab match {
\end_layout

\begin_layout Plain Layout

    case Left(a)  => Left(a) // Could also return Right(None) here.
\end_layout

\begin_layout Plain Layout

    case Right(b) => ???
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Let us consider the choice of whether to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

 in the line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Left(a) => 
\end_layout

\end_inset

.
 Both choices will satisfy the required return type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Option[B]]
\end_layout

\end_inset

.
 However, if we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

 in that line, we will ignore the given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

, which is a loss of information.
 Returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 will preserve more information, which is likely to be more useful.
\end_layout

\begin_layout Standard
Similarly, in the last line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Right(b) => ???
\end_layout

\end_inset

, we have a choice of returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(Some(b))
\end_layout

\end_inset

.
 The first choice ignores the given value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b:B
\end_layout

\end_inset

.
 Since we want to preserve information as much as possible, we make the
 second choice.
 The final code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
\end_layout

\begin_layout Plain Layout

  case None       => Right(None)
\end_layout

\begin_layout Plain Layout

  case Some(eab)  => eab match {
\end_layout

\begin_layout Plain Layout

    case Left(a)  => Left(a)
\end_layout

\begin_layout Plain Layout

    case Right(b) => Right(Some(b))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with the type signature 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = ???
\end_layout

\end_inset

The function should preserve as much information as possible.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by pattern matching on the argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => ???
\end_layout

\begin_layout Plain Layout

  case ???                => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the first case, we have values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b:B
\end_layout

\end_inset

, and we are required to return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[(A, B)]
\end_layout

\end_inset

.
 A value of that type is either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((x,y))
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:B
\end_layout

\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are arbitrary types, we cannot produce new values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 from scratch.
 The only way to satisfy the required type is to set 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x=a
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y=b
\end_layout

\end_inset

, returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((a, b))
\end_layout

\end_inset

.
 Now we have two choices: to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((a, b))
\end_layout

\end_inset

 or to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 Returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 would unnecessarily lose information; so we write
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => Some((a, b))
\end_layout

\begin_layout Plain Layout

  case (Some(a), None)    => ???
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the branch of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case (Some(a), None)
\end_layout

\end_inset

, we have a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

 but no values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Since the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 is arbitrary, we cannot produce any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, and so we cannot return a value of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((x, y))
\end_layout

\end_inset

.
 So, in this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 branch, the only computable value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[(A, B)]
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => Some((a, b))
\end_layout

\begin_layout Plain Layout

  case (Some(a), None)    => None // No other choice here.
\end_layout

\begin_layout Plain Layout

  case (None, Some(b))    => ???
\end_layout

\begin_layout Plain Layout

  case (None, None)       => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Writing out the remaining cases, we find that in all those cases we have
 no choice other than returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 So we can simplify the code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => Some((a, b))
\end_layout

\begin_layout Plain Layout

  case _                  => None // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exercises
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

CellState
\end_layout

\end_inset

 representing the visual state of one cell in the 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Minesweeper"
target "https://en.wikipedia.org/wiki/Minesweeper_(video_game)"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 game: A cell can be either closed (showing nothing), or show a bomb, or
 be open and show the number of bombs in neighbor cells.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Seq[CellState]]
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, counting the total number of cells with zero neighbor bombs shown.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootOfLinear
\end_layout

\end_inset

 representing all possibilities for the solution of the equation 
\begin_inset Formula $ax+b=0$
\end_inset

 for arbitrary real 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

.
 (The possibilities are: no roots; one root; all 
\begin_inset Formula $x$
\end_inset

 are roots.) Implement the solution as a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve1
\end_layout

\end_inset

 with type signature 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def solve1: ((Double, Double)) => RootOfLinear = ???
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(Double, Double)]
\end_layout

\end_inset

 containing pairs 
\begin_inset Formula $\left(a,b\right)$
\end_inset

 of the coefficients of 
\begin_inset Formula $ax+b=0$
\end_inset

, produce a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Double]
\end_layout

\end_inset

 containing the roots of that equation when a unique root exists.
 Use the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootOfLinear
\end_layout

\end_inset

 and the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve1
\end_layout

\end_inset

 defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Subscriber
\end_layout

\end_inset

 was defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-option-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Subscriber]
\end_layout

\end_inset

, compute the sequence of email addresses for all subscribers that did 
\emph on
not
\emph default
 give their phone numbers.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
In the following exercises, the goal is to implement a function that preserves
 as much information as possible and has a given type signature.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[(A, B)] => (Option[A], Option[B]) = ???
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: Either[A, B] => (Option[A], Option[B]) = ???
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f3[A,B,C]: Either[A, Either[B,C]] => Either[Either[A,B], C] = ???
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Subsection
Disjunctive types as mathematical sets
\end_layout

\begin_layout Standard
To understand the properties of disjunctive types from the mathematical
 point of view, consider a function whose argument is a disjunctive type,
 such as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def isDoubleRoot(r: RootsOfQ) = ...
\end_layout

\end_inset

The type of the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r:RootsOfQ
\end_layout

\end_inset

 represents the mathematical domain of the function, that is, the set of
 admissible values of the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

.
 We could imagine a function on a 
\emph on
disjoint
\emph default
 domain, for example 
\begin_inset Formula $r$
\end_inset

 is either a point on a line or a point on a surface, where the surface
 is completely separate from the line.
 Such domains are called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
disjoint domain
\end_layout

\end_inset

disjoint
\series default
 because the line and the surface have no common points.
\end_layout

\begin_layout Standard
The set of real roots of a quadratic equation 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

 is an example of a disjoint domain containing three parts: the no-roots
 case, the one-root case where the root is represented by a single number
 
\begin_inset Formula $x$
\end_inset

, and the two-roots case where the roots are represented by a pair of numbers
 
\begin_inset Formula $\left(x,y\right)$
\end_inset

.
 Geometrically, a number 
\begin_inset Formula $x$
\end_inset

 is pictured as a point on a line (a one-dimensional space), and pair of
 numbers 
\begin_inset Formula $\left(x,y\right)$
\end_inset

 is pictured as a point on a Cartesian plane (a two-dimensional space).
 The no-roots case corresponds to a zero-dimensional space, which is pictured
 as a single point (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RootsOfQ-disjoint-domain"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
begin{pdfpic}
\end_layout

\begin_layout Plain Layout

   
\backslash
newrgbcolor{lightpastel}{0.90 0.93 0.87}
\end_layout

\begin_layout Plain Layout

   
\backslash
psset{unit=0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{pspicture}(0,0)(1,1)
\end_layout

\begin_layout Plain Layout

      
\backslash
pscircle(0.3,0.5){0.005}
\end_layout

\begin_layout Plain Layout

      
\backslash
psline{->}(0.5,0.2)(0.5,0.8)
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.535,0.77){$x$}
\end_layout

\begin_layout Plain Layout

      
\backslash
pspolygon[fillstyle=solid,fillcolor=lightpastel](0.8,0.8)(0.8,0.3)(0.7,0.2)(0.7,0.7)(0.8,
0.8)
\end_layout

\begin_layout Plain Layout

      
\backslash
psline{->}(0.7,0.2)(0.775,0.275)
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.67,0.28){$x$} 
\backslash
rput(0.79,0.24){$y$}
\end_layout

\begin_layout Plain Layout

      
\backslash
psline{->}(0.7,0.2)(0.7,0.3)
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.30,0.45){
\backslash
smaller
\backslash
texttt{NoRoots()}}
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.49,0.85){
\backslash
smaller
\backslash
texttt{OneRoot(x)}}
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.75,0.15){
\backslash
smaller
\backslash
texttt{TwoRoots(x, y)}}
\end_layout

\begin_layout Plain Layout

   
\backslash
end{pspicture}
\end_layout

\begin_layout Plain Layout

%
\backslash
end{pdfpic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The disjoint domain represented by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 type.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:RootsOfQ-disjoint-domain"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the mathematical notation, a one-dimensional real space is denoted by
 
\begin_inset Formula $\mathbb{R}$
\end_inset

, a two-dimensional space by 
\begin_inset Formula $\mathbb{R}^{2}$
\end_inset

, and a zero-dimensional space may be denoted by 
\begin_inset Formula $\mathbb{R}^{0}$
\end_inset

.
 
\end_layout

\begin_layout Standard
At first sight, we may think that the mathematical representation of the
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is a union of the three sets, 
\begin_inset Formula $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}$
\end_inset

.
 But an ordinary union of sets would not work for two reasons.
 First, usually one considers that a point is a subset of a line, and a
 line is a subset of a plance, so 
\begin_inset Formula $\mathbb{R}^{0}\subset\mathbb{R}^{1}\subset\mathbb{R}^{2}$
\end_inset

 and therefore 
\begin_inset Formula $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}=\mathbb{R}^{2}$
\end_inset

.
 Even if we somehow avoided this conclusion, we would still confuse several
 sets of the same type since 
\begin_inset Formula $\mathbb{R}^{1}\cup\mathbb{R}^{1}=\mathbb{R}^{1}$
\end_inset

.
 We need to distinguish the parts of the union unambiguously, even if some
 parts have the same type.
 The disjunctive type shown in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 cannot be correctly represented by the mathematical set 
\begin_inset Formula 
\[
\mathbb{R}^{0}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}
\]

\end_inset

because this set is mathematically equivalent to 
\begin_inset Formula $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}$
\end_inset

, which is not the set we need.
\end_layout

\begin_layout Standard
In the Scala code, each part of a disjunctive type must be distinguished
 by a unique name such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

.
 To represent this mathematically, we need to attach a distinct label to
 each part of the union.
 Labels are symbols without any special meaning, so we can just say that
 labels are Scala identifiers.
 So, we will use sets of pairs such as 
\begin_inset Formula $(\text{\texttt{OneRoot}},x)_{x\in\mathbb{R}^{1}}$
\end_inset

 to represent the parts of the union, and write
\begin_inset Formula 
\[
\text{\texttt{RootsOfQ}}=(\text{\texttt{NoRoots}},u)_{u\in\mathbb{R}^{0}}\cup(\text{\texttt{OneRoot}},x)_{x\in\mathbb{R}^{1}}\cup(\text{\texttt{TwoRoots}},\left(x,y\right))_{\left(x,y\right)\in\mathbb{R}^{2}}\quad.
\]

\end_inset

This kind of labeled union is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjoint union
\end_layout

\end_inset


\series bold
disjoint union
\series default
.
 Each element of the disjoint union has a label that clearly identifies
 the part of the union.
 If we use disjoint unions, we cannot confuse different parts of the union
 even if they all have the same type, because labels are required to be
 distinct.
 Because of the different labels, any two values from different parts of
 the union cannot possibly be equal.
\end_layout

\begin_layout Standard
Disjoint unions are not often explicitly denoted in mathematics, but they
 are needed in software engineering because real-life data often has that
 form.
\end_layout

\begin_layout Paragraph
Named 
\family typewriter
Unit
\family default
 types
\end_layout

\begin_layout Standard
At first sight, it may seem confusing that the zero-dimensional space is
 represented by a set containing 
\emph on
one
\emph default
 point.
 Why should we not use an empty set (rather than a set with one point) to
 represent the case where the equation has no real roots? The reason is
 that we are required to represent not only the values of the roots but
 also the information 
\emph on
about
\emph default
 the existence of the roots.
 The case with no real roots needs to be represented by some 
\emph on
value
\emph default
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
 This value cannot be missing, which would happen if we used an empty set
 to represent the no-roots case.
 It is natural to use the named empty tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

 to represent this case, since we used a named tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(x, y)
\end_layout

\end_inset

 to represent the case of two roots.
\end_layout

\begin_layout Standard
The set containing a single point corresponds to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type in Scala because this type has only one distinct value, written as
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 A case class with no parts, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, has only one distinct value, written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

.
 We see that case classes with no parts are quite similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 except for an added name.
 For this reason, they can be viewed as 
\begin_inset Quotes eld
\end_inset

named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 types.
\begin_inset Index true 1 ""
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Disjunctive types in other programming languages
\end_layout

\begin_layout Standard
Disjunctive types (and the associated pattern matching) turns out to be
 one of the defining features of functional programming languages.
 Programming languages that were not designed for functional programming
 do not support this feature, while ML, OCaml, Haskell, F#, Scala, Swift,
 Elm, and PureScript support disjunctive types as part of the language design.
 
\end_layout

\begin_layout Standard
It is remarkable that the named tuple types (or 
\begin_inset Quotes eld
\end_inset

records
\begin_inset Quotes erd
\end_inset

) are present in almost every programming language, while disjunctive types
 are present almost exclusively in languages specifically designed for the
 functional programming paradigm.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset href
LatexCommand href
name "this Wikipedia page"
target "https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(basic_instructions)#Other_types"
literal "false"

\end_inset

 for a detailed comparison between programming languages.
 Ada and Pascal are the only older languages that provided disjunctive types
 without other features of the FP paradigm.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

union
\end_layout

\end_inset

 types in C and C++ are not disjunctive types because it is not possible
 to determine which part of the union is being represented.
 A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

union
\end_layout

\end_inset

 declaration in C looks like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

union { int x; double y; long z; } di;
\end_layout

\end_inset

The problem is that the parts of the union are not labeled.
 So, it is impossible to determine or to verify which part of the union
 is represented by a given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

di
\end_layout

\end_inset

.
 This leads to coding errors that are hard to track.
\end_layout

\begin_layout Standard
Older programming languages such as C, C++, and Java had 
\begin_inset Quotes eld
\end_inset

enumeration
\begin_inset Quotes erd
\end_inset

 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset

) types), which are a limited form of disjunctive types.
 An 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset

 type declaration in Java looks like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

enum Color { RED, GREEN, BLUE; } 
\end_layout

\end_inset

This is equivalent to a labeled union of three 
\emph on
empty
\emph default
 tuples,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Color
\end_layout

\begin_layout Plain Layout

final case class RED() extends Color
\end_layout

\begin_layout Plain Layout

final case class GREEN() extends Color
\end_layout

\begin_layout Plain Layout

final case class BLUE() extends Color
\end_layout

\end_inset

If the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset

 construction were 
\begin_inset Quotes eld
\end_inset

enriched
\begin_inset Quotes erd
\end_inset

 with extra data, so that each tuple could be non-empty, we would obtain
 disjunctive types.
 A definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 would then look like this: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// This is not valid in Java!
\end_layout

\begin_layout Plain Layout

enum RootsOfQ {
\end_layout

\begin_layout Plain Layout

  NoRoots, OneRoot(x: Double), TwoRoots(x: Double, y: Double);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

A future version of Scala 3 will have a shorter syntax for disjunctive types
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://dotty.epfl.ch/docs/reference/enums/adts.html"
target "https://dotty.epfl.ch/docs/reference/enums/adts.html"
literal "false"

\end_inset


\end_layout

\end_inset

 that indeed looks like an 
\begin_inset Quotes eld
\end_inset

enriched 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

enum RootsOfQ {
\end_layout

\begin_layout Plain Layout

  case NoRoots
\end_layout

\begin_layout Plain Layout

  case OneRoot(x: Double)
\end_layout

\begin_layout Plain Layout

  case TwoRoots(x: Double, y: Double)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For comparison, here is the OCaml and the Haskell syntax for a disjunctive
 type equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{* OCaml *}
\end_layout

\begin_layout Plain Layout

type RootsOfQ = NoRoots | OneRoot of float | TwoRoots of float*float
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Haskell
\end_layout

\begin_layout Plain Layout

data RootsOfQ = NoRoots | OneRoot Double | TwoRoots (Double,Double)
\end_layout

\end_inset

This syntax is more concise than the Scala syntax.
 When reasoning about disjunctive types, it is inconvenient to write out
 long type definitions.
 Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:3-3-The-formal-logic-curry-howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will define a short mathematical notation designed for efficient reasoning
 about types and code.
\end_layout

\begin_layout Subsection
Disjunctions and conjunctions in formal logic
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctions-and-conjunctions"

\end_inset


\end_layout

\begin_layout Standard
In formal logic, a 
\series bold
proposition
\begin_inset Index idx
status open

\begin_layout Plain Layout
proposition in logic
\end_layout

\end_inset


\series default
 is a statement that may be proven true or false.
 A 
\series bold
disjunction
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunction in logic
\end_layout

\end_inset


\series default
 of propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 is denoted by 
\begin_inset Formula $A\vee B\vee C$
\end_inset

 and is true if only if 
\emph on
at least one
\emph default
 of the propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 is true.
 A 
\series bold
conjunction
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
conjunction in logic
\end_layout

\end_inset

 of propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 is denoted by 
\begin_inset Formula $A\wedge B\wedge C$
\end_inset

 and is true if only if 
\emph on
all
\emph default
 of the propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 are true.
\end_layout

\begin_layout Standard
There is a similarity between a disjunctive data type and a logical 
\emph on
disjunction
\emph default
 of propositions.
 A value of the disjunctive data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 can be constructed only if we have at least one of the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(x)
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(x, y)
\end_layout

\end_inset

 for some specific 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

.
 To save words, denote by 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 the logical proposition 
\begin_inset Quotes eld
\end_inset

this 
\begin_inset Formula ${\cal C}$
\end_inset

ode 
\begin_inset Formula ${\cal H}$
\end_inset

as a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, where 
\begin_inset Quotes eld
\end_inset

this code
\begin_inset Quotes erd
\end_inset

 refers to a particular expression or function in our program.
 So, the proposition 
\begin_inset Quotes eld
\end_inset

a function can return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is denoted by 
\begin_inset Formula ${\cal CH}(\text{\texttt{RootsOfQ}})$
\end_inset

.
 We can then write the sentence about 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 as the logical formula
\begin_inset Formula 
\[
{\cal CH}(\text{\texttt{RootsOfQ}})={\cal CH}(\text{\texttt{NoRoots}})\vee{\cal CH}(\text{\texttt{OneRoot}})\vee{\cal CH}(\text{\texttt{TwoRoots}})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
There is also a a similarity between logical 
\emph on
conjunctions
\emph default
 and a named tuple type.
 Consider the named tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(x: Double, y: Double)
\end_layout

\end_inset

.
 When can we have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

? Only when we have two values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 Writing this statement as a formula, we get
\begin_inset Formula 
\[
{\cal CH}(\text{\texttt{TwoRoots}})={\cal CH}(\text{\texttt{Double}})\wedge{\cal CH}(\text{\texttt{Double}})\quad.
\]

\end_inset

Now, in logic we have the simplification
\begin_inset Formula 
\[
{\cal CH}(\text{\texttt{Double}})\wedge{\cal CH}(\text{\texttt{Double}})={\cal CH}(\text{\texttt{Double}})\quad.
\]

\end_inset

However, no such simplification will be available for an arbitrary tuple
 such as 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Data3(x: Int, y: String, z: Double)
\end_layout

\end_inset

For this type, we will have the statement
\begin_inset Formula 
\[
{\cal CH}(\text{\texttt{Data3}})={\cal CH}(\text{\texttt{Int}})\wedge{\cal CH}(\text{\texttt{String}})\wedge{\cal CH}(\text{\texttt{Double}})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We find that disjunctive types are related to logical disjunctions in the
 same way as tuples are related to logical conjunctions.
 This is the main motivation behind the name 
\begin_inset Quotes eld
\end_inset

disjunctive types
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The correspondence between disjunctions, conjunctions, and data types is
 explained in more detail in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:3-3-The-formal-logic-curry-howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For now, we note that the operations of conjunction and disjunction are
 not sufficient to produce all possible logical expressions.
 To obtain a complete logic, it is also necessary to have a logical negation
 
\begin_inset Formula $\neg A$
\end_inset

 (
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 is not true
\begin_inset Quotes erd
\end_inset

) or, equivalently, a logical implication 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $A$
\end_inset

 is true than 
\begin_inset Formula $B$
\end_inset

 is true
\begin_inset Quotes erd
\end_inset

).
 It turns out that the logical implication is related to the function types
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
 In the next chapter, we will study the function types in more depth.
\end_layout

\end_body
\end_document
