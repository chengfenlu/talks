#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% Better formatting of tables.
%\usepackage{booktabs}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.0pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}

\usepackage{pstricks}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.
\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt,utf8
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7in
\paperheight 9in
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Success,Failure,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The formal logic of types I.
 Disjunctive types
\end_layout

\begin_layout Standard
Disjunctive types describe values that belong to a disjoint set of alternatives.
 
\end_layout

\begin_layout Standard
To see how Scala implements disjunctive types, we need to begin by looking
 at 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Scala's case classes
\end_layout

\begin_layout Subsection
Case classes as 
\begin_inset Quotes eld
\end_inset

named tuple
\begin_inset Quotes erd
\end_inset

 types
\end_layout

\begin_layout Standard
It is often helpful to use names for the different parts of a tuple.
 Suppose that some program represents the size and the color of socks with
 the tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, String)
\end_layout

\end_inset

.
 What if the same tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, String)
\end_layout

\end_inset

 is used in another place in the program to mean the amount paid and the
 name of the payee? A programmer could mix the two values by mistake, and
 it would be hard to find out why the program incorrectly computes, say,
 the total amount paid.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def totalAmountPaid(ps: Seq[(Double, String)]): Double = ps.map(_._1).sum
\end_layout

\begin_layout Plain Layout

val x = (10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

) // Sock size and color.
\end_layout

\begin_layout Plain Layout

val y = (25.0, 
\begin_inset Quotes eld
\end_inset

friend
\begin_inset Quotes erd
\end_inset

) // Payment amount and payee.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(List(x, y)) // Nonsense.
\end_layout

\begin_layout Plain Layout

res0: Double = 35.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We would prevent this kind of mistake if we could use two 
\emph on
different
\emph default
 types, with names such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

, for the two kinds of data.
 There are  three basic ways of defining a new named type in Scala that
 replaces a tuple: using a type alias, using a case class, and using an
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
opaque type
\end_layout

\end_inset

opaque type.
 
\end_layout

\begin_layout Standard
Opaque types (hiding a given type under a new name) is a feature that will
 become standard in a future version of Scala 3; so let us focus on type
 aliases and case classes.
\end_layout

\begin_layout Standard
A 
\series bold
type alias
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type alias
\end_layout

\end_inset

 is an alternative name for an existing (already defined) type.
 We could use type aliases in our example to add clarity to the code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type MySockTuple = (Double, String)
\end_layout

\begin_layout Plain Layout

type PaymentTuple = (Double, String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val s: MySockTuple = (10.5, "white")
\end_layout

\begin_layout Plain Layout

s: MySockTuple = (10.5,white)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val p: PaymentTuple = (25.0, "friend")
\end_layout

\begin_layout Plain Layout

p: PaymentTuple = (25.0,friend)
\end_layout

\end_inset

But the mix-up error is not prevented:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> totalAmountPaid(List(s, p)) // Nonsense again.
\end_layout

\begin_layout Plain Layout

res1: Double = 35.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Scala's 
\series bold
case classes
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
case class
\end_layout

\end_inset

 can be seen as 
\begin_inset Quotes eld
\end_inset

tuples with names
\begin_inset Quotes erd
\end_inset

.
 A case class is equivalent to a tuple type that has a name that we choose
 when we define the case class.
 Also, each part of the case class will have a separate name that we must
 choose.
 This is how to define case classes for the example with socks and payments:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySock(size: Double, color: String)
\end_layout

\begin_layout Plain Layout

case class Payment(amount: Double, name: String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val sock = MySock(10.5, "white")
\end_layout

\begin_layout Plain Layout

sock: MySock = MySock(10.5,white)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val paid = Payment(25.0, "friend")
\end_layout

\begin_layout Plain Layout

paid: Payment = Payment(25.0,friend)                                  ^ 
\end_layout

\end_inset

The new types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

 were defined.
 Values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 are written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

, which is similar to writing the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 except for adding the name 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To access the parts of a case class, we use the part names:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> sock.size
\end_layout

\begin_layout Plain Layout

res2: Double = 10.5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> paid.amount
\end_layout

\begin_layout Plain Layout

res3: Double = 25.0
\end_layout

\end_inset

The mix-up error is now a type error flagged by the compiler:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def totalAmountPaid(ps: Seq[Payment]): Double = ps.map(_.amount).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(List(paid, paid))
\end_layout

\begin_layout Plain Layout

res4: Double = 50.0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(List(sock, paid))
\end_layout

\begin_layout Plain Layout

<console>:19: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : MySock
\end_layout

\begin_layout Plain Layout

 required: Payment
\end_layout

\begin_layout Plain Layout

       totalAmountPaid(List(sock, paid))
\end_layout

\begin_layout Plain Layout

                            ^
\end_layout

\end_inset

A function whose argument is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 cannot be applied to an argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

 or of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, String)
\end_layout

\end_inset

.
 Case classes with different names are 
\emph on
different types
\emph default
, even if they contain the same types of parts.
 
\end_layout

\begin_layout Standard
Just as tuples can have any number of parts, case classes can have any number
 of parts, but the part names must be distinct, for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Person(firstName: String, lastName: String, age: Int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val einstein = Person("Albert", "Einstein", 140)
\end_layout

\begin_layout Plain Layout

einstein: Person = Person(Albert,Einstein,140)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> einstein.firstName
\end_layout

\begin_layout Plain Layout

res5: String = Albert
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> einstein.age
\end_layout

\begin_layout Plain Layout

res6: Int = 140
\end_layout

\end_inset

This data type carries the same information as a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String, String, Int)
\end_layout

\end_inset

.
 However, the declaration of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Person
\end_layout

\end_inset

 gives the programmer several methods that make working with the tuple's
 data more convenient.
\end_layout

\begin_layout Standard
Some (or all) part names may be specified when creating a case class value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val poincare = Person(firstName = "Henri", lastName = "Poincaré",
 165)
\end_layout

\begin_layout Plain Layout

poincare: Person = Person(Henri,Poincaré,165)
\end_layout

\end_inset

It is a type error to use wrong types with a case class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

<console>:13: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : Int(140)
\end_layout

\begin_layout Plain Layout

 required: String
\end_layout

\begin_layout Plain Layout

       val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

                      ^
\end_layout

\begin_layout Plain Layout

<console>:13: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : String("Albert")
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\begin_layout Plain Layout

       val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

                                       ^
\end_layout

\end_inset

Here, the error is due to an incorrect order of parts when creating a case
 class value.
 However, parts can be specified in any order when using part names:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p = Person(age = 140, lastName = "Einstein", firstName = "Albert")
\end_layout

\begin_layout Plain Layout

p: Person = Person(Albert,Einstein,140)
\end_layout

\end_inset

A part of a case class can have the type of another case class, creating
 a 
\begin_inset Quotes eld
\end_inset

nested
\begin_inset Quotes erd
\end_inset

 type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class BagOfSocks(sock: MySock, count: Int)
\end_layout

\begin_layout Plain Layout

val bag = BagOfSocks(MySock(10.5, "white"), 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> bag.socks.size
\end_layout

\begin_layout Plain Layout

res7: Double = 10.5
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Case classes with type parameters
\end_layout

\begin_layout Standard
Generally, type classes can be defined with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type parameter
\end_layout

\end_inset

type parameters.
 As an example, consider a generalization of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 where, in addition to the size and color, a 
\begin_inset Quotes eld
\end_inset

sock
\begin_inset Quotes erd
\end_inset

 may hold another value.
 We could define several specialized case classes,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySockInt(size: Double, color: String, value: Int)
\end_layout

\begin_layout Plain Layout

case class MySockBoolean(size: Double, color: String, value: Boolean)
\end_layout

\end_inset

but it is better to define a single parameterized case class
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySockX[A](size: Double, color: String, value: A)
\end_layout

\end_inset

that works for every type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 When we create values of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

, we will use a specific type, for instance
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = MySockX(10.5, "white", 123)
\end_layout

\begin_layout Plain Layout

s: MySockX[Int] = MySockX(10.5,white,123) 
\end_layout

\end_inset

Here, the type variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 was automatically set to a specific type, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Specific types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 will be used by each specific value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[A]
\end_layout

\end_inset

, but we can write code working with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[A]
\end_layout

\end_inset

 
\series bold
parametrically
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
parametric code
\end_layout

\end_inset

, that is, keeping the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in the code.
 For example, a function that checks whether a sock of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[A]
\end_layout

\end_inset

 fits my foot can be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fitsMe[A](sock: MySockX[A]): Boolean = sock.size >= 10.5 && sock.size <=
 11.0
\end_layout

\end_inset

This function is defined for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 at once, because its code works in the same way regardless of the type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Scala will set the type parameter automatically:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fitsMe(MySockX(10.5, 
\begin_inset Quotes eld
\end_inset

blue
\begin_inset Quotes erd
\end_inset

, List(1,2,3))) // Parameter A = List[Int]
\end_layout

\begin_layout Plain Layout

res0: Boolean = true
\end_layout

\end_inset

In this case it is clear that the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 must be set to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

, and we may omit the type parameter when calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fitsMe
\end_layout

\end_inset

.
 When types become more complicated, it may be helpful to avoid type errors
 by specifying the values of type parameters.
 For example, here is a type error due to a mismatch between the type parameter
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 used in the 
\begin_inset Quotes eld
\end_inset

sock
\begin_inset Quotes erd
\end_inset

 value, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

, and the type parameter in the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fitsMe
\end_layout

\end_inset

, specified as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
\end_layout

\begin_layout Plain Layout

<console>:15: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : List[Int]
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\begin_layout Plain Layout

       fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
\end_layout

\begin_layout Plain Layout

                                             ^ 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Case classes may have several type parameters, and the types of the parts
 may use these type parameters.
 Here is an artificial example of a case class using type parameters in
 different ways,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Complicated[A,B,C,D](x: (A, A), y: (B, Int) => A, z: C => C)
\end_layout

\end_inset

This case class contains parts of different types that use the type parameters
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 in tuples and functions.
 The type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

 is not used at all; this is allowed as well.
\end_layout

\begin_layout Subsection
Tuples with one part and with zero parts
\end_layout

\begin_layout Standard
Let us compare tuples and case classes more systematically.
\end_layout

\begin_layout Standard
Parts of a case class are accessed by name with a dot syntax, for example
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sock.color
\end_layout

\end_inset

.
 Parts of a tuple are accessed with the accessors such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x._1
\end_layout

\end_inset

.
 This syntax is the same as that for a case class whose parts have names
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_2
\end_layout

\end_inset

, etc.
 So, it appears that tuple parts 
\emph on
do
\emph default
 have names in Scala, although those names are always automatically assigned
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_2
\end_layout

\end_inset

, etc.
 It turns out that tuple types also have automatically assigned names in
 Scala; these names are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple2
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple3
\end_layout

\end_inset

, etc., and they correspond to parameterized types, since each part of the
 tuple may be of any type.
 So, a tuple type expression such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, String)
\end_layout

\end_inset

 is just a special syntax for the parameterized type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple2[Int, String]
\end_layout

\end_inset

.
 One could define the tuple types as case classes like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Tuple2[A, B](_1: A, _2: B)
\end_layout

\begin_layout Plain Layout

case class Tuple3[A, B, C](_1: A, _2: B, _3: C)
\end_layout

\begin_layout Plain Layout

// And so on with Tuple4, Tuple5, ...
\end_layout

\end_inset

if these types were not already defined in the Scala library.
\end_layout

\begin_layout Standard
Proceeding systematically, we ask whether tuple types can have just one
 part or even no parts.
 Indeed, Scala defines 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple1[A]
\end_layout

\end_inset

 as a tuple with a single part.
 (This type is occasionally useful in practice.) 
\end_layout

\begin_layout Standard
The tuple with zero parts exists as well, and is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 (rather than 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple0
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

).
 At first sight, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type may appear to be completely useless; it is a tuple that contains 
\emph on
no
\emph default
 values.
 The syntax for the value of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type is the empty tuple, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 It is clear that there is 
\emph on
only one
\emph default
 value, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, of this type; this explains the name 
\begin_inset Quotes eld
\end_inset

unit
\begin_inset Quotes erd
\end_inset

.
 It turns out, however, that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type is important in functional programming, and it is used as a type guarantee
d to have only a single distinct value.
 This chapter will show some examples of using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
\end_layout

\begin_layout Standard
Case classes can be defined similarly to the one-part and zero-part tuples
 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class B(z: Int) // Tuple with one part.
\end_layout

\begin_layout Plain Layout

case class C() // Tuple with no parts.
\end_layout

\end_inset

Let us summarize the correspondence between tuples and case classes:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tuples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Case classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(123, "xyz"): Tuple2[Int, String]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class A(x: Int, y: String)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(123,): Tuple1[Int]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class B(z: Int)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(): Unit
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Scala has a special syntax for case classes without parts:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case object C // Similar to `case class C()`.
\end_layout

\end_inset

There are two main differences between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object C
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

 cannot have type parameters, while we may define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C[X, Y, Z]()
\end_layout

\end_inset

 if needed.
\end_layout

\begin_layout Itemize
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

 is allocated in memory only once, while new values of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 will be allocated in memory each time 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C()
\end_layout

\end_inset

 is evaluated.
\end_layout

\begin_layout Standard
Other than that, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object C
\end_layout

\end_inset

 have the same meaning: a named tuple with zero parts, which we may also
 call a 
\begin_inset Quotes eld
\end_inset

named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Index true 1 ""
status open

\begin_layout Plain Layout
named Unit
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 type.
 In this book, I will use the more general 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class
\end_layout

\end_inset

 rather than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Pattern matching for case classes
\end_layout

\begin_layout Standard
Scala performs pattern matching in two situations:
\end_layout

\begin_layout Itemize
destructuring definition: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

val $pattern$ = ...
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

case $pattern$ => ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Case classes can be used in both situations.
 Here is an example of a destructuring definition, used to implement a function
 whose argument is of case class type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BagOfSocks
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySock(size: Double, color: String)
\end_layout

\begin_layout Plain Layout

case class BagOfSocks(sock: MySock, count: Int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def printBag(bag: BagOfSocks): String = {
\end_layout

\begin_layout Plain Layout

  val BagOfSocks(MySock(size, color), count) = bag // Destructure the `bag`.
\end_layout

\begin_layout Plain Layout

  s
\begin_inset Quotes eld
\end_inset

Bag has $count $color socks of size $size
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val bag = BagOfSocks(MySock(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

), 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> printBag(bag)
\end_layout

\begin_layout Plain Layout

res0: String = Bag has 6 white socks of size 10.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An example of using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fitsMe(bag: BagOfSocks): Boolean = bag match {
\end_layout

\begin_layout Plain Layout

  case BagOfSocks(MySock(size, _), _) => size >= 10.5 && size <= 11.0
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the implementation of this function, we match the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bag
\end_layout

\end_inset

 value against the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BagOfSocks(MySock(size, _), _)
\end_layout

\end_inset

.
 This pattern will always match and will define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

 as the pattern variable of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The syntax for pattern matching expressions that use case classes is similar
 to the syntax for pattern matching of tuples, except for the presence of
 the 
\emph on
names
\emph default
 of the case classes.
 For example, if we remove the type names from the pattern
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case BagOfSocks(MySock(size, _), _) => ...
\end_layout

\end_inset

we obtain the nested tuple pattern 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case ((size, _), _) => ...
\end_layout

\end_inset

that could be used for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((Double, String), Int)
\end_layout

\end_inset

.
 We see that case classes behave in many ways exactly as named tuple types.
 
\end_layout

\begin_layout Standard
Scala's 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset

 got their name from their use in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions.
 It is usually more convenient to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions with case classes than to use destructuring.
\end_layout

\begin_layout Section
Disjunctive types
\end_layout

\begin_layout Subsection
Motivation and first examples
\end_layout

\begin_layout Standard
In many situations, it is useful to have several different shapes of data
 within the same type.
 As a first example, suppose we are looking for real roots of a quadratic
 equation 
\begin_inset Formula $x^{2}+ax+b=0$
\end_inset

.
 There are three cases: no real roots, one real root, and two real roots.
 It would be convenient if we had a type, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

, that means 
\begin_inset Quotes eld
\end_inset

the real roots of a quadratic equation
\begin_inset Quotes erd
\end_inset

.
 Inside that type, we can distinguish between the three cases, but outside
 it looks like a single type, so that it is easier to work with.
\end_layout

\begin_layout Standard
Another example is the binary search algorithm that looks for an integer
 
\begin_inset Formula $x$
\end_inset

 in a sorted array.
 There are two cases: the algorithm either finds the index of 
\begin_inset Formula $x$
\end_inset

 or determines that the array does not contain 
\begin_inset Formula $x$
\end_inset

.
 It is convenient if the algorithm could return a single value of a type,
 say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

, that represents 
\emph on
either
\emph default
 an index at which 
\begin_inset Formula $x$
\end_inset

 is found, 
\emph on
or
\emph default
 the absence of an index.
\end_layout

\begin_layout Standard
More generally, we may have computations that 
\emph on
either
\emph default
 return a value 
\emph on
or
\emph default
 generate an error and fail to produce a result.
 It is then convenient to return a value of type, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

, that could represent 
\emph on
either
\emph default
 a correct result 
\emph on
or
\emph default
 an error message.
 
\end_layout

\begin_layout Standard
In certain computer games, one has different types of 
\begin_inset Quotes eld
\end_inset

rooms
\begin_inset Quotes erd
\end_inset

, each room having certain properties depending on its type, – some rooms
 are dangerous because of monsters, other rooms contain useful objects,
 certain rooms allow you to finish the game, and so on.
 We want to represent all the different kinds of rooms uniformly, as a type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Room
\end_layout

\end_inset

, so that each 
\begin_inset Quotes eld
\end_inset

room value
\begin_inset Quotes erd
\end_inset

 automatically stores the correct properties in each case.
\end_layout

\begin_layout Standard
In all these situations, data comes in several mutually exclusive shapes.
 This data can be represented by a single type only if that type is able
 to describe a mutually exclusive set of cases:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 must be either the empty tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 or a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 must be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or the empty tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 must be either an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 value or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 message
\end_layout

\begin_layout Standard
We see that the empty tuple, also known as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, is convenient to use in this representation! It is also helpful to
 assign names to each of the cases:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

no roots
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

one root
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

two roots
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

index
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

not found
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset Quotes eld
\end_inset

error message
\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Scala's case classes provide exactly what we need here – 
\emph on
named tuples
\emph default
 with zero, one, two and more parts, and so it is natural to use case classes
 instead of tuples:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class NoRoots()
\end_layout

\end_inset

, or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class OneRoot(x: Double)
\end_layout

\end_inset

, or of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class TwoRoots(x: Double, y: Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Index(Int)
\end_layout

\end_inset

 or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class None()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Value(x: Int)
\end_layout

\end_inset

 or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Error(message: String)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our three examples are now described as types that select one case class
 out of a given set.
 The only remaining question is how Scala defines such types.
 For instance, the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 somehow needs to indicate that the case classes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

 are exactly the three alternatives described by the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
 The Scala syntax for this definition looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class NoRoots() extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class OneRoot(x: Double) extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class TwoRoots(x: Double, y: Double) extends RootsOfQ
\end_layout

\end_inset

In the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

, we we have two cases:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait SearchResult
\end_layout

\begin_layout Plain Layout

final case class Index(i: Int) extends SearchResult
\end_layout

\begin_layout Plain Layout

final case class NotFound() extends SearchResult
\end_layout

\end_inset

The definition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 type can be parameterized, so that we can describe results of any type
 (but error messages are always of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Result[A]
\end_layout

\begin_layout Plain Layout

final case class Value[A](x: A) extends Result[A]
\end_layout

\begin_layout Plain Layout

final case class Error[A](message: String) extends Result[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sealed trait
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

final case class
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 syntax defines a type that represents a choice of one case class from a
 fixed set of case classes.
 This kind of type is called the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type
\end_layout

\end_inset

disjunctive type
\series default
 in this book.
 
\end_layout

\begin_layout Subsection
Solved examples: Pattern matching with disjunctive types
\end_layout

\begin_layout Standard
Our first examples of disjunctive types were 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[A]
\end_layout

\end_inset

 defined in the previous section.
 We need to see the Scala syntax for creating values of disjunctive types
 and for using the created values.
\end_layout

\begin_layout Standard
Consider the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 that has three case classes (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

).
 The only way of creating a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is to create a value of one of these case classes.
 This is done by writing expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(2.0)
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(1.0, -1.0)
\end_layout

\end_inset

.
 Scala will see these expressions as values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x: RootsOfQ = OneRoot(2.0)
\end_layout

\begin_layout Plain Layout

x: RootsOfQ = OneRoot(2.0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:RootsOfQ
\end_layout

\end_inset

, how can we use it, say, as a function argument? The main tool for working
 with values of disjunctive types is pattern matching with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression needs to have one or more patterns, so that all possible cases
 of the disjunctive type are matched.
 If we only need to recognize a specific case of a disjunctive type, we
 can match all other cases with an underscore:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> x match {
\end_layout

\begin_layout Plain Layout

  case OneRoot(r) => s
\begin_inset Quotes erd
\end_inset

have one root $r
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case _          => 
\begin_inset Quotes eld
\end_inset

have something else
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

res0: String = have one root 2.0
\end_layout

\end_inset

Let us look at more examples of using the disjunctive types we just defined.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-rootsofq-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a sequence of quadratic equations, compute the sequence that contains
 their real roots as values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Define a case class representing a quadratic equation 
\begin_inset Formula $x^{2}+ax+b=0$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class QEqu(a: Double, b: Double)
\end_layout

\end_inset

The following function determines how many real roots an equation has:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def solve(quadraticEqu: QEqu): RootsOfQ = {
\end_layout

\begin_layout Plain Layout

   val QEqu(a, b) = quadraticEqu // Destructure QEqu.
\end_layout

\begin_layout Plain Layout

   val d = a * a / 4 - b
\end_layout

\begin_layout Plain Layout

   if (d > 0) {
\end_layout

\begin_layout Plain Layout

     val s = math.sqrt(d)
\end_layout

\begin_layout Plain Layout

     TwoRoots(a/2 - s, a/2 + s)
\end_layout

\begin_layout Plain Layout

   } else if (d == 0.0) OneRoot(a/2)
\end_layout

\begin_layout Plain Layout

   else NoRoots()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Test this function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> solve(QEqu(1,1))
\end_layout

\begin_layout Plain Layout

res1: RootsOfQ = NoRoots()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> solve(QEqu(1,-1))
\end_layout

\begin_layout Plain Layout

res2: RootsOfQ = TwoRoots(-0.6180339887498949,1.618033988749895) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> solve(QEqu(6,9))
\end_layout

\begin_layout Plain Layout

res3: RootsOfQ = OneRoot(3.0) 
\end_layout

\end_inset

We can now solve this example via this code,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map(solve)
\end_layout

\end_inset

If the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve
\end_layout

\end_inset

 is not used often, we may want to write it inline:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map { case QEqu(a, b)
 =>
\end_layout

\begin_layout Plain Layout

  (a * a / 4 - b) match {
\end_layout

\begin_layout Plain Layout

    case d if d > 0   =>
\end_layout

\begin_layout Plain Layout

      val s = math.sqrt(d)
\end_layout

\begin_layout Plain Layout

      TwoRoots(a / 2 - s, a / 2 + s)
\end_layout

\begin_layout Plain Layout

    case 0.0          => OneRoot(a/2)
\end_layout

\begin_layout Plain Layout

    case _            => NoRoots()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code illustrates some features of Scala syntax.
 We can use the partial function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case QEqu(a, b) => ...
 }
\end_layout

\end_inset

 directly as the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 instead of defining this function separately.
 This avoids the need to destructure 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

QEqu
\end_layout

\end_inset

 at a separate step.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 expression is replaced by an 
\begin_inset Quotes eld
\end_inset

embedded
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
embedded `if`
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 within the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression, which is easier to read.
 Test the final code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> findRoots(Seq(QEqu(1,1), QEqu(2,1)))
\end_layout

\begin_layout Plain Layout

res4: Seq[RootsOfQ] = List(NoRoots(), OneRoot(1.0)) 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-rootsofq"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a sequence of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

, compute the sequence that contains only the single roots.
 Example test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> singleRoots(Seq(TwoRoots(-1, 1), OneRoot(3.0), OneRoot(1.0), NoRoots()))
\end_layout

\begin_layout Plain Layout

res5: Seq[Double] = List(3.0, 1.0) 
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 to the sequence of roots:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] = rs.filter {
\end_layout

\begin_layout Plain Layout

  case OneRoot(x) => true
\end_layout

\begin_layout Plain Layout

  case _          => false
\end_layout

\begin_layout Plain Layout

}.map { case OneRoot(x) => x }
\end_layout

\end_inset

In the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 operation, we only need to cover the one-root case because the other two
 possibilities have been 
\begin_inset Quotes eld
\end_inset

filtered out
\begin_inset Quotes erd
\end_inset

 by the preceding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 operation.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-searchresult"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-searchresult"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement binary search returning a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

.
 We will modify the binary search implementation from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-binary-search-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b) so that it returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NotFound
\end_layout

\end_inset

 value when appropriate.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The code from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-binary-search-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b) will return 
\emph on
some
\emph default
 index even if the given number is not present in the array: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> binSearch(Array(1, 3, 5, 7), 5)
\end_layout

\begin_layout Plain Layout

res6: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> binSearch(Array(1, 3, 5, 7), 4)
\end_layout

\begin_layout Plain Layout

res7: Int = 1
\end_layout

\end_inset

When the number is not present, the array's element at the computed index
 will not be equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

goal
\end_layout

\end_inset

.
 We can return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NotFound
\end_layout

\end_inset

 in that case.
 The new code can be written as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression for clarity:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def safeBinSearch(xs: Seq[Int], goal: Int): SearchResult = binSearch(xs,
 goal) match {
\end_layout

\begin_layout Plain Layout

  case n if xs(n) == goal   => Index(n) 
\end_layout

\begin_layout Plain Layout

  case _                    => NotFound()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> safeBinSearch(Array(1, 3, 5, 7), 5)
\end_layout

\begin_layout Plain Layout

res8: SearchResult = Index(2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> safeBinSearch(Array(1, 3, 5, 7), 4)
\end_layout

\begin_layout Plain Layout

res9: SearchResult = NotFound()
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-resultA"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

 to implement safe arithmetic where a division by zero or a square root
 of a negative number will give an error message.
 Define arithmetic operations directly for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

; abandon computations if an error occurs.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing the square root:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sqrt(rx: Result[Int]): Result[Int] = rx match {
\end_layout

\begin_layout Plain Layout

  case Value(x) if x >= 0  => Value(math.sqrt(x).toInt)
\end_layout

\begin_layout Plain Layout

  case Value(x)            => Error(s
\begin_inset Quotes eld
\end_inset

error: sqrt($x)
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

  case Error(m)            => Error(m) // Keep the error message.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The square root is computed only if we have the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value(x)
\end_layout

\end_inset

 case, and only if 
\begin_inset Formula $x\geq0$
\end_inset

.
 If the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rx
\end_layout

\end_inset

 was already an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Error
\end_layout

\end_inset

 case, we keep the error message and perform no further operations.
\end_layout

\begin_layout Standard
To implement the addition operation, we need a bit more work:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) => Value(x + y)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)        => Error(m) // On any error, do no further computati
ons.
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code illustrates nested patterns that match the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(rx, ry)
\end_layout

\end_inset

 against various possibilities.
 In this way, the code is clearer than it would be if written with nested
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 expressions.
\end_layout

\begin_layout Standard
Implementing the multiplication operation results in almost the same code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def mul(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) => Value(x * y)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)        => Error(m)
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To avoid the repetition of code, we may define a general function that 
\begin_inset Quotes eld
\end_inset

promotes
\begin_inset Quotes erd
\end_inset

 operations on integers to operations on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

 types:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def do2(rx: Result[Int], ry: Result[Int])(op: (Int, Int) => Int): Result[Int]
 =
\end_layout

\begin_layout Plain Layout

  (rx, ry) match {
\end_layout

\begin_layout Plain Layout

    case (Value(x), Value(y)) => Value(op(x, y))
\end_layout

\begin_layout Plain Layout

    case (Error(m), _)        => Error(m)
\end_layout

\begin_layout Plain Layout

    case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

Now we can easily 
\begin_inset Quotes eld
\end_inset

promote
\begin_inset Quotes erd
\end_inset

 any binary operation that never generates an error to an operation on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sub(rx: Result[Int], ry: Result[Int]): Result[Int] = do2(rx, ry){ (x,
 y) => x - y }
\end_layout

\end_inset

 Custom code is still needed for operations that may generate errors:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def div(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) if y != 0 => Value(x / y)
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y))            => Error(s
\begin_inset Quotes eld
\end_inset

error: $x / $y
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)        => Error(m)
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can now test the new 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

 on simple calculations:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> add(Value(1), Value(2))
\end_layout

\begin_layout Plain Layout

res10: Result[Int] = Value(3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> div(add(Value(1), Value(2)), Value(0))
\end_layout

\begin_layout Plain Layout

res11: Result[Int] = Error(error: 3 / 0)
\end_layout

\end_inset

We see that indeed all further computations are abandoned once an error
 occurs.
 The error message shows only the immediate calculation that generated the
 error.
 For instance, the error message for 
\begin_inset Formula $20+\frac{1}{0}$
\end_inset

 never mentions 
\begin_inset Formula $20$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> add(Value(20), div(Value(1), Value(0)))
\end_layout

\begin_layout Plain Layout

res12: Result[Int] = Error(error: 1 / 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> add(sqrt(Value(-1)), Value(10))
\end_layout

\begin_layout Plain Layout

res13: Result[Int] = Error(error: sqrt(-1))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Standard disjunctive types: 
\family typewriter
Option
\family default
, 
\family typewriter
Either
\family default
, 
\family typewriter
Try
\end_layout

\begin_layout Standard
Most often used type: Option
\end_layout

\begin_layout Standard
A simple implementation: 
\end_layout

\begin_layout Standard
sealed trait Option[T]
\end_layout

\begin_layout Standard
final case class Some[T](t: T) extends Option[T]
\end_layout

\begin_layout Standard
final case object None extends Option[Nothing]
\end_layout

\begin_layout Standard
Pattern-matching example:
\end_layout

\begin_layout Standard
def saveDivide(x: Double, y: Double): Option[Double] = {
\end_layout

\begin_layout Standard
  if (y == 0) None else Some(x / y)
\end_layout

\begin_layout Standard
// Example usage:
\end_layout

\begin_layout Standard
val result = safeDivide(1.0, q) match {
\end_layout

\begin_layout Standard
  case Some(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 previousResult * x
\end_layout

\begin_layout Standard
  case None 
\begin_inset Formula $\Rightarrow$
\end_inset

 previousResult // provide a default value
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
Many Scala library functions return an Option[T]
\end_layout

\begin_layout Standard
find, headOption, reduceOption, get (for Map[K, V]), lift for Array[T]
\end_layout

\begin_layout Standard
Note: Option[T] is 
\begin_inset Quotes eld
\end_inset

collection-like
\begin_inset Quotes erd
\end_inset

: has map, flatMap, filter, exists...
\end_layout

\begin_layout Standard
Example: Either[String, Int] (may be used for error reporting)
\end_layout

\begin_layout Standard
Represents a value that is either a String or an Int (but not both)
\end_layout

\begin_layout Standard
Example values: Left("blah") or Right(123)
\end_layout

\begin_layout Standard
Use pattern matching to distinguish 
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

 from 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
def logError(x: Either[String, Int]): Int = x match {
\end_layout

\begin_layout Standard
  case Left(error) 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"Got error: $error"); -1
\end_layout

\begin_layout Standard
  case Right(res) 
\begin_inset Formula $\Rightarrow$
\end_inset

 res
\end_layout

\begin_layout Standard
} // Left(
\begin_inset Quotes eld
\end_inset

blah
\begin_inset Quotes erd
\end_inset

) and Right(123) are possible values of type Either[String, Int]
\end_layout

\begin_layout Standard
Now logError(Right(123)) returns 123 while logError(Left("bad result"))
 prints the error and returns -1
\end_layout

\begin_layout Standard
The case expression chooses among possible values of a given type
\end_layout

\begin_layout Standard
Note the similarity with this code:
\end_layout

\begin_layout Standard
def f(x: Int): Int = x match {
\end_layout

\begin_layout Standard
  case 0 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"error: must be nonzero"); -1
\end_layout

\begin_layout Standard
  case 1 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"error: must be greater than 1"); -1
\end_layout

\begin_layout Standard
  case res 
\begin_inset Formula $\Rightarrow$
\end_inset

 res
\end_layout

\begin_layout Standard
} // 0 and 1 are possible values of type Int
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Using disjunctive types with collections
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
What problems can we solve now?
\end_layout

\begin_layout Standard
Represent values from disjoint domains as a single type
\end_layout

\begin_layout Standard
Use such values in collections safely
\end_layout

\begin_layout Subsection
Solved examples
\end_layout

\begin_layout Standard
Define a disjunctive type DayOfWeek representing the seven days.
\end_layout

\begin_layout Standard
Modify DayOfWeek so that the values additionally represent a restaurant
 name and total amount for Fridays and a wake-up time on Saturdays.
 
\end_layout

\begin_layout Standard
Define a function rootAverage:
\begin_inset space \space{}
\end_inset

RootsOfQuadratic 
\begin_inset Formula $\Rightarrow$
\end_inset

 Option[Double] that computes the average value of all real roots, returning
 None if the average is undefined.
\end_layout

\begin_layout Standard
Generate 100 random coefficients 
\begin_inset Formula $b$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

 (uniformly distributed between 
\begin_inset Formula $-1$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

) and compute the mean of rootAverage for them.
\end_layout

\begin_layout Standard
Implement def f[A, B]:
\begin_inset space \space{}
\end_inset

((Option[A], Option[B])) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Option[(A, B)] 
\end_layout

\begin_layout Subsection
Exercises
\end_layout

\begin_layout Standard
Define a disjunctive type CellState representing the visual state of one
 cell in the 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Minesweeper"
target "https://en.wikipedia.org/wiki/Minesweeper_(video_game)"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 game: A cell can be either closed, or display a bomb, or be open and display
 the number of neighbor bombs.
\end_layout

\begin_layout Standard
Define a function from Seq[Seq[CellState]] to Int, counting the total number
 of cells with 
\begin_inset Formula $0$
\end_inset

 neighbor bombs shown.
\end_layout

\begin_layout Standard
Define a disjunctive type RootOfLinear representing all possibilities for
 the solution of the equation 
\begin_inset Formula $ax+b=0$
\end_inset

 for arbitrary real 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

.
 (The possibilities are: no roots; one root; all 
\begin_inset Formula $x$
\end_inset

 are roots.) Implement the solution as a function solve1:
\begin_inset space \space{}
\end_inset

((Double, Double)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 RootOfLinear.
\end_layout

\begin_layout Standard
Given a Seq[(Double, Double)] containing pairs 
\begin_inset Formula $\left(a,b\right)$
\end_inset

 of the coefficients of 
\begin_inset Formula $ax+b=0$
\end_inset

, use solve1 to produce a Seq[Double] containing the roots of that equation
 when a unique root exists.
\end_layout

\begin_layout Standard
Define functions having these type signatures: 
\end_layout

\begin_layout Standard
def f1[A, B]:
\begin_inset space \space{}
\end_inset

Option[(A, B)] 
\begin_inset Formula $\Rightarrow$
\end_inset

 (Option[A], Option[B])
\end_layout

\begin_layout Standard
def f2[A, B]:
\begin_inset space \space{}
\end_inset

Either[A,B] 
\begin_inset Formula $\Rightarrow$
\end_inset

 (Option[A], Option[B])
\end_layout

\begin_layout Standard
def f3[A,B,C]:
\begin_inset space \space{}
\end_inset

Either[A, Either[B,C]] 
\begin_inset Formula $\Rightarrow$
\end_inset

 Either[Either[A,B], C]
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
now let's look at disjunctive types 
\end_layout

\begin_layout Plain Layout
and try to access this error value when actually I'm in the right disjunctive
 in the second part of the disjunctive because the error is not defined
 in this Cobra that I am just showing in the scope only the rest is defined
 so these case expressions have limited scope so this expression from the
 first case until the second it is one scope and within this scope the error
 variable is defined outside it is not defined and similarly for this so
 if we call this function on the value such as write 123 then this function
 will match the first case will not match so then the second case will match
 and the result will be returned so this will be the value it returns then
 the match is performed line by line so if the first line that matches gives
 you this expression and that's it not no further lines are evaluated so
 log error of left bad result will match this because it matches the symbol
 the left and then error will be the variable equal to the value of it will
 be equal to bad result and so it'll print got error bad result and then
 it will return -1 so case X Russians that choose among possible values
 of a given type when this type is a disjunctive and here is another way
 of using case expressions with types that don't look like a disjunctive
 like int where you say if so I say X which is an argument of this function
 X match and then I enumerate certain cases 0 1 and then all other cases
 so if if 0 does not match if one does not match then this case this line
 will be evaluated and then this pattern matches everything is just a variable
 so this rest will be equal to this X since we matched it and so then the
 same X will be returned so you could think about integers as a type that
 has different values like 0 1 and others there are possible values of this
 type and so you could use case expression also for those so case expression
 is not limited to disjunctive types or case classes integer is not defined
 as a disjunctive type because it has long parts of disjunctive but it has
 different values and so just to know to the similarity between this code
 and this code the case expressions in the partial function enumerate possible
 values of the function and so here also I'm not limited to just writing
 two cases lines here case left error case rightness I could write anything
 I want like for example case left and then empty string instead of error
 here and that will only match when X has that value left of empty string
 then on the next line I could say case left of something else and won't
 match only when X is net this is just to what you know that the case expression
s are more powerful than just matching the two parts of a disjunctive they're
 matching anything these patterns can have many conditions and this can
 be complicated so either is a example of disjunctive but there are more
 general disjunctives like for example well if I want to have a disjunctive
 between three different domains do I have to do either of either so that
 is not convenient now in in principle what I want is something like this
 I want to just say this type or this type or let's say this type or this
 type or this type this is a disjunctive I want to be able to define these
 junctions like this but Scala does not have this syntax there are some
 libraries like these libraries that provide syntax similar to this one
 but I don't want to go into these libraries that are more advanced right
 now I want to use the standard syntax in Scala which is sufficient for
 most purposes in the more ordinary applications of functional programming
 which is most of its applications today later I won't talk about those
 libraries and see what they offer but for now let's use the long syntax
 which is available in Scala and this is the syntax okay this is quite long
 to represent what I would ideally write like this if I if I compare this
 with that my type is a name of the type the type has disjunctive of three
 domains the first domain is a list of integers so the first domain here
 has a name all domains must have a name in the disjunctive is a label so
 here in this context the name would be implicit something like underscore
 one or something but in this syntax in the long syntax the domain has to
 be explicit so your name is have list int it has one part so it's a tuple
 of one with name have list int and the part is named X let's say then I
 have to write this keyword extends my type and in this way I say that this
 case class is part of a disjunctive which I'm going to define now so my
 type is the name of the entire disjunctive and these are the names of its
 three parts the labels and these are the names of the tuple parts so each
 domain is a tuple with names case class as I explained is a tuple with
 names so this disjunctive has two lists the names for everything for every
 part of the disjunctive and for every part of each tuple finally these
 keywords sealed final case class trait these keywords are necessary in
 Scala and what they do is they make sure that you cannot by mistake change
 this disjunctive later because that would be a difficult bug that some
 other part of the program changes this disjunctive and then adds some more
 stuff to it let's see some other domain and then your case matches stop
 working because you don't know that somebody added domains you have your
 case State case expressions like this pattern matching and you expect three
 domains in your disjunctive so you write it like this but somebody adds
 a different domain and this stops working this will crash if if that word
 if that happens so to prevent that you say that my trait called my type
 is sealed so no so only the ones the the domains of the disjunctive that
 are listed next to it in the file well not necessarily next day but in
 the same file only those exist and no others may be defined later at any
 time similarly the case passes are final so they cannot be extended later
 as the result the syntax is quite long you have to write a lot of stuff
 just to express this kind of disjunctive of three domains but you write
 it only once and using it is quite short is not so bad at all so for example
 first I create a value of this type so this could be a result of some computati
on with conditions if some condition holds then the values have socks with
 some socks values and otherwise it's have list int with some list int value
 so this is computed and then somebody wants to find out what that X was
 and they don't know this could be in a different part of the code and this
 could be even in a different library and so you have to match on the three
 domains of the disjunctive that's how you write it you put pattern variables
 in the case classes so these nine names don't have to be the same as these
 they can be for convenience but they don't have to be I'm just specifically
 selecting all different names just to show you that these are arbitrary
 names they don't have to be the same and then you write expressions here
 that will be evaluated in each of these cases and this expression for example
 is allowed to use this LST but not this and all that because the scope
 is is limited so the scope of definition of this LST is only this expression
 the scope of definition of pmq is only this expression if you try to use
 P and Q here the compiler would say cannot find symbol or something like
 that if very often used disjunctive type is called option here is how I
 would implement option in a very simple way it has a disjunctive of two
 domains one domain is a tuple with one element of type T or T is a type
 parameter and the second domain is a tuple of zero elements or unit type
 which is represented as a case object this is just a keyword in skeleton
 doesn't really mean anything different from a tuple with no elements or
 a unit type and you notice here it extends option with type parameter nothing
 nothing is a special type that has no values at all so this is used to
 signal that this is an empty tuple it does not have any values inside so
 we cannot use any type for parameter here but we must specify the parameter
 so we use this special type nothing all of this is defined in the standard
 library of skeleton nothing option some none so some and none are the two
 labels on the two domains of the disjunctive now in order to use it you
 do pattern match for instance like this here's a function that performs
 safe divided divides X by Y but your turns an option of double and so option
 list is a disjunctive and option parameterize by the type double is a disjuncti
ve of of either double or nothing so no value rather unit is the type or
 empty tuple if you prefer is a type that does not carry any value of type
 double in it and so here's how you define a function that computes this
 it checks the condition and if Y is 0 you return none which is this label
 otherwise you return value X divided by Y labeled by the name and a single
 Sun now the symbol is a label on the second part or here on the first part
 of the disjunctive and here's how I would use it so I would say safe divide
 one divided by Q maybe Q is zero maybe not but I then match so this returns
 an option of double I match the option with two cases some X and none so
 these are the two parts of the disjunctive and I mention them and so if
 I have some X then I multiply that some whatever previous result by that
 X and otherwise I returned previous result so this is a kind of a default
 value that I return when I don't get anything out of this function this
 function returns none which is a valid result of type option double mini
 Scala library functions return an option type such as find returns so find
 looks in a collection and returns an option if it found then it returns
 some of the value and if it did not find it returns none had option is
 the first element of the collection but if it's an empty sequence there
 is no head element no first element so it returns none otherwise it returns
 some with the value of the first element and similarly these primary functions
 which you can look up in the library or in IntelliJ these functions return
 option and the final note is that option has many functions or methods
 defined on it in a sense option is like a collection it's like sequence
 of tea so option of tea is very much like sequence of tea in terms of what
 you can do with it you can see with sequins you cannot do this match because
 sequence is not a disjunctive between nan and Sun but sequence has map
 flatmap filter exists and so on all of this is also defined on an option
 and you can understand this in a simple way if you imagine that the sequence
 is like a container and that sequence of tea is like a container where
 or let's say array of teas and another kind of sequence it's like a container
 where you have 0 or more elements of type T so this container holds values
 of type T it can can hold no values empty array or empty sequence or it
 could hold one value or two values and so on option is like a container
 that can only hold 0 or 1 values of this type T it cannot hold two so it's
 like a very limited sequence the sequence that can only be of length 0
 or 1 otherwise it looks like a sequence so it has a map a function flat
 map filter and so on so what for example it's a map on an option I will
 show you when we go through the worked examples how that works map on the
 collection let's say on array of integers you can do a map with a function
 that maps integers to strings say in some way and then you map and you
 get an array of strings where each element is transformed by that function
 option will behave in a very similar way you do a map with an option and
 every element in an option will be transformed using the function you specify
 however option can only contain at most one element so it can be empty
 which is this disjunctive part or it can be non-empty containing one element
 of type T one value of type T so it's kind of a very limited simple-minded
 collection but otherwise it's similar to collection we will see how that
 works in the examples so with the tools we just learned what problems can
 we solve we can represent values from disjoint sets or domains as a single
 type and we can use these values to define functions on them or functions
 producing them and use also these values in collections as elements of
 collections or in any other way we can these are types so there's no restrictio
n on how you can use them so let's go through some examples now the first
 example is to define a disjunctive type day of week it represents the seven
 days of the week let me go to this example so here's what it would look
 like so all these keywords here in IntelliJ you see in bold blue dark blue
 seal the trade final case object.extend so these are keywords of Scala and
 everything else is our labels that we introduced so day of week is the
 name of this entire type the entire disjunctive type it has seven domains
 and these domains don't carry any values so these are just empty tuples
 and the syntax for them is to say case object and then you don't you don't
 write this this is a mistake you should know right that empty tuple empty
 tuple is written like this indeed but you don't have to write it here so
 the syntax is such that you don't write it left so when you put a name
 on an empty tuple then it's called a case object and then you don't write
 parenthesis so here's how we define the type how will we use the type like
 this will define values a and B let's say of this type and assign these
 values so we define Monday and Saturday just like this we don't have to
 do anything else we don't have to say new new Monday there's no numa there's
 only one Monday because that's a label of the domain and a disjunctive
 is no no sense in that to say new Monday cannot have different Monday's
 they're all the same it's a label on the disjunctive now if I don't do
 this and just say well a eCos Monday then Scala will actually not know
 that I want a to be of this type color we'll think but it has typed Monday
 type so monday dot type is just ask our feature that I'm not going to use
 right now it is a more advanced feature so with these disjunctive types
 it is a good idea to write type annotations Scala it can be too smart about
 what I want to do and so it is better if I do this but it would not be
 an error if I did it that way if I put just any without type annotation
 probably my code was to work just some types will become weird now suppose
 I want to print now how to print this well actually case classes and case
 objects already have a two-string method defined on them so I can just
 print like this with string interpolation and this will run and I will
 get the string printed after we implement the function so that this test
 can pass so how do we implement this function this function is supposed
 to give us a boolean which is true when the day of the week of Saturday
 and false otherwise so we do this by pattern matching since the type is
 a disjunctive so we need to match on the label of the disjunctive or in
 the scala language we match on the case class or case object so we say
 Dean match and then you see there's this red case close as expected sure
 and then there's this thing which I can click it says generate case closes
 for variants of sealed type now in the scholarly in which this means this
 was a sealed trait that I defined and it has seven variants or disjoint
 domains in my understanding and so if I click this IntelliJ will fill in
 the code actually not sure why is doing it like this because it's from
 from another from from another example I guess it's a bit confused but
 it allowed me to delete what was not necessary so it generated most of
 the code so now I need to put the expressions that I'm going to return
 in each case so if this day is Saturday I need to return true otherwise
 I need to return false now there's a lot of I could say false false a lot
 of work like this so I'm going to be more clever and I'm going to do this
 and when it puts Saturday first and then if there is anything else I'm
 going to return false so let's say playing this so in this way I'm expressing
 my intention much more clearly so Saturday true I do otherwise anything
 else false so there's one little thing so this will work but we can run
 this test and this will work there's one little detail here so green notice
 what is printed E is Monday B is Saturday so this is the string that I
 printed here with interpolation so a was Monday and it can be it's already
 printable so this is a convenience that scholar gives now the little detail
 I was talking about is that intelligence says Declaration is never used
 so I declared the variable X but I never actually used it there's a syntax
 which looks like this it needs to be used in this case to make it more
 clear like I said this still works this is not a mistake to do a variable
 that you don't have to use a variable here and never actually included
 anywhere so to left it unused it's not a mistake but it is a little misleading
 because you're introducing a variable and so I'm looking for its use maybe
 I don't find one so this syntax means it's a very that matches anything
 just like X no conditions and on it variable watches anything and I don't
 need its name I'm not going to use that variable so the underscore in this
 situation means that it's a pattern variable that I'm not going to use
 so I don't need its name and it matches everything and my tests are that
 a and B so a was Monday B was Saturday they they pass let's go to the second
 example [Music] modified day a week so that the values additionally represent
 a restaurant name and total amount for Friday's and a wake-up time on Saturdays
 so what does it mean I want additional values on list on this disjunctive
 on on the domains in the disjunctive I want these domains to be not just
 empty tuples as I did before here but for Friday I want a domain that represent
s a string which is restaurant name and an amount paid so here's what I
 do i make Friday and Saturday case classes instead of case objects and
 then I am free to add parts in there with different types so field called
 restaurant name and type string and its own so I can do that and similarly
 for Saturday now I think I made I haven't finished this so this is supposed
 to be wake up time so I think I want to do a local date time from the Javadoc
 time library and that's a wake up time so this is it so basically I have
 easily added more data but only for these two days so these they still
 have no no data so if if the day of the week is Monday then I didn't go
 to restaurant and in pain thing and and so so now let's define some test
 data they have weakness Monday now if I want to define Friday as day a
 week then I have to specify the parts of this case class or the fields
 with names now here's what I'm doing is like this and now I have defined
 the value of type day of week I can still print it and then I want to define
 a function that will tell me how much I paid on a given day of the week
 now notice on those days I didn't pay anything on only a Friday okay because
 I go out so this function will return an option double and this option
 will be none or empty option for all the days except Friday because there
 is nothing to be paid and on Friday I will return this amount notice this
 is cleaner than returning zero for other days I could return just double
 here instead of option double and I hope with a subsidy a zero on those
 days but this is cleaner what if somehow the amount paid was zero for some
 reason let's say I went to restaurant and I had a coupon and I didn't have
 to pay anything I was free so my amount paid was actually zero but I did
 go to a restaurant so that information is not lost if I'm returning option
 double and if if I give Friday's day of the week I will get a non-empty
 option with a value of type double inside it and that value could be zero
 or anything else I don't use any special values to denote the absence of
 amount paid the type denotes it's the option type that's why it's so useful
 that's why it's used so much in the library let's implement this function
 again we do ng match and again I'm going to fill in and see what it tells
 me oh great this is because I have two different case classes and case
 objects and traits defined and with the same name in the same file so IntelliJ
 is a bit confused I have defined them in the scope of this test so they
 are completely safe and invisible in the other test but IntelliJ is not
 able to see that okay I'm just going to correct this by hand not a lot
 on work alright and Friday and Saturday are actually correct now all right
 so now if I'm on Friday case then I need to return some amount paid so
 sum is the constructor for the domain of option that is not empty so I
 call this a constructor because this looks like I'm calling a function
 which is called sum on a value so it's like a constructor and the word
 constructor will be used and quite frequently there's a type constructor
 and there is a value constructor let's talk about how to implement this
 function will discuss the Constructors later alright so in all other cases
 I have to return none so I have to return none here here okay I'm bored
 I don't want to write on this code so I say first case is return this and
 in every other case I don't know what that is I don't I don't need to know
 I returned on this is how I want to write it and also here this declaration
 is never used I'm going to put underscore so now this is how I would run
 the code also run this symbol to be nicer so I have a special intelligent
 shortcut to insert this symbol and the symbol is exactly the same as this
 combination so there's no difference it's just pure aesthetics I like this
 symbol this is the way to write this kind of code and it clearly says here's
 a disjunct into disjunctive domain which we match and specify different
 possibilities one possibility is that it's a Friday so sub domain of the
 disjunctive that is labeled as Friday with these two values in it and then
 I return that otherwise for any other domain I return them so let's run
 this test and see what it prints because we printed here Monday and Friday
 right so here's what it prints interesting a is Monday B is Friday of McDonald'
s and 23.14 so this is the way scallop Prince case classes this is the default
 way to print case classes so you don't have to write code for your own
 printing function or to string function the function to string is already
 defined in a reasonable way it may not be what you want to Princeton your
 users but for debugging - this is pretty good let us continue the next
 example is to define a disjunctive type roots of quadratic it represents
 real valued roots of the equation x squared plus bx plus c equals 0 for
 arbitrary real B&C and there are three cases no real roots two real equal
 roots two unequal real roots notice I make this quadratic equation non
 degenerate so that it always has the term x squared if I said ax squared
 plus BX plus C there could be a case when a is zero and then we'll have
 a linear equation so in this particular example I chose it to be like this
 for simplicity and then we want to implement a solve function solve to
 or solve quadratic which takes a tuple of two coefficients B and C and
 returns the this value of this disjunctive type which is a roots whatever
 situation of this it returns that value and that value represents a disjunctive
 of these three cases no real roots 2 equals 2 M equals and conceptional
 conceptually this is easy to think about you call this function you get
 the value and then you can imagine it and see what the situation is if
 you feel like it how do we implement that let's take a look so I define
 sealed straight roots of quadratic final case object no real roots extends
 the roots of quadratic so I say again all this all this final extends and
 sealed trait these are scholar keywords this is kind of verbose but you
 just only write this once for every disjunctive and you never look at this
 more than once so that's to me that's acceptable although I would prefer
 for example that everything is sealed by default and everything else gives
 me everything is final by default but I would prefer that that I don't
 have to say final all the time but it's okay it's not so bad for the value
 it gives us is that we can represent arbitrary disjunctives of types when
 this case case classes and other types so there are three domains in the
 disjunctive as we were over told no real roots and that has no values obviously
 no roots so we say this is an empty tuple and that is represented by a
 case object also this case object doesn't have to be a new keyword in principle
 so but that's what scholar requires just remember that this needs to be
 everything like that second domain is when the roots are equal then there
 is only one number to store and that number is X and so the third domain
 is when there are two unequal roots and when there are two numbers to store
 all right so we have defined a disjunctive type and now we define a function
 solve - it takes a tuple of its coefficients a B and C and returns the
 roots of quadratic so how does it work I always say we I chose this syntax
 just to be a little the pure side of things you know value I could say
 this is a well functions are values right so I could say this is a well
 since I don't have any type parameters here I can do it well if I had type
 parameters I would need to do a death alright as I say here okay so there's
 a Val the function takes a tuple of double double as its argument so what
 will define this function we say in case BC we we do a case because this
 is the way to use tuples as arguments in Scala so this is a syntax if I
 don't say case not sure it will be healthy so you see this function has
 only one argument this one argument has of it has type tuple of double
 double and so that's why I need to do a match on that one argument so I
 already need a match right right here okay so here's what I do my B and
 C are these two coefficients so I determine the discriminant and if it's
 greater than 0 then I have two different roots which are given by this
 well-known formula and then so I just for clarity I define names x1 and
 x2 temporarily and return to roots X 1 St here if discriminant is zero
 I don't need to define any names temporarily it's too easy to not say just
 equal root of minus B over 200k in here I could also put these two expressions
 directly into the constructor of two roots case class but this is more
 clear in this clearer in this in this way finally if the discriminant is
 negative there are no real notes so in this way I return a value of this
 type I construct this value as an element of one of the three possible
 domains each domain having its own values in there so this is a disjunctive
 of empty to pull to pull of one and tuple of two but I put names on them
 so now it's much more readable it's clear what I'm doing and easy to check
 for mistakes so let's now check that this works so here's what I do i define
 a sequence of tuples just so that i can check at once [Music] all these
 equations so this is the equation x squared minus 2x plus 1 equals 0 so
 this equation has a double root X equal 1 obviously now this equation is
 x squared plus X plus 1 equals 0 and it has no reloads its roots are complex
 this equation is x squared minus X still to come zero it has two real roots
 different two different railroads so in this way I check all three possible
 domains and all three possible cases and so I have a sequence of these
 three two bulls and I map over the sequence with the functions of two which
 takes a tuple and returns roots of connecticut the result is a sequence
 of roots of contradict so then I check that the sequence is equal to what
 I expect the first one has roots only one root x equals one the second
 one has no real roots a third one has two different real roots so that's
 test passes and it shows that we have implemented our function correctly
 now notice that this function returns a value doesn't bail out or generate
 errors it always returns a value this value has three different domains
 in some domain there's no result another domain there's some result so
 this is the way to have deal with complicated logic and complicating domains
 in functional programming your model is domain with types so you make a
 type that represents everything you want to say as much as possible and
 then you write code with it so you see it's quite easy to write code with
 this there are no special values there is no flag boolean flag that would
 be true or false when you have roots or you don't have words you don't
 do any of this it's much more visual and clear when your code exactly says
 what's happening there are no hidden flags hidden special values this is
 the advantage of using disjunctive types actually this is one of the main
 advantages over using some other methods of representing complicated data
 next example is that we want to define a function called route average
 which is from roots of quadratic in to option double that computes the
 average value of all real roots returning none if the average is undefined
 so it means if there's no roots that we return otherwise we return the
 average problem so how do we implement this the test is already written
 so for example route average of this should be 0 son 0 so it's option right
 so a non empty option has the form some zero empty option has the firm
 none so these are the two domains of the option and so you you have to
 always have to write the sum and this none this is a bit verbose if you
 have a lot of those values but you need to think about how to reduce the
 velocity but you always have to write specific values like this if you
 have equal roots then average is the same as this one value otherwise you
 get none so how do you implement well you say roots and then you say generate
 case closes I'm just lazy and then clearly if we are in this domain then
 it's not here it is some X there the sum of x + y / - not that we're done
 no way to make a mistake you see your boolean Flags - check nothing no
 way to make a mistake very safe code finally what do we do now we generate
 100 random coefficients B and C and compute the mean of Route average for
 all of them let's do that so first we make a function get random that generates
 a random number so let's say between minus 1 and the one who generates
 a uniformly distributed random numbers for simplicity and we prepare a
 sequence of coefficients by filling 100 random numbers now each get random
 will be a new number it is actually good style in Scala to make these functions
 syntactically different from values so that you see that this function
 actually computes something new every time it's not just a value because
 I could I could call this random could you name it and then if I don't
 write these parentheses then it looks like a value it looks like it's going
 to be the same every time but it's right now it's not a new random number
 so to emphasize that the style convention often in Scala is that you do
 the empty parenthesis just kind of a function of 0 arguments which you
 can also think of a function of an empty tuple as an argument but in Scala
 is actually different you have functions with zero arguments in Scala which
 are different from functions of single argument that's an empty tuple Scala
 is a bit redundant in this way and this is because it has to maintain compatibi
lity with Java but is never a big problem so the syntax helps if you use
 it in a way that is suggestive so we make these coefficients we get a sequence
 of random numbers and then we map over the sequence with the functions
 of two that we implemented just previously the result will be a sequence
 of this roots of quadratic that we have so each element of the sequence
 could have different configuration of roots in or roots at one or two rows
 and it's all in this type because this is a disjunctive tab now we compute
 averages so solutions we map over that sequence with root n rooster remember
 the function wrote average takes roots of quadratic and returns option
 double so when we map with this function over sequence of roots of quadratic
 we get a sequence of option double each element being transformed now that's
 not what we want though we now we want to compute average of the sequence
 but it's a sequence of option double so some of them are none some of them
 are not known how do we get all the ones that are not none to take the
 average of them so I will show you several attempts to do that in the first
 attempt is to filter the averages by retaining those that are not null
 no not none so we do this with a filter with this matching expression which
 is actually working but it still gives you a sequence of option of double
 it does not eliminate the option type and that's kind of bothersome so
 there are two ways in which you can do it more easily and more safely one
 way is to use this flatten function on sequence so it's a special case
 when you have so flattened usually what it does is that you get from a
 sequence of sequences you get the sequence so usually for example so usually
 the sequence of sequence of T and you get from it sequence of T but also
 it works with sequence of option of T and you get from it sequence of T
 so this usually what flattens do is just flatten does is just every sequence
 here is concatenated and you get one big sequence now if you think that
 option is like a sequence of at most one element you can do the same operation
 you can concatenate all those options that are not empty discard those
 that are empty and you get a sequence so that's what flatten does and that's
 exactly what we need to do here we have a sequence of optional double and
 we need to discard those that are empty and get a sequence of double as
 a result so that's what flattening does as another way of achieving the
 same result is to use the collect function collect function is quite useful
 because you can do partial function here and match and transform things
 and transform types also so here I transform type so this is an option
 type option of double and this is double so I have transformed the type
 and the collect function will check that this case actually matches and
 four empty options it will not match and they will be discarded so that
 is how these functions work very useful functions in this case flatten
 would be my preferred option my preferred way of implementing it because
 it is shorter and very clear I just want to discard all know all empty
 options and that's what flatten does but if I have some more complicated
 transformation discarding some elements while transforming others and flatten
 is only defined for this special case sequence of option for example flatten
 is not defined for an option of sequence or for some others such things
 then I use collect so but anyway we can run this test now and either result
 one or result two will compute exactly the same thing [Music] let's see
 what is Prince for yeah interesting some interesting number every root
 fine so this is our result the final worked example for this tutorial is
 slightly different so far we have been computing things now we want to
 implement a function with a fully parametric type which is given like this
 what does this function do it takes a tuple of two options and returns
 an option of a tuple now actually I forgot the double parenthesis in this
 type signature this must be double parenthesis and in my code I believe
 it is like here a a function that takes a tuple you must have double parenthesi
s because in scala the syntax is that the first pair of parenthesis designates
 the arguments of the function so we can have one or more arguments and
 each argument could be a tuple or not also so if you have just one argument
 that's a tuple and you must do this double parenthesis so I should have
 done it here too I will check I will correct this in my slides let's look
 at the implementation so I start with a test so if I had such a function
 of type two co-option int option string let's say into option of tuple
 in string how would I check that this works correctly for example if both
 options are non-empty then I want to return a non-empty option of the of
 the pair but if if just one of them is empty I cannot return the pair I
 cannot have a pair because I don't have the other value and so I must return
 none for the entire option of tuple so this is the only way that this function
 can work and this test then checks that this is so so it returns none in
 all cases except when both of these options are non empty so here's the
 implementation one implementation of this function what's reason about
 it to see how this implementation can be new right well firstly we say
 they said these are the two arguments so let's match on the first argument
 the matching of the argument has let me delete this perhaps and write the
 code again by reasoning about what needs to be done so obviously maybe
 a is a option of a sec maybe is a empty option maybe not empty so maybe
 we have a name will be not so we need to match to do the case closes I
 generate them so then let me call this a just for clarity okay so now I
 have two cases either a is non-empty or NES empty if it is empty I know
 what to do there is nothing else to do except to return empty option of
 this type because if I were to return non-empty option of this type I would
 have to supply both a and B but I don't have B sorry I don't have a my
 a option is empty there is no way for me to get an a value of type a because
 I don't know what that type is I'm not given a value of type a and I cannot
 create it from nothing so I must return none in case that the option a
 is non-empty I have hope that maybe also B is present so let's see if that
 is so we'll be dimensional let me again generate cases so it calls value
 B all right so if B is present then I can actually return a and B in the
 tuple so I'm supposed to return an option of tuple and so I return non
 empty option some with tuple as the value and here I again must return
 none there's no away so basically my implementation is more or less fixed
 except that of course I could return none here as well and the type would
 be still correct it will be a very uninteresting implementation but always
 returns none whatever the arguments and this the only interesting implementatio
n is this one now by interesting what I mean is if does not discard all
 the information in the arguments it discards some sometimes some information
 sometimes but it doesn't always discard everything so this implementation
 is is non-trivial and it's the most information preserving one and therefore
 the most interesting now this code actually it is correct I have tests
 below that call my check function on this one so I can check that this
 is correct but this is verbose all this match case and then case none goes
 to none case Nando's no all of that is quite verbose and if I wanted to
 modify logic here I would have to modify a lot of things so remember that
 option is like sequences it has a map function defined on it you have map
 method I use the word method and function interchangeably not in scholar
 there is a difference methods are those things defined with the syntax
 in a class and functions are values of function type that cannot be used
 with this syntax again this is a legacy of Java Java does not does not
 have functions at all it only has methods so Scala must have methods too
 and yet scholar wants to have functions function values so this is a compromise
 we have both in Scala have methods and we have functions for the purposes
 of functional programming methods are just like functions so I use the
 words functions and methods interchangeably it's just that this syntax
 must be different if map were a function not a method then the syntax would
 be map both you may be a F something like that and it's exactly similar
 map logically speaking has two arguments maybe a and F but the syntax is
 that map is written in between with the daughter actually there is an alternati
ve syntax like this without without Dalton without parentheses but I don't
 like that syntax so much sometimes I use it but only when it is really
 in easy to read and what's happening so let me remove this what I wanted
 to show it is that this code is so common and it's exactly equivalent to
 this code if you have the school that matches on the option so maybe a
 this option some type and you imagine it and if it's not empty then you
 return the non-empty option with some transformed value and if it's empty
 or returned empty this is exactly the same as doing a map on a collection
 if a collection is empty you return an empty collection again and if it's
 not empty then you take each element and you transform it with the function
 and then you return a collection having those transformed elements an option
 being a collection with just one element only needs one such transformation
 to be performed at most and so this code is exactly the same as this code
 so let's take that code and simplify it instead of maybe be match we just
 have now we can write let me write this as a comment so this actually let
 me let me copy the entire piece that I'm going to simplify and do it step
 by step looking at this template here so whenever I have this pattern sum
 of X going to sum of f of X not going to none I just do a map so I have
 this pattern right here maybe be not just like that so instead of this
 I say maybe B dot map and then the function is from B to the tuple a B
 and that takes care of this thing so now the code is much shorter it has
 this shape and it's but it still has the same pattern match son to their
 son and or to option none - none so let's do maybe a dot map and then a
 going to this so the entire code was replaced by this does it actually
 work so let's go and see what happens with this implementation which I
 called f2 well where I wrote what we just saw maybe a dot map it's going
 to maybe be that map why going to tuple x1 exactly what we ended up with
 you know after renaming of variables let me remove that now actually it's
 not quite right because the type of this thing is option of option of a
 b c this.type is option after mapping we have an option and then this has
 a type a so we map X of type a into an option of something and the result
 is going to be option of option let me write a comment explaining how this
 happened I have option of a then I do map with a function that goes from
 a to optional B or action of tuple a B and the result is going to be C
 this a is going to be replaced by this through the map function so result
 is going to be the type option of option of a B and that's what IntelliJ
 tells us if I delete this that's what it knows the type is so we need to
 transform this to an ordinary option how do we transform well this is the
 whole whole logic here if both of them are non empty only then we'll get
 a non empty option at the end so that is what flatten does a collection
 of empty collections gives you an empty collection after flattening so
 we just use and that's it now that works so that's a valid way of doing
 it but it's not the best because there's this pattern which is map followed
 by flatten and this pattern also seems to be very very often used and so
 in the standard library there is a method called flat map which is the
 same as map followed by flatten and so actually the code that you could
 write would be this now it is it is questionable whether this code is easy
 to read or easier to read than this I would actually say this code is a
 little easier to read because of things in app and happened here's a flat
 map and map there are other ways of making this much easier to read and
 to write which I'll talk about later this is the for yield block notation
 but for now it is important right all of these things by hand all of the
 maps flat maps and so on and to follow the types follow to see how the
 types are transformed IntelliJ sometimes gives you help here for example
 I tell if I press command and then hover my mouse over symbols it gives
 me some information about their types and definitions so it tells me that
 for example this is an option of being this is a map that takes a function
 and returns an of option of B and [Music] these types are not always clear
 here what is this 8 to be for example b2b I'm not sure what ageism not
 be is this oops this is certainly a contrived example of such a function
 but is this type a please this type B but actually this is not the types
 we're using we're using option a and so on so IntelliJ is not always right
 when you do this on the map but tell J is right when you do control shift
 p1 symbols so that for example is always right what option B so to make
 a long story short you need to start with code like this and then simplify
 it and make it shorter and then gradually you will start thinking in terms
 of these map flatmap and so on so that it is much easier for you to think
 in terms of transformations on an option collection and so on rather than
 transformations done on individual elements it's very important to follow
 how types change so let me let me try to rewrite this function in in a
 longer fashion here and this is what you might do initially when you start
 learning about functional programming code like this is very short it is
 not very readable so what you can do is you can say first of all you can
 make these functions multiline by putting curly braces around them and
 then you can introduce intermediate values for example Wow C equals this
 and then you return C it's the same right you call this value C and right
 away that is your expression but now you can see what type it is so it's
 option LV and you do option return like click on the keyboard to add the
 type annotation and so it tells you that this is actually an option of
 a B that information was not obvious here when you look at this code but
 you can make this easier for me to understand so first maybe B has type
 option of B you map it like this and it becomes option of a B maybe what's
 what's rename this X into a and that's why into B so that it becomes easier
 to read and then also here you are not sure what are you what your return
 it but flat map tells you flat map takes a function from a to option B
 returns option B well actually this is confusing because your B is not
 therapy so there be here is defined in the standard library somewhere it's
 not your B so the definition of flat map is this there's some be here there's
 some a here it's not what you wanted it's not your B and what your a so
 that is a bit confusion so let's do the same trick here well result equals
 this return result and now let's add a type annotation to this okay so
 now if you didn't do flat map let's remove this type annotation and add
 it again you could do control shift P to see what it is or you can just
 put it into the code to document that you at this point you got a gallery
 of this type so these transformations each of them will change the type
 of values and it's nice to see what type it is to check that that's exactly
 what you want now obviously we want an option of a B and not an option
 option of a B so we need to flatten it so now let me see what that is so
 in this way you can go step by step within each of these transformations
 and see what types then generate and having if you have done this enough
 times initially it will take time and you you have many steps and at the
 end you will see it becomes easier so here are some more exercises for
 you to work with disjoint disjunctive types case classes and collections
 of them and implement some functions like like these also with fully parametric
 types and so these functions are usually obvious what is meant so for example
 option of a pair goes into a pair of options obviously this option is empty
 then you must return to empty options here and if this option is not empty
 then it makes sense to return to non-empty options in order to maximize
 information and similarly here for either if you have either of a B that
 could be a and then you can return here and non-empty optional a but you
 must return empty option of B and vice versa in order to not lose information
 and in this example also if you have either a either B C so for example
 you could have a and then what they return while you return the left version
 of either and the left version of this either with a inside so in this
 way you can always see what kind of value it makes sense to return in order
 to not lose information good luck with these exercises 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Disjunctive types as mathematical sets
\end_layout

\begin_layout Standard
To understand the properties of disjunctive types from the mathematical
 point of view, consider a function whose argument is a disjunctive type,
 such as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def isDoubleRoot(r: RootsOfQ) = ...
\end_layout

\end_inset

The type of the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r:RootsOfQ
\end_layout

\end_inset

 represents the mathematical domain of the function, that is, the set of
 admissible values of the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

.
 We could imagine a function on a 
\emph on
disjoint
\emph default
 domain, for example 
\begin_inset Formula $r$
\end_inset

 is either a point on a line or a point on a surface, where the surface
 is completely different from the line.
 Such domains are called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
disjoint domain
\end_layout

\end_inset

disjoint
\series default
 because the line and the surface have no common points.
 
\end_layout

\begin_layout Standard
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
begin{pdfpic}
\end_layout

\begin_layout Plain Layout

%   
\backslash
psset{unit=
\backslash
linewidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{pspicture}(0,0)(10,10)
\end_layout

\begin_layout Plain Layout

      
\backslash
psline(2,2)(2,8)
\end_layout

\begin_layout Plain Layout

      
\backslash
pspolygon(8,8)(8,3)(7,2)(7,7)(8,8)
\end_layout

\begin_layout Plain Layout

   
\backslash
end{pspicture}
\end_layout

\begin_layout Plain Layout

%
\backslash
end{pdfpic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Disjoint domains are not often used in mathematics, but they are frequently
 needed in software engineering because real-life data often comes from
 disjoint domains.
 
\end_layout

\begin_layout Standard
I just gave you examples on the previous slide so how would we do a disjoint
 domain between line and surface let's say line is the real numbers and
 surfaces are part two the real plane so in functional programming the way
 it's done is that the domains are labeled so we introduce some fixed special
 set of symbols with which are labels like left Android's say these are
 just symbols that come from a fixed set of symbols and then we first make
 two sets the first set will be a set of pairs where the first element of
 the pair is the symbol left and the second element of the pair is some
 real number so this set is a set of all such pairs and this set is a set
 of all different pairs where the first element is a symbol right and the
 second element is some point from a surface from r2 and then make union
 of these two sets now this is a labeled union because each set has this
 label and so there's no way that any even if this were our and this were
 also our there will be no way to confuse an element from the left part
 of the union and lanolin from the right part of the Union and so the disjoint
 union is always an exclusive or it's never inclusive or it could be couldn't
 be both from here and from here because the symbols are different so given
 any such X from this set from this entire set we can always determine by
 looking at the first element of the pair from which side it comes and we
 therefore can obtain and know what is the type of the corresponding other
 value in each case so there is no confusion if we label the two parts of
 the Union even if all these types are worth the same with this where artists
 were also her will still be no confusion whereas a ordinary mathematical
 Union you would be confused you would think well our union ours just are
 so but disjoint Union is labeled and allows you to always know from which
 part you come from that from which parts the value comes so in Scala this
 kind of type is disjoint Union or exclusive or between two domains it's
 denoted like this so it's special library you find a special type defined
 in the library called either it has two type parameters describing the
 two domains the first let's say double that's a describing this and second
 is a tuple of two doubles which describes the so this was a very close
 analogy with a mathematical disjunctive between the two domains and as
 I just said domains in mathematics corresponds to types of variables in
 programming in functions so types of variables is exactly the same as a
 set from which the variable comes so like X comes from the set of real
 numbers and here double is a type that approximately represents real numbers
 and pattern matching is used to define expressions with such types so let's
 look at examples with either so we were looking before at a situation when
 we wanted to generate error messages with computation and so let's suppose
 we have a function that needs to return an integer but may actually have
 an error and so it turns this type either of string and integer which is
 a disjunctive between two domains the first is the set of all strings the
 second is the set of all integers and it is labeled by symbols left and
 right these symbols also come from the skull a standard library now if
 we have a function let's say log error we want to write this function that
 takes an argument of this type how can we construct an expression using
 this type and here's how we say X match this is keyword match so say X
 match and then you write this partial function which matches against possible
 values of X and there are two cases the left having an error value which
 is of type string and the right having a result value which is of type
 integer in both cases we can specify what needs to be done or rather the
 expression that needs to be computed well we can print of course but we
 need to return a value and this function must return integer value so let's
 return some integer value or not and then the result now this is just an
 example now how can we interpret this code what does it mean case left
 error case right result it means these are actually possible values of
 this type so this and this are specific possible values of this type remember
 that we have this labeled disjunctive so this is a possible value with
 symbol left and a number and so similarly here a symbol left which is the
 name of the case class this is just a symbol it is not itself a value it's
 it does not give you a value until you give it this the the string and
 so left of blah is actually a value of type either string int and similarly
 right of one two three is also a possible value of this type so in this
 for in this code we enumerate the possible cases the disjunctive there
 are only two cases in this disjunctive the left and the right and so we
 enumerate them and each time we have a pattern variable of a different
 type because if we are in the left case of disjunctive when the error is
 of string type this pattern variable we could have called it X or Y or
 whatever it's just a pattern variable and it's introduced right here and
 it only is visible within the scope of this expression so here we cannot
 have access to error if you want to here if I cannot make a mistake 
\end_layout

\begin_layout Standard
The type of the function's argument represents the function's 
\emph on
domain
\end_layout

\begin_layout Standard
For example: 
\begin_inset Formula $f(x)$
\end_inset

 where 
\begin_inset Formula $x\in\mathbb{R}$
\end_inset

 
\end_layout

\begin_layout Standard
We would like to be able to represent arbitrary 
\emph on
disjoint
\emph default
 domains
\end_layout

\begin_layout Standard
For example: 
\begin_inset Formula $x$
\end_inset

 is either a point on a line or a point on a surface
\end_layout

\begin_layout Standard
In functional programming, the disjoint domains are always 
\series bold
labeled
\end_layout

\begin_layout Standard
For example: 
\begin_inset Formula $x\in\left(\text{left},\mathbb{R}\right)\cup\left(\text{right},\mathbb{R}^{2}\right)$
\end_inset


\end_layout

\begin_layout Standard
The disjoint union is always an 
\emph on
exclusive-or
\end_layout

\begin_layout Standard
Labels come from a fixed, special set of symbols
\end_layout

\begin_layout Standard
Given any such 
\begin_inset Formula $x$
\end_inset

, we can determine its 
\begin_inset Quotes eld
\end_inset

side
\begin_inset Quotes erd
\end_inset

 of the union
\end_layout

\begin_layout Standard
We can obtain the corresponding value in each case
\end_layout

\begin_layout Standard
In Scala, this type is denoted 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Double, (Double, Double)]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Disjunctive types in other programming languages
\end_layout

\begin_layout Standard
Disjunctive types (and the associated pattern matching) turns out to be
 one of the defining features of functional programming languages.
 Programming languages that were not designed for functional programming
 do not support this feature, while ML, OCaml, Haskell, F#, Scala, Swift,
 Elm, and PureScript support disjunctive types as part of the language design.
 
\end_layout

\begin_layout Standard
It is remarkable that the tuple types (or 
\begin_inset Quotes eld
\end_inset

records
\begin_inset Quotes erd
\end_inset

) are present in almost every programming language, while disjunctive types
 are absent except in languages specifically designed for the functional
 programming paradigm.
\end_layout

\begin_layout Standard
A future version of Scala 3 will have a short syntax for disjunctive3 types:
\end_layout

\begin_layout Standard
type MyIntOrStr = Int | String
\end_layout

\begin_layout Standard
more generally, type MyType = List[Int] | (Int, Boolean) | MySocks
\end_layout

\begin_layout Standard
Some libraries (scalaz, cats, shapeless) also provide shorter syntax
\end_layout

\begin_layout Standard
For now, in Scala 2, we use the 
\begin_inset Quotes eld
\end_inset

long syntax
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
(specify names for each case and for each part, use 
\begin_inset Quotes eld
\end_inset

trait
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

extends
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
sealed trait MyType
\end_layout

\begin_layout Standard
final case class HaveListInt(x: List[Int]) extends MyType
\end_layout

\begin_layout Standard
final case class HaveIntBool(s: Int, b: Boolean) extends MyType
\end_layout

\begin_layout Standard
final case class HaveSocks(socks: MySocks) extends MyType
\end_layout

\begin_layout Subsection
Disjunctions and conjunctions in logic
\end_layout

\end_body
\end_document
