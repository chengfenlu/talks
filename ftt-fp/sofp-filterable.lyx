#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.0pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

\usepackage{CJKutf8} % For occasional Chinese characters. Also, add "russian" to documentclass.
\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.44in
\paperheight 9.68in
\leftmargin 2cm
\topmargin 1.1cm
\rightmargin 1.5cm
\bottommargin 1.75cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Success,Failure,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Computations in functor blocks.
 I.
 Filterable functors
\end_layout

\begin_layout Section
Slides
\end_layout

\begin_layout Subsection
Computations within a functor context
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula 
\[
\sum_{x\in\mathbb{Z};\:0\leq x\leq100;\:\cos x>0}\sqrt{\cos x}\approx38.71
\]

\end_inset

Scala code:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
(0 to 100).map(math.cos(_)).filter(_ > 0).map(math.sqrt).sum
\end_layout

\begin_layout Standard
Using Scala's 
\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
yield
\family default
\size default
\color inherit
 syntax (
\begin_inset Quotes eld
\end_inset

functor block
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
 comprehension
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
(for { x 
\begin_inset Formula $\leftarrow$
\end_inset

 0 to 100
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    y = math.cos(x)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    if y > 0
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  } yield math.sqrt(y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
).sum
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
(0 to 100).map { x 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   math.cos(x) }.filter { y 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   y > 0 }.map { y 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     math.sqrt(y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  }.sum
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Functor block
\begin_inset Quotes erd
\end_inset

 is a syntax for manipulating data within a container
\end_layout

\begin_layout Standard
Container must be a functor (has 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 such that the laws hold)
\end_layout

\begin_layout Standard
Data changes but remains within the same container 
\end_layout

\begin_layout Standard
A 
\series bold
filterable functor
\series default
 is a functor that has a 
\family typewriter
\size footnotesize
\color blue
withFilter
\family default
\size default
\color inherit
 method
\end_layout

\begin_layout Standard
Can use 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
if
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 when 
\family typewriter
\size footnotesize
\color blue
withFilter(p:
\begin_inset space \space{}
\end_inset

A
\begin_inset Formula $\Rightarrow$
\end_inset

Boolean):
\begin_inset space \space{}
\end_inset

F[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 F[A]
\family default
\size default
\color inherit
 is defined
\end_layout

\begin_layout Standard
What are the required laws for 
\family typewriter
\size footnotesize
\color blue
withFilter
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Standard
What data types are filterable functors?
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Filterable functors: Intuitions I
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Itemize
Consider these possibly useful properties of containers 
\begin_inset Formula $C^{A}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Can create an empty container
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{empty}^{A}:1\Rightarrow C^{A}$
\end_inset

 – 
\series bold
fillable
\end_layout

\begin_layout Itemize
Can create a container that holds a given value
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{wrap}^{A}:A\Rightarrow C^{A}$
\end_inset

 – 
\series bold
pointed
\end_layout

\begin_layout Itemize
Can extract an element from container
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{get}^{A}:C^{A}\Rightarrow A$
\end_inset

 – 
\series bold
co-pointed
\end_layout

\begin_layout Itemize
Can extract an element safely (even if the container is empty)
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{toOption}^{A}:C^{A}\Rightarrow1+A$
\end_inset

 – 
\series bold
extractable
\end_layout

\begin_layout Itemize
Can select element(s) satisfying a condition
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{withFilter}^{A}:C^{A}\Rightarrow\left(A\Rightarrow\text{Boolean}\right)\Rightarrow C^{A}$
\end_inset

 – 
\series bold
filterable
\end_layout

\end_deeper
\begin_layout Itemize
to formulate such properties, use fully type-parametric functions
\end_layout

\begin_deeper
\begin_layout Itemize
note: 
\begin_inset Formula $\text{Boolean}\equiv1+1$
\end_inset


\end_layout

\begin_layout Itemize
all functions have the form 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 with some functors 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
functions of this sort are called 
\series bold
natural transformations
\end_layout

\begin_layout Itemize
parametricity (naturality) is the property that holds automatically for
 all such functions
\end_layout

\end_inset

Intuition: the 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 call 
\emph on
may decrease
\emph default
 the number of data items held
\end_layout

\begin_layout Standard
a filterable container can hold 
\emph on
more or fewer
\emph default
 data items of type 
\begin_inset Formula $T$
\end_inset


\end_layout

\begin_layout Standard
Examples:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Option[T]
\family default
\size default
\color inherit
 
\begin_inset Formula $\equiv1+T$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Some(123).filter(_ > 0)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
Some(123)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Some(123).filter(_ == 1)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
None
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Some(123).withFilter(_ == 1).map(identity)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
None
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
List[T]
\family default
\size default
\color inherit
 
\begin_inset Formula $\equiv1+T+T\times T+T\times T\times T+...$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
List(10, 20, 30).filter(_ > 10)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
List(20, 30)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
List(10, 20, 30).filter(_ == 1)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
List()
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
What we learn from these examples:
\end_layout

\begin_layout Standard
The data type must contain a 
\emph on
disjunction
\emph default
 having different counts of 
\begin_inset Formula $T$
\end_inset


\end_layout

\begin_layout Standard
When the predicate 
\family typewriter
\size footnotesize
\color blue
p
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
false
\family default
\size default
\color inherit
 on some 
\begin_inset Formula $T$
\end_inset

 values, the remaining data goes to a part of the disjunction that has fewer
 
\begin_inset Formula $T$
\end_inset

 values
\end_layout

\begin_layout Standard
Values 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 are 
\emph on
algebraically
\emph default
 replaced by 
\begin_inset Formula $1$
\end_inset

 (a 
\family typewriter
\size footnotesize
\color blue
Unit
\family default
\size default
\color inherit
) when 
\family typewriter
\size footnotesize
\color blue
p(x) = false
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
The container can become 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 as a result of filtering
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Examples of filterable functors I
\end_layout

\begin_layout Standard
Consider these business requirements:
\end_layout

\begin_layout Standard
An order can be placed on Tuesday and/or on Friday
\end_layout

\begin_layout Standard
An order is approved under certain conditions (amount < $1000, etc.)
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
final case class Orders[A](tue: Option[A], fri: Option[A]) {
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  def withFilter(p: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Boolean): Orders[A] = 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
    Orders(tue.filter(p), fri.filter(p))
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Orders(Some(500), Some(2000)).withFilter(_ < 1000)
\end_layout

\begin_layout Standard

\family roman
\size footnotesize
\color darkgray
// returns 
\family default
Orders(Some(500), None)
\family roman
 – see example code
\end_layout

\begin_layout Standard
This functor type is written as 
\begin_inset Formula $F^{A}=(1+A)\times(1+A)$
\end_inset


\end_layout

\begin_layout Standard
When a value does not pass the filter, the 
\begin_inset Formula $A$
\end_inset

 is replaced by 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Standard
Filtering is applied independently to both parts of the product type
\end_layout

\begin_layout Standard
What if additional business requirements were given:
\end_layout

\begin_layout Standard
(a) both orders must be approved, or else no orders can be placed
\begin_inset Newline newline
\end_inset

or
\end_layout

\begin_layout Standard
(b) both orders can be placed if at least one of them is approved
\end_layout

\begin_layout Standard
Does this still make sense as 
\begin_inset Quotes eld
\end_inset

filtering
\begin_inset Quotes erd
\end_inset

?
\end_layout

\begin_layout Standard
Need mathematical laws to decide this
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Filterable functors: Intuitions II
\end_layout

\begin_layout Standard
Intuition: computations in the functor block should 
\begin_inset Quotes eld
\end_inset

make sense
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
we should be able to reason correctly by looking at the program text
\end_layout

\begin_layout Standard
A schematic example of a functor block program using 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
for { 
\family roman
\color darkgray
// computations lifted into the 
\family default
List
\family roman
 functor
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  x 
\begin_inset Formula $\leftarrow$
\end_inset

 List(...) 
\family roman
\color darkgray
// the first line has 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\leftarrow$
\end_inset


\begin_inset Quotes erd
\end_inset

, other lines do not
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  y = f(x) 
\family roman
\color darkgray
// will become a 
\begin_inset Quotes eld
\end_inset


\family default
map(f)
\family roman

\begin_inset Quotes erd
\end_inset

 after compilation
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  if p1(y) 
\family roman
\color darkgray
// will become a 
\begin_inset Quotes eld
\end_inset


\family default
withFilter(p1)
\family roman

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  if p2(y)
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  z = g(x, y)
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  if q(x, y, z)
\family roman
\color darkgray
 // – more conditions, etc.; see example code
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
} yield 
\family roman
\color darkgray
//  for all 
\family default
x
\family roman
 in list, such that conditions hold, compute this:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  k(x, y, z) 
\family roman
\color darkgray
//  all the new values will stay within the container
\end_layout

\begin_layout Standard
What we intuitively expect to be true about such programs:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
y = f(x); if p(y);
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size footnotesize
\color blue
if p(f(x)); y = f(x);
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
if p1(y); if p2(y);
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size footnotesize
\color blue
if p1(y) && p2(y)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
When a filter predicate 
\family typewriter
\size footnotesize
\color blue
p(x)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
true
\family default
\size default
\color inherit
 for 
\emph on
all
\emph default
 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
, we can delete the line 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
if p(x)
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 from the program with no change to the results
\end_layout

\begin_layout Standard
When a filter predicate 
\family typewriter
\size footnotesize
\color blue
p(x)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
false
\family default
\size default
\color inherit
 for some 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 then
\emph on
 that
\emph default
 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 will be excluded from computations performed after 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
if p(x)
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Examples of filterable functors II: Checking the laws
\end_layout

\begin_layout Standard
Properties 1 – 4 are expressed as laws for 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit

\begin_inset Formula $^{(p\Rightarrow\text{Boolean})\Rightarrow F^{A}\Rightarrow F^{A}}$
\end_inset

:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{fmap}\,f^{A\Rightarrow B}\bef\text{filter}\,p^{B\Rightarrow\text{Boolean}}=\text{filter}\left(f\bef p\right)\bef\text{fmap}\,f^{A\Rightarrow B}$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{filter}\,p_{1}^{A\Rightarrow\text{Boolean}}\bef\text{filter}\,p_{2}^{A\Rightarrow\text{Boolean}}=\text{filter}\left(x\Rightarrow p_{1}(x)\wedge p_{2}(x)\right)$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{filter}\left(x^{A}\Rightarrow\text{true}\right)=\text{id}^{F^{A}\Rightarrow F^{A}}$
\end_inset

 
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{filter}\,p\bef\text{fmap}\,f^{A\Rightarrow B}=\text{filter}\,p\bef\text{fmap}\left(f_{|p}\right)$
\end_inset

 
\size default
where 
\size footnotesize

\begin_inset Formula $f_{|p}$
\end_inset


\size default
 is the 
\emph on
partial function
\emph default
 defined as 
\family typewriter
\size footnotesize
\color blue
{ case x if p(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 f(x) }
\family default
\size default
\color inherit
 – only works if 
\begin_inset Formula $p(x)$
\end_inset

 holds
\end_layout

\begin_layout Standard
Can define a type class 
\family typewriter
\size footnotesize
\color blue
Filterable
\family default
\size default
\color inherit
, method 
\family typewriter
\size footnotesize
\color blue
withFilter
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Check the laws for the 
\family typewriter
\size footnotesize
\color blue
Orders
\family default
\size default
\color inherit
 functor (see example code)
\end_layout

\begin_layout Standard
Laws hold for the 
\family typewriter
\size footnotesize
\color blue
Orders
\family default
\size default
\color inherit
 functor with / without business rule (a)
\end_layout

\begin_layout Standard
Another filterable functor: 
\begin_inset Formula $F^{A}\equiv1+A\times A$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

collapsible product
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Examples of functors that are 
\emph on
not
\emph default
 filterable:
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Orders
\begin_inset Quotes erd
\end_inset

 with additional business rule (b) – breaks law 2 for some 
\begin_inset Formula $p_{1,2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}$
\end_inset

 defining 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 in a special way e.g.
\begin_inset space ~
\end_inset

for 
\begin_inset Formula $A=\text{Int}$
\end_inset

 – breaks law 1
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv1+A$
\end_inset

 defining 
\begin_inset Formula $\text{filter}\left(p\right)\left(x\right)\equiv1+0$
\end_inset

 breaks law 3
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A$
\end_inset

 – must define 
\begin_inset Formula $\text{filter}\left(p^{A\Rightarrow\text{Boolean}}\right)\left(x^{A}\right)=x$
\end_inset

, breaking law 4
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A\times\left(1+A\right)$
\end_inset

 – unable to remove the first 
\begin_inset Formula $A$
\end_inset

, breaking law 4
\end_layout

\begin_layout Standard
The equational laws 1–4 specify 
\emph on
rigorously
\emph default
 what it means to 
\begin_inset Quotes eld
\end_inset

filter data
\begin_inset Quotes erd
\end_inset

!
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Worked examples I: Programming with filterables
\end_layout

\begin_layout Standard
John can have up to 3 coupons, and Jill up to 2.
 
\emph on
All
\emph default
 of John's coupons must be valid on purchase day, while each of Jill's coupons
 is checked independently.
 Implement a filterable functor describing this setup.
\end_layout

\begin_layout Standard
A server received a sequence of requests.
 Each request must be authenticated.
 Once a non-authenticated request is found, no further requests are accepted.
 Is this setup described by a filterable functor?
\begin_inset Newline newline
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset Newline newline
\end_inset

For each of these functors, determine whether they are filterable, and if
 so, implement 
\family typewriter
\size footnotesize
\color blue
withFilter
\family default
\size default
\color inherit
 via a type class:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
final case class P[T](first:
\begin_inset space \space{}
\end_inset

Option[T], second:
\begin_inset space \space{}
\end_inset

Option[(T, T)])
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv\text{Int}+\text{Int}\times A+\text{Int}\times A\times A+\text{Int}\times A\times A\times A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}=\text{NonEmptyList}^{A}$
\end_inset

 defined recursively as 
\begin_inset Formula $F^{A}\equiv A+A\times F^{A}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{Z,A}\equiv Z+\text{Int}\times Z\times A\times A$
\end_inset

 (with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{Z,A}\equiv1+Z+\text{Int}\times A\times\text{List}^{A}$
\end_inset

 (w.r.t.
\begin_inset space \space{}
\end_inset

the type parameter 
\begin_inset Formula $A$
\end_inset

)
\end_layout

\begin_layout Standard
* Show that 
\begin_inset Formula $C^{Z,A}=A\Rightarrow1+Z$
\end_inset

 is a filterable 
\emph on
contrafunctor
\emph default
 w.r.t.
\begin_inset space \space{}
\end_inset


\begin_inset Formula $A$
\end_inset

 (implement 
\family typewriter
\size footnotesize
\color blue
withFilter
\family default
\size default
\color inherit
 with the same type signature; no law checking)
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Exercises I
\end_layout

\begin_layout Standard
Confucius gave wisdom on each of the 7 days of a week.
 Sometimes the wise proverbs were hard to remember.
 If Confucius forgets what he said on a given day, he also forgets what
 he said on all the previous days of the week.
 Is this setup described by a filterable functor?
\end_layout

\begin_layout Standard
Define 
\family typewriter
\size footnotesize
\color blue
evenFilter(p)
\family default
\size default
\color inherit
 on an 
\family typewriter
\size footnotesize
\color blue
IndexedSeq[T]
\family default
\size default
\color inherit
 such that a value 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

T
\family default
\size default
\color inherit
 is retained if 
\family typewriter
\size footnotesize
\color blue
p(x)=true
\family default
\size default
\color inherit
 
\emph on
and
\emph default
 only if the sequence has an 
\emph on
even
\emph default
 number of elements 
\family typewriter
\size footnotesize
\color blue
y
\family default
\size default
\color inherit
 for which 
\family typewriter
\size footnotesize
\color blue
p(y)=false
\family default
\size default
\color inherit
.
 Does this define a filterable functor?
\begin_inset Newline newline
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset Newline newline
\end_inset

Implement 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 for these functors if possible (law checking optional):
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv\text{Int}+\text{String}\times A\times A\times A$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
final case class Q[A, Z](id:
\begin_inset space \space{}
\end_inset

Long, user1:
\begin_inset space \space{}
\end_inset

Option[(A, Z)], user2:
\begin_inset space \space{}
\end_inset

Option[(A, Z)]) 
\family default
\size default
\color inherit
– with respect to the type parameter 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}=\text{MyTree}^{A}$
\end_inset

 defined recursively as 
\begin_inset Formula $F^{A}\equiv1+A\times F^{A}\times F^{A}$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
final case class R[A](x:
\begin_inset space \space{}
\end_inset

Int,
\begin_inset space \space{}
\end_inset

y: Int, z:
\begin_inset space \space{}
\end_inset

A, data:
\begin_inset space \space{}
\end_inset

List[A])
\family default
\size default
\color inherit
, where the standard functor 
\begin_inset Formula $\text{List}$
\end_inset

 already has 
\family typewriter
\size footnotesize
\color blue
withFilter
\family default
\size default
\color inherit
 defined
\end_layout

\begin_layout Standard
* Show that 
\begin_inset Formula $C^{A}\equiv A+A\times A\Rightarrow1+Z$
\end_inset

 is a filterable contrafunctor
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Filterable functors: The laws in depth I
\end_layout

\begin_layout Standard
Is there a shorter formulation of the laws that is easier to remember?
\end_layout

\begin_layout Standard
Intuition: When 
\family typewriter
\size footnotesize
\color blue
p(x) = false
\family default
\size default
\color inherit
, replace 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

A
\family default
\size default
\color inherit
 by 
\family typewriter
\size footnotesize
\color blue
1:
\begin_inset space \space{}
\end_inset

Unit
\family default
\size default
\color inherit
 in 
\family typewriter
\size footnotesize
\color blue
F[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
(1) How to replace 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 by 
\family typewriter
\size footnotesize
\color blue
1
\family default
\size default
\color inherit
 in 
\family typewriter
\size footnotesize
\color blue
F[A]
\family default
\size default
\color inherit
 without breaking the types?
\end_layout

\begin_layout Standard
(2) How to transform the resulting type back to 
\family typewriter
\size footnotesize
\color blue
F[A]
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Standard
We could do (1) if instead of 
\begin_inset Formula $F^{A}$
\end_inset

 we had 
\begin_inset Formula $F^{1+A}$
\end_inset

 i.e.
\begin_inset space ~
\end_inset


\family typewriter
\size footnotesize
\color blue
F[Option[A]]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Now use 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 to replace 
\begin_inset Formula $A$
\end_inset

 by 
\begin_inset Formula $1$
\end_inset

 in each item of type 
\begin_inset Formula $1+A$
\end_inset


\end_layout

\begin_layout Standard
Get 
\begin_inset Formula $F^{1+A}$
\end_inset

 from 
\begin_inset Formula $F^{A}$
\end_inset

 using 
\begin_inset Formula $\text{inflate}:F^{A}\Rightarrow F^{1+A}=\text{fmap}\,(\text{Some}^{A\Rightarrow1+A})$
\end_inset

 
\end_layout

\begin_layout Standard
Filter 
\begin_inset Formula $F^{1+A}\Rightarrow F^{1+A}$
\end_inset

 using 
\begin_inset Formula $\text{fmap}\left(x^{1+A}\Rightarrow\text{filter}_{\text{Opt}}(p^{A\Rightarrow\text{Boolean}})(x)\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{filter}\,p:\xymatrix{\xyScaleX{5pc}F^{A}\ar[r]\sb(0.45){\text{inflate}} & F^{1+A}\ar[r]_{\text{fmap}\left(\text{filter}_{\text{Opt}}p\right)} & F^{1+A}\ar[r]\sb(0.55){\text{deflate}} & F^{A}}
\]

\end_inset


\end_layout

\begin_layout Standard
Doing (2) means 
\emph on
defining
\emph default
 a function 
\family typewriter
\size footnotesize
\color blue
deflate:
\begin_inset space \space{}
\end_inset

F[Option[A]] 
\begin_inset Formula $\Rightarrow$
\end_inset

 F[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
standard library already has 
\family typewriter
\size footnotesize
\color blue
flatten[T]:
\begin_inset space \space{}
\end_inset

Seq[Option[T]] 
\begin_inset Formula $\Rightarrow$
\end_inset

 Seq[T]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Simplify
\size footnotesize
 
\begin_inset Formula $\text{fmap}(\text{Some}^{A\Rightarrow1+A})\bef\text{fmap}\left(\text{filter}_{\text{Opt}}p\right)=\text{fmap}\left(\text{bop}\left(p\right)\right)$
\end_inset


\size default
 where we defined 
\size footnotesize

\begin_inset Formula $\text{{\color{blue}bop}}\left(p\right):\left(A\Rightarrow1+A\right)\equiv$
\end_inset


\size default
 
\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\Rightarrow$
\end_inset

 Some(x).filter(p)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
In this way, express 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 through 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 (see example code)
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{filter}\,p=\text{fmap}\left(\text{bop}\,p\right)\bef\text{deflate}$
\end_inset

.
 – Notation: 
\begin_inset Formula $\text{bop}\,p$
\end_inset

 is 
\begin_inset Formula $\text{bop}\left(p\right)$
\end_inset

, like 
\begin_inset Formula $\cos x$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{filter}\:p:\xymatrix{\xyScaleX{5pc}F^{A}\ar[r]\sb(0.45){\text{fmap}\left(\text{bop}\,p\right)} & F^{1+A}\ar[r]\sb(0.55){\text{deflate}} & F^{A}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Filterable functors: Using 
\family typewriter
\size footnotesize
\color blue
deflate
\end_layout

\begin_layout Standard
So far we have expressed 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 through 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
We can also express 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 through 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 (assuming law 4 holds):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{deflate}:\xymatrix{\xyScaleX{5pc}F^{1+A}\ar[r]\sb(0.5){\text{filter}\left(\text{.nonEmpty}\right)} & F^{1+A}\ar[r]\sb(0.5){\text{fmap}\left(\text{.get}\right)} & F^{A}}
\]

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
def deflate[F[_],A](foa: F[Option[A]]): F[A] =
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
  foa.filter(_.nonEmpty).map(_.get) 
\family roman
\color gray
// 
\family default
_.get
\family roman
 is 
\begin_inset Formula $0+x^{A}\Rightarrow x^{A}$
\end_inset


\end_layout

\begin_layout Standard

\family roman
\size footnotesize
\color gray
// for 
\family default
F = Seq
\family roman
, this would be 
\family default
foa.collect { case Some(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x }
\end_layout

\begin_layout Standard

\family roman
\size footnotesize
\color gray
// for arbitrary functor 
\family default
F
\family roman
 we need to use the partial function, 
\family default
_.get
\end_layout

\begin_layout Standard
This means 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 are 
\series bold
computationally equivalent
\end_layout

\begin_layout Standard
We could specify filterable functors by implementing 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
The implementation of 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 would then be derived by library
\end_layout

\begin_layout Standard
Use 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 to verify that some functors are certainly not filterable:
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}=A+A\times A$
\end_inset

.
 Write 
\begin_inset Formula $F^{1+A}=1+A+(1+A)\times(1+A)$
\end_inset

 
\end_layout

\begin_layout Standard
cannot map 
\begin_inset Formula $F^{1+A}\Rightarrow F^{A}$
\end_inset

 because we do not have 
\begin_inset Formula $1\rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}=\text{Int}\Rightarrow A$
\end_inset

.
 Write 
\begin_inset Formula $F^{1+A}=\text{Int}\Rightarrow1+A$
\end_inset

 
\end_layout

\begin_layout Standard
type signature of 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 would be 
\begin_inset Formula $\left(\text{Int}\Rightarrow1+A\right)\Rightarrow\text{Int}\Rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
cannot map 
\begin_inset Formula $F^{1+A}\Rightarrow F^{A}$
\end_inset

 because we do not have 
\begin_inset Formula $1+A\rightarrow A$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 is easier to implement and to reason about
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* Filterable functors: The laws in depth II
\end_layout

\begin_layout Standard
We were able to define 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 only by assuming that law 4 holds
\end_layout

\begin_layout Standard
Now, law 4 is satisfied 
\emph on
automatically
\emph default
 if 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 is defined via 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
!
\end_layout

\begin_layout Standard
Denote 
\size footnotesize

\begin_inset Formula $\psi_{p}^{F^{A}\Rightarrow F^{1+A}}\equiv\text{fmap}\left(\text{bop}\:p\right)$
\end_inset

 for brevity, then 
\begin_inset Formula $\text{filter}\,p=\psi_{p}\bef\text{deflate}$
\end_inset


\end_layout

\begin_layout Standard
Law 4 then becomes: 
\size footnotesize

\begin_inset Formula $\psi_{p}\bef\text{deflate}\bef\text{fmap}\:f^{A\Rightarrow B}=\psi_{p}\bef\text{deflate}\bef\text{fmap}\:f_{|p}$
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.1pc}\xyScaleX{3pc} & F^{1+A}\ar[r]\sp(0.5){\text{deflate}} & F^{A}\ar[rd]\sp(0.5){\text{ fmap}\:f^{A\Rightarrow B}}\\
F^{A}\ar[ru]\sp(0.5){\psi_{p}}\ar[rd]\sb(0.5){\psi_{p}} &  &  & F^{B}\\
 & F^{1+A}\ar[r]\sb(0.5){\text{deflate}} & F^{A}\ar[ru]\sb(0.5){\text{fmap}\:f_{|p}^{A\Rightarrow B}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
We would like to interchange 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 in both sides
\end_layout

\begin_layout Standard
We need a 
\emph on
naturality
\emph default
 law; let's express law 1 through 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula 
\[
\text{fmap}\:f^{A\Rightarrow B}\bef\psi_{p}\bef\text{deflate}^{F,B}=\psi_{f\bef p}\bef\text{deflate}^{F,A}\bef\text{fmap}\:f^{A\Rightarrow B}
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.1pc}\xyScaleX{3pc} & F^{B}\ar[r]\sp(0.5){\psi_{p}} & F^{1+B}\ar[rd]\sp(0.5){\text{ deflate}^{F,B}}\\
F^{A}\ar[ru]\sp(0.5){\text{fmap}\:f^{A\Rightarrow B}}\ar[rd]\sb(0.5){\psi_{f\bef p}} &  &  & F^{B}\\
 & F^{1+A}\ar[r]\sb(0.5){\text{deflate}^{F,A}} & F^{A}\ar[ru]\sb(0.5){\text{fmap}\:f^{A\Rightarrow B}}
}
\]

\end_inset

Can we simplify 
\begin_inset Formula $\text{fmap}\:f\bef\psi_{p}=\text{fmap}\:f\bef\text{fmap}\left(\text{bop}\,p\right)=\text{fmap}\left(f\bef\text{bop}\,p\right)$
\end_inset

?
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* Filterable functors: The laws in depth III
\end_layout

\begin_layout Standard

\size footnotesize
Have property: 
\begin_inset Formula $f^{A\Rightarrow B}\bef\text{bop}\left(p^{B\Rightarrow\text{Boolean}}\right)=\text{bop}\left(f\bef p\right)\bef\text{fmap}^{\text{Opt}}\,f$
\end_inset

 (see code)
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & B\ar[rd]\sp(0.5){\text{bop}\,p}\\
A\ar[ru]\sp(0.5){f^{A\Rightarrow B}}\ar[rd]\sb(0.4){\text{bop}\left(f\bef p\right)\,} &  & 1+B\\
 & 1+A\ar[ru]\sb(0.6){\text{fmap}^{\text{Opt}}f}
}
\]

\end_inset

We can now rewrite Law 1 as
\begin_inset Formula 
\[
\text{fmap}\,(\text{bop}\left(f\bef p\right))\bef\text{fmap}\,(\text{fmap}^{\text{Opt}}f)\bef\text{deflate}=\text{fmap}\left(\text{bop}\left(f\bef p\right)\right)\bef\text{deflate}\bef\text{fmap}\,f
\]

\end_inset

Remove common prefix 
\begin_inset Formula $\text{fmap}\left(\text{bop}\left(f\bef p\right)\right)\bef...$
\end_inset

 from both sides:
\begin_inset Formula 
\[
\text{fmap}\,(\text{fmap}^{\text{Opt}}f^{A\Rightarrow B})\bef\text{deflate}^{F,B}=\text{deflate}^{F,A}\bef\text{fmap}\,f^{A\Rightarrow B}\ \ -\text{ \textbf{law 1 for deflate}}
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{1+B}\ar[rd]\sp(0.5){\ \text{deflate}^{F,B}}\\
F^{1+A}\ar[ru]\sp(0.5){\text{fmap}\,(\text{fmap}\,f)\ }\ar[rd]\sb(0.5){\text{deflate}^{F,A}\,} &  & F^{B}\\
 & F^{A}\ar[ru]\sb(0.5){\text{fmap\,}f^{A\Rightarrow B}}
}
\]

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
deflate
\family default
\color inherit

\begin_inset Formula $:F^{1+A}\Rightarrow F^{A}$
\end_inset


\size default
  is a 
\series bold
natural transformation
\series default
 (has naturality law)
\end_layout

\begin_layout Standard
Example:
\size footnotesize
 
\begin_inset Formula $F^{A}=1+A\times A$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $F^{1+A}=1+(1+A)\times(1+A)=1+1\times1+A\times1+1\times A+A\times A$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
natural transformations map containers 
\begin_inset Formula $G^{A}\Rightarrow H^{A}$
\end_inset

 by rearranging data in them
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* Filterable functors: The laws in depth IV
\end_layout

\begin_layout Standard
The naturality law for 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
:
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}\,(\text{fmap}^{\text{Opt}}f^{A\Rightarrow B})\bef\text{deflate}^{F,B}=\text{deflate}^{F,A}\bef\text{fmap}\,f^{A\Rightarrow B}
\]

\end_inset


\size default
Law 4 expressed via 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
:
\size footnotesize

\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.1pc}\xyScaleX{3pc} & F^{1+A}\ar[r]\sp(0.5){\text{deflate}} & F^{A}\ar[rd]\sp(0.5){\text{ fmap}\:f^{A\Rightarrow B}}\\
F^{A}\ar[ru]\sp(0.5){\psi_{p}}\ar[rd]\sb(0.5){\psi_{p}} &  &  & F^{B}\\
 & F^{1+A}\ar[r]\sb(0.5){\text{deflate}} & F^{A}\ar[ru]\sb(0.5){\text{fmap}\:f_{|p}^{A\Rightarrow B}}
}
\]

\end_inset


\begin_inset Formula 
\[
\psi_{p}\bef\text{deflate}^{F,A}\bef\text{fmap}\:f^{A\Rightarrow B}=\psi_{p}\bef\text{deflate}^{F,A}\bef\text{fmap}\:f_{|p}
\]

\end_inset


\end_layout

\begin_layout Standard
Use naturality to interchange 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 in both sides of law 4:
\size footnotesize

\begin_inset Formula 
\begin{align*}
\psi_{p}\bef\text{fmap}\,(\text{fmap}^{\text{Opt}}f)\bef\text{deflate}^{F,B} & =\psi_{p}\bef\text{fmap}\,(\text{fmap}^{\text{Opt}}f_{|p})\bef\text{deflate}^{F,B}\\
\text{[omit }\text{deflate}^{F,B}\text{ from} & \ \text{both sides; expand }\psi_{p}\text{]}\\
\text{bop}\,p\bef\text{fmap}^{\text{Opt}}f & =\text{bop}\,p\bef\text{fmap}^{\text{Opt}}f_{|p}\ \ -\text{ check this by hand:}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\Rightarrow$
\end_inset

 Some(x).filter(p).map(f)
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\Rightarrow$
\end_inset

 Some(x).filter(p).map { case x if p(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 f(x) }
\end_layout

\begin_layout Standard
These functions are equivalent because law 4 holds for 
\family typewriter
\size footnotesize
\color blue
Option
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Filterable functors: The laws in depth V
\end_layout

\begin_layout Standard
Maybe 
\begin_inset Formula $\psi_{p}\bef\text{deflate}$
\end_inset

 is easier to handle than 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
? Let us define 
\size footnotesize

\begin_inset Formula 
\[
\text{{\color{blue}fmapOpt}}^{F,A,B}(f^{A\Rightarrow1+B}):F^{A}\Rightarrow F^{B}=\text{fmap}\:f\bef\text{deflate}^{F,B}
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{1+B}\ar[rd]\sp(0.5){\ \text{deflate}^{F,B}}\\
F^{A}\ar[ru]\sp(0.5){\text{fmap}\,f^{A\Rightarrow1+B}\ }\ar[rr]\sb(0.5){\text{fmapOpt}\:f^{A\Rightarrow1+B}\,} &  & F^{B}
}
\]

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 are 
\emph on
equivalent
\emph default
: 
\size footnotesize

\begin_inset Formula $\text{deflate}^{F,A}=\text{fmapOpt}^{F,1+A,A}(\text{id}^{1+A\Rightarrow1+A})$
\end_inset

 
\end_layout

\begin_layout Standard
Express laws 1 – 3 in terms of 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
: do they get simpler?
\end_layout

\begin_layout Standard
Express 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 through 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
: 
\size footnotesize

\begin_inset Formula $\text{filter}\,p=\text{fmapOpt}^{F,A,A}\left(\text{bop}\,p\right)$
\end_inset


\end_layout

\begin_layout Standard
Consider the expression needed for law 2: 
\begin_inset Formula $x\Rightarrow p_{1}(x)\wedge p_{2}(x)$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{bop}\left(x\Rightarrow p_{1}(x)\wedge p_{2}(x)\right)=x^{A}\Rightarrow\left(\text{bop}\,p_{1}\right)(x)\text{.flatMap}\left(\text{bop}\,p_{2}\right)$
\end_inset

 
\size default
– see code
\end_layout

\begin_layout Standard
Denote this computation by 
\begin_inset Formula $\diamond_{\text{Opt}}$
\end_inset

 and write
\size footnotesize

\begin_inset Formula 
\[
q_{1}^{A\Rightarrow1+B}\diamond_{\text{Opt}}q_{2}^{B\Rightarrow1+C}\equiv x^{A}\Rightarrow q_{1}(x).\text{flatMap}\left(q_{2}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
Similar to composition of functions, except the types are 
\begin_inset Formula $A\Rightarrow1+B$
\end_inset


\end_layout

\begin_layout Standard
This is a particular case of 
\series bold
Kleisli composition
\series default
; the general case: 
\size footnotesize

\begin_inset Formula $\diamond_{M}:(A\Rightarrow M^{B})\Rightarrow(B\Rightarrow M^{C})\Rightarrow(A\Rightarrow M^{C})$
\end_inset


\size default
; we set 
\begin_inset Formula $M^{A}\equiv1+A$
\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
Kleisli identity
\series default
 function: 
\begin_inset Formula $\text{id}_{\diamond_{\text{Opt}}}^{A\Rightarrow1+A}\equiv x^{A}\Rightarrow\text{Some}\left(x\right)$
\end_inset


\end_layout

\begin_layout Standard
Kleisli composition 
\begin_inset Formula $\diamond_{\text{Opt}}$
\end_inset

 is associative and respects the Kleisli identity!
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 lifts a Kleisli
\begin_inset Formula $_{\text{Opt}}$
\end_inset

 function 
\begin_inset Formula $f^{A\Rightarrow1+B}$
\end_inset

 into the functor 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Filterable functors: The laws in depth VI
\end_layout

\begin_layout Standard
Simplifying down to two laws
\end_layout

\begin_layout Standard
Only 
\emph on
two
\emph default
 laws are necessary for 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
!
\end_layout

\begin_layout Standard

\series bold
Identity law
\series default
 (covers old law 3): 
\size footnotesize

\begin_inset Formula 
\[
\text{fmapOpt}\,(\text{id}_{\diamond_{\text{Opt}}}^{A\Rightarrow1+A})=\text{id}^{F^{A}\Rightarrow F^{A}}
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Composition law
\series default
 (covers old laws 1 and 2): 
\size footnotesize

\begin_inset Formula 
\[
\text{fmapOpt}\,(f^{A\Rightarrow1+B})\bef\text{fmapOpt}\,(g^{B\Rightarrow1+C})=\text{fmapOpt}\left(f\diamond_{\text{\textbf{Opt}}}g\right)
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc} & F^{B}\ar[rd]\sp(0.55){\ \text{fmapOpt}\,(g^{B\Rightarrow1+C})}\\
F^{A}\ar[ru]\sp(0.45){\text{fmapOpt}\,(f^{A\Rightarrow1+B})\ }\ar[rr]\sb(0.5){\text{fmapOpt}\left(f\diamond_{\text{Opt}}g\right)} &  & F^{C}
}
\]

\end_inset


\end_layout

\begin_layout Standard
The two laws for 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 are very similar to the two functor laws
\end_layout

\begin_layout Standard
Both of them use more complicated types than the old laws
\end_layout

\begin_layout Standard
Conceptually, the new laws are simpler (lift 
\begin_inset Formula $f^{A\Rightarrow1+B}$
\end_inset

 into 
\begin_inset Formula $F^{A}\Rightarrow F^{B}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* Filterable functors: The laws in depth VII
\end_layout

\begin_layout Standard
Showing that old laws 1 – 3 follow from the identity and composition laws
 for 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\end_layout

\begin_layout Standard
Old law 3 is 
\emph on
equivalent
\emph default
 to the identity law for 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
:
\size footnotesize

\begin_inset Formula 
\[
\text{filter}\,(x^{A}\Rightarrow\text{true})=\text{fmap}\,(x^{A}\Rightarrow0+x)\bef\text{deflate}=\text{fmapOpt}\,(\text{id}_{\diamond_{\text{Opt}}})=\text{id}^{F^{A}\Rightarrow F^{A}}
\]

\end_inset


\end_layout

\begin_layout Standard
Derive old law 2: need to work with
\size footnotesize
 
\begin_inset Formula $q_{1,2}\equiv\text{bop}\left(p_{1,2}\right):A\Rightarrow1+A$
\end_inset

 
\end_layout

\begin_layout Standard
The Boolean conjunction 
\size footnotesize

\begin_inset Formula $x\Rightarrow p_{1}(x)\wedge p_{2}(x)$
\end_inset

 
\size default
corresponds to 
\size footnotesize

\begin_inset Formula $q_{1}\diamond_{\text{\textbf{Opt}}}q_{2}$
\end_inset


\end_layout

\begin_layout Standard
Apply the composition law to Kleisli functions of types 
\size footnotesize

\begin_inset Formula $A\Rightarrow1+A$
\end_inset

 
\size default
:
\size footnotesize

\begin_inset Formula 
\begin{align*}
\text{filter}\,p_{1}\bef\text{filter}\,p_{2} & =\text{fmapOpt}\,q_{1}\bef\text{fmapOpt}\,q_{2}\\
=\text{fmapOpt}\left(q_{1}\diamond_{\text{\textbf{Opt}}}q_{2}\right) & =\text{fmapOpt}\left(\text{bop}\left(x\Rightarrow p_{1}(x)\wedge p_{2}(x)\right)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Derive old law 1:
\end_layout

\begin_layout Standard
express 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 through 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
; old law 1 becomes
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}\:f\bef\text{fmapOpt}\left(\text{bop}\,p\right)=\text{fmapOpt}\left(\text{bop}\left(f\bef p\right)\right)\bef\text{fmap}\:f\ \text{ – eq. (*)}
\]

\end_inset


\end_layout

\begin_layout Standard
lift 
\begin_inset Formula $f^{A\Rightarrow B}$
\end_inset

 to Kleisli
\begin_inset Formula $_{\text{Opt}}$
\end_inset

 by defining 
\size footnotesize

\begin_inset Formula $k_{f}^{A\Rightarrow1+B}=f\bef\text{id}_{\diamond_{\text{\textbf{Opt}}}}$
\end_inset

;
\size default
 then we have 
\begin_inset Formula $\text{fmapOpt}\left(k_{f}\right)=\text{fmap}\,k_{f}\bef\text{deflate}=\text{fmap}\:f\bef\text{fmap}\,\text{id}_{\diamond_{\text{\textbf{Opt}}}}\bef\text{deflate}=\text{fmap}\,f$
\end_inset


\end_layout

\begin_layout Standard
rewrite eq.
\begin_inset space \space{}
\end_inset

(*) as 
\size footnotesize

\begin_inset Formula $\text{fmapOpt}\left(k_{f}\diamond_{\text{\textbf{Opt}}}\text{bop}\,p\right)=\text{fmapOpt}\left(\text{bop}\left(f\bef p\right)\diamond_{\text{\textbf{Opt}}}k_{f}\right)$
\end_inset

 
\end_layout

\begin_layout Standard
it remains to show that 
\size footnotesize

\begin_inset Formula $k_{f}\diamond_{\text{\textbf{Opt}}}\text{bop}\,p=\text{bop}\left(f\bef p\right)\diamond_{\text{\textbf{Opt}}}k_{f}$
\end_inset

 
\end_layout

\begin_layout Standard
use the properties 
\size footnotesize

\begin_inset Formula $k_{f}\diamond_{\text{\textbf{Opt}}}q=f\bef q$
\end_inset

 and 
\begin_inset Formula $q\diamond_{\text{\textbf{Opt}}}k_{f}=q\bef\text{fmap}^{\text{Opt}}f$
\end_inset

, and 
\begin_inset Formula $f\bef\text{bop}\,p=\text{bop}\left(f\bef p\right)\bef\text{fmap}^{\text{Opt}}\,f$
\end_inset

 (property from slide 11)
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Summary: The methods and the laws
\end_layout

\begin_layout Standard
Filterable functors can be defined via 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
, or 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
All three methods are 
\emph on
equivalent
\emph default
 but have different roles:
\end_layout

\begin_layout Standard
The easiest to use in program code is 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
withFilter
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
The easiest type signature to implement and reason about is 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Conceptually, the laws are easiest to remember with 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
* The 2 laws for 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 are the 2 functor laws with a Kleisli 
\begin_inset Quotes eld
\end_inset

twist
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
* Category theory accommodates this via a generalized definition of functors
 as liftings between 
\begin_inset Quotes eld
\end_inset

twisted
\begin_inset Quotes erd
\end_inset

 types.
 Compare:
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{fmap}:\left(A\Rightarrow B\right)\Rightarrow F^{A}\Rightarrow F^{B}$
\end_inset

 – ordinary container (
\begin_inset Quotes eld
\end_inset

endofunctor
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{contrafmap}:\left(B\Rightarrow A\right)\Rightarrow F^{A}\Rightarrow F^{B}$
\end_inset

 – lifting from reversed functions
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{fmapOpt}:\left(A\Rightarrow1+B\right)\Rightarrow F^{A}\Rightarrow F^{B}$
\end_inset

 – lifting from Kleisli
\begin_inset Formula $_{\text{Opt}}$
\end_inset

-functions 
\end_layout

\begin_layout Standard
CT gives us some 
\emph on
intuitions
\emph default
 about how to derive better laws:
\end_layout

\begin_layout Standard
look for type signatures that resemble a generalized sort of 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
look for natural transformations and use the naturality law
\end_layout

\begin_layout Standard
However, CT does not directly provide any derivations for the laws
\end_layout

\begin_layout Standard
you will not find the laws for 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 in any CT book
\end_layout

\begin_layout Standard
CT is abstract, only gives hints about possible further directions
\end_layout

\begin_layout Standard
investigate functors having 
\begin_inset Quotes eld
\end_inset

liftings
\begin_inset Quotes erd
\end_inset

 with different type signatures
\end_layout

\begin_layout Standard
replace 
\family typewriter
\size footnotesize
\color blue
Option
\family default
\size default
\color inherit
 in the Kleisli
\begin_inset Formula $_{\text{Opt}}$
\end_inset

 construction by another functor
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Structure of filterable functors
\end_layout

\begin_layout Standard
How to recognize a filterable functor by its type?
\end_layout

\begin_layout Standard
Intuition from 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
: reshuffle data in 
\begin_inset Formula $F^{A}$
\end_inset

 after replacing some 
\begin_inset Formula $A$
\end_inset

's by 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

reshuffling
\begin_inset Quotes erd
\end_inset

 usually means reusing different parts of a disjunction
\end_layout

\begin_layout Standard
Some constructions of exponential-polynomial filterable functors 
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}=Z$
\end_inset

 (constant functor) for a fixed type 
\begin_inset Formula $Z$
\end_inset

 (define 
\begin_inset Formula $\text{fmapOpt}\,f=\text{id}$
\end_inset

)
\end_layout

\begin_layout Standard
Note: 
\begin_inset Formula $F^{A}=A$
\end_inset

 (identity functor) is 
\emph on
not
\emph default
 filterable
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{A}\times H^{A}$
\end_inset

 for any filterable functors 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{A}+H^{A}$
\end_inset

 for any filterable functors 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{H^{A}}$
\end_inset

 for 
\emph on
any
\emph default
 functor 
\begin_inset Formula $G^{A}$
\end_inset

 and filterable functor 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv1+A\times G^{A}$
\end_inset

 for a filterable functor 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Standard
Note: 
\emph on
pointed
\emph default
 types 
\begin_inset Formula $P$
\end_inset

 are isomorphic to 
\begin_inset Formula $1+Z$
\end_inset

 for some type 
\begin_inset Formula $Z$
\end_inset


\end_layout

\begin_layout Standard
Example of non-trivial pointed type: 
\begin_inset Formula $A\Rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
Example of non-pointed type: 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 when 
\begin_inset Formula $A$
\end_inset

 is different from 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Standard
So 
\begin_inset Formula $F^{A}\equiv P+A\times G^{A}$
\end_inset

 where 
\begin_inset Formula $P$
\end_inset

 is a pointed type and 
\begin_inset Formula $G^{A}$
\end_inset

 is filterable
\end_layout

\begin_layout Standard
Also have 
\begin_inset Formula $F^{A}\equiv P+A\times A\times...\times A\times G^{A}$
\end_inset

 similarly
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{A}+A\times F^{A}$
\end_inset

 (recursive) for a filterable functor 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{A}\Rightarrow H^{A}$
\end_inset

 if
\emph on
 
\emph default
contrafunctor 
\begin_inset Formula $G^{A}$
\end_inset

 and functor 
\begin_inset Formula $H^{A}$
\end_inset

 
\emph on
both
\emph default
 
\emph on
filterable
\end_layout

\begin_layout Standard
Note: the functor 
\begin_inset Formula $F^{A}\equiv G^{A}\Rightarrow A$
\end_inset

 is not filterable
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* Worked examples II: Constructions of filterable functors I
\end_layout

\begin_layout Standard
(2) The 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 laws hold for 
\begin_inset Formula $F^{A}\times G^{A}$
\end_inset

 if they hold for 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset Formula $f^{A\Rightarrow1+B}$
\end_inset

, get 
\size footnotesize

\begin_inset Formula $\text{fmapOpt}_{F}(f):F^{A}\Rightarrow F^{B}$
\end_inset

 
\size default
and 
\size footnotesize

\begin_inset Formula $\text{fmapOpt}_{G}(f):G^{A}\Rightarrow G^{B}$
\end_inset


\end_layout

\begin_layout Standard
Define 
\size footnotesize

\begin_inset Formula $\text{fmapOpt}_{F\times G}f\equiv p^{F^{A}}\times q^{G^{A}}\Rightarrow\text{fmapOpt}_{F}(f)(p)\times\text{fmapOpt}_{G}(f)(q)$
\end_inset


\end_layout

\begin_layout Standard
Identity law: 
\begin_inset Formula $f=\text{id}_{\diamond_{\text{Opt}}}$
\end_inset

, so 
\size footnotesize

\begin_inset Formula $\text{fmapOpt}_{F}f=\text{id}$
\end_inset


\size default
 and 
\size footnotesize

\begin_inset Formula $\text{fmapOpt}_{G}f=\text{id}$
\end_inset


\end_layout

\begin_layout Standard
Hence we get 
\begin_inset Formula $\text{fmapOpt}_{F+G}(f)(p\times q)=\text{id}(p)\times\text{id}(q)=p\times q$
\end_inset


\end_layout

\begin_layout Standard
Composition law:
\size footnotesize

\begin_inset Formula 
\begin{align*}
 & (\text{fmapOpt}_{F\times G}\,f_{1}\bef\text{fmapOpt}_{F+G}\,f_{2})(p\times q)\\
=\  & \text{fmapOpt}_{F\times G}(f_{2})\left(\text{fmapOpt}_{F}(f_{1})(p)\times\text{fmapOpt}_{G}(f_{1})(q)\right)\\
=\  & (\text{fmapOpt}_{F}\,f_{1}\bef\text{fmapOpt}_{F}\,f_{2})(p)\times\left(\text{fmapOpt}_{G}\,f_{1}\bef\text{fmapOpt}_{G}\,f_{2}\right)(q)\\
=\  & \text{fmapOpt}_{F}(f_{1}\diamond_{\text{Opt}}f_{2})(p)\times\text{fmapOpt}_{G}(f_{1}\diamond_{\text{Opt}}f_{2})(q)\\
=\  & \text{fmapOpt}_{F\times G}(f_{1}\diamond_{\text{Opt}}f_{2})(p\times q)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Exactly the same proof as that for functor property for 
\begin_inset Formula $F^{A}\times G^{A}$
\end_inset


\end_layout

\begin_layout Standard
this is because 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 corresponds to a generalized functor
\end_layout

\begin_layout Standard
New proofs are necessary only when using non-filterable functors
\end_layout

\begin_layout Standard
these are used in constructions 4 – 6
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* Worked examples II: Constructions of filterable functors II
\end_layout

\begin_layout Standard
(5) The 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 laws hold for 
\begin_inset Formula $F^{A}\equiv1+A\times G^{A}$
\end_inset

 if they hold for 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset Formula $f^{A\Rightarrow1+B}$
\end_inset

, get 
\size footnotesize

\begin_inset Formula $\text{fmapOpt}_{G}(f):G^{A}\Rightarrow G^{B}$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
Define 
\begin_inset Formula $\text{fmapOpt}_{F}(f)(1+a^{A}\times q^{G^{A}})$
\end_inset

 by returning 
\begin_inset Formula $0+b\times\text{fmapOpt}_{G}(f)(q)$
\end_inset

 if the argument is 
\begin_inset Formula $0+a\times q$
\end_inset

 and if 
\begin_inset Formula $f(a)=0+b$
\end_inset

, and returning 
\begin_inset Formula $1+0$
\end_inset

 otherwise
\end_layout

\begin_layout Standard
Identity law: 
\size footnotesize

\begin_inset Formula $f=\text{id}_{\diamond_{\text{Opt}}}$
\end_inset

, so 
\begin_inset Formula $f(a)=0+a$
\end_inset

 and 
\begin_inset Formula $\text{fmapOpt}_{G}f=\text{id}$
\end_inset


\end_layout

\begin_layout Standard
Hence we get
\size footnotesize
 
\begin_inset Formula $\text{fmapOpt}_{F}(\text{id}_{\diamond_{\text{Opt}}})(1+a\times q)=1+a\times q$
\end_inset


\end_layout

\begin_layout Standard
Composition law: 
\size footnotesize
need only to check for arguments 
\begin_inset Formula $0+a\times q$
\end_inset

, and only when 
\begin_inset Formula $f_{1}(a)=0+b$
\end_inset

 and 
\begin_inset Formula $f_{2}(b)=0+c$
\end_inset

, in which case 
\begin_inset Formula $(f_{1}\diamond_{\text{Opt}}f_{2})(a)=0+c$
\end_inset

; then 
\begin_inset Formula 
\begin{align*}
 & (\text{fmapOpt}_{F}\,f_{1}\bef\text{fmapOpt}_{F}\,f_{2})(0+a\times q)\\
=\  & \text{fmapOpt}_{F}(f_{2})\left(\text{fmapOpt}_{F}(f_{1})(0+a\times q)\right)\\
=\  & \text{fmapOpt}_{F}(f_{2})\left(0+b\times\text{fmapOpt}_{G}(f_{1})(q)\right)\\
=\  & 0+c\times(\text{fmapOpt}_{G}\,f_{1}\bef\text{fmapOpt}_{G}\,f_{2})(q)\\
=\  & 0+c\times\text{fmapOpt}_{G}(f_{1}\diamond_{\text{Opt}}f_{2})(q)\\
=\  & \text{fmapOpt}_{F}(f_{1}\diamond_{\text{Opt}}f_{2})(0+a\times q)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This is a 
\begin_inset Quotes eld
\end_inset

greedy filter
\begin_inset Quotes erd
\end_inset

: if 
\begin_inset Formula $f(a)$
\end_inset

 is empty, will delete all data in 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* Worked examples II: Constructions of filterable functors III
\end_layout

\begin_layout Standard
(6) The 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 laws hold for 
\begin_inset Formula $F^{A}\equiv G^{A}+A\times F^{A}$
\end_inset

 if they hold for 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
For 
\begin_inset Formula $f^{A\Rightarrow1+B}$
\end_inset

, we have 
\begin_inset Formula $\text{fmapOpt}_{G}(f):G^{A}\Rightarrow G^{B}$
\end_inset

 and 
\begin_inset Formula $\text{fmapOpt}_{F}^{\prime}(f):F^{A}\Rightarrow F^{B}$
\end_inset

 (for use in recursive arguments as the inductive assumption)
\end_layout

\begin_layout Standard

\size footnotesize
Define 
\begin_inset Formula $\text{fmapOpt}_{F}(f)(q^{G^{A}}+a^{A}\times p^{F^{A}})$
\end_inset

 by returning 
\begin_inset Formula $0+\text{fmapOpt}_{F}^{\prime}(f)(p)$
\end_inset

 if 
\begin_inset Formula $f(a)=1+0$
\end_inset

, and 
\begin_inset Formula $\text{fmapOpt}_{G}(f)(q)+b\times\text{fmapOpt}_{F}^{\prime}(f)(p)$
\end_inset

 otherwise
\end_layout

\begin_layout Standard
Identity law: 
\size footnotesize

\begin_inset Formula $\text{id}_{\diamond_{\text{Opt}}}(x)\neq1+0$
\end_inset


\size default
, so 
\size footnotesize

\begin_inset Formula $\text{fmapOpt}_{F}(\text{id}_{\diamond_{\text{Opt}}})(q+a\times p)=q+a\times p$
\end_inset

 
\end_layout

\begin_layout Standard
Composition law: 
\size footnotesize

\begin_inset Formula $(\text{fmapOpt}_{F}(f_{1})\bef\text{fmapOpt}_{F}(f_{2}))(q+a\times p)=\text{fmapOpt}_{F}(f_{1}\diamond_{\text{Opt}}f_{2})(q+a\times p)$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
For arguments 
\begin_inset Formula $q+0$
\end_inset

, the laws for 
\begin_inset Formula $G^{A}$
\end_inset

 hold; so assume arguments 
\begin_inset Formula $0+a\times p$
\end_inset

.
 When 
\begin_inset Formula $f_{1}(a)=0+b$
\end_inset

 and 
\begin_inset Formula $f_{2}(b)=0+c$
\end_inset

, the proof of the previous example will go through.
 So we need to consider the two cases 
\begin_inset Formula $f_{1}(a)=1+0$
\end_inset

 and 
\begin_inset Formula $f_{1}(a)=0+b$
\end_inset

, 
\begin_inset Formula $f_{2}(b)=1+0$
\end_inset

 
\end_layout

\begin_layout Standard

\size footnotesize
If 
\begin_inset Formula $f_{1}(a)=1+0$
\end_inset

 then 
\begin_inset Formula $(f_{1}\diamond_{\text{Opt}}f_{2})(a)=1+0$
\end_inset

; to show 
\begin_inset Formula $\text{fmapOpt}_{F}^{\prime}(f_{2})(\text{fmapOpt}_{F}^{\prime}(f_{1})(p))$
\end_inset

 
\begin_inset Formula $=\text{fmapOpt}_{F}^{\prime}(f_{1}\diamond_{\text{Opt}}f_{2})(p)$
\end_inset

, use the inductive assumption about 
\begin_inset Formula $\text{fmapOpt}_{F}^{\prime}$
\end_inset

 on 
\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
If 
\begin_inset Formula $f_{1}(a)=0+b$
\end_inset

 and 
\begin_inset Formula $f_{2}(b)=1+0$
\end_inset

 then 
\begin_inset Formula $(f_{1}\diamond_{\text{Opt}}f_{2})(a)=1+0$
\end_inset

; to show 
\begin_inset Formula $\text{fmapOpt}_{F}(f_{2})(0+b\times\text{fmapOpt}_{F}^{\prime}(f_{1})(p))$
\end_inset

 
\begin_inset Formula $=\text{fmapOpt}_{F}^{\prime}(f_{1}\diamond_{\text{Opt}}f_{2})(p)$
\end_inset

, rewrite 
\begin_inset Formula $\text{fmapOpt}_{F}(f_{2})(0+b\times\text{fmapOpt}_{F}^{\prime}(f_{1})(p))$
\end_inset

 
\begin_inset Formula $=\text{fmapOpt}_{F}^{\prime}(f_{2})(\text{fmapOpt}_{F}^{\prime}(f_{1})(p))$
\end_inset

 and again use the inductive assumption about 
\begin_inset Formula $\text{fmapOpt}_{F}^{\prime}$
\end_inset

 on 
\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Standard
This is a 
\begin_inset Quotes eld
\end_inset

list-like filter
\begin_inset Quotes erd
\end_inset

: if 
\begin_inset Formula $f(a)$
\end_inset

 is empty, will recurse into nested 
\begin_inset Formula $F^{A}$
\end_inset

 data
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Worked examples II: Constructions of filterable functors IV
\end_layout

\begin_layout Standard
Use known filterable constructions to show that
\size footnotesize
 
\begin_inset Formula $F^{A}\equiv(\text{Int}\times\text{String})\Rightarrow\left(1+\text{Int}\times A+A\times\left(1+A\right)+\left(\text{Int}\Rightarrow1+A+A\times A\times\text{String}\right)\right)$
\end_inset

 
\size default
is a filterable functor
\end_layout

\begin_layout Standard
Instead of implementing 
\family typewriter
\size footnotesize
\color blue
Filterable
\family default
\size default
\color inherit
 and verifying laws by hand, we analyze the structure of this data type
 and use known constructions
\end_layout

\begin_layout Standard
Define some auxiliary functors that are parts of the structure of 
\begin_inset Formula $F^{A}$
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Formula $R_{1}^{A}=\left(\text{Int}\times\text{String}\right)\Rightarrow A$
\end_inset

 and 
\begin_inset Formula $R_{2}^{A}=\text{Int}\Rightarrow A$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula $G^{A}=1+\text{Int}\times A+A\times\left(1+A\right)$
\end_inset

 and 
\begin_inset Formula $H^{A}=1+A+A\times A\times\text{String}$
\end_inset


\end_layout

\begin_layout Standard
Now we can rewrite 
\size footnotesize

\begin_inset Formula $F^{A}=R_{1}\left[G^{A}+R_{2}\left[H^{A}\right]\right]$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $G^{A}$
\end_inset

 is filterable by construction 5 because it is of the form 
\begin_inset Formula $G^{A}=1+A\times K^{A}$
\end_inset

 with filterable functor 
\begin_inset Formula $K^{A}=1+\text{Int}+A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $K^{A}$
\end_inset

 is of the form 
\begin_inset Formula $1+A+X$
\end_inset

 with constant type 
\begin_inset Formula $X$
\end_inset

, so it is filterable by constructions 1 and 3 with the 
\family typewriter
\size footnotesize
\color blue
Option
\family default
\size default
\color inherit
 functor 
\begin_inset Formula $1+A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $H^{A}$
\end_inset

 is filterable by construction 5 with 
\begin_inset Formula $H^{A}=1+A\times\left(1+A\times\text{String}\right)$
\end_inset

, while 
\begin_inset Formula $1+A\times\text{String}$
\end_inset

 is filterable by constructions 5 and 1
\end_layout

\begin_layout Standard
Constructions 3 and 4 show that 
\begin_inset Formula $R_{1}\left[G^{A}+R_{2}\left[H^{A}\right]\right]$
\end_inset

 is filterable
\end_layout

\begin_layout Standard
Note that there is more than one way of implementing 
\family typewriter
\size footnotesize
\color blue
Filterable
\family default
\size default
\color inherit
 here
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* Exercises II
\end_layout

\begin_layout Standard
Implement a 
\family typewriter
\size footnotesize
\color blue
Filterable
\family default
\size default
\color inherit
 instance for 
\family typewriter
\size footnotesize
\color blue
type F[T] = G[H[T]]
\family default
\size default
\color inherit
 assuming that the functor 
\family typewriter
\size footnotesize
\color blue
H[T]
\family default
\size default
\color inherit
 already has a 
\family typewriter
\size footnotesize
\color blue
Filterable
\family default
\size default
\color inherit
 instance (construction 4).
 Verify the laws rigorously (i.e.
\begin_inset space \space{}
\end_inset

by calculations, not tests).
\end_layout

\begin_layout Standard
For 
\family typewriter
\size footnotesize
\color blue
type F[T] = Option[Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Option[(T, T)]]
\family default
\size default
\color inherit
, implement a 
\family typewriter
\size footnotesize
\color blue
Filterable
\family default
\size default
\color inherit
 instance.
 Show that the filterable laws hold by using known filterable constructions
 (avoiding explicit proofs or tests).
\end_layout

\begin_layout Standard
Implement a 
\family typewriter
\size footnotesize
\color blue
Filterable
\family default
\size default
\color inherit
 instance for 
\begin_inset Formula $F^{A}\equiv G^{A}+\text{Int}\times A\times A\times F^{A}$
\end_inset

 (recursive) for a filterable functor 
\begin_inset Formula $G^{A}$
\end_inset

.
 Verify the laws rigorously.
\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $F^{A}=1+A\times G^{A}$
\end_inset

 is in general 
\emph on
not
\emph default
 filterable if 
\begin_inset Formula $G^{A}$
\end_inset

 is an arbitrary (non-filterable) functor; it is enough to give an example.
\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $F^{A}=1+G^{A}+H^{A}$
\end_inset

 is filterable if 
\begin_inset Formula $1+G^{A}$
\end_inset

 and 
\begin_inset Formula $1+H^{A}$
\end_inset

 are filterable (even when 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset

 are by themselves not filterable).
\end_layout

\begin_layout Standard
Show that the functor 
\begin_inset Formula $F^{A}=A+\left(\text{Int}\Rightarrow A\right)$
\end_inset

 is not filterable.
\end_layout

\begin_layout Standard
Show that one can define 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit

\begin_inset Formula $:C^{1+A}\Rightarrow C^{A}$
\end_inset

 for any contrafunctor 
\begin_inset Formula $C^{A}$
\end_inset

 (not necessarily filterable), similarly to how one can define 
\family typewriter
\size footnotesize
\color blue
inflate
\family default
\size default
\color inherit

\begin_inset Formula $:F^{A}\Rightarrow F^{1+A}$
\end_inset

 for any functor 
\begin_inset Formula $F^{A}$
\end_inset

 (not necessarily filterable).
 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* Bonus slide I: Definition of filterable contrafunctors
\end_layout

\begin_layout Standard
When is a contrafunctor filterable?
\end_layout

\begin_layout Standard
When a contrafunctor 
\size footnotesize

\begin_inset Formula $C^{A}$
\end_inset


\size default
 with 
\size footnotesize

\begin_inset Formula $\text{contrafmap}:\left(B\Rightarrow A\right)\Rightarrow C^{A}\Rightarrow C^{B}$
\end_inset


\size default
 has also
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
withFilter
\family default
\color inherit

\begin_inset Formula $:\left(A\Rightarrow\text{Boolean}\right)\Rightarrow C^{A}\Rightarrow C^{A}$
\end_inset


\size default
 – same as for functors
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
inflate
\family default
\color inherit

\begin_inset Formula $:C^{A}\Rightarrow C^{1+A}$
\end_inset


\size default
 and 
\family typewriter
\size footnotesize
\color blue
contrafmapOpt
\family default
\color inherit

\begin_inset Formula $:\left(B\Rightarrow1+A\right)\Rightarrow C^{A}\Rightarrow C^{B}$
\end_inset


\end_layout

\begin_layout Standard
All three functions are computationally equivalent...
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{filter}(p^{A\Rightarrow\text{Boolean}})=\text{inflate}^{C^{A}\Rightarrow C^{1+A}}\bef\text{contrafmap}(\text{bop}\,p)$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{inflate}^{C^{A}\Rightarrow C^{1+A}}=\text{contrafmap}\left(0+x^{A}\Rightarrow x\right)\bef\text{filter}\left(\_\Rightarrow\text{true}\right)$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{contrafmapOpt}\:f^{B\Rightarrow1+A}=\text{inflate}\bef\text{contrafmap}\,f$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $\text{inflate}=\text{contrafmapOpt}\,(\text{id}^{1+A\Rightarrow1+A})$
\end_inset


\end_layout

\begin_layout Standard
but have different laws
\end_layout

\begin_layout Standard
4 laws (naturality, conjunction, identity, partial function) for 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
3 laws (naturality, conjunction, identity) for 
\family typewriter
\size footnotesize
\color blue
inflate
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
2 laws (identity, contracomposition) for 
\family typewriter
\size footnotesize
\color blue
contrafmapOpt
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
as before, 
\family typewriter
\size footnotesize
\color blue
contrafmapOpt
\family default
\size default
\color inherit
 is a 
\begin_inset Quotes eld
\end_inset

twisted
\begin_inset Quotes erd
\end_inset

 version of 
\family typewriter
\size footnotesize
\color blue
contrafmap
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Examples of filterable contrafunctors
\end_layout

\begin_layout Standard
\begin_inset Formula $C^{A}\equiv A\Rightarrow1+Z$
\end_inset

 where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type
\end_layout

\begin_layout Standard
\begin_inset Formula $C^{A}\equiv1+A\Rightarrow Z$
\end_inset


\end_layout

\begin_layout Standard
Examples of non-filterable contrafunctors
\end_layout

\begin_layout Standard
\begin_inset Formula $C^{A}\equiv A\times F^{A}\Rightarrow Z$
\end_inset

 – cannot implement 
\family typewriter
\size footnotesize
\color blue
inflate
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
* Bonus slide II: Structure of filterable contrafunctors
\end_layout

\begin_layout Standard
How to build up a filterable contrafunctor from parts?
\end_layout

\begin_layout Standard
Filterable contrafunctors 
\begin_inset Quotes eld
\end_inset

can consume fewer data items
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The easiest function to consider first is 
\family typewriter
\size footnotesize
\color blue
inflate
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Some constructions of filterable contrafunctors:
\end_layout

\begin_layout Standard
\begin_inset Formula $C^{A}=Z$
\end_inset

 (constant contrafunctor)
\end_layout

\begin_layout Standard
Functor constructions (no need to check laws for these): 
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{A}\times H^{A}$
\end_inset

 for any filterable contrafunctor 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{A}+H^{A}$
\end_inset

 for any filterable contrafunctor 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{H^{A}}$
\end_inset

 for 
\begin_inset Formula $H^{A}$
\end_inset

 a filterable (contra)functor and 
\begin_inset Formula $G^{A}$
\end_inset

 any (contra)functor – various combinations possible here
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv G^{A}\Rightarrow H^{A}$
\end_inset

 if
\emph on
 
\emph default
functor 
\begin_inset Formula $G^{A}$
\end_inset

 and contrafunctor 
\begin_inset Formula $H^{A}$
\end_inset

 
\emph on
both
\emph default
 
\emph on
filterable
\end_layout

\begin_layout Standard
Special constructions:
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv1+A\times G^{A}\Rightarrow H^{A}$
\end_inset

 where 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset

 are filterable
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}\equiv A\times G^{A}\Rightarrow1+H^{A}$
\end_inset

 if 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset

 are filterable
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Addendum
\end_layout

\begin_layout Standard
Notes added after the tutorial was complete
\end_layout

\begin_layout Standard
A polynomial functor 
\begin_inset Formula $F^{A}$
\end_inset

 is filterable if and only if it can be expressed (isomorphically) as 
\begin_inset Formula $F^{A}=C\times\left(1+...\right)$
\end_inset

 where 
\begin_inset Formula $C$
\end_inset

 is a constant type.
 An example of a polynomial functor not of this form is 
\begin_inset Formula $F^{A}=P+Q\times A$
\end_inset

, where 
\begin_inset Formula $P\neq Q$
\end_inset

 are constant types and 
\begin_inset Formula $P$
\end_inset

 is not pointed (not known to be isomorphic to 
\begin_inset Formula $1+Z$
\end_inset

 for some type 
\begin_inset Formula $Z$
\end_inset

).
\end_layout

\begin_layout Standard
Given a polynomial functor 
\begin_inset Formula $F^{A}$
\end_inset

, one can decide algorithmically whether 
\begin_inset Formula $F^{A}$
\end_inset

 is filterable, and derive 
\emph on
some
\emph default
 implementation of 
\family typewriter
\size footnotesize
\color blue
deflate
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
withFilter
\family default
\size default
\color inherit
 such that the laws hold.
 However, typically there will be many legitimate implementations, and the
 application-specific filtering requirements are not obviously guessable
 in advance.
\end_layout

\begin_layout Section
Practical use
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Chapter six of the functional programming tutorial it is about computations
 in the filterable factor consider this example this is a mathematical computati
on how would we express this computation in functional program we can write
 this Scala code now let us look a little bit more carefully about what
 this computation is doing for all integer X such that X is between 0 and
 100 we select those that have positive value of cosine X and then we compute
 square root of cosine X and sum over all those so we sum over only those
 that have cosine X greater than 0 those eggs and then if cosine X Radian
 is greater than 0 it is safe to compute the square root of cosine X so
 we compute that and we add together all those values of the square root
 of cosine X so in the Scala code this is represented by in this program
 because we take the sequence from zero to hundred we map with a cosine
 function we filter with the condition that the argument is greater than
 zero after the filter only those elements which are already transformed
 to the cosine values are left then it is safe to take the square root of
 those cosine values and add them up so this would be approximately the
 result now Scala has a different syntax for computations like this where
 you have a chain of map filter map and so on the syntax uses the key words
 for and the yield so it is sometimes called a for yield syntax I prefer
 to call it a Thunder block because this does not work unless you have some
 functor type around and you're using this only for computations in the
 factory type other names for the syntax are for comprehension now this
 comes from Python I believe and it does not add to my comprehension of
 what this code is doing so I will not call it a for comprehension I will
 call it a functor block because it's a block of code for something yield
 something and it has to be handled as a single expression so if I want
 to do anything with this expression I have to put it in parenthesis like
 this so it's a block that is except is an expression it yields a value
 so how does it work we can compare it side-by-side with the code of this
 program written a little bit more verbally where I wrote out all the arguments
 with names so here I say for example cosine of underscore and this is a
 Scala syntax for a function like this X goes to cosine of X so Scala allows
 you to have this function shorter just say cosine of underscore but let's
 write it out with names of variables and it will be map of X going to math
 dot cosine X then filter Y is going to wine greater than zero the map y
 is going to square root of y and then some the for yield syntax describes
 exactly the same computation and we can come compare line by line how the
 syntax is changing the for yield syntax is automatically transformed by
 the compiler into the form on the right so this is just syntax there is
 no special keyword or function that is called yield there's a keyword yield
 what healed itself is not a function it has syntax keyword so all of this
 is removed by the compiler and replaced by the code on the right the first
 line is equivalent to saying that whatever follows will have the value
 X going from 1 0 to 100 the first line in the for yield block must be this
 line with the left pointing arrow to the right of the left pointing arrow
 there must be a functor a functor value so this value is a sequence from
 zero to hundred and as we know sequences are factors to the left of the
 arrow is a variable or more generally a pattern with pattern variables
 in these examples we will only use simple variables to the left of the
 arrow but it can be a pattern match so the first line says take X to be
 any value in this sequence the second line says compute cosine of this
 value call it Y exactly similar to this is that we compute the cosine of
 X and in the next whatever comes filter or mat or whatever we call that
 why we're free to call that X here in fact aren't we it's a different scope
 it would be confusing however if we wrote X here X equals math dot cosine
 of X we can though it will be valid it will be just confusing so let's
 not do it but it would be exactly the same code if we renamed Y to X in
 what follows in this block just because it's translated into this kind
 of code and there we are free to call this variable by any name we want
 we can call it X Y or whatever the next line here says if y greater than
 zero now if is a keyword and this is an expression that should evaluate
 two boolean just like here this is an expression that should evaluate two
 boolean and this is under filter the last line is yield and after yield
 there can be some expression this expression is what comes here after we
 do the last map so actually yield is just as part of a block as as all
 this stuff it is not different we could put this computation inside the
 block for example we could have said Z equals a little Y and then say yield
 Z instead of this it will be exactly the same computation this would be
 here the last map after that we do the sum the sum cannot be done inside
 the filter block because it takes us out of the factor context as I say
 some transforms a functor value or sequence in the same in this case into
 a single number so every line in the functor block after the first line
 will be repeated for every X that belongs to this sequence however if some
 Y in in this computation isn't is non positive we will not compute the
 square root of Y so this value will be emitted from this resulting sequence
 just like it is here because it's the same code that's just written in
 a different syntax after we filter only values that pass the condition
 are left in the sequence so the same logic is a little more visual in the
 functor block syntax that anything after the if only is executed or is
 computed when it passes the condition so to summarize the funter block
 as a syntax for manipulating data within a container where this container
 in this case this was a sequence of integers it could be any container
 which is a functor which is any type constructor that has a map function
 such that the function laws hold as a result of computations in a functor
 block we manipulate data inside the factor or the container however the
 data changes it will still still remain within the same container so the
 value of this expression is a sequence it can be a sequence of double numbers
 level precision floating point numbers as a in this example so it changes
 type the data items inside the container can change their type of course
 the container does not change it is still a sequence we cannot change the
 type of the container in the functor block it must be within the same container
 so in Chapter four we have started with the container semantics looking
 at the map function and generalized from it to obtain the Kansai the concepts
 of a functor we will do the same in this tutorial to generalize the filter
 we will find what laws the filter must satisfy and what kind of containers
 will be such that you can define a filter method now more precisely in
 Scala there is a method called with filter if your functor has a method
 called with filter then you can use this function in a functor block with
 an if keyword otherwise it will fail to compile so we will call a functor
 filterable if it has a method called with filter that satisfies the appropriate
 laws that we will investigate later in this tutorial however for convenience
 many factors also define the filter method it is shorter to write it might
 be implemented differently for performance reasons in this tutorial we
 will not distinguish between filter and West filter we will consider them
 to be the same function their types are exactly the same and they are isomorphi
c in the sense that they yield maybe different implementations but these
 implementations are completely equivalent this is the type signature of
 the function with filter that needs to be implemented in order for us to
 be able to use the if syntax in a functor block with the factory F Scala
 syntax will be available no matter how you define this method with filter
 it must be that you are able to write F dot with filter it can be done
 using an implicit conversion typeclass or just defining a method West filter
 on your on your data type that does not matter you can use it in the functor
 block after that so the main questions that remains for this tutorial is
 what are the required laws that captured the intuition we have for these
 computations and once we found those laws what are the possible data types
 that are filterable the main intuition is that the filter call the function
 filter when you call it with some non-trivial condition may decrease the
 number of data items that a container holds it may not decrease it but
 it may also decrease the container therefore must be able to hold fewer
 or more data items it must be able to hold in some sense a different number
 of data items of course still of the same type t so here's an example that
 we are familiar with which is option the option type is written in the
 type in the short type notation as 1 plus T and here are some computations
 that we can do with an option using filter if an option is empty then whatever
 you filter it or whatever it still returns empty so that's not very interesting
 but you see if this number passes the condition and the number remains
 but if it does not pass the condition the option becomes empty also you
 can use width filter on an option that actually returns a different type
 not option but that type is isomorphic to option so it still has all the
 same methods as the option has it has map it also has filter and with filter
 and so on so it's isomorphic and it can be used if you wish but as I said
 in this tutorial it will be not important for us how this is implemented
 and what types are behind this operation in the standard library a standard
 library makes its choices which may change with time what's important is
 that the results of filtering can can be an empty option if the number
 inside the option does not pass the condition a second example familiar
 to us is lists so a list type can be visualized as this short notation
 so this is a disjunction of unit a single data item of type T two data
 items three data items and so on and if you apply filter to the list then
 only those elements that pass the condition remain in the list how does
 it work so for instance a list 10 20 30 is a disjunction of three elements
 which is this part of the disjunction after the filter only two elements
 remain twenty and thirty so after the filter we are in this part of the
 disjunction in the second example after the filter we go from this part
 of the disjunction to this one the empty list so what do we learn by looking
 at these examples it looks like the data type must be a disjunction of
 some sort or must contain a disjunction may be somewhere in this disjunction
 must have a different number of data items of type T so that when some
 data items do not pass the condition we take data from one part of the
 disjunction and put it into another part of the disjunction so for example
 here we had ten twenty thirty now this one did not pass the condition we
 still had these two so we put them into these two data items in this part
 of the disjunction so the data goes from one part of the disjunction to
 another as necessary according to whether the predicate P returns which
 is this this predicate P the function from a to Gulen or from in this case
 will be from T to boolean whether this predicate returns false on some
 T values of or true on the on the values that you actually have in your
 in your function another curious thing here we can notice is that when
 some data item does not pass the condition like this one in this example
 we we can see what's happening as if we replace this T with a unit with
 one unit type and the result would be 1 times T times T which is exactly
 is isomorphic to T times T so 1 times T times T is this part of the disjunction
 actually so this is a curious phenomenon that we noticed at the type level
 that certain items are replaced by a unit type and then the resulting type
 like this for example would be T times 1 times T it's equivalent to T times
 T and that's another part of the disjunction so we can accommodate replacing
 some items T by unit type that does not break the type it still remains
 within the same disjunction we will use this intuition later in second
 part of this tutorial and finally we notice that the container can actually
 become empty so all of these examples contain a disjunction part which
 is unit which represents an empty container now of course there are names
 for this in Scala so this is not the unit itself in this case it's a case
 object called none in this case it's a case object called nil I believe
 but that's just syntax this is a name for a unit type so Scala can have
 any number of named unit types the unit is the standard one but you can
 define any number of your own of course so these are these intuitions we
 we gather from these examples we would like to generalize this realize
 we need more examples so let's consider a business application where we
 have the following logic an order can be placed on Tuesday and or on Friday
 and under certain conditions an order is approved so separately on Tuesday
 and on Friday the order is considered for approval now this logic of approving
 or not approving is a function such as amount less than thousand or any
 other requirements we would like to abstract away the logic of approval
 from the logic of which orders are approved and that logic is the one that
 the filter function represents so therefore we will also abstract the type
 of order to a type parameter so we will consider a class or data type orders
 with type parameter a and it has two parts as a conjunction one is an option
 of a another is also an option away you're presenting that we can place
 an order on Tuesday or not and we can also place an order on Friday or
 not and then we define a filter function on this case class by simply calling
 the filter function on each option now this filter function option does
 what we just saw it does these things so that's going to represent exactly
 what we want when T is given some kind of approval condition we can apply
 this condition to the order placed on Tuesday if any order was placed on
 Tuesday and also we will apply it to an order placed on Friday if any the
 result of this definition is like this so suppose we placed an order for
 500 on Tuesday and for 2,000 on Friday but approval happens only when it's
 less than a thousand so then the Friday order will not be approved and
 the Tuesday order will be approved so the result will be this data so would
 have we achieved well we separated the logical which orders will be approved
 from the order of from the logic of how orders are approved and also from
 the specific data type that represents orders so this code only represents
 the logic of how orders will be removed from our container and that's what
 filter represents let's look at example code so this is this code I have
 written here orders 1 because we will have some variations on it shortly
 and here are some typical examples so if we filter with this condition
 then only this one survives now of course if no order was placed and it's
 still empty on Friday so condition is such that every order passes then
 both of the orders remain in the container and finally when now none of
 the orders pass the filter then a container becomes empty so we see that
 orders one is a container that can can represent empty or non empty sets
 of orders and that's the logic we want now in the short notation this functors
 type is written like this it's just a product of two option values and
 option is one plus a so it's one plus a times one plus a as in the other
 examples we see that the a is replaced by one or by the nun named unit
 when the value here does not pass the filter in this case filtering is
 applied independently to both parts of the product but we could consider
 other options for example both orders must be approved or else no orders
 can be placed at all that could be a business requirement another business
 requirement that one could come up with is that if at least one of the
 orders is approved then both orders can be placed so let's see how that
 works in code if we implement the rule a it means that both orders orders
 must be approved for them to be placed now if there's one order then this
 rule does not modify our previous behavior if there is only one order placed
 then we still apply a filter to it as as before but if there are two orders
 placed and then both of them must be approved so let's see how this logic
 can be implemented so first we find what will be the ordinary filtering
 procedure so the Tuesday orders after filtering is this new to use them
 and new Friday now the order the the ordinary filtering procedure would
 be applicable if both of them passed the test passed the predicate now
 this condition expresses that either the Tuesday is empty and for the empty
 option for all is always true well this is a mathematical convention that
 empty for all is true if this is not empty then predicate must hold for
 the value of the option so this condition therefore will be true either
 if both orders are present and pass the test or if one of the orders are
 both are empty and if not empty they pass the test so only in this situation
 we return something that could be non empty and that in other cases we
 return empty container so this expresses the business rule a so for example
 if we have 500 and 2000 and the filter is less than 1000 and one of them
 passes and the other one does not pass and then we return empty container
 so this is the new business requirement in all other cases we do exactly
 as before so for example here one of them passes the other didn't was not
 placed so that's fine all of the orders that were placed pass that's the
 business rule and that's the result then and finally when both pass then
 we return both non-empty so this is the new rule now the second business
 rule that we could consider in the business rule B is that both orders
 are approved if at least one of them is approved so both orders can be
 placed if at least one of them is approved so this is expressed by this
 condition exists on an option means that the option is not empty and its
 contents pass the test so P is a predicate exists on an option is this
 means that other exists a value inside the option and such that P on that
 value returns true so if at least one of them exists in other words is
 placed on order that was approved then we return this which is the the
 value of the container unmodified so we do not actually filter so even
 if some of them did not pass the filter so the first one did not pass the
 filter here's an example first one passed the second one did not pass the
 children but the result is still that we returned both orders so both orders
 can be placed if at least one of them was approved that's the new business
 rule now if one of the orders was empty still we applied the filter to
 the other one if both orders pass we'll return both others if none of the
 orders passed were returned empty container so in this way we have implemented
 these business requirements but now I would like to ask well I can come
 up with any number of other requirements of this kind which of them actually
 make sense in terms of filtering and this cannot be answered without some
 mathematical principles or laws that allow us to decide whether a certain
 function satisfies the laws and therefore it makes sense to be used as
 a filter otherwise we're just going to argue opinions and that is not productiv
e so what are these mathematical laws in order to arrive at them we need
 some more intuition and now we can generalize from examples we have seen
 the main intuition here is that computations in the funds our block should
 be reasonable they should make sense in other words here is a thunder block
 program this program should make sense you should look at it and reason
 about it in a way that is intuitively correct mathematically reasonable
 so let us now think about it and decide and derive what these mathematical
 requirements must be so here's a kind of schematic example of a functor
 block program the first line must be the line with a left arrow which let's
 say has some functor on the right hand side let's say list so then the
 entire block will be computations as we say lifted into the list functor
 or computation in the context of the list function which means that we
 have some data here when we're going to manipulate this data and the results
 are going to stay as a list container now let me go back a little bit and
 remind you that this is not modifying the container in place in any way
 these are mathematical computations are not modifications of anything these
 are values so from the point of view of the program this was one container
 and the result of this expression will be another container while this
 original container is left unmodified so this is just a mathematical kind
 of computation which no way to look at the mathematical equation like this
 we don't say oh was this X modified was this X modified when we did the
 cosine X was this X replaced by cosine X and then we know it wasn't mathematica
lly we never talked we never do this replacing value values our values we
 cannot replace y 100 by anything makes no sense and so let's not replace
 anything we just compute values so similarly here we just compute new values
 every time now imagine we have some kind of program like this we compute
 some functions we filter on some conditions we again compute some more
 functions again filter and some more conditions and finally we get some
 function of all these depending on all these values we computed and all
 these values computed here will be put into the final list and all the
 values that did not pass any of these tests will not be put into the final
 list so what do we expect to be true intuitively true about such programs
 for one thing for example here we have a condition depending on Y but Y
 is defined as f of X so if we put this f of X here instead of why we should
 be computing the same thing it's the same condition x goes over all elements
 in this list and Y is computed and then we check some condition we should
 be able to get the same result if we check this condition directly on f
 of X instead of Y and we should be able to do it first so the order should
 not matter them once we so once we write if p1 of f of X on this line instead
 of this and we write this on the next line instead of that's the way interchang
e these lines and replace Y by f of X it should be exactly the same thing
 because these are values that we computed and these are conditions we we
 evaluate if that were not true if somehow Scala compiled this to a different
 code it will be highly confusing you would not be able to simplify your
 program by substituting values into other places see it looks like Y is
 equal to f of X but then somehow you cannot substitute f of X here that
 will be highly confusing or you cannot first compute f of X in the condition
 and maybe you don't need Y then maybe the older rest doesn't really need
 Y you can simplify your program so you want to be able to do that to reason
 about your program like this here is my value let's substitute it in here
 instead maybe the program becomes simpler now it means we have this requirement
 for any program that has this kind of code must be equivalent to any program
 that that that has this kind of code notice the semicolons I put them here
 because Scala also allows you that syntax you can put this entire functor
 block on one line if you wish and separate the lines with semicolons but
 this might be harder to read it's up to up to you how to write the code
 with one line or with many lines the next requirement is found if we look
 at these two conditions intuitively first we check a 1 and we only pass
 those values that satisfy that first condition and we check the second
 condition only from those that pass the first condition we additionally
 take only those that pass the second condition so that should be equivalent
 to check in just one condition that is the conjunction of these two conditions
 that gives us the second requirement the third requirement is somewhat
 trivial if a predicate always returns true for all values of X for instance
 if this p1 were just identically true then we should remove we should be
 able to remove this check from the program because that should not affect
 at all what's happening if we remove it all the values will always pass
 to the next line and so that's the same as if this check wasn't there so
 that's our requirement 3 another final requirement quite important in fact
 is that remember what we had in our initial computation that the filter
 was for positive Y and then we took the square root of Y now if some Y
 were negative we shouldn't be doing square root of it so in other words
 we rely on the fact that only values that pass the filter will ever be
 used in further calculations after this if line just like we rely on this
 here with after the filter we relied on the fact that data that the node
 passed the filter will be emitted from any further calculation and so we
 formulate that as a requirement that when whenever a filter predicate P
 of X returns false for some value of X then that value of x will not be
 included in any computations performed after that line so that is our final
 condition so these are the four properties that functor block programs
 must satisfy let us now formulate these properties mathematically in fact
 it is very important that we can formulate these laws mathematically we
 it's not just talking about the program you know what you could change
 in the program without changing its result it's not just words we can actually
 write equations and check them to see that these conditions hold how do
 we do that for instance we write the first law like this we say whenever
 there is a function f and the filter condition P such as here the function
 f and the filter condition P then we look at how this part of the founder
 block program will be translated by skeleton pilot into the map and filter
 so this will be map F filter P and this will be filtered P of F map F in
 other words this will be compositions of the functions map F here is AF
 map because that's the right well type the flip map its argument is f so
 map F composed with filter P must be equal to filter of F composed with
 P which is this remind you that function composition works from left to
 right when you when you write it with this symbol F composed P but if you
 want to write specifically as code you must put the functions in the opposite
 order P of F because first YouTube f of X and then he applied P to the
 result and so that's first you took F and then the applied P and Scala
 there is an operation called and then on functions which does exactly this
 in Scala this code would be F and then P which is a nice and visual way
 of writing function composition notice here I did not write it here because
 this is actually going to be code but I could have written elsewhere and
 I will be writing this in the in the example code I'll be using and then
 so in other words the factor block program that has first a map step and
 then a filter step is equivalent to the factor block program that first
 has a filter step with this different condition as it is necessary as we
 were thinking here and then it has the map step now what does it mean to
 have one step of a functor block program remember how the functor block
 program is translated into maps and filters each line actually consists
 is replaced by a step so a function map or fill map with a function filter
 with a function and so on so instead of saying the functor block program
 remains the same when we do this and that with the line we say the map
 with this function would do the same with the functor value as a map with
 another function x filter with another function and so on so we actually
 say instead of saying the Thunderer block program remains the same when
 we change the number of lines or something we say the functor value itself
 the value of the sequence or the value of some other factor the factor
 value itself is transformed in the same way by a certain map and filter
 operation and that's what it is so f map f is a function that transforms
 the frontier value into another frontier value the filter p is a function
 that transforms a function value into another function value and so this
 law says that function values are transformed in the same way any function
 value whatever you want will be transformed in the same way by these two
 functions composed and also by these two functions composed if this is
 so then you can replace here this map filter with that filter map and for
 any functor value here and this could be actually a long funter program
 before that so this could be instead of just a simple sequence this could
 be sequence does map that map does filter those children map all inside
 this expression regardless of this the transformation by these two functions
 will be the same as the transformation by these two functions so it is
 in this way that we can stop talking about just replacing lines in code
 and start talking about mathematical functions and their equality that
 has a great advantage because first of all functions have types we can
 check the types are correct we can reason about functions with types much
 better second functions have values that we can check to be equal for all
 values of the argument this is what we have done before with the functor
 laws and we will do the same now with a filter laws so this was the first
 law the second law represents this condition the conjunction law by the
 way laws have names for convenience but actually there are just equations
 so the first law is called natural ality this comes from category theory
 and it's not important why it is called natural 'ti but basically whatever
 law you have that interchanges your interesting function with f map or
 map that's naturally G so typically that means you can map the contents
 of your container before your operation or you can map it after your operation
 and it's equivalent in some way so that's naturally naturality expresses
 the idea that you're manipulating data inside the factor in some way or
 inside a container and this manipulation preserves the data items it does
 not look into their details so when you map the data items from one type
 to another then your manipulation would be equivalent to some similar manipulat
ion followed by the transformation of the data items so for instance if
 the manipulation is to omit some elements and you can omit them before
 transformation or you can rip them sorry this is will be after you can
 read them before the transformation or you can omit them after the transformati
on if the condition is adjusted appropriately the result will be the same
 or this could be a transformation that somehow rearranges the order of
 elements or does some other such thing that does not actually look into
 the elements values themselves but just rearranges something about them
 it can emit them which can duplicate them and so on so all these transformation
s are called natural and so therefore this law of natural T is called let's
 look at the second law now the second law represents this requirement that
 if we have two conditions next to each other then we can replace them by
 a single condition that is the conjunction of these two mathematically
 we can say that the filter transformation so think about filter P as a
 single symbol just like F map F is a single value that transforms the functor
 values FA to FB so filter filter P transforms FA 2 FA so this is a transformati
on of theta FA composed with another transformation of FA 2 FA and they
 must be equivalent to a filter transformation again FA 2 FA when the predicate
 is equal to the conjunction of these two predicates so I have written down
 the mathematical conjunction but of course in Scala code there will be
 just the double ampersand boolean conjunction so that's the second law
 the third law is that if the condition is identically true it returns true
 for all X then the transformation that the filter on the functor is identity
 does not change the function value at all and if this is so then whenever
 you have a filter with identity function you know that whatever was before
 is going to be identically preserved by that kind of filter so you can
 just you delete that operation and that would correspond here to deleting
 this line if this were an identically true condition so in this way you
 see how mathematical laws actually represent a general way of manipulating
 code and the fourth law is a little more complicated to formulate so filter
 P and followed by some map that's we're trying to describe what it means
 that X will be excluded from computations performed after this if so we
 need to put some computation after this if let's call it let's say this
 is a computation that is transforming by F it could be a filter right so
 we have a filter or F map as possible computations but we already have
 a law for what happens when we have a filter followed by a filter so now
 we have a law about what happens when we have a filter followed by F map
 so this computation F should not see any values X for which PA will return
 false how do we express that but F should not see those memories a good
 way to express that is to use a partial function instead of F I denoted
 it like this so F barque is a partial function that is only defined for
 those X for which the condition P holds in Scala this could be written
 like this it's a case expression with the condition and if the condition
 is true we just return f of X so we don't change the function f but now
 if the condition is not true this partial function fails it will it will
 be a runtime exception if we apply this partial function to value X for
 which P of X does not hold so the filter guarantees however that all further
 computations will never see such X for which P of X does not hold and so
 therefore it should be safe for us to use that partial function here after
 the filter so the filter transforms FA to FA look at this type signature
 again filter P so we put the first argument and the result is a function
 from a fatal funny so filter will transform a fading in such a way that
 the values that are left in it will always pass the condition P and so
 it is safe to apply a partial function not only it is safe but it will
 give the same result because the partial function is made out of the function
 f unmodified so therefore we have this law that filter followed by MANET
 should be the same as filter followed by a partial function map and it
 should be safe and it should give the same result so that is well because
 it is safe mathematically we don't know how to express that we just say
 it needs to give the same result if it always gives the same result for
 any functor values that you put into this transformation then you are safe
 so here are the four laws and we can define a typeclass let's call it filterabl
e and the typeclass will have a method with filter which will be a partial
 type 2 value function and this function must satisfy these laws together
 with F map so we cannot really define filterable without also defining
 map for this type so this partial type 2 value function must be defined
 in such a way that it requires already the functor typeclass as a constraint
 so it is only defined for types 4 for type constructors that are functors
 and so then for those we already have F map with the correct laws so those
 are necessary for filter so filter is a further property of a functor so
 we can say it's a filterable functor so let us see if the laws hold for
 the functor example that we have the orders but with Tuesday and Friday
 we will also look at some examples of the filter block program notation
 so before we return to the orders example let's refresh the filter block
 notation so here are some examples we take integers from 1 to 10 we perform
 some calculation with them so there's this Y will be I computed for each
 of these axes then we impose the condition that y is negative and only
 for those Y's we continue so then Z is computed then we impose another
 condition of Z and then we can get something else but actually we don't
 use this P and that's fine and then we return a tuple we don't actually
 return a tuple we return a sequence of these tuples the yield is not the
 final result of this entire factor block the yield is the result of a single
 computation for a single data item inside the factor or if you wish the
 container of data so now I'm showing some transformations that you can
 make so for instance here instead of saying if Z is less than 100 on line
 86 I'm saying on line 96 if this entire expression is less than 100 and
 then I compute Z later and that gives the same result and also instead
 of doing P equals Z minus X which I'm not actually using so I could actually
 should actually delete this from the code I use P here and that's exactly
 the same so you can put more computations into the yield part of the block
 or fewer computations you can put some of them here it's entirely equivalent
 and the only consideration here is readability how easy it is to read the
 code and understand what it should do also I can mathematically express
 this condition as a condition on Y is that absolute value of y must be
 less than the square root of 100 minus six and together gives the same
 result so I can transform these conditions in any way I want and the results
 are the same and finally I merge these two conditions for y into one condition
 using the conjunction law and again the results are the same so this is
 the test not very far yet so this isn't this is the way that we expect
 the program to behave we expect to be able to simplify the program in certain
 ways so that for instance here we notice we compute this expression twice
 let's not do it let's compute it here first as Z and then use it that's
 a typical transformation of a program that the programmer would do so we
 see that the naturality law the first law of filter guarantees that this
 program transformation is valid it does not change the result what a surprise
 it would be if that were not true a programmer would look for a button
 for a very long time and this is because reasoning about the program has
 become broken if you break the laws of the filter so it becomes impossible
 to reason about the program by looking at the code we should avoid that
 at all costs breaking mathematical laws is something that has real costs
 that has real consequences makes our life much harder so now let's see
 if these laws hold for the orders example to do that we define the typeclass
 instance in the example code I have defined typeclass called filterable
 with filter I have not found a standard filterable typeclass in libraries
 either in the cats or in the Scala z library so I defined my own it's just
 a few lines of code to do that [Music] we'll see how that is defined it's
 using an abstract class with an implicit function value which means that
 you cannot create instances of this abstract class without having a functor
 instance for your type constructor f so in this way I enforce that filterable
 here must be already a factor and then it has this method which is in the
 way I implemented the partial type T value function so I define the partial
 type to type function and a partial type to value function the other typeclass
 is just called filterable not filter ball with filter and it does not define
 a function with filter it defines a function called flatten so this we'll
 be talking about in the second part of this tutorial so now we only look
 at filter and it's its properties in order to define typeclass instance
 for orders so that we you find a partial type 2 type function extending
 it to orders we need to define this and override the function with filter
 and also we need to have a functor instance for orders until we have that
 this wouldn't compile so we need to have the functor instance well a functor
 instance for orders is the straightforward thing orders is a simple conjunction
 type option times option so the cats library has an extension that derives
 such functor instances for case classes so I'm just going to use it very
 convenient very little typing when it works we'll see cases when it doesn't
 work so we first define a functor instance and then a filterable instance
 so how do we define the federal instance we just override the function
 with filter in the class and this is the exactly exactly the same code
 as we had in our first example we filter the first option we filter in
 the second option and notice that this is a standard library function on
 options so this is not the function I am defining this is not really recursive
 in any way this is a standard library function already defined on option
 and very easy one to implement so then I check the laws now I have implemented
 this law checking helper just as I did with factors so let's look at how
 it's implemented so it has a bunch of arbitrary values as at once and then
 for all these values I will check the laws so the first law is that map
 followed by filter is the same as filter followed by map the only thing
 is that the filter needs to have a different function type so this is a
 2 B this is B 2 boolean and this is a to be B to boolean so this entire
 thing is a tubulin so then it is filter of a and then a to B so first you
 map filter than you filter map and that should have equal values the conjunctio
n law is that we do a filter not filter and that's the same as filter with
 this function the identity law is that you do a filter with something that's
 identically true and that should be exactly the same as what you started
 with so in all these examples I have an arbitrary value of the function
 and I check that for an arbitrary value of the funder these transformations
 are equivalent give the same values so for this I need to be able to compare
 values of the factors so learn in this extra function compare for equality
 of the funder this is very similar to what I did in the factor that class
 they finalized the partial function law for which we savings the filter
 P and then map F and then we do a filter P and then we map using this partial
 function which is f except that it's only defined for those X for which
 P of X is true so here are the four laws naturality sometimes called permit
 Rissa t but let's avoid the mumbo-jumbo and not reality is not mumbo-jumbo
 because it's natural so conjunction law identity law and partial function
 law so this test passes so the laws hold for this order's functor with
 this type cons instance now notice in this test i define the functor instance
 outside the test but the filter will instance inside so that i can define
 different filterable instances in different tests and that's what I will
 do I will first vary for example 1 which is this straightforward filtering
 here's how it works so we can use it in the filter in the filter block
 notation data is this orders of some orders of 500 and 2,000 so X is compared
 with 1000 which is our approval criterion and then we transform to a string
 and the result is the orders of transformed and they're printed more nicely
 and this second order was not approved so the first order was approved
 the second example is the orders with business rule a and orders with business
 rule a is this more complicated code that we saw before again we check
 the laws and notice we define a different filterable instance and so this
 checking is with a different instance and exactly the same function block
 code returns now empty orders because for business rule a both orders need
 to be approved for any of them to be placed and so exactly the same function
 block code now gives a different result because we define the filterable
 instance differently and interestingly the example 2 B does not work that
 it breaks the function or sorry the filterable law it does not break the
 function but still factor it breaks the filter rule law and so this fails
 and actually there is specific data that shows it to fail and also it fails
 a partial function law and so we will look at it why why that happens for
 now let's look at this well actually that's what's finished with the orders
 why does the law break it's an interesting consideration so if we filter
 with one filter and then it was another filter that should be equal to
 the filtering with a conjunction now in this example I chose the two conditions
 so that their conjunction always returns folks so we should be having an
 empty container after this however in the data one of the orders is below
 and one is above thousand and so the business rule to be says that both
 orders can be placed if if at least one can be approved and so then after
 the first filter both orders are still placed and I laughter the second
 filter also both holders can be placed however if we filter with the condition
 that no orders pass then we get an empty order so that's not the same and
 also breaks the partial function law we filter with a condition and we
 use the function that is only defined when that condition holds and we
 have an exception at runtime so what happens here is that it's counterintuitive
 we thought we would limit computations to these eggs but actually we have
 not limited them to that to the next mm is still there so reasoning about
 a program that uses this filter implementation would break our intuition
 about what the filter should do and that's why this is not a good filterable
 implementation so business rule to be is not filterable [Music] so now
 consider the example of this factor it is a disjunction that has either
 no data items or two data items so it's a product or nothing how can we
 implement it as a filterable so I call this a collapsible product for reasons
 we'll we'll see momentarily well we first derive a functor for it so the
 type isn't just an option of tuple a a which is this type now how do we
 define filter for it well let's write this function so we have F a of type
 option to pull a a and we have a filter function so now option to call
 a a has two cases in the disjunction first as its non-empty with some values
 X and one now what can we do we must apply the filter to both of them because
 if we don't go fail some of the laws as we just saw with the business rule
 to be example when we don't apply the filter to some of the values then
 partial functions will fail and conjunctions may also feel so now if we
 apply to X and we also applied to Y what if one of them passes and the
 other does not what we can we have to exclude the one that did not pass
 but our type has a disjunction that has only two parts one must have two
 and the other is empty so if X passes and why does not pass we cannot retain
 Y we could retain X if we had any way of retaining X but we need a we need
 a two value so we cannot just put X here we need another value we could
 put X twice I'm not sure that would be a good idea though it doesn't feel
 right it probably will violate some law if you do that it feels wrong but
 you duplicate values it will be I have not checked it so you're welcome
 to check if the laws hold with that implementation but the most reasonable
 implementation is that if none of them if if only one of them passes we
 need to remove both so we get the empty container so that's how it's implemente
d so only if both x and y passes the test the container is unchanged I just
 write FA just to save typing sum of X Y again and it's faster otherwise
 we return empty container so laws hold I checked the laws with different
 types just to be sure now as a reminder this function takes type parameters
 so that it cannot just check laws with all types at once it's impossible
 you have to give specific types on which you would check the laws so transform
 from int to strain to something that need to be specified so let's look
 now at examples of functors that are not filterable so we have seen that
 orders with business you'll be or break laws it actually breaks law for
 as well now another example of a function that is not filterable is a function
 that defines filter in a special way for certain types for example for
 into type it defines the filter function in one way and for all other types
 in a different way so that is not natural the filter should not look at
 types it should manipulate data without regard of its type so this type
 a should be unknown type and should not check that it is integer or something
 else so it actually breaks slower so let's look at how that works so here
 is this factor a zero which is just an option and I'm going to define a
 filterable instance where I define a filter not in the way that usual option
 is defined in the filter I will first check if the type is integer if the
 type is integer then I'm going to check the condition if the condition
 passes I do whatever what was before I return the same value if the condition
 does not pass then I return zero so this is actually zero so I especially
 prepared this so if the type is integer and the filter fails I replace
 the integer by zero that's a special rule that's only used for integer
 for all other types i do the standard thing and filter on an option in
 the standard way so this kind of thing is an incorrect implementation of
 filter because it is not natural in the type it is using some information
 about the type that is not parametric and what happens is that as long
 as you don't try to use the integer type then you are in this second case
 and it's all right it's it's it's correct but once you start using the
 integer type then naturality law fails and if you uncomment this test and
 run it it won't tell you that it failed in the natural tool and here's
 a counter example that breaks naturality law we say this data is some zero
 subtract one and check that it is greater than zero and another way is
 to check first that X minus 1 is greater than zero which is the same right
 y is equal to X minus 1 so I could put this X minus 1 in here which I did
 and put the condition first and that should be the same it doesn't matter
 if I first check the condition and then compute X minus 1 or if I first
 come to the X minus 1 and then check the same condition but the results
 are not the same so actually the first result is not equal to the second
 one the second result is not empty the first result is empty so that is
 a clear violation of the naturality law so this is this shows you that
 we are trying to reason about the program and we refactored the program
 in some way and the results changed this kind of bug would be very hard
 to find you refactor your program and results change example is this factor
 1 plus a where the filter is defined so that it always returns 1 plus 0
 now 1 plus 0 is my short notation for this part of the disjunction so it's
 only the unit so 1 plus a is option of a and 1 plus 0 would mean none so
 you always return none part of the disjunction now if you do that here
 is our implementation so the filter always returns none that breaks the
 identity law if filter with true and it's not the same because it always
 returns none so if you did not have none to begin with you get none and
 that's regardless of what you filter so even if you filter with the true
 that's still none so that breaks like the identity oh yeah there were 3
 so these are so far wrong implementations of filter this is the notion
 type as we know it has a good implementation of photo so now the last two
 examples are functors that cannot have an implementation of filter they
 are not filterable so let's see how that works the first is the identity
 function it's not filterable identity factor needs to implement filter
 but how can we implement filter well we get a value a and we need to return
 let me let me just you bring then use two penny for clarity we get the
 value of type a and we need to filter now if the condition does not pass
 there is nothing for us to do except still to return the same value so
 we cannot actually apply the filter there's nothing we could do if the
 filter were to return false there's nothing we can do we must return the
 value of type a and so we return the identity so basically this is a filter
 that always returns identity does not ever filter out anything and that
 breaks the partial function law because it does not filter out anything
 and so we rely on filtering out certain values and that expectation is
 broken so here's an example we have some data with a negative number we
 filter by positive we take square roots and we expect that everything is
 fine but actually the result is this not a number because square root of
 a negative number is not a number and so our expectation is broken and
 the second example is this factor is a product of a and 1 plus a now one
 plus a is option a is the identity factor so it's a product of two factors
 one of them is not filter what we just saw the other is filterable it turns
 out that the product is still not filterable so why is that well a very
 similar reason we have a value of type T and the value of type option T
 if this value does not pass the we need to remove it somehow from the container
 but we can't the container always must have a value here it's a product
 so it requires both parts and so it always must have a value of type T
 here we can not remove it so let's suppose this were some value and this
 were an empty option so this one none the only way we could filter this
 is to retain this value X and that's the same problem as we had with the
 identity function if we do not filter out values that don't pass the test
 when we violate the partial function law so this is exactly the same test
 as before we violate the partial function law so to summarize this these
 laws one to four these are equation laws with in other words these are
 equations for functions there are not just some kind of vague descriptions
 of what we do with the code these are actually mathematical equations for
 functions that can be proved to hold or not to hold and these equations
 rigorously specify what it means to filter data in the container so we
 have derived these four equations from our intuitions about what a filter
 should do now we will only use these equations we will not need to do any
 more intuitive reasoning we're now on solid ground and we will derive there
 is functors filter ball or not filterable in these worked examples in the
 first example john has up to three coupons and Jill after two coupons all
 the John's coupons must be valid but each of jewels coupons is going to
 be checked independently why is this even described by a functor we need
 to abstract the problem from details and see how we can represent this
 as a functor and then we will see what is the filterable factor first of
 all to represent this as a factor we need to have a tight constructor so
 what is a type parameter more clearly the type of coupons the factor is
 going to be the container with all the coupons the type of the data that
 coupons represent is going to be a parameter so we are going to abstract
 away a specific type of the coupon data so then we have a container that
 has two parts so it's a conjunction one part is John's coupons and other
 part is juice coupons and the first part will be itself a disjunction because
 it can have zero one two or three coupons the second part zero one or two
 so once we reformulate the situation in this way it is clear that it is
 represented by a factor and then the conditions of coupon being valid is
 an arbitrary condition which is a predicate a function from coupon type
 to believe and we are going to filter our container using that condition
 and the result will be a container having all valid coupons according to
 the logic defined here so the first thing I would do is to write the type
 in a short notation then I can have a bird's-eye view of the data so the
 type is a conjunction of two parts Jones coupons is a disjunction of unit
 one coupon two coupons three coupons and each group one is represented
 by a data item of type a joke just coupons is a disjunction of 0 coupons
 one coupon and two coupons so now we can implement this in a standard way
 using sealed trades and case closes so for convenience we first implement
 the left part of the disjunction and the right part of the disjunction
 ah sorry of the conjunction and so at the end we'll have the functor coupons
 which is the conjunction of jones coupons and jones coupons as before we
 need to define the factory instance so we use automatic derivation for
 functor instance now it remains to implement in a filterable so the logic
 is that first of all jones coupons and jost coupons are validated independently
 so jones are independent from Jules for John there is one kind of logic
 and for Jo there's another kind of logic so what is it for Jones well if
 there is any number of coupons there could be none and then we don't have
 to filter anything there is any number of coupons then all of them must
 be valid by the filter condition and then we retain them otherwise we discard
 them so logic is that if John has no coupons then we return again in no
 coupon situation if there's one coupon and the condition is valid then
 the coupon is retained otherwise we return the empty situation if there
 are two coupons then both must be valid and then we retain both of them
 otherwise we return the empty situation again similarly for three coupons
 so that's the logic for John's coupons and for dos 2.0 logic has just examined
 each coupon separately so there's one we keep one if there are two we see
 which one returns true so we use this matching on pair so we compute a
 pair of two boolean values corresponding to whether the filter results
 are true or false for c1 and c2 which are the two coupons of jill's and
 then we match at the same time on both values of the pair so that it makes
 the code a little more clear and readable so we have just four situations
 and way you turn one coupon or two coupons or zero coupons so finally having
 computed the new filtered John's coupons and filtered jos coupons we put
 them into the coupons let's class into the conjunction and that's our result
 so now here is some test data there are two coupons each for John and Jill
 but the condition is that the value must be above 150 and so for John one
 of them is below and so none of his coupons are valid for Jill one of the
 coupons is valid and then this Thunder block will transform the coupon
 value into a string and so we see that John's coupons are all gone they're
 not valid because one of them is not valid but Jill's coupons have been
 filtered differently so the valid coupon is retained and there is a Jill
 one disjunction part so that's how we can implement the situation and this
 is indeed a filterable factor which we can check automatically by a helper
 function that checks the laws the second example is that we imagine that
 there is the server that receives a sequence of requests and each request
 must be authenticated now there's a special logic that once an own authenticate
d request is found the server accepts no further requests how shall we describe
 this with a functor and how shall we make that function filterable if possible
 so the server is representing a sequence of requests so let's first of
 all generalize the request type to R so we have done a sequence of our
 as requests we make the functor instance for the server and that doesn't
 seem to work with automatic generation so we just do the met by hand this
 is not a lot of code the server is just a sequence wrapped in a case class
 so we just need to call me up on the sequence so how do we implement filterable
 so we need to take requests one by one until we find a request that is
 not not authenticated so we abstract the condition for being authenticated
 as a predicate that goes from a to boolean and then we use the function
 take while which is the standard library function defined on sequences
 and this will take the initial part of the sequence until while the predicate
 is true on the well on elements of the sequence until we find an element
 that fails the predicate or until the sequence is over so we compute that
 sequence and though so we have the resulting instance testing this we do
 using this test data so let's say the condition for acceptance would be
 that the square of the number is less than 1000 and so then only the first
 three numbers satisfy now I could actually put a zero here and it still
 would just be the first three because after this the take wire will stop
 taking illness once one element was found to fail the condition and so
 this logic is now encapsulated by this code you see in this code I do not
 mention this logic that the server should take sequence and so on it looks
 like I am just processing elements one by one for each X in the container
 compute this and check this condition and then compute this so this code
 describes what I compute and the logic about how elements are retained
 or emitted from the container is encapsulated in the filterable in instance
 that we defined over there and as usual we check the laws of the filterable
 the other examples already start with a tight data type in the first two
 examples I showed how you can stake a real world situation and convert
 it into a factor with a filterable instance so this should help us to learn
 to recognize such situations in real life and make code so that the logic
 of filtering is separate from the logic of checking data data for conditions
 well so the filter by instance helps us separate such situations in three
 parts first part is the data type privet which is completely freed data
 it's a type parameter so we can we will separate all knowledge about the
 data type into a different part of the code second is the predicates in
 which we filter so the specific logic for checking valid coupons or authenticat
ing requests so that's a function from this data type to boolean so again
 this is implemented in a different part of the code and the third part
 into which we split the code is the filtering logic which is which elements
 are retained and which elements are emitted under what condition so the
 condition is already given but then for instance for John all coupons must
 be must be valid for Jill they're all independent and for the server the
 initial subsequence must be all valid and so on so that logic is what the
 filter will instance implements so by recognizing these situations and
 structuring the code in this way we separate concerns and so in the following
 examples we assume that the first two logical steps have been made and
 we already have a data type and it only remains to see if that data type
 is filterable and if so to implement the filterable instance the first
 example is this case class which is written here so the first step for
 me would be to write this in a short notation because then I can see much
 more clearly how to implement anything with it so the short notation would
 be this so there's an option and conjunction or product with an optional
 tuple so now I'm this type that I see it's a product so I can filter this
 because this is an option and I can filter this because we just had this
 example this was the collapsing product example I can filter both of them
 so most likely I can easily filter the product by just filtering the two
 parts so let's see how that works by actually declaring separately the
 filter both instances for the two parts of the product and then combining
 them so the first type would be optionally in a second would be option
 of two point a so that's the first type the first the part of the conjunction
 and the second part in the conjunction so they functor value needs a functor
 instance needs to be defined so we use a giraffe for that and the filter
 will instance needs three defines our we define these functions in the
 usual way so that i just wrote out here the code which would be exactly
 the same as a filter clean but just for clarity and to illustrate what
 exactly is doing this is the code so the option is standard filter instance
 for option f is non-empty we need to check the condition for for the value
 that's in it and if the condition holds then we return the non-empty option
 as it was so unchanged in all other cases either it was empty or it is
 not empty but the predicate does not hold we return empty option the second
 factor is the option of a tuple and here we did what we did before if both
 conditions are valid we return unchanged otherwise return none so either
 we had an empty option here or we had a non empty option but one of these
 conditions failed so then we return empty ocean so now we have defined
 two filterable instances for the two parts of the conjunction let's now
 define the total instance for [Music] the conjunction itself so as of this
 class p that is defined here and all we need to do so again we derive the
 function automatically all we need to do really is to take the two parts
 of the conjunction and filter them separately now just to note this detail
 of the syntax of dot filter is available because of this typeclass so the
 first is of type F one of a so it's some kind of function second a subtype
 of two away it's another kind of function that we defined these factors
 do not by themselves automatically get a dot filter method so this method
 as a syntax appears once you define the class at the typeclass of filter
 ball and then in the imports at the top of this test file you look at the
 imports I have imports filterable so the filterable is the object filterable
 underscore so the filterable is the object that contains all the syntax
 for the factory and sorry for the filter multi class so this is the way
 that it is defined which we already saw in the previous tutorial so let
 me just go very quickly over it the filter syntax is defined when we have
 already with filter then we defined also a filter isn't an alias to with
 filter and we also define other functions which I will talk about later
 but this is this implicit class that converts your factor into something
 that has this syntax this is a pure syntax extension which does not change
 the code we could have used the different syntax we could have said yet
 the evidence value for this partial function and the evidence value contains
 the filter call that so that will be just less readable using that syntax
 we have this more readable style of dot something dot something does something
 which is easier to read so now we can check the laws for the P using these
 definitions so you see it's very easy to derive filter instances if from
 parts that already have filter instances and we will look at it in more
 detail later the next example is this type now if you look at this type
 its int + int here and also in so each part of the disjunction has an int
 so we could factorize it out like in ordinary algebra with types and we
 have int times 1 plus a plus a na plus a a in we could have done this like
 that and then we already have a filterable instance for this cut type because
 this is John's coupons in their previous examples we already have an implementa
tion of this type so we could just leave the integer unchanged under filter
 filter this and we're done now the other implementation is possible and
 valid there's another implementation that's perhaps more interesting because
 it keeps information about what filters what items were filtered out and
 it gives you no trivial information in these integer values yet it's still
 consistent with the laws so let's see what we want to do well so let's
 look at this type what we're given suppose that we are in this part of
 the disjunction so we are given a value which is in this part of the disjunctio
n then we filter something and we have one of the data items not passing
 the test so two of them are left well clearly we have an int we have two
 data items so we should be in this part of a disjunction so we will move
 data over here and in this way we implement that's how we did in the Jones
 example Jones good but we can also add one to the integer value here to
 show that we have emitted one data item so more generally this type allows
 us to implement a filter in such a way that whenever we emit some data
 items we can add the number of these items to the integer value and in
 this way we will in some sense keep track of how much we have lost so how
 many have been filtered out this could have been this could be an interesting
 implementation for certain cases maybe so let's see how it works so we
 implement first of all this type as a sealed trait with four case classes
 sorts of disjunction with four parts so this part will be just the integer
 this part has one item two items three items implemented functor instance
 now we implement the filtering so how we do this well actually this is
 a bit complicated because of all the different cases that can help so in
 order to simplify the code I implemented the ad function from list that
 converts a list of a into this leader structure and a list of a should
 be at most a length three so this function takes an integer and takes a
 list away and then it implements it finds out how many elements are in
 the list and notice this thing it adds to the integer the number corresponding
 to how many elements were not in the list so now I'm using this function
 and implement the filter so if I have zero elements I returns in your elements
 nothing to filter if I have one element I check the condition and if it
 passes I return unchanged otherwise I return the zero elements but I increment
 the end showing that I have emitted one element and similarly for all the
 other cases I filter but then I put the new integer into the data items
 in other words that's what I implemented so here's here's an example so
 I have it initially three elements with integer equal to zero and I have
 a condition that the string has length less than for only two elements
 sorry only one element passes that test and so this code will give me a
 list of one a one with a value Firefox and the integer value too so that
 was here so L plus two and plus two in other words I know that after filtering
 this is the result of Firefox went to items were filtered out so in this
 way I can implement more interesting logic and and keeping track of how
 many items were deleted because I have the integer value in the types so
 that's an integer that's so interesting presentation of the filter and
 I can of course check I should check that laws hold in fact if I changed
 anything here if I put n plus three here for example instead of n plus
 one the laws would not hold why is that because for example we have a conjuncti
on law or the filter by one condition and then filter by another condition
 the result must be equal to the filtering by and junction of the conditions
 so the keeping track of how many elements were deleted must be consistent
 it must actually keep track of the number of elements deleted because only
 that will satisfy the conjunction law if you first delete one element then
 you delete two more elements then it should be the same as if you deleted
 three elements and right away and so the integer must reflect that so if
 the integer does not reflect that you will violate one of the laws the
 next example is the functor which is non empty list it's a recursive function
 defined like this so it's type F is defined as a disjunction of a or a
 times F so it can be a or it can be a times a or it can be any times a
 times a and so on so it's a list that has always at least one element is
 just like a list except it does not have the unit it cannot be empty so
 actually this cannot be filtered law the intuitive reason for this is that
 the empty container cannot be represented so this disjunction [Music] as
 this form a plus a times a plus a times a times a and so on and all the
 parts of the disjunction have at least one item of type a and so if let's
 say the filter condition were identically false we should have excluded
 all data items but we cannot because there is no part of a disjunction
 that represent in all data items there must be at least one somewhere so
 if we had a functor like this you'll find recursively like this or in some
 other way with a 1 plus something so if we had the unit as one part of
 the disjunction then we would be able to represent the empty container
 using that part of the disjunction but now we we can't so let's see how
 that works so we can certainly write down the factor a functor instance
 is fine and we can try dividing a filterable instance but we will fail
 the laws and the reason is when we do this case so how do we define the
 recursive first of all how do we define recursive filter for instance we
 use this function with filtering recursively so there are two cases for
 the disjunction one case is the one in this case we just have no choice
 except to return the same value because there's no way to represent anything
 else we cannot represent empty now the recursive case with tail we again
 we don't do anything with the hell because well we we could actually they
 wouldn't help us by we could we couldn't actually filter the hill it's
 not true there's no way to point a filter at your hand let's apply it I'll
 still fail of course because if this one is wrong we should have used the
 filter here as well we can't there's no way to present absence the absence
 of data but let's try as hard as we can so what do we do with the head
 well we need to check whether the predicate is true on the head if if so
 then we can return this otherwise what if the predicate is wrong is false
 only head well we don't have this a so we omit it we still have FFA we
 can filter F of n notice we are returning this part after filter so we
 can omit that and we return F of a which is the tail which is off of the
 same type non-empty list already and that's fine because it's recursive
 type so this type is the same as the entire type it's recursively the same
 so we can return a value of this type of a way taking as a tail so we can
 return tail organ return filter detail it will be of the right type so
 this is the best we can do to implement filter law but that actually won't
 help us if we are we see what happens here well I'm just ingest all the
 tests so we could filter on this so how would that work this is an instance
 of the non-empty list with two elements both negative and we want to filter
 with a positive condition and then we take a square root so according to
 the logic of what the filter should do let's reveal an empty container
 because none of that one should pass the test so we should never can compute
 any square roots in this calculation but this is not what happens because
 the filter is wrong so the first one is filtered so we were here P hat
 is false so we're in this case so we return the filter on recursive so
 this is a recursive invocation of the seen function with the filter we
 returned the recursive invocation on this then we are in this case where
 we must return the same thing since there's no other way to do anything
 there's nothing else that we can return so as a result the square root
 will be applied to minus 100 so this would be emitted but this would not
 be emitted so in other words this filter fails to filter out some of the
 data and that's why it's wrong it's not going to satisfy laws and it's
 not filterable so in fact it is impossible to implement the filter function
 correctly it's not just that we didn't manage it's actually impossible
 in this second part of the tutorial we will see why the next example is
 this factor which has two type parameters but we are interested in the
 type parameter a so there's a Z or there is an integer Z a and a so how
 do we filter that I certainly it's a functor its covariant in a but how
 do we filter so in order to understand how we will filter this I look at
 the type in this notation and I imagine well it would be if one of these
 failed the filter well if if no element fails the filter I know what to
 do I just return the same continue so the only question is what happens
 when some elements fail the filter condition and so then let's say this
 one fails and let's say this one passes so I have to exclude this one but
 and what can I return like I must return one of these two parts of the
 disjunction I cannot return this part well I could I could duplicate this
 value it's probably not very interesting but I might want to do this in
 some cases I shall return this perhaps well it's more logical right you
 have fewer data items after filtering if you duplicate then you don't represent
 the fact that you have fewer data items and maybe it is better to try to
 represent that fact if you can and here we can so we can actually return
 Z we had a Z already we can just return it we don't need to change it in
 any way we just return it and so in this way we will be representing a
 collapsible filter collapsible product so if at least one of them fails
 then both will be filtered out and will have this value which will we will
 use to represent an empty container now this value is not going to be just
 one value like a unit if it's some type Z and we don't know what that type
 is but having that part of the disjunction will represent an empty container
 doesn't have any ace in it it has a Z in it but that's not what we were
 filtering we're filtering AIDS so this is totally fine to represent an
 empty container and notice we can only return the Z because we already
 had a Z in this part of the disjunction so in this part we already had
 a Z if we didn't for instance if we had this type then there's no way for
 us to return a Z when these two fail all the tests we have an int we have
 an A but we need to return a Z we can't and so this factor is not filterable
 with respect to a so just to show you that it's important that in this
 function there is a Z here and the Z here all right let's implement so
 we will just write it short without we don't need to have sealed traits
 here just right on either of Z and this conjunction or the product or the
 tuple the same thing so either of Z and tuple these things is the type
 now we have a type constructor with two parameters and we only are interested
 in a factor with respect to one parameter so we need to use the type lambda
 or anonymous type function which is written like this I'm using that projector
 plug in the kind projector plug-in so this syntax means take this type
 constructor fix Z consider the second type parameter as unknown and the
 result is a type constructor which still waits for a type parameter to
 be given and that's our type constructor so that's the syntax equivalent
 syntax is let's say we could say lambda X going to f of Z X so the capital
 lambda introduces a type function and so the type function is taking the
 type X and returning this type so this type function is an anonymous type
 expression that is unnamed type expression it represents a type function
 a functional type level takes one type argument and returns a type so just
 like our anonymous functions are called lambdas anonymous type functions
 are called type lambdas what the type lambda represents would be something
 like this if we could write it with which we can note for example Q of
 x equals F of G of X now if Z were not a type parameter but a type that
 is already fixed somewhere we could write this and then Q would be a type
 function that we want but in this situation we cannot write that because
 Z is not a fixed type C is a type parameter so we must put Z here which
 defeats the purpose we want a type constructor with a single type parameter
 we want to fix the Z type parameter in F and we want the result to be type
 constructor with a single undetermined type parameter so that's what type
 lambda does so this syntax does not work an alternative faster syntax for
 this is that so this is a tentative syntax that works and let me just for
 reference show what it would be in ordinary functions so we had an ordinary
 function let's say f of X we want to define a function that fixes the value
 of Z and only considers X as an argument so we want a function with one
 argument which is f of X but we don't have a Z to do that Z is not available
 in this scope so we cannot do that so instead we write an anonymous function
 such as X going to f of Z X so in an expression where Z is which is known
 this this can be done so we don't need a name Q for this function it's
 an anonymous function so this is exactly equivalent and the Scala syntax
 for this can be shorter we might list and so see the syntax of the kind
 projector podían was designed to resemble the ordinary Scala syntax for
 anonymous functions were lambdas to give you an honest type functions for
 type lambdas so this wasn't aggression just explain what is it going to
 have a type London so we need to use the type lambdas unfortunately the
 cats derive library does not work with type lambdas and so that doesn't
 compile our no matter we implemented by hand so we write a functor instance
 by hand then we can use the carry Harvard library to implement the actual
 map function and that works here so anyway we can save typing we should
 now the filterable instance needs to be implemented and so let's go back
 to our type so we have a disjunction we have two parts of the disjunction
 if the if we are in this part there is nothing to filter because we don't
 have any age if we end in this part we need to see if both of them pass
 the filter and only in that case we return in the container unchanged otherwise
 we return to Z which was this one this is e so let's implement this logic
 if we're in the left we just returned the container and changed if we're
 in the right we have an N Z X and y if both of them can pass the test both
 of the x and y chat x and y are tied a z is of type Z and n is integer
 we don't use the integer we discard it if we're in the case that at least
 one of them fails if we're on the kit in the case that both of them passed
 and we return FA which is the original value unchanged so actually we could
 replace these unused variables you see now unused intellij underlines them
 within gray you can replace them with underscores which is a shorthand
 for saying that this is a pattern that we don't need to name it should
 just match and whatever is there we don't need that's usual way of doing
 this so then we check the filterable laws with this factor and that works
 so we can put a type lambda as a type parameter that works however we need
 to put specific types in terms of bullying or integer or string or something
 otherwise there's no way to run any code actually if your types are not
 specified the next example is this functor which is a disjunction of several
 parts and one of them includes a list so for the list we're just going
 to use the standard filter instance so a filter function on the list I'm
 not going to reinvent that or implement that in any other way we're just
 interested in finding out how we could implement filter on this kind of
 thing we're interested in these parts what a list is already standard we
 know how to filter list although of course there are more than one way
 of filtering lists but that's not the point of this exercise so here's
 this factor we define it as the sealed trade with three is Junction cases
 so empty have Z and have list there's standard way in which we implement
 these junctions in Scala now unfortunately we cannot implement functor
 automatically because cats derive doesn't work with type lambdas and carry
 Hubbard's implement does not work with list being a fun tree doesn't know
 how to do function list and cannot derive it either because it's a recursive
 type that is not yet supported by this library so we need to implement
 for instance ourselves which is which is not a lot of work if it's empty
 then it's empty and we just whatever should be mapped whatever part is
 mapped is mapped so as we have seen in Chapter four hunters are relatively
 straightforward to implement so if you build a functor out of parts then
 if you know how to implement functor for the parts then you're easily implement
ed for the entire type and that's what we have here so how do we implement
 filterable well we have again got to look at the type if we're in this
 disjunction part or in this part there is nothing to filter no ace and
 so we just return them unchanged always a good idea to return unchanged
 if there's nothing to filter in this way and we could always return one
 of course the unit but then we would lose information so if we are in this
 part of the disjunction we don't want to lose that information when we're
 filtered so we shouldn't in return one actually that would violate the
 identity law if we're filtering with a predicate that's identically true
 we should not change the value and so if we're in here there's nothing
 to filter and that's exactly the same as if we're filtering with something
 that's identically true and so we should not change the value so that means
 in all other cases except the case of have lists we should just return
 the unchanged value now if we are in the have list case which is that we're
 in this case then obviously in truth stay unchanged now we need to check
 if this a is passing the test and we also need to use filter on this so
 we filter this we will get another list that's fine but what if this a
 does not pass well we cannot then return this part of the disjunction because
 we don't have an a to put in this part this list could be empty so this
 there could be no ace in there in any case we can't find given a out of
 there always and so there's no other choice except to return one of these
 two parts of the disjunction but which one or we can't really return Z
 because we don't have a value of Z Z is a type parameter so we don't know
 where to get such a value but we can return one the unit well in this case
 it's a named unit it has a named empty but since it's a unit you can always
 return it and so that's what we do if that condition holds we return [Music]
 the heaviest case with filtered list here otherwise we return empty case
 there's no other choice and that works lost pass so all the tests here
 are run and they'd all pass the laws are always checked the last example
 is a little advanced because it introduces a new concept filterable control
 factor now it seems the what to introduce a new concept in an example but
 it's an easy step right now we'll talk a bit more about filterable control
 factors in the second part of this tutorial recall that the control factor
 is a tight constructor that has a control map function that is like map
 except that the arrow is going in the other direction if functor represents
 a container that is something that holds values a data of some type and
 contrivance represents something that consumes values of the type it's
 not a container it's actually doesn't have any values of that type it consumes
 them it needs them so it will consume them we've given given and so a filterabl
e control factor means a container that can consume less it can filter what
 it consumes and if they're consumed items do not pass a test it will not
 consume them it can consume fewer items so here's an example of a filter
 Concha functor will not check laws at this point but we will check them
 later once once we find more about filterable hunters it will be quite
 easy to understand what the filterable contract you must be so at this
 point we will not check laws for contractors from filterable country hunters
 so here it is I just put co-variants adaptations for illustrative purposes
 for no particular use in the code that follows I'm not using subtyping
 but just to illustrate and this is a cultural factor control factors cannot
 be able to medically derived by in a cat's library which is a shame because
 they're just as easy to generate as hunters are but they don't exist there
 so let's use the Curie Harvard library to implement the country hunter
 instance so the country hunter is a called contravariant in the cats library
 and it has the country map function with this signature so so it's C of
 A to C or B but the function is literally not a to b so i just implement
 automatically and by the way just to check that cats cannot derive anything
 with exponential types anything with function types but cannot derive so
 cannot this is a very easy factor but cannot derive so not support it well
 just for our information the cat's derive can do case classes polynomial
 types only products and sums but no Exponential's so the contra filter
 is the function [Music] sorry the the control control factor instance which
 I just called control filter now is implemented as a function with filter
 it has exactly the same signature as for filters so it takes the predicate
 from a to boolean it takes old value of the function returns a new oh sorry
 contra funky and it turns a new value of the control factor so how do we
 filter the control factor quite easily in fact you need to return a function
 so C is a function from a to option Z so we need to return a function from
 a to options if so that's that is the that is the function return it takes
 an X of tightly and it checks whether X passes the test if so it lets our
 country function cancion X otherwise it does not let it consume X and instead
 it returns none none is the possible value that it can return so that's
 important that in the case that our argument does not pass the test we
 have to return something and we're not allowed to let the country hunter
 consume that value and that's similar to the partial function law if for
 fun tips if value does not pass the test we're not allowing the factor
 to transform this value any further so any further processing should not
 happen for that value and so for the country functor this happens right
 here contra fighters conceal values and so the are they should be guaranteed
 not to need to consume values that don't pass the filter that's the main
 intuition behind filtering the Contra factors and so here we define a specific
 type constructor example eight which is C of L Z with Z equals string we
 can do that with specific type without it we the only thing we have to
 do is at I clamp the C of question mark Z so so that's the only thing we
 have to do it here we can if we are willing to constrain the parameter
 Z to be a fixed type then we can do it and we are doing this here because
 we're about to run tests and for tests in any case we need specific types
 so just to run the test I need to define the Equality function that will
 compare two different values of contra factor and since they're functions
 it's not immediately easy to compare them we need to do it for all and
 run the functions on some arguments and so I also have contra filterable
 laws implemented but this is just for later logo we discussed these laws
 right now so now here are some exercises for you which they are based on
 what we just have covered [Music] they're very similar to the works examples
 I just gave and after you do these exercises we will go on to the second
 part of the tutorial where we will discuss the laws of functors in more
 detail and in more depth we will discover why the laws are like this however
 they can be simplified and how we can reason about filterable factors in
 a much simpler 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Laws and structure
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
this is part 2 of chapter 6 of the functional programming tutorial in part
 1 we considered filterable functions starting from examples we considered
 the syntax of the functor block starting from the intuitive requirements
 that the if operation search should satisfy we derived the filter laws
 and then we considered what types could be filterable or not filter belong
 examples in the second part we will look at the laws in more in-depth and
 one motivation is that there are four laws it's a lot of laws to remember
 each of them seems to be describing a difference side of the filter function
 in different property but doesn't seem to be any obvious connection between
 these laws but actually there is we will find by looking at what the filtering
 function does with a bit of intuition we can actually reduce the number
 of laws to two and we can find why these laws must be as they are to begin
 consider our intuition from the first part of the tutorial which is that
 we considered filterable type like this more like this and we noticed that
 when a data item does not pass the filter condition then the remaining
 data items are moved into a different part of the disjunction but algebraically
 is a similar to replacing this type with one so whatever data items do
 not pass the filter condition are going to be replaced with one with the
 unit type and if you replace this with a unit type what is left is a type
 1 times T times T which is isomorphic to this so let us see if we can make
 this intuition more precise what does it mean that we replace a data item
 of type a by a unit type if we're given a factor such as a freeway how
 can we replace this data item by one without breaking the type because
 the replacing cannot be just happening blindly that would be changing the
 type of F of a and we are not allowed to change it the filter operation
 should keep the type unchanged so the first question is how to replace
 this data item by one can we make that more precise and second maybe we
 replace it by different type so then how do we transform that time back
 to halfway so let us try to do this and first of all note that we could
 replace data items by unit if instead of the type F of a we had the type
 F of one plus a in other words F of option away and that type means that
 every time that the function f contains a data item type of type A instead
 now it contains disjunction either it will be a data item of type A or
 it will be one the unit value if we had this kind of type then we could
 easily implement the step one every time we look at a data item of this
 type we see whether this is you know whether this is one or a o if it is
 one then it remains one if it is a and it does not pass the filter condition
 we replace that by one and this replacement replacement does not break
 the type because this disjunction contains both the type a and the unit
 type so but how do we get this type out of this one we can use a function
 actually very easily called inflate I'll just call this function inflate
 it transforms any factor into the factor type of option a and it works
 by lifting this function into the function so this function which is in
 Scala the son type constructor it takes a value of type a and returns a
 value of type option a just takes this value a and puts it into the right
 part of the disjunction so this function exists obviously for any type
 a and when we lift this function into the filter using the F map we get
 a function from f of A to F of 1 plus a so that's the function we want
 that's inflate so that always exists from any function and after that we
 filter so we perform the filtering operation by taking each element of
 type 1 plus a and filtering it and that is just a filtering operation on
 an option that operation is defined in the standard library it is obviously
 easy to define we have done it in first part of the tutorial we just filter
 the option with the given radical P so if the option I was empty it remains
 empty if the option was non empty and the predicate holds on that value
 X then it remains non-empty on changed otherwise it becomes empty now so
 far we have gotten this type but we need FFA how do we get from a family
 of FFA from F of 1 plus a 2 F of 8 so that's step 2 so actually if filter
 does not so somehow this function must be available so I call this function
 deflate somehow for the filterable factor this function must be available
 otherwise the filter couldn't work like this so this intuition tells us
 that perhaps we should be able to define the function deflate for the function
 f if the filter is in filterable and notice that the standard Scala library
 already has a function called flatten which works like this of this type
 it takes a sequence of option and we can return the sequence so this is
 exactly the same type signature as deflate except for specific functor
 seek for the sequence so sequence is filterable as we know so this suggests
 that actually being able to define deflate is necessary if a factor is
 filterable so let's look at this diagram again to see how this works so
 that we expect that the filter function applied to a predicate P and a
 founder of a functor value if a first works by inflating to f11 plus a
 then we filter the option inside the function so we lift the filtering
 operation on the option to the factor using F map we get again everyone
 plus a then we deflate that into FA and so then we get a function from
 FA to F if that's the type signature of filter of P just to remind you
 that filter of PE is a function that is taking a fail and with returning
 a fee so let's try to express more formally filter through different now
 there is a car composition here in flight and this F map inflate itself
 is defined as f map so we have f map of some composed with f map of filter
 so that's f map of the composition of these two functions by the property
 of death note now the composition of these two functions can be simplified
 with I call this Bob boolean option boolean to option so we take filter
 P which is a condition from a to boolean and we get a function from a to
 one plus a it from a to option A so we kind of lift the boolean predicate
 P into a function from a to option A and this function works by checking
 that the predicate holds if it does we just return some of that X otherwise
 we return none so this is defined by this color code now notice here we
 use a standard filter on an option which is a very simple function so we
 aren't really using this filter on some arbitrary function f we're using
 a very specific function which is called filter on an option we do not
 have to write the word filter here we could have implemented this by hand
 it's very easy so this function Bob boolean to option lifting will be very
 convenient for us in what follows so make sure you understand what it does
 and how its defined it transforms a predicate from a function a to boolean
 to a function from a to optional so then we see that this function is basically
 a composition of this and this so therefore we can simplify an Express
 filter through deflate by saying this composition is equal to composition
 of the first two is equal to f map of the Bob and the second one is deflate
 and so basically we have a composition of F map Bob and deflate and that's
 how we would have expressed further if we had the function deflate so the
 flight is assumed of this type signature from F M a1 plus a2 F F just a
 short digression about notation here sometimes I write functions with parenthes
es and sometimes without parentheses now this is similar to mathematical
 notation like cosine of X where we do not write parentheses when this expressio
n is very short but we do right parentheses when it's longer for clarity
 for example cosine of a plus B or some larger expression we would write
 of course parentheses the parentheses but if the expression is very short
 we do not write parentheses so similarly I would use this notation we would
 write both p4f map f filter P without parentheses so to summarize this
 in the function type diagram filter P is defined through the flight as
 a composition of F map Bob which sub Bob is Bob T so already applies to
 the filter condition P is a function from a to one plus a so we lifted
 to the vomiter we get a function from get a function from FA to f1 plus
 a and then we deflate so as another reminder my notation is that the compositio
n works from left to right so we apply first the function on the left and
 then we apply the function on the right to the result so just so that it
 is easier to read easier to reason about and easier to write on the diagram
 so far we have expressed a filter through the flight assuming that defy
 it existed so actually we can also express the flight through filter and
 when we do that it will be interesting to note we assume we will assume
 that law for holes so here's how we can express deflate through a filter
 what's very easy the idea of deflate is that we have a factor of 1 plus
 a sum of these 1 plus A's are empty some of them are non empty we just
 want to filter out those that are empty only the non empty ones need have
 to be remaining and then we will get a function get those that are non
 empty we will extract the value a value type made out of them and that
 will give us F of a so how do we do that well we can write code like this
 so F of a is a value of type F of optionally we can first filter on the
 condition that the option is non empty and then can map with the gate function
 on the option now the get one method is a partial function that takes only
 the right part of the disjunction and returns the X but it is undefined
 on the left part of the disjunction so the gate is undefined on 1 plus
 0 so it's a partial function but it is safe to use this partial function
 after filter that's our fourth law we have filtered to the condition that
 all the option values that pass are non empty and so it is safe to use
 the partial function now in Scala code if this were a sequence I would
 have used the collect function and written the code like this the collect
 function is functionally equivalent to this consequences but for arbitrary
 function f not necessarily having the collect method we can just use the
 partial function it's safe because of the filter property for so if law
 for holds then we can define the flight through filter so we have defined
 filter thread of flight and we have defined the flight through filter this
 means they are computationally equivalent this is a very important idea
 these two functions are actually doing the same thing if we have one of
 them you can have the other and these are equations these are not just
 mappings so to speak from one to another these are actually equations so
 one function is equal to some combination of the other function with stuff
 and the other function is also equal to some combination with the first
 function Wisla so basically it means we have one you have the other and
 they carry the same amount of information the same amount of power so if
 you are able to define filter for some function for functor you can also
 define deflate and vice versa we have seen that some function some factors
 are not filterable so you cannot define filter therefore you also are unable
 to define deflate for them so we could actually say that filterable factors
 are those that have deflate and we could specify them by implementing deflate
 and then we could derive the implementation of filter from the given implementa
tion of the flight by a standard library function so we could actually define
 a typeclass of filter about 3d flights rather than through filter it would
 be equivalent as we have shown we can express one through the other provided
 that the laws hold of course but they must be formulated for the flight
 in that case and then we need to check the de haut so the flight is actually
 there useful because its type signature is so simple it's a function from
 functor of option A to function and because its type signature is so simple
 we can easily verify that some functors are certainly not filterable here
 are some examples consider this factor if I wanted to check if that this
 function is filterable then in principle I could try to implement filter
 for it and check the laws that would take me while perhaps so let me see
 if I can write a deflate function the deflate function would have mapped
 F 1 plus a 2 F a what is F 1 plus a it is this type now mapping F of 1
 plus a 2 FA means I'm mapping this type to this type so I have a function
 from this type to this type this function cannot be implemented because
 the argument contains the unit part of the disjunction if the argument
 is unit if I need to produce a value of this type but I don't have any
 ace all I have is a unit type if I am if I'm in any of these parts on the
 disjunction maybe I can produce value of type a but if I'm in this part
 of the disjunction I don't have any values available in order to define
 a function from this type to this type I'm required to define what happens
 with every element of the disjunction when it is given as an argument and
 so I'm not able to map one to a and I'm also not able to map one to a times
 a being able to map this is equivalent to having a selected element of
 type a but I don't have that I don't know what the type a is if the type
 a were pointed then I would have a selected element and I would have implemente
d this function by returning that selected element when I'm given the unit
 so it's an example of a pointed type is option event the point in value
 the selected value is not the empty option but in this example is a type
 parameter we do not have any more information about a so we do not know
 whether it is pointed therefore we cannot implement this function 1 to
 a and therefore we cannot implement this function since we cannot implement
 the flight we could not possibly implement filter either because as we
 know filter is expressed through deflate like this another example is this
 functor this functor is not filterable how do we see that if we wanted
 to implement deflate then we would have to map f a 1 plus a 2 FA every
 one plus a is this so we need to have a function of this type how can we
 implement this function well we have an int and we have this we need an
 a well we can put an end here and we can get one plus a but we need to
 produce a value of type a and we only have one plus a so this function
 cannot be implemented for an arbitrary type a for the same reason what
 if its argument is the empty option the the part of the disjunction that
 is unit then we would have to produce some value of type a but we don't
 have one therefore it is not filterable so the function deflate is easier
 to implement than filter and easier to reason about that non filter is
 very quick to see that you cannot map this to this and therefore it is
 not filterable or it is also easy to see when you can so let us continue
 to analyze the the laws of filterable and we noticed that we were able
 to define the flight out of filter only by assuming that law for homes
 for filter the interesting thing that and that we find we will find now
 is that if we define filter from deflate law for will be satisfied automaticall
y for filter in other words deflate only has three laws this is a very interesti
ng observation and perhaps unexpected let me now show how this is derived
 we will now derive and mathematically prove that one filter is defined
 through deflate law for four filter is satisfied automatically for convenience
 we will be using this function a lot so what can denote this with sy p
 sy p is a function that already is applied to the condition p and its type
 is this so this function already encapsulate the filtering functionality
 if this value does not pass the condition and then it will be replaced
 by 1 if it does pass the condition it will remain here we can then write
 filter like this much shorter let us now write law for in this notation
 expressing filter through deflate law for looks like this it is the partial
 function law so if we first filter which is this composition and then we
 apply a map with some function it's the same as wave first filter and uh
 apply the partial function map where the partial function is defined as
 the same function as f except it's only legal to pass values that satisfy
 the condition P let us use this type diagram the fact that the function
 type diagram as I call them to visualize this law in the vertices of this
 diagram are types and each edge of the diagram is labeled with the function
 that makes the transformation from this type to this type so then it is
 easier to read this law this law means that first we take the type of a
 notice that here in this law there is no space really to write the types
 of everything so this law is convenient like this if we don't already know
 the types when we just need to manipulate things but if we need to first
 understand the types and this notation is too short it's better to use
 a diagram notation and on the diagram intention we just write the same
 things except we put all the types intermediate and final initial and so
 on types of everything so we start with a value of type of a the left-hand
 side of the equation transforms in the upper part on the diagram first
 transfer strobe side P and then we get F of 1 plus I because side P has
 this type signature then we deflate we get FA and then we map with function
 f F maps a to be F map F maps FA to FB and the lower part of the diagram
 similarly first of psi P we get F 1 + I and we deflate we get F a then
 we have map with the partial of F we got FB and the law says says that
 if you take a value here you go to the upper way or you go the lower way
 you get to the same value here always connects this equality again a little
 remark about notation so I'm writing F map F without parenthesis here the
 type signature of F map is curried so it has a first argument F and then
 there is a second argument which is FA and so f map applied to F is a function
 from a fatal FB and I do not write parentheses here for clarity so think
 about this notation is again similar to mathematical function like cosine
 X or sine X without parentheses so then think of this is one value one
 expression like cosine X all right so we have formulated the law in terms
 of deflect how do we show that this law holds now we are supposed to show
 this with no further assumptions perhaps about deflate well actually that
 is not true we cannot do this unless we know something about deflate so
 one thing we know this is that this law is supposed to tell me that it
 is safe to map with a partial function it will be the same as if I mapped
 with the total function because I have filtered so I filtered out the possibly
 illegal values for this partial function but the filtering happens right
 here far from Earth map so there's this deflate step in the middle I have
 filtered here than I deflate and the ninetieth map maybe I will be able
 to reason about it better if this F map were close to beside P because
 this beside P contains the predicate P this also contains the predicate
 P so maybe I can reason about this eclair together site is by the way its
 itself enough map of something so if I put this F map next to this side
 P somehow if I transform this expression into an expression where I have
 a composition of site P and F map of something then perhaps I can easily
 reason about it because that will be F map composition with F map and then
 I can simplify everything and look at these functions and maybe get what
 I want how do we interchange the flight and F map in the two sides of this
 equation well remember that we have a law law one which interchanges f
 map and filter so filter now is expressed through deflate so maybe if we
 put it right here instead of filter but we'll have a law that interchanges
 earth map and deflate such a law is called usually natural reality law
 so let's express the old law one the filters go one through the flight
 we get this equation which is now more difficult to understand without
 the type diagram so I write a function time diagram here it starts with
 F a it first maps with a function a to b 2f b then we apply the filtering
 function we get we get F 1 plus B and we deflate that to f b now this deflate
 is parametrized by big f and b so it's a deflate for F 1 plus B 2 F be
 the right hand side is the lower part of the diagram which first maps with
 psy of composition F in P now P goes from B to Bui so composition F and
 P goes from A to B the boolean so from A to B and shy of that goes from
 a to 1 plus a I'm sorry from FA to F 1 plus F so first we get this and
 this already incorporates filtering then we deflate we get FA and then
 we map if FA to FB using the same function f as we used here so here the
 filtering worker is first on the Left map here the filtering occurs after
 of milk that's the law that we can interchange filtering and F map now
 we would like to transform this so that we can have a law that interchanges
 deflate and F map we almost have that except we have this I in the way
 so can we simplify this perhaps somehow let's write it down f map F composition
 with psy which is f map of both P is by the ethnic composition law it is
 this so can we simplify this expression we can actually there is a property
 which the Bob function has which looks like we can interchange Bob with
 some functions so it's like a natural Adil except it isn't because Bob
 is not if a function that works with functors only those functions can
 have natural tools so it's kind of a similar law not interchanges the order
 of Bob and some functions here's the function type diagram for it we start
 with some type a we first map F A to B we get a B and we map with Bob we
 get big on plus B some Bob maps from Vito and plus B it and takes the boolean
 predicate makes it an option kind of predicate option valued predicate
 the second way the right hand side is a lower part of the equation is first
 we do the book filtering we get one plus a and then we map the function
 f so we have to map 1 plus a 2 1 plus B using F F goes from A to B so obviously
 we just lift F to the option factor so we get a function 1 plus a 2 1 plus
 B so this is denoted like I denote it like this is f map for the option
 factor I right opt for gravity instead of option I need to spend less faint
 less less space in my equations so how can we verify that this property
 holds well I have code actually I have both symbolic derivation of this
 and the code that checks so let's look at the code so here's the definition
 of filter from the flight and here's the definition from the flight from
 filter and let me see where my book property is Bob yes it's here so let
 me first look at the Bob property perhaps since we're talking about this
 so Bob is defined like this and I also defined it as composition of apply
 and filter just like we did in the slide it's a composition of this and
 filter so I can write it down if I want explicitly has a composition we
 can check that this is the same function actually I have a helper function
 that checks function equality which I could have used here but functional
 equality means checking that for all arguments X and for all arguments
 P it has two arguments so both of px is equal to BA first composition P
 X so now the law of natural T is that this must hold so f is of type let's
 site T to a and this is a to boolean so this composition is of type so
 this composition is of type T to boolean and this can this is composition
 is of type T - 1 plus a and that should be equal to that function from
 T to 1 plus a so therefore we take T to string just to check it a is int
 and so then we write that F composition with hope of P so I'm just writing
 it straightforwardly here composition and Scala is and then so F is applied
 and then this is applied so book of P is a function so book is already
 applied to P and the result is again a function which is of this type that
 should equal book of composition F and P like this and then so composition
 with map of F on the option then I applied both of these functions to some
 X so that I can check that the results are the same and also I can check
 this law symbolically now of course the test passes but it checks the law
 for certain values maybe 400 randomly chosen this is perhaps if enough
 of any assurance but this is correct but it is nice to be able to have
 rigorous derivation not just a numerical test so how do we have a sim how
 do we find a symbolic rigorous derivation we transform the Scala code so
 the easy way of doing this is to first replace these mathematical notations
 with specific Scala code that corresponds to them for instance F composition
 F and then both P means first we apply F to some X and then we apply both
 painter the result when we put in a definition of both P which is some
 dot filter of people then we expand what filter means filter means if P
 of f of X then some f of X is known so that is the left-hand side let's
 call this expression 1 and the right-hand side is that this applies to
 some X in Scala that would be dot map of F and then we do the same thing
 so we expand the book into its definition we expand the definition of filter
 which is nice for option then we put the map inside so if this condition
 is true then this dot map else this dot map then we simplify this because
 we can obviously see this as a non-empty option so mapping it over F means
 we just put F inside so that is the result of the right-hand side of the
 law and this is expression 2 obviously expression 1 and 2 are identical
 so in this way we have proved this property both using a test numerically
 so to speak and mathematically rigorous them using this property we can
 now rewrite law one which was this by interchanging this F and book into
 so f composition book F and then what is pop and then as map f so we put
 that in note here that we have now F map of Bob and then F map of F map
 depth of of F now this F map is with respect to the option factor and this
 F map is with respect to the F factor that's why I use this sub sub superscript
 opt to make sure we don't get lost different types so this is a lifting
 of F into the option factor so this is of type option a to option B and
 then we F map that over to function to functor F and then we get this part
 of the diagram F of option A to F of option D through F map of F map F
 so now we rewrite this left hand side like this and we write the right-hand
 side of that already contained the F map of this book of composition which
 was here F map because I is f map of Bob so this is f map of both composition
 this is this so now the left hand side and the right hand side contains
 common prefix and we can remove it because our goal is to show that they're
 equal we do not assume that they are equal we need to show them they're
 equal so if we show that they're equal without this prefix then they will
 be equal with this so we can remove this prefix now we need to show this
 codes and that exactly looks like a law for a deflate that we want this
 is low one for deflate now we will also want to show that this law is [Music]
 equivalent to the law one for filtering then we would have to show it in
 the other direction and then we have to reason about why we can remove
 this prefix but let's just keep it aside this prefix by the way is the
 only one that contains the filter condition P and so this prefix should
 it contains the arbitrary filter condition P and so that's how it would
 prove equivalence and the laws but at this point we're not so interested
 in the equivalence of the laws for the flight because deflate actually
 will not be so important in terms of checking its laws for us but we could
 give derive the laws for the flight there will be two three laws from the
 first three laws the filter would follow the three laws of the flight and
 so at this point we have derived in natural G law for the flight which
 was ours so on the diagram it looks like this we first map F 1 plus I 2
 F 1 plus B then we deflate with respect to B or we first deflate with respectiv
e a and then we map a to b and that should be the same that's the natural
 reality law and having the naturality law for a function between factors
 means that it's a natural transformation that's basically the definition
 of natural transformation it is a transformation of one factor into another
 such that the natural T law holds that you can f map before the transformation
 or you can F map after the transformation and that's the same so here's
 an example of implementing deflate so suppose we take this factor then
 we look at the type of f of 1 plus a which will be this just substituting
 1 plus a here when we expand brackets just like in school algebra we expand
 brackets and we are allowed to do this because of isomorphisms in the polynomia
l types so then we have this type this disjunction and then we say well
 we need to map with deflate this into this so let's see which parts of
 the disjunction we could map into which parts obviously this well the unit
 we can happen to unit and into nothing else this we should probably map
 into this and these things could be mapped into unit all of them so all
 of these could be mapped into unit and that's fine that's natural transformatio
n and that would have defined the collapsing filter that we considered in
 the first part on this tutorial the filter that retains the two values
 only when both of them passed the filter when even one of them doesn't
 pass the filter both of them are removed and we get the empty the empty
 container so this would be an example of implementing deflate for this
 factor so it is quite easy the function has a very simple type signature
 and this illustrates what natural transformations do so in general natural
 transformation would map some container GA into some container age and
 what it does it rearranges the data it is not allowed to modify the values
 unless we know something about these types but generally we don't and so
 this is an arbitrary type were not allowed to change its value were allowed
 to rearrange the order of values or the disjunction part in which these
 values are held and well of course able to remove values or duplicate them
 also very loud but we're not allowed to inspect the type and do something
 type specific or and so on so same considerations as for a good implementation
 of functor that we just look at the type and try to see how we can produce
 a new type with no changes to the values exactly the same considerations
 apply here a natural transformation will not modify any values it will
 just rearrange data in a container so if you have a natural transformation
 between two containers which you don't always have but if you do have it
 it means that data in this container can be somehow naturally rearranged
 with no changes to the data just some erasing maybe some duplicating in
 some order changing it can be rearranged and you get this type is this
 container so if these two containers are in some sense sufficiently similar
 that this can be done this rearrangement of data then you have a natural
 transformation between these two factors so we have found the law for deflate
 which is this which interchanges F map and deflate now let's use this to
 show that law for poles what is love for expressed while deflated is this
 I'm repeating the type diagram from the slide before now we can use a natural
 T law which is this to interchange the flatten map in both sides of this
 equation so when we do this we get this equation so we just interchanged
 and now this F is next to the sign in both parts of the equation so we
 can now admit this common suffix the common part of the two equations because
 we're interested in showing that this is true so we show that this is true
 without the composition will deflate then it will also be true with that
 composition and so then we expand the PSI back into its definition which
 was here it's just the definition for brevity and we get F map of this
 equal to f map of this now this is quite simple to check that this is true
 let's write out the Scala code for the left hand side on the right hand
 side we see these two pieces of Scala code I've corrected the Scala code
 here so this function is partial function will be always safe because we
 are applying it after filtering on the condition P and so any values X
 that this partial function will receive will be guaranteed to satisfy the
 condition P this is because this is the law for for the option functor
 and we need to verify that it holds for the optional function when we define
 this filter according to the usual the usual way of defining the filter
 going to the way we we have assumed that we define it so let me show the
 code and that demonstrates this unit so easily but this law holds so let
 me just write it down so why does it hold for option or we have son of
 X filter P f map map is X P of X goes to X or half of X so what is some
 X filter P it is if P of X some X else none so how do we map this well
 if it is none then it is not so we put them F map we put a map in here
 so this is equal to that so this this code is evaluated like this to this
 expression so now how do we do a map on the Sun well we have a non empty
 option here so we just put this X in there now clearly this P of X holds
 so the sum will be evaluated only if P of X holds so then we don't need
 this condition this condition will be satisfied by by the way that if is
 compiled so then we don't need to to do all this we just do f of X and
 that is precisely sum of F of f of X filtered P of X so if you'll repeat
 so this is lawful for option that we can map with function if so this is
 some of X P so therefore some of X filter PMF so therefore these two are
 equivalent and so what do we find we find that law for holds this was the
 last equation that we needed to show and we showed that this is the same
 code that is evaluated in the same way for all arguments therefore this
 holds therefore law for holds so we find that the law for for filter hold
 automatically if we define filter through deflate so let me show you an
 example code that was there before where I defined filters through deflate
 and deflate through a filter so I actually used functions to define that
 so I define a function which is called filter from the flight which is
 paralyzed on a factor and this function takes an argument which is a deflate
 function which is a function of this type and it returns so this this takes
 the deflate as an argument and returns filter as an argument as a value
 so it returns as a value a function with the type necessary for filter
 so you see this is the this is part of the power of functional program
 we can transform code one function into another by writing a function it
 transforms code what we don't actually transform source code we transform
 expressions algebraically or using other functions but the point is that
 we define a function that performs this work so that can be done with no
 restrictions so this could be any type signature pretty much [Music] as
 long as all the type parameters are defined up front in here one limitation
 is that we cannot have further type parameters inside of this argument
 so this limitation is sometimes quite serious but often not so so this
 is our definition of filter from the flight is the F map of Bop and then
 deflate since exactly how we defined filter from the flight I've mapped
 Bob and then deflate and we also define a function that takes a filter
 and returns a deflate now instead of taking a filter function I just wanted
 to save myself some typing and I assume that the founder F was from the
 filter with filter typeclass so that has a filter function and then I do
 so how do these functions work well they I'm supposed to return this function
 so I take P which is this and then I'm supposed to return this function
 so this is the F map book and then deflate all I need to do is to prepare
 this map properly I need to do F map on an option so I use the implicit
 evidence value foot which is this implicitly funder F it has a map function
 which has this type signature but has the first argument which is function
 f of a and the second argument which is function f but I need these arguments
 in the opposite order I need first F F because I want F map I want a flipped
 map functions I want to interchange these two arguments so for this I use
 the flip function which is defined in my common code like this it takes
 a function from A to B to C returns a function from B to A to C in its
 code I leave for automatic instrumentation so this is this flip function
 and then I get the F map for the types that I need then I just write more
 or less than mathematical notation and here also I prepare an implicit
 function instance sorry implicit function evidence and then once I get
 that evidence into the implicit scope I can use the syntax F way dot filter
 dot map if I don't have this then dot map would not compile on an F for
 because F Way is a filter but with filter all we know about it is that
 it's filterable with filter but that actually includes functor and that's
 not automatic as it includes filter and so we need to prepare this evidence
 other than that this is the definition we had in the slides we deflate
 is first we filter non empty options and then we get the values from the
 option so this is a partial function but it is safe here because it's after
 the filter and as an example we do the orders example from the first part
 of the tutorial and then we just deflate from filter actually takes no
 arguments and filter from the flight takes arguments so then I first obtain
 the flight from the filter then I obtain filter from that D flight and
 then I check that that filter is the same as the previous one so that's
 what is checked here so that the filter is the same function as the filter
 obtained from the flight that was obtained from Philips alone it's showing
 me that it's really equivalent functions all right well that is so good
 but still we have a bit of complication because the flight seems to have
 a lot of laws three laws and notice we always have this deflate composed
 with psi with this F map of something always deflate is with F map of something
 in front of it so maybe this F map of something or this I and then deflate
 maybe this composition is actually easier to handle let's look at the type
 signature of this composition the type signature is actually interesting
 it is going from F a then we get this F map si which is going from some
 a to some 1 plus B so let's say this is a function we get f1 plus B and
 we deflate that we get FB so actually the composition of F map and deflate
 is a function from FA to FB that consumes this function f from 8 to 1 plus
 B so let's call this F map option or F map opt for short now the type signature
 of Asmat opt is that it takes an argument of type from a to one plus B
 and note this argument already expresses filtering and mapping at the same
 time so this function from a to one plus B expresses first that we check
 some condition on a and for some edge rate return every option and for
 some is very turned on empty and then we also map a to some be in some
 way so so this F combines combines filtering and mapping and the result
 is a map from FA to FB so deflation is already incorporated so F may up
 F composed with deflate that is the definition of F may opt here's the
 type diagram for it so from FA 12 be either directly through F map opt
 and this is how we define it it's a composition of F map F and deflate
 now it's important to note that F map opt and deflate are equivalent functions
 because we can also define the flight through F map opt to do that it's
 very easy we just make this arrow identity we said let this a be actually
 the same as 1 plus B so let's say this is actually 1 plus a and this is
 also 1 plus a we can do this because a and B are arbitrary so we can set
 a equals 1 plus B if we want to then this will be identity so this is an
 identity function and then obviously deflate is equal to f map opt applied
 to that identity function because these two will then become equal so since
 we can express one function through another and the second really first
 they are equivalent these are equalities so these are not some kind of
 mappings so these functions are actually equal on all values so now it's
 interesting to express the laws in terms of F map opt now law 4 is already
 taken care of so it's already automatically satisfied we can express filter
 through F map opt this is actually quite short because we have incorporated
 this F map and deflate into one function so I'm writing out all the type
 arguments here for clarity so this F map opt has actually three type arguments
 to F and the types a and B so no filter is this kind of thing so now how
 do we show that the laws hold well we will show it now actually well we
 cannot show that the law school we need to derive what the laws are for
 F map opt we need to serve its press filter through F map opt and substitute
 into the laws so for example let's look at the at this law well in this
 law it's probably easy we just have some morality this law looks interesting
 so there is some boolean conjunction here so how are we how will we deal
 with it or we need a book of this to be able to do so we need to know what
 happens when Bob is applied to the conjunction of two predicates how is
 that expressed through a both of the two predicates alone through Bob of
 p1 and whoop of p2 well it so happens that for the option this is the code
 so we need to take Bob p1 applied it to X to X and then to do a flat map
 on the resulting option with Bob p2 so that is maybe unexpected let's look
 at the code that shows yeah so here's by the way deflate from map option
 and map option from the flight and again the check in that they are equivalent
 when we will take one from the other so let me explain this a little later
 but let's look at the boolean some property of Bob the conjunction property
 so we can check this property by a numerical test or we can check it symbolical
ly so numerical test is that for any X a bob of this applied to X is the
 same as that formula drop of P 1 of X flat map book Peter why is that well
 so we can write out the code the Bob is defined as some dot filter so we
 have this code some dot filter means that since this is already non-empty
 option if P 1 of X and P 2 of X then it's sum of X else is known so that
 is the left-hand side let's call this expression 1 the right-hand side
 of the law is that we have what P 1 of X flat mat book Peter now book T
 1 X is this which is this expression so now we need to flat map this with
 something how do we flat map well if the option is none then the result
 is none now if it's not known when we need to check if P 2 applies and
 then we still have a son otherwise we have known so we have this code if
 P 1 then if B 2 then some else none else now so obviously with only return
 sum of X when both conditions hold so that is equivalent to this which
 is expression 2 and expression 1 and expression 2 are identical so we see
 that flat map actually expresses the boolean conjunction in some strange
 way so this was the property that we needed and actually this is very important
 we will be using this a lot in this this formula so let's have a notation
 for it so this is kind of a composition of Bob Irwin and Bob - Bob p1 and
 don't be - let's go let's call them Q so Q actually is a function from
 a to 1 plus B and Q 2 is a function from B to 1 plus C and we can write
 this formula like this q one of X will be option of B we can flatmap this
 with q2 and get an option of C and so the result is a function from a to
 option C so this is a kind of composition but the types of the functions
 are kind of twisted so the usual composition would be if the types were
 a to B B to C and the result is of type A to C but here instead of a to
 B we have into one plus B so option B here we have B to one plus C and
 here we have a to 1 plus C so every time the type of the function is twisted
 there is something added to it on the right hand side but it's the same
 thing that's added every time so it's that it's some functor that is put
 on top of that so this is called nicely composition in the general case
 of the closely composition is for some functor m where you have a function
 from M to M a - M B from B to MC and you can post these two functions and
 you get a function from A to M C so you twist the type on the right hand
 side of the function by applying some function m in our case the function
 M is the option factor so we just applied 1 + 8 so we twist with 1 plus
 a at the right hand side so in this tutorial we'll only be using this closely
 composition with this function or as I said twisting the notation for that
 will be closely opt and I would use a diamond opt diamond with subscript
 opt to remind ourselves that we are only using this specific case we're
 not going to be you in the general case in this tutorial but the general
 case is extremely useful nevertheless so that's why I wanted to mention
 it so this is called the Kleiss lis composition so we're using the Chrysler
 composition for the specific case of option so this is the closely opted
 composition and interestingly this composition has an identity element
 which is a function of this type that returns the non empty option this
 function is an identity for this composition so if you take this function
 and compose it with this operation with any other function you get that
 function and so we will show now that the classic composition operation
 is associative and respects the closely identity just as a normal compositional
 would so this is very interesting because it is a full analog of a normal
 composition of functions with identity function and associativity of compositio
n however the types are twisted so how can we can even do that so the reason
 is that are twisted in this way so this is a special kind of twisting that
 allows you to to work the option is a very special factor and that's why
 it works and let us now look at the code that shows how this all works
 so we define a closely opt composition which is a function from a to option
 B from beta option C into a two options the code of this function is left
 for automatic implementation we also define an implicit class for syntax
 so that we can say this we can use this symbol to compose using the class
 Li opt composition law so we just refer to that function we define the
 identity which is a function from a to option a again this is left for
 automatic implementation but this is basically some dot apply so X goes
 to some of X just so that we know what it is but that's what it is I'm
 going to be implemented and then we check the laws so we say well I have
 this now func function equation utility and it checks that functions are
 equal just for from brevity so this is exactly like the associativity of
 composition except I replace the composition symbol in the little circle
 with this strange symbol but that's the only difference so this is the
 closely composition and that is associative and also the identity so identity
 on the Left composed with F is equal to F and identity on the right composed
 with F is also equal to F and I check that with various types but also
 I can derive the symbolically deriving and symbolically is again a matter
 of writing out Scala code and transforming it as if you are evaluating
 so I will leave this for you to look at I will just go through the first
 few steps that are necessary the important thing to make it easier that
 you can just do it brute force you can just write out this code and check
 everything but it's much easier and more visual if you decompose the function
 of this type into a pair of functions one is the filter function and the
 other is the transformation function so remember that this function represents
 at once filtering and transformation but it is easier to reason about it
 if you decompose them into filtering separately than transformation separately
 so let me do that here is how I can define F is if I have P and Q here's
 a how I define P and Q is if I have F so they are equivalent so I can define
 one through the other and the others would have the first one so then I
 note that the composition the closely opt composition expresses boolean
 conjunction we have seen as before but now I'd like to see this more explicitly
 in fact so what is the class the composition of the two functions and while
 I transform the code in the same way I did before I expand then there's
 an if when I put the flat map inside the F and so on and I find that the
 P and Q component of the composition is expressed like this so T composition
 the filter is the boolean conjunction of the two filters except that the
 second filter has to be applied to the transformed value of x because it
 could be a different type and the queue functions are simply composed the
 transformations that are inside here are actually composed in the usual
 way but the filter is composed using the boolean conjunction and so this
 is why the walls hold obviously a laws will hold for Q because the ordinary
 composition is associative and respects the identity and by the way the
 identity function is mapped into a filter that is identically true and
 a transformation that is identity and so obviously then the filter will
 be identity element for this because this will be identically true and
 something that will be equal to that something whether it's only right-hand
 side or in the left hand side and identity and in these logical so it is
 for this reason that the laws hold you're welcome to check in more detail
 all these calculations and I would like to wrap up the previous topic the
 transformation from one function to another and just illustrate a Scala
 trick here so I want to define a deflate function from this map option
 and I want to deflate to define map option from the flight however I have
 a little trouble here during this and the trouble is I want to define a
 function deflate from map option which takes an argument that is map option
 characterized by a and parameterize by D but a and B must be special you'll
 be chosen so remember how I define it here the flight is defined through
 map option when I set one of the parameters to one plus a another to a
 well I could I could write B here instead of a so it will be B baby baby
 so I could say I say I sat in the D flight I'm sorry uncertain the F map
 opt I said a to be equal to one plus B so a must be optional D but how
 do i express this in a function map option is a function with this signature
 but I need to set somehow the type a equal to the type option B so that
 this is actually the same type and I can put identity in there how do I
 do that so I use produce the cats library which contains a useful utility
 called is so this is is a type constructor which is parameterize by two
 types the Scala syntax allows me to write is in between a and option B
 but you can see that is is defined just as a type constructor with two
 type parameters and is a the class that holds evidence that this type is
 equal to that type what does it mean to hold that evidence it means you
 could in using this value you could transform this type to this type or
 backward with no computation we just map identically so this evidence would
 not compile because you don't have the implicit value if these types are
 not equal when you actually call this function so when you define the code
 of this function you don't know what a and B are and you say they must
 be equal so you have evidence that they are equal but what when you actually
 call this function which will do the you needs to write the types correctly
 so that actually they are equal and then it will compile these implicit
 evidence will be found so once you have this implicit evidence so then
 you return this you have a for example an X of type a but a is option B
 so how do you get an option B out of it well you use the squares function
 which takes an a returns not should be in this case this function is automatica
lly defined but only because you have the evidence that a is option B and
 here's the substitute function that will transform F of option B into F
 of a now a is the same as option B so this transformation actually doesn't
 do anything it doesn't perform computations very convenient and flip means
 that you you do it in the other direction so substitute will do FA from
 F function B to F a but without flip it will go from F a to F optionally
 so with this evidence you can easily coerce one type into another or the
 second at first and also with any functions you have functor and we do
 have a functor here so we need actually to check the types and make sure
 that we are given we're given fo B which is a type F of option B but we
 actually need F of a to call the function and that's what we do here so
 we substitute which is a function defined for his in the cat's library
 that's very convenient it's a bit of writing to get all these types correct
 and actually all this performs no computation at all because this is just
 identical equality of types of X is just of this type or that type it can
 pile time at the run time is actually the same value because when you call
 this function you must use the same types so there's no or very little
 overhead and calling these functions they don't actually perform computation
 so if you have a big data structure here and this is immediate this is
 very quick to do that there's no computation so how do we call that so
 here's how we call that we specify the types option B and B and then this
 is a type a right so this is a type parameter a in that function and we
 specified directly as option B and that's why here as well yeah we directly
 specify that and that's why it compiles so that's how we implement what's
 in the slide here we call F map opt with option B & B as type parameters
 here is option a and a or Justin and we check that the deflate obtained
 by direct definition was equal to deflate that obtained through the map
 option which itself was obtained from the flight and just rename this for
 consistency so these computations illustrate the equivalence between F
 map option D flight and the properties of the class like composition so
 let us look at the type signature of F my opt once again it takes a function
 from a to one plus B and it returns a function from FA to LV in other words
 we can imagine that we have this set of Kleiss Li functions which are functions
 with this type which is kind of twisted so these are the nicely opted functions
 or in the language of category theory this is a function that belongs to
 the class like category with opt functor now for us this is not particularly
 helpful right now we are actually coming from another direction we found
 that these functions were helpful and we are studying their properties
 and we discovered that they have this product the composition of functions
 of this type which is very similar to the usual function composition and
 this function f map opt is very similar to a usual F map because it lifts
 the function of this type into the functor except for this twist so it
 lifts a function from a to one plus B into a function f A to F be not f1
 plus B but F B so this is a twisted kind of lift but it's very similar
 to a usual F map it lifts a function from A to B into a function from F
 A to F be in other words it lifts a computation into a functor context
 it makes those computations occur on values that are held within a functor
 so this is a very similar kind of lifting although it's with a twist as
 twist is of course highly non-trivial we have a lot of work to do to deal
 with this but once we have done this work with C and that this formulation
 is actually very intriguing it's very similar to just lifting a function
 into a functor context so in fact [Music] only two laws are necessary for
 this F map opt namely this law that if you take identity function then
 the lifting of that into the functor context gives you identity function
 on the functor in the container and second law is the composition law which
 is that if you take the composition of two lifted functions that's the
 same as the lifting of the closely composition of these two functions so
 let's look at the type diagram for the composition we have F a FB and FC
 so let's say F goes from 801 plus B G goes from B to 1 plus C then the
 closely composition of F and G goes from a to 1 plus C and F map opt would
 lift each of them but this lifting is consistent so this way gives you
 the same value as this way and that's the left-hand side gives you the
 same value as the right-hand side so the two laws for F mapped are very
 similar to the two function laws if two functor laws were that lifting
 an identity gives you identity and lifting a function and composing it
 with a rather lifted function is the same as lifting of the composition
 so they're very similar here except that the types are more complicated
 they're twisted and as I said and the composition here isn't nicely composition
 so this is a kind some kind of twisted composition and your more complicated
 types then the the functor laws but conceptually they're simpler actually
 they're also more complicated than the filter laws conceptually they're
 simpler they're fewer and easier to understand this is just some kind of
 twisted lifting from from one kind of set of functions to another and [Music]
 from functions of this type to functions on the container and the lifting
 of course must respect the usual laws it must lift identity to identity
 must live composition to composition so that's kind of natural and there
 are no more laws so there are only the natural laws for for the factor
 just twist it so let us show that this is indeed so mean I just claimed
 so fine didn't really show yet and that's only two loans are actually necessary
 let me see how that is proved so let's start with the law 3 which is the
 filter with a identically true function now that function after you pop
 it it gives you this and so this composition is the F map opt of the clearly
 identity because actually the book of this filter function is exactly the
 function that is the closely identity business this function doesn't let
 me highlight correctly this function so therefore if the filter law is
 true then this is an identity and so then the F map opt of identity must
 be identity and if this is true and the filter must be identity so old
 law 3 is actually equivalent to the identity law both of them imply each
 other because of this equal votes are equal science everywhere so that's
 very strong identity done isomorphism now we need to derive the laws 1
 & 2 obviously we have only one law the composition law left and somehow
 this one law should cover two old laws at once how can that be so let's
 see we know that the conjunction responds to the classical position let's
 so the way that we can take one law and get two out of it is to use different
 type parameters in this law you see this law has three type parameters
 a B and C we can choose them to whatever we want and you choosing them
 in different ways can give us different perhaps specific laws and that's
 what we shall do now so let's consider nicely functions only of types it
 goes to one plus a no other types so we're choosing the type parameter
 in the class Lee in this way and then actually we can see that the filter
 composition is equal to this so Q I'm just defining for gravity that Q
 is Bob of P so all Q's are of this type and then the filter is equal to
 f map opt of Bob right so in other words F map opt of dope of p1 which
 is Q 1 in position with F map opt Q 2 that's the composition of two filters
 now by the composition law we have this and then we know that the composition
 of the class ly responds to the Bob of the boolean conjunction we have
 already derived that so this derives the law to law one is a little longer
 to derive because it's a natural to know it has more stuff in it it says
 that F map can be interchanged with F map opt so notice that here we have
 specialized two functions of this type of the class Lee functions of this
 type here will always also specify a specialized namely specialized two
 functions that are filled that are ordinary functions transformed into
 a closely opt kind of function which we will denote by K F so K F is a
 function of a twisted type that corresponds to some function f of an ordinary
 type by always returning the non empty option so we just take a we'll apply
 F to it and always return a non empty option never return empty option
 so that is basically a composition of F with the identity in the class
 Lee and because of this we have the property that F map opt of K F is is
 by definition is this we can then decompose the F map because K F is the
 composition so we can decompose that into F map lesson F map of it and
 F map edan on the flight is identity because you can you can check that
 and so yeah let's let me think why I did not say anything here about why
 this is identity so if you F map the identity in the closely means you
 map F of a into F of one plus a but in that F of one plus a there are not
 there no empty options because the identity never produces an empty option
 so then when you deflate that there aren't any empty options and so that
 it returns you the original container but in principle this actually oh
 that isn't actually easier by definition this is f map opt of it opt because
 this is F map and then the flight is the same as f map opt by definition
 and so by the identity law this is equal to identity so therefore this
 is equal to F map F so f map opt of this transformed function is actually
 the same as I've met Beth therefore we can just rewrite this law using
 F map opt of K F instead of F map F when we do that we can use the fly
 sleep composition and so then for example we will get this using the closely
 composition of K F and Bob P which we can then simplify because we know
 that the KF times what P we can just you can just expand we know that that
 Bob P has this has this law sorry it has the law that we derived before
 this one we know that both P has this law and so therefore we can transform
 this into that the only thing we need to do is to see that if we if you
 do a closely composition like this and actually this is an ordinary composition
 with F so all of this hinges on the fact that K was defined from an ordinary
 function f so K is not an arbitrary clastic function it's a class a function
 that never returns empty option and so it's much simpler to compose anything
 with it you just compose normally like this and then finally you substitute
 that in there and you find that this is equal to that they are under F
 map oops and so therefore the one holds I encourage you to go through this
 may be slower but all the steps are written here we start with this when
 we write we define an arbitrary function f then we define K out of that
 F and we show that we need we can rewrite star as this equation then we
 show that what is under F map opt is the same by transforming the left
 hand side into F and then book P the right hand side into Bob FP and them
 F may opt so we just used set of Q here and we use this instead of Q here
 we use this and we obtain this property which we already showed previously
 so let me summarize what we have found filterable functors can be defined
 in different ways we can define them using a filter function using a deflate
 function or using F mapped all these three methods are equivalent expressed
 identically through and so if you have one of them you can define to others
 but these methods have different roles for us in the program code in the
 funster blocks we use the if operation the easiest reason about in the
 code is that operation which corresponds to a filter or with filter a type
 signature that is the simplest is that of deflate that is the easiest goes
 to implement and to reason about conceptually however the F map opt has
 the simplest laws it has a just two laws which are functor laws with a
 twist now let me talk a little about category theory so the to function
 laws with a twist are accommodated by category theory as just some kind
 of generalized functor laws or other words in other words as ordinary functor
 laws for some kind of a twisted functor and the twisted functor has twisted
 function types and so if we for example look at type signatures of f map
 contrived map and f may poped compare them you see this is an ordinary
 of map type signature this is the contra of map type signature and this
 is the F myope type signature so they all look like some kind of lifting
 of functions from here into a functor context or container on a Content
 context but this lifting is ordinary and this lifting is from reversed
 functions and this lifting is from these twisted closely opt functions
 otherwise it's very similar the laws are the same identity law and composition
 law now here of course we have contract on position so composition here
 goes in the into the other direction that's natural because we have twisted
 the composition because we have twist the type here the composition has
 a class like composition we have to twist it so cutting category theory
 says let's consider all of them as actually functors but on the left hand
 side you have something twisted so you have a twisted founder here that's
 how category theory generalizes all of this into lifting so it's always
 lifting from one kind of arrow to another kind of function arrow to another
 kind of functional arrow with twisted types now category theory gives us
 intuitions about how better laws could be derived and two of these intuitions
 we have seen is one is that it's probably helpful and useful if we look
 for type signatures that look like lifting if we find a function like f
 map opt whose type signature looks like lifting then it's probably very
 useful because then you can expect that you just need to twist the composition
 here somehow of these strange twisted functions other than that you have
 standard functor laws just the two laws and they're standard very easy
 to understand identity and composition so at the price of twisting the
 type here and here and using a different composition because the types
 are twisted second hint is look for natural transformations and use a natural
 T law to interchange F map and whatever you need so you can do that and
 that allows you to reason about the laws and derive one law from another
 so that's kind of intuition that natural transformations are useful because
 they have this natural reality where you can flip F map across them and
 that is useful for deriving the laws so notice how we have arrived at this
 point we have started with filter we derived a large number of laws of
 four okay twice as many as now a number of laws for filter and then we
 were looking for a better type signature basically a smaller more kind
 of reasonable type signature deflate had a great type signature but F map
 opt has fantastic excuse me fantastic type signature because it's it's
 a lifting and it's laws are very easy however category theory does not
 directly provide any derivations from these laws so I don't think you will
 find these laws from any category theory look filter and deflate are not
 usually found there or the laws from them category tier is too abstract
 for that it gives hints about what you could do but it doesn't give you
 laws or equations for these functions or specific types doesn't also doesn't
 tell you that this should have been the type that is at the root of being
 able to filter not actually somehow you need to look for class Li and use
 the option to twist the class Li category theory doesn't tell you that
 you start with filter and you think you're doing something very down-to-earth
 filtering values out of sequences and actually at the root of this there
 is this twisted Kleiss Li opt category of functions but category Theory
 doesn't tell you that you have to derive it yourself it does not also it
 doesn't help you derive that either just gives you hints about how you
 might be able to do it in particular look for a lifting like type signature
 but we were lucky to find it there's no easy way of deriving this so what
 are the further directions that category Theory hints about I can give
 you two examples so now that we have seen this pattern let's investigate
 other kinds of liftings for example well if here I have some and a 1 plus
 a 2 B or something instead of this what if I here here have F of a to be
 instead of A to B well if I have 8 a 2 F of B with the same F as this will
 I have something else would have I can try to investigate different kinds
 of liftings and see if they're interesting or useful but this actually
 so this is one kind of abstract direction we could go now I'm not going
 to go into that direction I'll explain why um another thing you can do
 is to replace the option in this construction by another function so not
 F but let's say some m and then let's see what happen is then we'll have
 some different twisted thing and let's try to interpret it so why I don't
 want to go into this direction is because first of all there's no end to
 different functions or types that you can write down there's no end to
 twisting and generalizing and putting more functors here you know F of
 F of B of F of something there is no obvious limit or obvious direction
 where to go so infinitely many possibilities are open and you can spend
 a very long time studying all of those possibilities with not much of a
 practical use it takes a very long time to discover which are practical
 things that you can use and which are just theoretical things that don't
 necessarily give you a lot of practical value so one approach is that I
 start with examples we start with practical value that we obviously see
 in code and then I generalize so I generalize a certain to a certain extent
 to a certain degree and then stop so certainly where to stop is a judgment
 call there's no obvious decision to make and you need to understand have
 some intuition about how much generalization is useful and how much is
 just I don't play you could you could go very far here in generalizing
 and category theory especially encourages you to generalize with very little
 regard for practical use and I don't think that's the direction I want
 to go so having said all this let us look at the practical question what
 are the filterable factors if I give you some type how do you know that
 this is a filterable factor so let's eat to answer that question let's
 use intuition from our deflate type signature so we reshuffle data in a
 container by replacing some values of type a by unit and reshuffling means
 we just reuse a different part of disjunction usually not always so therefore
 we can try to reason about it and say look at the type and try to substitute
 one plus a instead of a in the type and see if you can reshuffle the results
 to get what to get FA again if you cannot it means you cannot in and deflate
 I showed you examples of that some simple ones and then it's not filterable
 but if you can then you can look further how you want to make it filterable
 and especially for your particular requirements of your application and
 to get some intuition about this let us consider how we can build up filterable
 factors from parts this is very similar to what we did with ordinary factors
 so we will now list some constructions certainly not all possible constructions
 but some sufficiently large number of constructions and give you new filterable
 functors given old ones and let's see how that works so first of all a
 constant function meaning that for all types aids it's a constant the same
 fixed type Z and for that functor we define F map opt as identity so whatever
 type you have here you can transform it from A to B but Z stays the same
 just identity so filtering does nothing and filter is identical constant
 I'm sorry add an identical transformation and Z is some fixed type so that
 is filter book note that this is not floatable the identity function for
 the reason that you cannot transform one plus a into a unless a is a pointed
 type but this needs to be for all types so it is not filterable the typical
 constructions that we have for functors are that you have a product of
 two functions and that's a function same for filterable sum of two functions
 is a function same for filterable composition of any factor and the filterable
 factor is filterable now this is not necessarily Tolcher well this has
 to be so if you compose them then it's filterable this is a construction
 that's specific to fill troubles and this is a functor that needs to be
 filter ball already and then you can do this and you again get a filterable
 factor so notice we can replace this one with a pointed type so we can
 do this a pointed type is basically something that's that has an element
 that's selected somehow so we could imagine that this is isomorphic to
 a disjunction of either you have that selected element which is represented
 by this part of the disjunction or you do not or your value is not that
 selected value and then your in this part of the disjunction so all the
 values that are not selected are in this type Z somehow defined and the
 selected value is represented by this unit so this is an isomorphism that
 you could imagine not necessarily very useful as a morphism but you can
 imagine that this is one plus Z and then this is one plus something so
 one plus something as a as a rule is filterable similarly you could do
 mini-mini so how do you how do you filter this if a passes then you filter
 this and you are still in the same part of the disjunction if it does not
 pass your return unit you ignore that you just drop from those now so a
 recursive filter will functor we had an example where this was I believe
 a unit or something but if G is filterable then you can add this and this
 is a recursive function that looks like a list a little bit except that
 the empty list is not empty but this G and then you have a and then again
 a and then again a and and some G so this is a list like functor and it
 is filterable in the same way that lists are and the final construction
 is that you take some country factor which has to be filterable as well
 and that function gives you a filterable factor here's an example of something
 that's not filterable again if you have them even if this is filter rule
 this is not filterable and so this entire thing is not filtered back so
 let us look at some of these constructions in detail and see how the laws
 can be satisfied so take the construction of product if the laws hold for
 the two factors so they are both vulnerable then let's do F map opt how
 do we define F map opt for the product factor so we have F map opt for
 the F and F map opt for the G we have them and now we need to define a
 map opt for F G so we define that by taking the product of the two values
 one was type F a another of type Q and G a and we do F map opt on both
 of them separately obviously that's an easy way of doing it the identity
 law calls because it holds for the two as my box F and G and therefore
 we have a product of identity of P and identity of key as being composition
 law holds because the composition acts separately on P and Q and so we
 have composition of 2f map opts F and tulip earth map opens G separately
 so these are we are not mixing up P and Q so let me pop F only X on P and
 F map up G only X and Q so when you're mixing it up and so the composition
 act separately on the two parts of the conjunction on the product and therefore
 the lowest hold now we can transform each composition using its own law
 this must be again diamond opt I forgot the subscript here and finally
 we get what the law for the product function notice this is exactly the
 same proof as for the functor property if you look at the chapter four
 we we have the same construction for product of two factors being a factor
 and the proof for the two laws of factor is exactly the same except for
 the diamonds and these other notation F map opt instead of F map otherwise
 it's exactly the same computation one-to-one why is this it's because in
 category theory F map opt response to this generalized functor between
 a twisted class three category nicely opt category which is kind of twisted
 and the functions on the container and so because it is a fun treat has
 exactly the same properties of any factor once we define it that way all
 the proofs remain literally the same except for notation new proofs therefore
 are necessary only when using non filterable functors when we cannot represent
 all the factors in our construction as filterable which is constructions
 four to six in constructions four to six son functor is not filterable
 like this one and this one and in this construction France and they're
 both filterable and so in the category Theory formulation that would be
 just functor so that would be exactly the same proof as that this is a
 functor if this is a country furniture and this as a function so we don't
 really want to repeat the same proofs and just putting in some new diamonds
 and so on we want to look at proofs for new interesting properties here's
 the property that lost hold for this type if they hold for GF so how do
 we define the map opt F map opt act on this disjunction if the argument
 is in the right part of the disjunction of this form then we return the
 right part and or if there are if not only if the argument is in the right
 part in the disjunction but also if the function f acting on a is in the
 right part of its disjunction so this is there are these two conditions
 if these two conditions hold then we'll return the right part of the disjunctio
n which is we return this B that was transformed from a and we transform
 the Q in using its own F map opt otherwise we return the left part of the
 disjunction so that is how we define the F map opt I remind you F map opt
 takes a function that transforms and filters at the same so this function
 could give you a left the left part of the disjunction the empty option
 or it could give you a newbie new value so if it gives you a new value
 then on only then will return the right part of the junction with this
 new value because we're it's supposed to return FB so we need to return
 one plus B times G B and so we return b times the f map opt and the g filter
 will factor now we check that identity law holds is straightforward we
 take F in this definition to be the identity in the closely I hoped category
 so then I'm saying category just to get familiar with that terminology
 all I mean here is that this is a function of type a to one plus a and
 mean nothing else and we know that functions of type a to 1 plus B have
 the property of this twisted composition and they have this twisted identity
 and that's what we that's all we know but that's what it means when I say
 it's class like adding or it's these functions of these funny types that
 have this funny composition so taking F here to be the flyest identity
 we find that F of a is f of a is by definition 0 plus a by definition of
 this and so f map of the graph is identity by the identity law in the G
 not supposed to hold and if we put it in then 1 goes to 1 and a times Q
 goes into a times Q so that gives you identity composition law we only
 need to check that if the argument is of this type and only when all the
 functions return the right hand side because if if even one of the arguments
 in the composition returns less inside anywhere then the entire thing was
 going to return left-hand side and then all laws will hold because there
 will be none it was none in all laws so the only non-trivial case that
 needs to be checked is that everything is in the right side of the disjunctions
 in that case the conjunction also is in the right side and then we need
 to check what happens with this thing and of course that's that's really
 easy because everything is just working on this right-hand side F map opt
 of this is by definition that and we again apply F math opt and we again
 have some C which we assume this everything then we'll the right hand side
 then we have composition of F math opts in the GE filter we'll factor that
 has its own law so we transform it like this and finally we get the F map
 opt for F from the composition of the functions on the right side of the
 disjunction so the interpretation of this filter is that it's kind of greedy
 if if a does not pass the test and all the data here is deleted even if
 they all pass the test the a is kind of very very special and if that only
 if the a passes the test and we filter this and see if any of those pass
 the test but if a it does not pass we return one so this is kind of a Brady
 filter so now I've shown that its laws hold let me actually look at some
 code see if I have oh yeah it's nicely up category and we have seen this
 and [Music] yeah this is in implementing filterable typeclass using the
 flatten instead of instead of a filter and this is just the check letitia's
 satisfying the wall so let me go to my worked examples for this chapter
 so these examples show you that sums and products and all filter balls
 are filterable so here I have an implicit def that produces an evidence
 for functor given the two factors F and G so that is done using a type
 lambda here and then I'll just do the laps on the factors in the usual
 way the Sun is the either and I say that if I have F and G functors and
 I have a functor instance for either FG so that's trivial the fermentation
 here and I do very similar very trivial implementation using deflate very
 easy to do because of its type signature and I show that if F and G are
 filterable and if there are factors at the same time says syntax in Scala
 is like this : filter book : function and I have both evidence values then
 I produce a filterable for this type constructor which is a type lambda
 which is a product of F and G and I do the same with yourself so the implementa
tion of deflate is particularly easy I'm given a tuple of F option AG option
 a I'm supposed to return a tuple of f AG and that's easy I just deflate
 both of them separately similarly with the either and given to an either
 of a function AG option a I'm supposed to return either of FNG a and I
 just match and deflate separately and I can wear this red did I change
 maybe maybe I need to refresh this because the tests tests passed I check
 the laws I have some data and I use the borders now the orders to is the
 tuple of two orders and orders easy either of two orders so I use the orders
 and then the filterable instance for orders is already defined and then
 I have already filterable for orders to in order Z and here is the code
 for the construction of functor construction v where I have a functor Jeep
 which is filterable so first I say that the function f that I define like
 this so F of a equals one was a G okay first of all I need to show this
 has a functor instance given that G has one so that is straightforward
 I need to do this option map and so on and I do the same with deflate so
 if G has a filterable and functor instance then I produce a new evidence
 for filterable instance for the type lambda which is this and the code
 is simple kind because of the signature of that option of optional a G
 of option a and I'm supposed to return an option of a G of a so I just
 met on the option and flattened and I'm sorry deflate cannot swallow here
 I have to deflate as deflate is an arbitrary function G and then I use
 flat map on the option because this is an option type so I use the standard
 flat map on it so that's basically it and see what was was changed not
 sure what was changed now let's check it after this recording just to make
 sure everything compiles if I find anything I'll make a patch and upload
 it the next example is the recursive construction where you define a new
 factor with Perceval using an already existing filterable factor G and
 you're adding a new data item and again an instance of recursive function
 so this is like a list except in the list this would be a unit and now
 here we put a unit is filterable trivially now we put an arbitrary filterable
 here so an interesting thing about deriving this law is that the proof
 must be inductive because the type is recursive so given a function f from
 a to it 1 plus B we have the F map opt for the filterable function G so
 we have that and also we have F map opt for F which is the inductive assumption
 so I use it I use the prime here to show that this F map opt is not the
 one we are going to define but it's the one that we already assumed to
 exist and to satisfy the laws in the previous inductive step so this is
 the inductive assumption that's how we're going to derive the laws we're
 going to say if this F map opt is already satisfying the laws and we will
 only use it when we call the recursive F map opt in the definition of this
 function filterable functor and so when we use the recursive code we're
 allowed to use this recursive definition which already is assumed to satisfy
 all laws but then we prove that the definition of the next step satisfies
 the laws so here's the definition we define f map opt by first of all looking
 at f of a so first of all if we're in the queue then we just return if
 we're in the left side of this disjunction we just return the F map of
 G applied to this so there's not much to do if we are in this part of the
 disjunction then we need to check whether F of a is in the left or in the
 right if it's in the left then actually we do an interesting thing so if
 this does not pass the filter then we we can't return this because we don't
 have a value of Q of type G we return this filtered so so we descend into
 the recursive instance we discard this a this a with this card and we return
 this filtered this P filtered using the recursive instance of F map opt
 so we call ourselves we call this function that will derive defining now
 on this P and we return the result why is this valid it's because the type
 is recursive so when we return that that will be of type FB and that's
 exactly what we are supposed to return because this type is the same as
 this entire type this entire disjunction is the same as this so we are
 allowed to return it in there in the core otherwise we so if F of a is
 some be in the right side then we return this B times again the recursive
 filter result of this so we can return the right-hand side of this disjunction
 which is fine we can return the left-hand side of this disjunction if we
 have a Q or we can return only this piece after filtering because the type
 of this piece is the same as the entire type by the recursive definition
 so this is a definition of F nap opt of F let me show you the code to perhaps
 make it more clear how the recursive thing works so here is a definition
 of this construction using the type constructor c6 it's paralyzed by filterable
 function G and type a so then you have this disjunction so this is this
 disjunction the left side has a G a on the right side has a product of
 a and FA which is itself of the same type c6 so this defines this construction
 so now we have a convenient place to put all the implicit for this type
 and Scala allows you to have a object with the same name as a type constructor
 and if you put implicit into that object then whenever you use the type
 constructor these implicit are visible you don't have to include them yourself
 or import them yourself that's very convenient but saves you typing and
 looking for where these employees must be and so here we put a functor
 instance assuming that G is a factor and the filterable instance assuming
 that G is both filterable and fund although the filterable typeclass requires
 function so we could have just gotten the functor evidence out of filterable
 evidence but it's just for convenience to have both and now let's look
 at the code the both the functor instance and the filterable instance must
 be recursive because it's at a corrosive type so the map function takes
 a c6 of GA so a function from A to B and returns a c6 of GB so there are
 two cases the base case you just map a GA which should be fun to play assumptio
n and note that this dot map syntax is available because cats library allows
 you to do this with simple input which I believe is just import cats syntax
 functor dot underscore so I can just use this syntax easily anything that's
 declared as a factor and the step I have two values X and s x fa the recursive
 value of c6 so I apply F to X and I map which is the same map here and
 map recursively and the function f over this thing same thing I have to
 do with the flight I have to probably have a base I can do flight that
 if there is a step that means I have two values here both of them are type
 option and I need to deflate the first of all and the second so the first
 if the first is not empty it means that in this type this a passed the
 test so note that in the slide I had F map opt define but here I have flat
 undefined because it's easier but it's the same thing I need to decide
 what to do when this passes the test or doesn't if it passes the test I
 return that thing deflated and I deflate the other part this part recursively
 so this is the recursive call of this to the same function and if the pay
 is not passing the test if this option is empty then I need to deflate
 this recursive value and return its it deflated alone so that has the same
 type as the entire functor and that's why I - return the 20s so just to
 make a correspondence between what I have in the slides and what I have
 here in the code it is easier to implement flatten sorry deflate it's easier
 to implement deflate then it is to implement F map opt or map option or
 anything like that but it is equivalent so all the decisions we make when
 we implement f na opt are made here exactly the same way we need to flatten
 sorry to deflate G of option A plus option a times F of option and so every
 option needs to give us a decision how to flat deflate it into a non option
 type so in our FF definition we had exactly the same exactly the same question
 how to define the result of F map opt when this is given or when this is
 given and the result of F is in the left and some one so then we check
 identity law and the composition law so identity law it's easy to check
 because the identity function never returns an empty option so we're never
 in this case and therefore either we are here and we return the flattened
 queue the deflated queue which is just the same for identity or we on the
 right and then we have a times P and then we just return the same because
 a recursive instance of if map opt already satisfies the identity law and
 so when we when we apply that to P we get P identity so in this way we
 use induction plane mathematical induction to show that laws hold the compositi
on law holds in the same way so we need to show this holds now if the arguments
 are in the left then it's just about a loss for DNA which are holding by
 assumption if the arguments are in the right in here then we need to look
 at what's happening so we have F 1 and F 2 and there are four cases so
 well either if both of them returned in all empty then the previous proof
 will go through this one it's exactly the same so we need to consider the
 cases when one of them returns non-empty if the first one returns empty
 then we are returning the recursive instance so there is nothing more to
 show the second one will never be cold so we need we need actually two
 more cases only the first returns empty and the first returns non empty
 but the second returns empty so just remember to remind you decomposition
 alloys assuming two arbitrary nicely functions so a - 1 + B beta 1 plus
 C and we need to show that F map opt gives you the composition so if the
 first function returns an empty option then this also returns an empty
 option because the class decomposition is the boolean conjunction of the
 two filters so if one of them returns emptied in both conjunction also
 returns empty so then it which it remains to show so we collapse this equation
 because this is now 1 + 0 so we can use that face fruit for the right-hand
 side we need to show this and that is just the inductive assumption for
 left my post prime so if we are always in during inductive case we don't
 want to prove any further it remains to show this case again the composition
 is empty so it remains to show that the F map opt applied to this and is
 equal to F map opt prime because we are in the case of + 1 + 0 so there
 is nothing else to do and we rewrite this and we again get just the inductive
 assumption so this being equal to list so this filter is really lists like
 if this is empty we we go into the nested data structure so if you expand
 this recursive type it looks like GA plus 8 times open parenthesis GA plus
 8 times opening other parenthesis and so on so it's it's then expanded
 into GA plus 8 times J plus a times a times G a and so on so if 1a is empty
 you can always delete it and you are still in the disjunction it just recurse
 into the nested fa and they were still in in the disjunction so this is
 exactly like filter on the list the final marked example is is this one
 this is a bit interesting so here's what we have we have a big type expression
 how can we show that this is filter or order that is not it looks a lot
 of like lot of work you have to write a lot of code and then check laws
 and what if you implement it and then laws don't hold where did you make
 a mistake oh that is a lot of work so instead of trying to do that we will
 analyze the structure of this data type and use these constructions constructio
ns that are listed here and try to see if we can decompose this type expression
 into these constructions so let's look at it first of all we have this
 int time string going to this big thing okay let's denote in time string
 going to able to denote this by r1 a and also we have this int going to
 big expression so let's call this R to a inte going to a then we have one
 plus int of a instance a plus int times 1 plus 6 there's this big piece
 and after that big piece is this function type so the function type contains
 that so now we can rewrite it like that so it's r1 applied to the type
 GA plus r2 applied to AJ so that's great ga is filterable by so what is
 Jia is this it is filterable because it has type 1 plus a times something
 right we can make this a we can put it outside brackets and then you have
 1 plus a times int plus 1 plus a so n plus 1 plus a is let's call it K
 and that is filterable because it's of the form 1 plus a plus constant
 and that gives us filter rule by constructions 1 and 3 is a constant is
 construction 1 and the construction of 3 is the sum of 2 filter balls so
 constant is filterable and 1 plus a is option filterable of course so therefore
 K is filter mo therefore this is federal H is filter ball by the same construct
ion v again because 1 plus a time string is filterable by constructions
 5 and 1 so we can see this is constant so it's filterable then it's 1 plus
 a times filter which is construction v this is again construction v so
 H is filterable DS filterable and then we have so r2 of H a is a composition
 of two functions with the compositional factor r2 which is this and filterable
 so that's filterable then we have a sum of filterable and filter book therefore
 this is filterable and then we have a composition of a factor doesn't have
 to be full turbo in that construction and the filter wall so that's that's
 all we just looked at the types and we use this see in this construction
 the factor does not have to be filterable outside so this doesn't have
 to be filtered this doesn't have to be filterable these functions are just
 whatever functions we want this is filter ball and this is filterable and
 we're done so we have shown and also of course each construction comes
 with specific code that you can use to implement the filter walls and so
 you don't have to worry about it anymore you can just follow these these
 constructions you can write general library that will implement all of
 these constructions as implicit and you just call the functions from this
 line but you want something you get it and implicit will be found automatically
 so one important comment at this point is that first of all these constructions
 are not the only ones available and second there are more than one ways
 there's more than one way of implementing the filterable certainly this
 is one a valid way but there are alternatives and certain applications
 might require different alternatives so if you remember the examples from
 the previous the part 1 of this tutorial there are different business requireme
nts that might lead you to different in implementations of the filterable
 and so you can probably add more rules more constructions to this list
 but in in any case it shows you a large number of possible factors that
 can have filter ball behavior and a large number of different filterable
 behaviors such as greedy or collapsible or list like filter behavior so
 you can combine them in any way you want using these constructions here
 are some exercises for you to follow what we did and we worked examples
 and finally some bonus about filterable control factors so until now we
 were dealing only with filterable functions but actually filterable control
 factors also are interesting and could be useful and let me just conclude
 this tutorial with a discussion of filterable control factors and the discussio
n will be again modeled after the way we did we dealt with filterable factors
 first of all what are the definitions and laws how do you define filterable
 control factors so the filter functions have the same signature for country
 functions and for fun clips the there is instead of deflator than there
 is inflate which goes the opposite way and instead of F map upstairs contra
 F map opt which also goes in the opposite way so again this is a kind of
 a twisted function type it has first of all it it has reversed direction
 so B to a and here's a to b as appropriate for a control factor but also
 it has this twist with the klystron opt category just like the content
 ma opt all these functions are computation like we want you can express
 each of them through any other so for example filter through inflate contra
 F map is standard for contra factor so if you have country factor you can
 express filter through inflate inflate through filter control app opted
 to inflate inflate through contrast map opt in very much the same way as
 we expressed and for all four factors they have different laws for laws
 for filter 3los translate to laws for contract map opt and as before contract
 map opt is just kind of a twisted lifting what are examples of filterable
 country factors so here some from a 2 1 plus Z where Z is a fixed constant
 type from 1 plus a 2 Z or again C is any constant type what is a non filterable
 country function for example this where F is whatever you cannot implement
 inflate for it because what to implement inflate you have to transform
 this into a sea of 1 plus a which means the function that consumes UCC
 a is a function that consumes a and other stuff C 1 plus a is a function
 that consumes 1 plus a and other stuff to construct that function it means
 that you should be able to consume 1 that is a unit and go on and other
 stuff and go on but you don't have that you only have a function that consumes
 a and other stuff so you're required to consume a we cannot implement inflate
 so this gives us some intuition about what filterable country functors
 do first of all let's recall the main visual image of what frontiers and
 country functions do factors hold data a fonder F away in some sense it
 holds data of type a and allows you to manipulate that data a contra functor
 CA in some sense it consumes data of type a it does not actually have any
 data of type a inside it consumes it like these examples it is a function
 that consumes data of type a or some other type related to a so a contra
 functor wants you to give it one or more items of type a and then it will
 consume them and give you something else which is not a a filterable country
 functor is able to consume fewer data items of type a if you filter a country
 functor by a condition it means you prevent it from consuming some data
 that does not pass a test in other words let's say it's such a consumer
 that it is able to consume less it is able to refrain from consuming certain
 items a function of this type let's take a simpler example a twosie with
 this arbitrary factor being just unit a to Z is a function that requires
 you to give it an A it cannot refrain from consuming an a there's no way
 for it to not consume an A this function on the other hand can do it if
 you don't give it an A there is this part of the disjunction and the function
 can take that and produce a Z so this contra factor is able to refrain
 from consuming certain values and still give you the result but this functor
 is not able to do that and so it this contra factor is not filterable for
 this reason so this is the interpretation that it can consume fewer data
 items if necessary by filtering them out and the easiest function again
 is inflate so consider that function and try to implement it here are some
 constructions some analogous to filter both under constructions first of
 all a constant control factor with identity filter then the functor constructio
ns which are exactly analogous to functor you don't need to check any laws
 therefore really if g and h AR filter will control factors then the product
 is filterable control factor their sum and the composition like this is
 a filterable control enter and here you have different combinations you
 can have a functor of a control function you could have a contra functor
 of a function or you could have control factor of contra factor the result
 will be a factor again filterable you can do this of course if they're
 both filterable this is a factor this is a control function and contravariance
 is here on the left sorry covariance is on the left of the arrow so it
 becomes contravariant and so this is a contra factor if they're both filter
 button this is also filterable that is quite easy to show all of this it's
 just analogous because the laws are the functor laws it's just a twist
 and the twist is irrelevant for these constructions the twist just remains
 the same in all computations so whatever twist you have on the type the
 proofs remain the same for the factor construction now there are special
 constructions where you have to deal with the twisted type I will not go
 through the proofs of these but just to mention two of them so if you have
 this type then you can filter because you can refrain from consuming this
 a because you have the unit you can consume unit and here you cannot refrain
 from consuming any but if there are no a is given you can return one you
 can always return one how do you filter a control function well you just
 give it before you give it the data you filter it out so you give it less
 data and the Contra factors should be able to handle that if it is filterable
 it should be able to consume less data so that's the intuition behind it
 and I'm not going to go a lot into detail for but for country functions
 because so far haven't seen a lot of obvious applications for them but
 certainly there might be some this concludes chapter 6 or the functional
 programming tutorial 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
