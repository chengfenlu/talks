
\chapter{The formal logic of types I. Disjunctive types}

Disjunctive types describe values that belong to a disjoint set of
alternatives. 

To see how Scala implements disjunctive types, we need to begin by
looking at ``case classes''.

\section{Scala's case classes}

\subsection{Case classes as ``named tuple'' types}

It is often helpful to use names for the different parts of a tuple.
Suppose that some program represents the size and the color of socks
with the tuple type \lstinline!(Double, String)!. What if the same
tuple type \lstinline!(Double, String)! is used in another place
in the program to mean the amount paid and the name of the payee?
A programmer could mix the two values by mistake, and it would be
hard to find out why the program incorrectly computes, say, the total
amount paid.
\begin{lstlisting}
def totalAmountPaid(ps: Seq[(Double, String)]): Double = ps.map(_._1).sum
val x = (10.5, "white") // Sock size and color.
val y = (25.0, "friend") // Payment amount and payee.

scala> totalAmountPaid(List(x, y)) // Nonsense.
res0: Double = 35.5
\end{lstlisting}

We would prevent this kind of mistake if we could use two \emph{different}
types, with names such as \lstinline!MySock! and \lstinline!Payment!,
for the two kinds of data. There are  three basic ways of defining
a new named type in Scala that replaces a tuple: using a type alias,
using a case class, and using an \index{opaque type}opaque type. 

Opaque types (hiding a given type under a new name) is a feature that
will become standard in a future version of Scala 3; so let us focus
on type aliases and case classes.

A \textbf{type alias}\index{type alias} is an alternative name for
an existing (already defined) type. We could use type aliases in our
example to add clarity to the code:
\begin{lstlisting}
type MySockTuple = (Double, String)
type PaymentTuple = (Double, String)

scala> val s: MySockTuple = (10.5, "white")
s: MySockTuple = (10.5,white)

scala> val p: PaymentTuple = (25.0, "friend")
p: PaymentTuple = (25.0,friend)
\end{lstlisting}
But the mix-up error is not prevented:
\begin{lstlisting}
scala> totalAmountPaid(List(s, p)) // Nonsense again.
res1: Double = 35.5
\end{lstlisting}

Scala's \textbf{case classes}\index{case class} can be seen as ``tuples
with names''. A case class is equivalent to a tuple type that has
a name that we choose when we define the case class. Also, each part
of the case class will have a separate name that we must choose. This
is how to define case classes for the example with socks and payments:
\begin{lstlisting}
case class MySock(size: Double, color: String)
case class Payment(amount: Double, name: String)

scala> val sock = MySock(10.5, "white")
sock: MySock = MySock(10.5,white)

scala> val paid = Payment(25.0, "friend")
paid: Payment = Payment(25.0,friend)                                  ^ 
\end{lstlisting}
The new types \lstinline!MySock! and \lstinline!Payment! were defined.
Values of type \lstinline!MySock! are written as \lstinline!MySock(10.5, "white")!,
which is similar to writing the tuple \lstinline!(10.5, "white")!
except for adding the name \lstinline!MySock!.

To access the parts of a case class, we use the part names:
\begin{lstlisting}
scala> sock.size
res2: Double = 10.5

scala> paid.amount
res3: Double = 25.0
\end{lstlisting}
The mix-up error is now a type error flagged by the compiler:
\begin{lstlisting}
def totalAmountPaid(ps: Seq[Payment]): Double = ps.map(_.amount).sum

scala> totalAmountPaid(List(paid, paid))
res4: Double = 50.0

scala> totalAmountPaid(List(sock, paid))
<console>:19: error: type mismatch;
 found   : MySock
 required: Payment
       totalAmountPaid(List(sock, paid))
                            ^
\end{lstlisting}
A function whose argument is of type \lstinline!MySock! cannot be
applied to an argument of type \lstinline!Payment! or of type \lstinline!(Double, String)!.
Case classes with different names are \emph{different types}, even
if they contain the same types of parts. 

Just as tuples can have any number of parts, case classes can have
any number of parts, but the part names must be distinct, for example:
\begin{lstlisting}
case class Person(firstName: String, lastName: String, age: Int)

scala> val einstein = Person("Albert", "Einstein", 140)
einstein: Person = Person(Albert,Einstein,140)

scala> einstein.firstName
res5: String = Albert

scala> einstein.age
res6: Int = 140
\end{lstlisting}
This data type carries the same information as a tuple \lstinline!(String, String, Int)!.
However, the declaration of a \lstinline!case class Person! gives
the programmer several methods that make working with the tuple's
data more convenient.

Some (or all) part names may be specified when creating a case class
value:
\begin{lstlisting}
scala> val poincare = Person(firstName = "Henri", lastName = "Poincaré", 165)
poincare: Person = Person(Henri,Poincaré,165)
\end{lstlisting}
It is a type error to use wrong types with a case class:
\begin{lstlisting}
scala> val p = Person(140, "Einstein", "Albert")
<console>:13: error: type mismatch;
 found   : Int(140)
 required: String
       val p = Person(140, "Einstein", "Albert")
                      ^
<console>:13: error: type mismatch;
 found   : String("Albert")
 required: Int
       val p = Person(140, "Einstein", "Albert")
                                       ^
\end{lstlisting}
Here, the error is due to an incorrect order of parts when creating
a case class value. However, parts can be specified in any order when
using part names:
\begin{lstlisting}
scala> val p = Person(age = 140, lastName = "Einstein", firstName = "Albert")
p: Person = Person(Albert,Einstein,140)
\end{lstlisting}
A part of a case class can have the type of another case class, creating
a ``nested'' type:
\begin{lstlisting}
case class BagOfSocks(sock: MySock, count: Int)
val bag = BagOfSocks(MySock(10.5, "white"), 6)

scala> bag.socks.size
res7: Double = 10.5
\end{lstlisting}


\subsection{Case classes with type parameters}

Generally, type classes can be defined with \index{type parameter}type
parameters. As an example, consider a generalization of \lstinline!MySock!
where, in addition to the size and color, a ``sock'' may hold another
value. We could define several specialized case classes,
\begin{lstlisting}
case class MySockInt(size: Double, color: String, value: Int)
case class MySockBoolean(size: Double, color: String, value: Boolean)
\end{lstlisting}
but it is better to define a single parameterized case class
\begin{lstlisting}
case class MySockX[A](size: Double, color: String, value: A)
\end{lstlisting}
that works for every type \lstinline!A!. When we create values of
\lstinline!MySockX!, we will use a specific type, for instance
\begin{lstlisting}
scala> val s = MySockX(10.5, "white", 123)
s: MySockX[Int] = MySockX(10.5,white,123) 
\end{lstlisting}
Here, the type variable \lstinline!A! was automatically set to a
specific type, \lstinline!Int!. 

Specific types \lstinline!A! will be used by each specific value
of type \lstinline!MySockX[A]!, but we can write code working with
\lstinline!MySockX[A]! \textbf{parametrically}\index{parametric code},
that is, keeping the type parameter \lstinline!A! in the code. For
example, a function that checks whether a sock of type \lstinline!MySockX[A]!
fits my foot can be written as
\begin{lstlisting}
def fitsMe[A](sock: MySockX[A]): Boolean = sock.size >= 10.5 && sock.size <= 11.0
\end{lstlisting}
This function is defined for all types \lstinline!A! at once, because
its code works in the same way regardless of the type \lstinline!A!.
Scala will set the type parameter automatically:
\begin{lstlisting}
scala> fitsMe(MySockX(10.5, "blue", List(1,2,3))) // Parameter A = List[Int]
res0: Boolean = true
\end{lstlisting}
In this case it is clear that the type parameter \lstinline!A! must
be set to \lstinline!List[Int]!, and we may omit the type parameter
when calling \lstinline!fitsMe!. When types become more complicated,
it may be helpful to avoid type errors by specifying the values of
type parameters. For example, here is a type error due to a mismatch
between the type parameter \lstinline!A! used in the ``sock'' value,
which is \lstinline!List[Int]!, and the type parameter in the function
\lstinline!fitsMe!, specified as \lstinline!Int!:
\begin{lstlisting}
scala> fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
<console>:15: error: type mismatch;
 found   : List[Int]
 required: Int
       fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
                                             ^ 
\end{lstlisting}

Case classes may have several type parameters, and the types of the
parts may use these type parameters. Here is an artificial example
of a case class using type parameters in different ways,
\begin{lstlisting}
case class Complicated[A,B,C,D](x: (A, A), y: (B, Int) => A, z: C => C)
\end{lstlisting}
This case class contains parts of different types that use the type
parameters \lstinline!A!, \lstinline!B!, \lstinline!C! in tuples
and functions. The type parameter \lstinline!D! is not used at all;
this is allowed as well.

\subsection{Tuples with one part and with zero parts}

Let us compare tuples and case classes more systematically.

Parts of a case class are accessed by name with a dot syntax, for
example \lstinline!sock.color!. Parts of a tuple are accessed with
the accessors such as \lstinline!x._1!. This syntax is the same as
that for a case class whose parts have names \lstinline!_1!, \lstinline!_2!,
etc. So, it appears that tuple parts \emph{do} have names in Scala,
although those names are always automatically assigned as \lstinline!_1!,
\lstinline!_2!, etc. It turns out that tuple types also have automatically
assigned names in Scala; these names are \lstinline!Tuple2!, \lstinline!Tuple3!,
etc., and they correspond to parameterized types, since each part
of the tuple may be of any type. So, a tuple type expression such
as \lstinline!(Int, String)! is just a special syntax for the parameterized
type \lstinline!Tuple2[Int, String]!. One could define the tuple
types as case classes like this,
\begin{lstlisting}
case class Tuple2[A, B](_1: A, _2: B)
case class Tuple3[A, B, C](_1: A, _2: B, _3: C)
// And so on with Tuple4, Tuple5, ...
\end{lstlisting}
if these types were not already defined in the Scala library.

Proceeding systematically, we ask whether tuple types can have just
one part or even no parts. Indeed, Scala defines \lstinline!Tuple1[A]!
as a tuple with a single part. (This type is occasionally useful in
practice.) 

The tuple with zero parts exists as well, and is called \lstinline!Unit!
(rather than ``\lstinline!Tuple0!''). At first sight, the \lstinline!Unit!
type may appear to be completely useless; it is a tuple that contains
\emph{no} values. The syntax for the value of the \lstinline!Unit!
type is the empty tuple, \lstinline!()!. It is clear that there is
\emph{only one} value, \lstinline!()!, of this type; this explains
the name ``unit''. It turns out, however, that the \lstinline!Unit!
type is important in functional programming, and it is used as a type
guaranteed to have only a single distinct value. This chapter will
show some examples of using the \lstinline!Unit! type.

Case classes can be defined similarly to the one-part and zero-part
tuples like this:
\begin{lstlisting}
case class B(z: Int) // Tuple with one part.
case class C() // Tuple with no parts.
\end{lstlisting}
Let us summarize the correspondence between tuples and case classes:
\begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{Tuples} & \textbf{Case classes}\tabularnewline
\hline 
\hline 
\lstinline!(123, "xyz"): Tuple2[Int, String]! & \lstinline!case class A(x: Int, y: String)!\tabularnewline
\hline 
\lstinline!(123,): Tuple1[Int]! & \lstinline!case class B(z: Int)!\tabularnewline
\hline 
\lstinline!(): Unit! & \lstinline!case class C()!\tabularnewline
\hline 
\end{tabular}
\par\end{center}

Scala has a special syntax for case classes without parts:
\begin{lstlisting}
case object C // Similar to `case class C()`.
\end{lstlisting}
There are two main differences between \lstinline!case class C()!
and \lstinline!case object C!:
\begin{itemize}
\item A \lstinline!case object! cannot have type parameters, while we may
define a \lstinline!case class C[X, Y, Z]()! if needed.
\item A \lstinline!case object! is allocated in memory only once, while
new values of a \lstinline!case class C()! will be allocated in memory
each time \lstinline!C()! is evaluated.
\end{itemize}
Other than that, \lstinline!case class C()! and \lstinline!case object C!
have the same meaning: a named tuple with zero parts, which we may
also call a ``named \lstinline!Unit!\index{named Unit}'' type. 

\subsection{Pattern matching for case classes}

Scala performs pattern matching in two situations:
\begin{itemize}
\item destructuring definition: \lstinline[mathescape=true]!val $pattern$ = ...!
\item \lstinline!case! expression: \lstinline[mathescape=true]!case $pattern$ => ...!
\end{itemize}
Case classes can be used in both situations. Here is an example of
a destructuring definition, used to implement a function whose argument
is of case class type \lstinline!BagOfSocks!:
\begin{lstlisting}
case class MySock(size: Double, color: String)
case class BagOfSocks(sock: MySock, count: Int)

def printBag(bag: BagOfSocks): String = {
  val BagOfSocks(MySock(size, color), count) = bag // Destructure the `bag`.
  s"Bag has $count $color socks of size $size"
}

val bag = BagOfSocks(MySock(10.5, "white"), 6)

scala> printBag(bag)
res0: String = Bag has 6 white socks of size 10.5
\end{lstlisting}

An example of using the \lstinline!case! expression:
\begin{lstlisting}
def fitsMe(bag: BagOfSocks): Boolean = bag match {
  case BagOfSocks(MySock(size, _), _) => size >= 10.5 && size <= 11.0
}
\end{lstlisting}
In the implementation of this function, we match the \lstinline!bag!
value against the pattern \lstinline!BagOfSocks(MySock(size, _), _)!.
This pattern will always match and will define \lstinline!size! as
the pattern variable of type \lstinline!Double!.

The syntax for pattern matching expressions that use case classes
is similar to the syntax for pattern matching of tuples, except for
the presence of the \emph{names} of the case classes. For example,
if we remove the type names from the pattern
\begin{lstlisting}
case BagOfSocks(MySock(size, _), _) => ...
\end{lstlisting}
we obtain the nested tuple pattern 
\begin{lstlisting}
case ((size, _), _) => ...
\end{lstlisting}
that could be used for values of type \lstinline!((Double, String), Int)!.
We see that case classes behave in many ways exactly as named tuple
types. 

Scala's ``case classes'' got their name from their use in \lstinline!case!
expressions. It is usually more convenient to use \lstinline!match!
/ \lstinline!case! expressions with case classes than to use destructuring.

\section{Disjunctive types}

\subsection{Motivation and first examples}

In many situations, it is useful to have several different shapes
of data within the same type. As a first example, suppose we are looking
for real roots of a quadratic equation $x^{2}+ax+b=0$. There are
three cases: no real roots, one real root, and two real roots. It
would be convenient if we had a type, such as \lstinline!RootsOfQ!,
that means ``the real roots of a quadratic equation''. Inside that
type, we can distinguish between the three cases, but outside it looks
like a single type, so that it is easier to work with.

Another example is the binary search algorithm that looks for an integer
$x$ in a sorted array. There are two cases: the algorithm either
finds the index of $x$ or determines that the array does not contain
$x$. It is convenient if the algorithm could return a single value
of a type, say, \lstinline!SearchResult!, that represents \emph{either}
an index at which $x$ is found, \emph{or} the absence of an index.

More generally, we may have computations that \emph{either} return
a value \emph{or} generate an error and fail to produce a result.
It is then convenient to return a value of type, say, \lstinline!Result!,
that could represent \emph{either} a correct result \emph{or} an error
message. 

In certain computer games, one has different types of ``rooms'',
each room having certain properties depending on its type, \textendash{}
some rooms are dangerous because of monsters, other rooms contain
useful objects, certain rooms allow you to finish the game, and so
on. We want to represent all the different kinds of rooms uniformly,
as a type \lstinline!Room!, so that each ``room value'' automatically
stores the correct properties in each case.

In all these situations, data comes in several mutually exclusive
shapes. This data can be represented by a single type only if that
type is able to describe a mutually exclusive set of cases:
\begin{itemize}
\item \lstinline!RootsOfQ! must be either the empty tuple \lstinline!()!
or \lstinline!Double! or a tuple \lstinline!(Double, Double)!
\item \lstinline!SearchResult! must be either \lstinline!Int! or the empty
tuple \lstinline!()!
\item \lstinline!Result! must be either an \lstinline!Int! value or a
\lstinline!String! message
\end{itemize}
We see that the empty tuple, also known as the \lstinline!Unit! type,
is convenient to use in this representation! It is also helpful to
assign names to each of the cases:
\begin{itemize}
\item \lstinline!RootsOfQ! is ``empty'' with value \lstinline!()!, or
``single root'' with value \lstinline!Double!, or ``double root''
with value \lstinline!(Double, Double)!
\item \lstinline!SearchResult! is ``index'' with value \lstinline!Int!,
or ``not found'' with value \lstinline!()!
\item \lstinline!Result! is ``value'' of type \lstinline!Int! or ``error
message'' of type \lstinline!String!
\end{itemize}
Scala's case classes provide exactly what we need here \textendash{}
\emph{named tuples} with zero, one, two and more elements, and so
it is natural to use case classes instead of tuples:
\begin{itemize}
\item \lstinline!RootsOfQ! is of type \lstinline!case class Empty()!,
or or type \lstinline!case class SingleRoot(x: Double)!, or of type
\lstinline!case class DoubleRoot(x: Double, y: Double)!
\item \lstinline!SearchResult! is of type \lstinline!case class Index(Int)!,
or of type \lstinline!case class None()!
\item \lstinline!Result! is of type \lstinline!case class Value(x: Int)!
or of type \lstinline!case class Error(message: String)!
\end{itemize}
The only remaining question is how to define these types. We somehow
need to indicate that the case classes \lstinline!Empty!, \lstinline!SingleRoot!,
and \lstinline!DoubleRoot! are the three alternative cases described
by the type \lstinline!RootsOfQ!. The Scala syntax for these definitions
looks like this:
\begin{lstlisting}
sealed trait RootsOfQ
case class Empty() extends RootsOfQ
case class SingleRoot(x: Double) extends RootsOfQ
case class DoubleRoot(x: Double, y: Double) extends RootsOfQ
\end{lstlisting}

We may use \lstinline!case object! for the named \lstinline!Unit!
cases:
\begin{lstlisting}
sealed trait SearchResult
case class Index(i: Int) extends SearchResult
case object NotFound extends SearchResult
\end{lstlisting}
The definition of the \lstinline!Result! type can be parameterized,
so that we can describe results of any type (but error messages are
always of type \lstinline!String!):
\begin{lstlisting}
sealed trait Result[A]
case class Value[A](x: A) extends Result[A]
case class Error[A](message: String) extends Result[A]
\end{lstlisting}

The ``\lstinline!sealed trait! / \lstinline!case class!'' syntax
defines a type that represents a choice of one case class from a fixed
set of case classes. This kind of type is called the \textbf{\index{disjunctive type}disjunctive
type} in this book. 

\subsection{Pattern matching with disjunctive types}

Our first examples of disjunctive types were \lstinline!RootsOfQ!,
\lstinline!SearchResult!, and \lstinline!Result[A]!. Let us see
how we can write code that works with these types.

\subsection{Disjunctive types as mathematical sets}

To understand more deeply the meaning of disjunctive types, let us
look at at the mathematical point of view usually the type means madam
ethically that the function has an arguments let's say f of X has
an argument X the type of X let's say X is a real number then the
type of X represent the domain of the function so now we would like
to represent disjoint domains so for example X is either a point on
the line or as a point on the surface completely different surface
and from a line and so in mathematics this is not often used but in
functional programming it is used quite a lot because it looks it
appears that real life situations and tasks require a lot of this
coming of this disjoint domains I just gave you examples on the previous
slide so how would we do a disjoint domain between line and surface
let's say line is the real numbers and surfaces are part two the real
plane so in functional programming the way it's done is that the domains
are labeled so we introduce some fixed special set of symbols with
which are labels like left Android's say these are just symbols that
come from a fixed set of symbols and then we first make two sets the
first set will be a set of pairs where the first element of the pair
is the symbol left and the second element of the pair is some real
number so this set is a set of all such pairs and this set is a set
of all different pairs where the first element is a symbol right and
the second element is some point from a surface from r2 and then make
union of these two sets now this is a labeled union because each set
has this label and so there's no way that any even if this were our
and this were also our there will be no way to confuse an element
from the left part of the union and lanolin from the right part of
the Union and so the disjoint union is always an exclusive or it's
never inclusive or it could be couldn't be both from here and from
here because the symbols are different so given any such X from this
set from this entire set we can always determine by looking at the
first element of the pair from which side it comes and we therefore
can obtain and know what is the type of the corresponding other value
in each case so there is no confusion if we label the two parts of
the Union even if all these types are worth the same with this where
artists were also her will still be no confusion whereas a ordinary
mathematical Union you would be confused you would think well our
union ours just are so but disjoint Union is labeled and allows you
to always know from which part you come from that from which parts
the value comes so in Scala this kind of type is disjoint Union or
exclusive or between two domains it's denoted like this so it's special
library you find a special type defined in the library called either
it has two type parameters describing the two domains the first let's
say double that's a describing this and second is a tuple of two doubles
which describes the so this was a very close analogy with a mathematical
disjunctive between the two domains and as I just said domains in
mathematics corresponds to types of variables in programming in functions
so types of variables is exactly the same as a set from which the
variable comes so like X comes from the set of real numbers and here
double is a type that approximately represents real numbers and pattern
matching is used to define expressions with such types so let's look
at examples with either so we were looking before at a situation when
we wanted to generate error messages with computation and so let's
suppose we have a function that needs to return an integer but may
actually have an error and so it turns this type either of string
and integer which is a disjunctive between two domains the first is
the set of all strings the second is the set of all integers and it
is labeled by symbols left and right these symbols also come from
the skull a standard library now if we have a function let's say log
error we want to write this function that takes an argument of this
type how can we construct an expression using this type and here's
how we say X match this is keyword match so say X match and then you
write this partial function which matches against possible values
of X and there are two cases the left having an error value which
is of type string and the right having a result value which is of
type integer in both cases we can specify what needs to be done or
rather the expression that needs to be computed well we can print
of course but we need to return a value and this function must return
integer value so let's return some integer value or not and then the
result now this is just an example now how can we interpret this code
what does it mean case left error case right result it means these
are actually possible values of this type so this and this are specific
possible values of this type remember that we have this labeled disjunctive
so this is a possible value with symbol left and a number and so similarly
here a symbol left which is the name of the case class this is just
a symbol it is not itself a value it's it does not give you a value
until you give it this the the string and so left of blah is actually
a value of type either string int and similarly right of one two three
is also a possible value of this type so in this for in this code
we enumerate the possible cases the disjunctive there are only two
cases in this disjunctive the left and the right and so we enumerate
them and each time we have a pattern variable of a different type
because if we are in the left case of disjunctive when the error is
of string type this pattern variable we could have called it X or
Y or whatever it's just a pattern variable and it's introduced right
here and it only is visible within the scope of this expression so
here we cannot have access to error if you want to here if I cannot
make a mistake 

The type of the function's argument represents the function's \emph{domain}

For example: $f(x)$ where $x\in\mathbb{R}$ 

We would like to be able to represent arbitrary \emph{disjoint} domains

For example: $x$ is either a point on a line or a point on a surface

In functional programming, the disjoint domains are always \textbf{labeled}

For example: $x\in\left(\text{left},\mathbb{R}\right)\cup\left(\text{right},\mathbb{R}^{2}\right)$

The disjoint union is always an \emph{exclusive-or}

Labels come from a fixed, special set of symbols

Given any such $x$, we can determine its ``side'' of the union

We can obtain the corresponding value in each case

In Scala, this type is denoted \lstinline!Either[Double, (Double, Double)]!

Pattern-matching is used to define expressions with such types

\subsection{Disjunctive type: \texttt{Either{[}A, B{]}}}

Example: Either{[}String, Int{]} (may be used for error reporting)

Represents a value that is either a String or an Int (but not both)

Example values: Left(\textquotedbl blah\textquotedbl ) or Right(123)

Use pattern matching to distinguish ``left'' from ``right'':

def logError(x: Either{[}String, Int{]}): Int = x match \{

  case Left(error) $\Rightarrow$ println(s\textquotedbl Got error:
\$error\textquotedbl ); -1

  case Right(res) $\Rightarrow$ res

\} // Left(``blah'') and Right(123) are possible values of type
Either{[}String, Int{]}

Now logError(Right(123)) returns 123 while logError(Left(\textquotedbl bad
result\textquotedbl )) prints the error and returns -1

The case expression chooses among possible values of a given type

Note the similarity with this code:

def f(x: Int): Int = x match \{

  case 0 $\Rightarrow$ println(s\textquotedbl error: must be nonzero\textquotedbl );
-1

  case 1 $\Rightarrow$ println(s\textquotedbl error: must be greater
than 1\textquotedbl ); -1

  case res $\Rightarrow$ res

\} // 0 and 1 are possible values of type Int


\subsection{General disjunctive types in Scala: trait + case classes}

A future version of Scala 3 has a short syntax for disjunctive3 types:

type MyIntOrStr = Int | String

more generally, type MyType = List{[}Int{]} | (Int, Boolean) | MySocks

Some libraries (scalaz, cats, shapeless) also provide shorter syntax

For now, in Scala 2, we use the ``long syntax'':

(specify names for each case and for each part, use ``trait'' /
``extends'')

sealed trait MyType

final case class HaveListInt(x: List{[}Int{]}) extends MyType

final case class HaveIntBool(s: Int, b: Boolean) extends MyType

final case class HaveSocks(socks: MySocks) extends MyType

Pattern-matching example:

val x: MyType = if (...) HaveSocks(...) else HaveListInt(...)

... // some other code here

x match \{

  case HaveListInt(lst) $\Rightarrow$ ...

  case HaveIntBool(p, q) $\Rightarrow$ ...

case HaveSocks(s) $\Rightarrow$ ...

\}


\subsection{The most often used disjunctive type: \texttt{Option{[}T{]}}}

A simple implementation: 

sealed trait Option{[}T{]}

final case class Some{[}T{]}(t: T) extends Option{[}T{]}

final case object None extends Option{[}Nothing{]}

Pattern-matching example:

def saveDivide(x: Double, y: Double): Option{[}Double{]} = \{

  if (y == 0) None else Some(x / y)

// Example usage:

val result = safeDivide(1.0, q) match \{

  case Some(x) $\Rightarrow$ previousResult {*} x

  case None $\Rightarrow$ previousResult // provide a default value

\}

Many Scala library functions return an Option{[}T{]}

find, headOption, reduceOption, get (for Map{[}K, V{]}), lift for
Array{[}T{]}

Note: Option{[}T{]} is ``collection-like'': has map, flatMap, filter,
exists...

\section{Summary}

What problems can we solve now?

Represent values from disjoint domains as a single type

Use such values in collections safely

\subsection{Solved examples}

Define a disjunctive type DayOfWeek representing the seven days.

Modify DayOfWeek so that the values additionally represent a restaurant
name and total amount for Fridays and a wake-up time on Saturdays.

Define a disjunctive type RootsOfQuadratic that represents real-valued
roots of the equation $x^{2}+bx+c=0$ for arbitrary real $b$, $c$.
(The cases of interest are: no real roots; two equal roots; two unequal
roots.) Implement solve2:\ ((Double, Double)) => RootsOfQuadratic.

Define a function rootAverage:\ RootsOfQuadratic $\Rightarrow$ Option{[}Double{]}
that computes the average value of all real roots, returning None
if the average is undefined.

Generate 100 random coefficients $b$, $c$ (uniformly distributed
between $-1$ and $1$) and compute the mean of rootAverage for them.

Implement def f{[}A, B{]}:\ ((Option{[}A{]}, Option{[}B{]})) $\Rightarrow$
Option{[}(A, B){]}

\subsection{Exercises}

Define a disjunctive type CellState representing the visual state
of one cell in the ``\href{https://en.wikipedia.org/wiki/Minesweeper_(video_game)}{Minesweeper}''
game: A cell can be either closed, or display a bomb, or be open and
display the number of neighbor bombs.

Define a function from Seq{[}Seq{[}CellState{]}{]} to Int, counting
the total number of cells with $0$ neighbor bombs shown.

Define a disjunctive type RootOfLinear representing all possibilities
for the solution of the equation $ax+b=0$ for arbitrary real $a$,
$b$. (The possibilities are: no roots; one root; all $x$ are roots.)
Implement the solution as a function solve1:\ ((Double, Double))
$\Rightarrow$ RootOfLinear.

Given a Seq{[}(Double, Double){]} containing pairs $\left(a,b\right)$
of the coefficients of $ax+b=0$, use solve1 to produce a Seq{[}Double{]}
containing the roots of that equation when a unique root exists.

Define functions having these type signatures: 

def f1{[}A, B{]}:\ Option{[}(A, B){]} $\Rightarrow$ (Option{[}A{]},
Option{[}B{]})

def f2{[}A, B{]}:\ Either{[}A,B{]} $\Rightarrow$ (Option{[}A{]},
Option{[}B{]})

def f3{[}A,B,C{]}:\ Either{[}A, Either{[}B,C{]}{]} $\Rightarrow$
Either{[}Either{[}A,B{]}, C{]}

\section{Discussion}

\begin{comment}
now let's look at disjunctive types 

and try to access this error value when actually I'm in the right
disjunctive in the second part of the disjunctive because the error
is not defined in this Cobra that I am just showing in the scope only
the rest is defined so these case expressions have limited scope so
this expression from the first case until the second it is one scope
and within this scope the error variable is defined outside it is
not defined and similarly for this so if we call this function on
the value such as write 123 then this function will match the first
case will not match so then the second case will match and the result
will be returned so this will be the value it returns then the match
is performed line by line so if the first line that matches gives
you this expression and that's it not no further lines are evaluated
so log error of left bad result will match this because it matches
the symbol the left and then error will be the variable equal to the
value of it will be equal to bad result and so it'll print got error
bad result and then it will return -1 so case X Russians that choose
among possible values of a given type when this type is a disjunctive
and here is another way of using case expressions with types that
don't look like a disjunctive like int where you say if so I say X
which is an argument of this function X match and then I enumerate
certain cases 0 1 and then all other cases so if if 0 does not match
if one does not match then this case this line will be evaluated and
then this pattern matches everything is just a variable so this rest
will be equal to this X since we matched it and so then the same X
will be returned so you could think about integers as a type that
has different values like 0 1 and others there are possible values
of this type and so you could use case expression also for those so
case expression is not limited to disjunctive types or case classes
integer is not defined as a disjunctive type because it has long parts
of disjunctive but it has different values and so just to know to
the similarity between this code and this code the case expressions
in the partial function enumerate possible values of the function
and so here also I'm not limited to just writing two cases lines here
case left error case rightness I could write anything I want like
for example case left and then empty string instead of error here
and that will only match when X has that value left of empty string
then on the next line I could say case left of something else and
won't match only when X is net this is just to what you know that
the case expressions are more powerful than just matching the two
parts of a disjunctive they're matching anything these patterns can
have many conditions and this can be complicated so either is a example
of disjunctive but there are more general disjunctives like for example
well if I want to have a disjunctive between three different domains
do I have to do either of either so that is not convenient now in
in principle what I want is something like this I want to just say
this type or this type or let's say this type or this type or this
type this is a disjunctive I want to be able to define these junctions
like this but Scala does not have this syntax there are some libraries
like these libraries that provide syntax similar to this one but I
don't want to go into these libraries that are more advanced right
now I want to use the standard syntax in Scala which is sufficient
for most purposes in the more ordinary applications of functional
programming which is most of its applications today later I won't
talk about those libraries and see what they offer but for now let's
use the long syntax which is available in Scala and this is the syntax
okay this is quite long to represent what I would ideally write like
this if I if I compare this with that my type is a name of the type
the type has disjunctive of three domains the first domain is a list
of integers so the first domain here has a name all domains must have
a name in the disjunctive is a label so here in this context the name
would be implicit something like underscore one or something but in
this syntax in the long syntax the domain has to be explicit so your
name is have list int it has one part so it's a tuple of one with
name have list int and the part is named X let's say then I have to
write this keyword extends my type and in this way I say that this
case class is part of a disjunctive which I'm going to define now
so my type is the name of the entire disjunctive and these are the
names of its three parts the labels and these are the names of the
tuple parts so each domain is a tuple with names case class as I explained
is a tuple with names so this disjunctive has two lists the names
for everything for every part of the disjunctive and for every part
of each tuple finally these keywords sealed final case class trait
these keywords are necessary in Scala and what they do is they make
sure that you cannot by mistake change this disjunctive later because
that would be a difficult bug that some other part of the program
changes this disjunctive and then adds some more stuff to it let's
see some other domain and then your case matches stop working because
you don't know that somebody added domains you have your case State
case expressions like this pattern matching and you expect three domains
in your disjunctive so you write it like this but somebody adds a
different domain and this stops working this will crash if if that
word if that happens so to prevent that you say that my trait called
my type is sealed so no so only the ones the the domains of the disjunctive
that are listed next to it in the file well not necessarily next day
but in the same file only those exist and no others may be defined
later at any time similarly the case passes are final so they cannot
be extended later as the result the syntax is quite long you have
to write a lot of stuff just to express this kind of disjunctive of
three domains but you write it only once and using it is quite short
is not so bad at all so for example first I create a value of this
type so this could be a result of some computation with conditions
if some condition holds then the values have socks with some socks
values and otherwise it's have list int with some list int value so
this is computed and then somebody wants to find out what that X was
and they don't know this could be in a different part of the code
and this could be even in a different library and so you have to match
on the three domains of the disjunctive that's how you write it you
put pattern variables in the case classes so these nine names don't
have to be the same as these they can be for convenience but they
don't have to be I'm just specifically selecting all different names
just to show you that these are arbitrary names they don't have to
be the same and then you write expressions here that will be evaluated
in each of these cases and this expression for example is allowed
to use this LST but not this and all that because the scope is is
limited so the scope of definition of this LST is only this expression
the scope of definition of pmq is only this expression if you try
to use P and Q here the compiler would say cannot find symbol or something
like that if very often used disjunctive type is called option here
is how I would implement option in a very simple way it has a disjunctive
of two domains one domain is a tuple with one element of type T or
T is a type parameter and the second domain is a tuple of zero elements
or unit type which is represented as a case object this is just a
keyword in skeleton doesn't really mean anything different from a
tuple with no elements or a unit type and you notice here it extends
option with type parameter nothing nothing is a special type that
has no values at all so this is used to signal that this is an empty
tuple it does not have any values inside so we cannot use any type
for parameter here but we must specify the parameter so we use this
special type nothing all of this is defined in the standard library
of skeleton nothing option some none so some and none are the two
labels on the two domains of the disjunctive now in order to use it
you do pattern match for instance like this here's a function that
performs safe divided divides X by Y but your turns an option of double
and so option list is a disjunctive and option parameterize by the
type double is a disjunctive of of either double or nothing so no
value rather unit is the type or empty tuple if you prefer is a type
that does not carry any value of type double in it and so here's how
you define a function that computes this it checks the condition and
if Y is 0 you return none which is this label otherwise you return
value X divided by Y labeled by the name and a single Sun now the
symbol is a label on the second part or here on the first part of
the disjunctive and here's how I would use it so I would say safe
divide one divided by Q maybe Q is zero maybe not but I then match
so this returns an option of double I match the option with two cases
some X and none so these are the two parts of the disjunctive and
I mention them and so if I have some X then I multiply that some whatever
previous result by that X and otherwise I returned previous result
so this is a kind of a default value that I return when I don't get
anything out of this function this function returns none which is
a valid result of type option double mini Scala library functions
return an option type such as find returns so find looks in a collection
and returns an option if it found then it returns some of the value
and if it did not find it returns none had option is the first element
of the collection but if it's an empty sequence there is no head element
no first element so it returns none otherwise it returns some with
the value of the first element and similarly these primary functions
which you can look up in the library or in IntelliJ these functions
return option and the final note is that option has many functions
or methods defined on it in a sense option is like a collection it's
like sequence of tea so option of tea is very much like sequence of
tea in terms of what you can do with it you can see with sequins you
cannot do this match because sequence is not a disjunctive between
nan and Sun but sequence has map flatmap filter exists and so on all
of this is also defined on an option and you can understand this in
a simple way if you imagine that the sequence is like a container
and that sequence of tea is like a container where or let's say array
of teas and another kind of sequence it's like a container where you
have 0 or more elements of type T so this container holds values of
type T it can can hold no values empty array or empty sequence or
it could hold one value or two values and so on option is like a container
that can only hold 0 or 1 values of this type T it cannot hold two
so it's like a very limited sequence the sequence that can only be
of length 0 or 1 otherwise it looks like a sequence so it has a map
a function flat map filter and so on so what for example it's a map
on an option I will show you when we go through the worked examples
how that works map on the collection let's say on array of integers
you can do a map with a function that maps integers to strings say
in some way and then you map and you get an array of strings where
each element is transformed by that function option will behave in
a very similar way you do a map with an option and every element in
an option will be transformed using the function you specify however
option can only contain at most one element so it can be empty which
is this disjunctive part or it can be non-empty containing one element
of type T one value of type T so it's kind of a very limited simple-minded
collection but otherwise it's similar to collection we will see how
that works in the examples so with the tools we just learned what
problems can we solve we can represent values from disjoint sets or
domains as a single type and we can use these values to define functions
on them or functions producing them and use also these values in collections
as elements of collections or in any other way we can these are types
so there's no restriction on how you can use them so let's go through
some examples now the first example is to define a disjunctive type
day of week it represents the seven days of the week let me go to
this example so here's what it would look like so all these keywords
here in IntelliJ you see in bold blue dark blue seal the trade final
case object.extend so these are keywords of Scala and everything else
is our labels that we introduced so day of week is the name of this
entire type the entire disjunctive type it has seven domains and these
domains don't carry any values so these are just empty tuples and
the syntax for them is to say case object and then you don't you don't
write this this is a mistake you should know right that empty tuple
empty tuple is written like this indeed but you don't have to write
it here so the syntax is such that you don't write it left so when
you put a name on an empty tuple then it's called a case object and
then you don't write parenthesis so here's how we define the type
how will we use the type like this will define values a and B let's
say of this type and assign these values so we define Monday and Saturday
just like this we don't have to do anything else we don't have to
say new new Monday there's no numa there's only one Monday because
that's a label of the domain and a disjunctive is no no sense in that
to say new Monday cannot have different Monday's they're all the same
it's a label on the disjunctive now if I don't do this and just say
well a eCos Monday then Scala will actually not know that I want a
to be of this type color we'll think but it has typed Monday type
so monday dot type is just ask our feature that I'm not going to use
right now it is a more advanced feature so with these disjunctive
types it is a good idea to write type annotations Scala it can be
too smart about what I want to do and so it is better if I do this
but it would not be an error if I did it that way if I put just any
without type annotation probably my code was to work just some types
will become weird now suppose I want to print now how to print this
well actually case classes and case objects already have a two-string
method defined on them so I can just print like this with string interpolation
and this will run and I will get the string printed after we implement
the function so that this test can pass so how do we implement this
function this function is supposed to give us a boolean which is true
when the day of the week of Saturday and false otherwise so we do
this by pattern matching since the type is a disjunctive so we need
to match on the label of the disjunctive or in the scala language
we match on the case class or case object so we say Dean match and
then you see there's this red case close as expected sure and then
there's this thing which I can click it says generate case closes
for variants of sealed type now in the scholarly in which this means
this was a sealed trait that I defined and it has seven variants or
disjoint domains in my understanding and so if I click this IntelliJ
will fill in the code actually not sure why is doing it like this
because it's from from another from from another example I guess it's
a bit confused but it allowed me to delete what was not necessary
so it generated most of the code so now I need to put the expressions
that I'm going to return in each case so if this day is Saturday I
need to return true otherwise I need to return false now there's a
lot of I could say false false a lot of work like this so I'm going
to be more clever and I'm going to do this and when it puts Saturday
first and then if there is anything else I'm going to return false
so let's say playing this so in this way I'm expressing my intention
much more clearly so Saturday true I do otherwise anything else false
so there's one little thing so this will work but we can run this
test and this will work there's one little detail here so green notice
what is printed E is Monday B is Saturday so this is the string that
I printed here with interpolation so a was Monday and it can be it's
already printable so this is a convenience that scholar gives now
the little detail I was talking about is that intelligence says Declaration
is never used so I declared the variable X but I never actually used
it there's a syntax which looks like this it needs to be used in this
case to make it more clear like I said this still works this is not
a mistake to do a variable that you don't have to use a variable here
and never actually included anywhere so to left it unused it's not
a mistake but it is a little misleading because you're introducing
a variable and so I'm looking for its use maybe I don't find one so
this syntax means it's a very that matches anything just like X no
conditions and on it variable watches anything and I don't need its
name I'm not going to use that variable so the underscore in this
situation means that it's a pattern variable that I'm not going to
use so I don't need its name and it matches everything and my tests
are that a and B so a was Monday B was Saturday they they pass let's
go to the second example {[}Music{]} modified day a week so that the
values additionally represent a restaurant name and total amount for
Friday's and a wake-up time on Saturdays so what does it mean I want
additional values on list on this disjunctive on on the domains in
the disjunctive I want these domains to be not just empty tuples as
I did before here but for Friday I want a domain that represents a
string which is restaurant name and an amount paid so here's what
I do i make Friday and Saturday case classes instead of case objects
and then I am free to add parts in there with different types so field
called restaurant name and type string and its own so I can do that
and similarly for Saturday now I think I made I haven't finished this
so this is supposed to be wake up time so I think I want to do a local
date time from the Javadoc time library and that's a wake up time
so this is it so basically I have easily added more data but only
for these two days so these they still have no no data so if if the
day of the week is Monday then I didn't go to restaurant and in pain
thing and and so so now let's define some test data they have weakness
Monday now if I want to define Friday as day a week then I have to
specify the parts of this case class or the fields with names now
here's what I'm doing is like this and now I have defined the value
of type day of week I can still print it and then I want to define
a function that will tell me how much I paid on a given day of the
week now notice on those days I didn't pay anything on only a Friday
okay because I go out so this function will return an option double
and this option will be none or empty option for all the days except
Friday because there is nothing to be paid and on Friday I will return
this amount notice this is cleaner than returning zero for other days
I could return just double here instead of option double and I hope
with a subsidy a zero on those days but this is cleaner what if somehow
the amount paid was zero for some reason let's say I went to restaurant
and I had a coupon and I didn't have to pay anything I was free so
my amount paid was actually zero but I did go to a restaurant so that
information is not lost if I'm returning option double and if if I
give Friday's day of the week I will get a non-empty option with a
value of type double inside it and that value could be zero or anything
else I don't use any special values to denote the absence of amount
paid the type denotes it's the option type that's why it's so useful
that's why it's used so much in the library let's implement this function
again we do ng match and again I'm going to fill in and see what it
tells me oh great this is because I have two different case classes
and case objects and traits defined and with the same name in the
same file so IntelliJ is a bit confused I have defined them in the
scope of this test so they are completely safe and invisible in the
other test but IntelliJ is not able to see that okay I'm just going
to correct this by hand not a lot on work alright and Friday and Saturday
are actually correct now all right so now if I'm on Friday case then
I need to return some amount paid so sum is the constructor for the
domain of option that is not empty so I call this a constructor because
this looks like I'm calling a function which is called sum on a value
so it's like a constructor and the word constructor will be used and
quite frequently there's a type constructor and there is a value constructor
let's talk about how to implement this function will discuss the Constructors
later alright so in all other cases I have to return none so I have
to return none here here okay I'm bored I don't want to write on this
code so I say first case is return this and in every other case I
don't know what that is I don't I don't need to know I returned on
this is how I want to write it and also here this declaration is never
used I'm going to put underscore so now this is how I would run the
code also run this symbol to be nicer so I have a special intelligent
shortcut to insert this symbol and the symbol is exactly the same
as this combination so there's no difference it's just pure aesthetics
I like this symbol this is the way to write this kind of code and
it clearly says here's a disjunct into disjunctive domain which we
match and specify different possibilities one possibility is that
it's a Friday so sub domain of the disjunctive that is labeled as
Friday with these two values in it and then I return that otherwise
for any other domain I return them so let's run this test and see
what it prints because we printed here Monday and Friday right so
here's what it prints interesting a is Monday B is Friday of McDonald's
and 23.14 so this is the way scallop Prince case classes this is the
default way to print case classes so you don't have to write code
for your own printing function or to string function the function
to string is already defined in a reasonable way it may not be what
you want to Princeton your users but for debugging - this is pretty
good let us continue the next example is to define a disjunctive type
roots of quadratic it represents real valued roots of the equation
x squared plus bx plus c equals 0 for arbitrary real B\&C and there
are three cases no real roots two real equal roots two unequal real
roots notice I make this quadratic equation non degenerate so that
it always has the term x squared if I said ax squared plus BX plus
C there could be a case when a is zero and then we'll have a linear
equation so in this particular example I chose it to be like this
for simplicity and then we want to implement a solve function solve
to or solve quadratic which takes a tuple of two coefficients B and
C and returns the this value of this disjunctive type which is a roots
whatever situation of this it returns that value and that value represents
a disjunctive of these three cases no real roots 2 equals 2 M equals
and conceptional conceptually this is easy to think about you call
this function you get the value and then you can imagine it and see
what the situation is if you feel like it how do we implement that
let's take a look so I define sealed straight roots of quadratic final
case object no real roots extends the roots of quadratic so I say
again all this all this final extends and sealed trait these are scholar
keywords this is kind of verbose but you just only write this once
for every disjunctive and you never look at this more than once so
that's to me that's acceptable although I would prefer for example
that everything is sealed by default and everything else gives me
everything is final by default but I would prefer that that I don't
have to say final all the time but it's okay it's not so bad for the
value it gives us is that we can represent arbitrary disjunctives
of types when this case case classes and other types so there are
three domains in the disjunctive as we were over told no real roots
and that has no values obviously no roots so we say this is an empty
tuple and that is represented by a case object also this case object
doesn't have to be a new keyword in principle so but that's what scholar
requires just remember that this needs to be everything like that
second domain is when the roots are equal then there is only one number
to store and that number is X and so the third domain is when there
are two unequal roots and when there are two numbers to store all
right so we have defined a disjunctive type and now we define a function
solve - it takes a tuple of its coefficients a B and C and returns
the roots of quadratic so how does it work I always say we I chose
this syntax just to be a little the pure side of things you know value
I could say this is a well functions are values right so I could say
this is a well since I don't have any type parameters here I can do
it well if I had type parameters I would need to do a death alright
as I say here okay so there's a Val the function takes a tuple of
double double as its argument so what will define this function we
say in case BC we we do a case because this is the way to use tuples
as arguments in Scala so this is a syntax if I don't say case not
sure it will be healthy so you see this function has only one argument
this one argument has of it has type tuple of double double and so
that's why I need to do a match on that one argument so I already
need a match right right here okay so here's what I do my B and C
are these two coefficients so I determine the discriminant and if
it's greater than 0 then I have two different roots which are given
by this well-known formula and then so I just for clarity I define
names x1 and x2 temporarily and return to roots X 1 St here if discriminant
is zero I don't need to define any names temporarily it's too easy
to not say just equal root of minus B over 200k in here I could also
put these two expressions directly into the constructor of two roots
case class but this is more clear in this clearer in this in this
way finally if the discriminant is negative there are no real notes
so in this way I return a value of this type I construct this value
as an element of one of the three possible domains each domain having
its own values in there so this is a disjunctive of empty to pull
to pull of one and tuple of two but I put names on them so now it's
much more readable it's clear what I'm doing and easy to check for
mistakes so let's now check that this works so here's what I do i
define a sequence of tuples just so that i can check at once {[}Music{]}
all these equations so this is the equation x squared minus 2x plus
1 equals 0 so this equation has a double root X equal 1 obviously
now this equation is x squared plus X plus 1 equals 0 and it has no
reloads its roots are complex this equation is x squared minus X still
to come zero it has two real roots different two different railroads
so in this way I check all three possible domains and all three possible
cases and so I have a sequence of these three two bulls and I map
over the sequence with the functions of two which takes a tuple and
returns roots of connecticut the result is a sequence of roots of
contradict so then I check that the sequence is equal to what I expect
the first one has roots only one root x equals one the second one
has no real roots a third one has two different real roots so that's
test passes and it shows that we have implemented our function correctly
now notice that this function returns a value doesn't bail out or
generate errors it always returns a value this value has three different
domains in some domain there's no result another domain there's some
result so this is the way to have deal with complicated logic and
complicating domains in functional programming your model is domain
with types so you make a type that represents everything you want
to say as much as possible and then you write code with it so you
see it's quite easy to write code with this there are no special values
there is no flag boolean flag that would be true or false when you
have roots or you don't have words you don't do any of this it's much
more visual and clear when your code exactly says what's happening
there are no hidden flags hidden special values this is the advantage
of using disjunctive types actually this is one of the main advantages
over using some other methods of representing complicated data next
example is that we want to define a function called route average
which is from roots of quadratic in to option double that computes
the average value of all real roots returning none if the average
is undefined so it means if there's no roots that we return otherwise
we return the average problem so how do we implement this the test
is already written so for example route average of this should be
0 son 0 so it's option right so a non empty option has the form some
zero empty option has the firm none so these are the two domains of
the option and so you you have to always have to write the sum and
this none this is a bit verbose if you have a lot of those values
but you need to think about how to reduce the velocity but you always
have to write specific values like this if you have equal roots then
average is the same as this one value otherwise you get none so how
do you implement well you say roots and then you say generate case
closes I'm just lazy and then clearly if we are in this domain then
it's not here it is some X there the sum of x + y / - not that we're
done no way to make a mistake you see your boolean Flags - check nothing
no way to make a mistake very safe code finally what do we do now
we generate 100 random coefficients B and C and compute the mean of
Route average for all of them let's do that so first we make a function
get random that generates a random number so let's say between minus
1 and the one who generates a uniformly distributed random numbers
for simplicity and we prepare a sequence of coefficients by filling
100 random numbers now each get random will be a new number it is
actually good style in Scala to make these functions syntactically
different from values so that you see that this function actually
computes something new every time it's not just a value because I
could I could call this random could you name it and then if I don't
write these parentheses then it looks like a value it looks like it's
going to be the same every time but it's right now it's not a new
random number so to emphasize that the style convention often in Scala
is that you do the empty parenthesis just kind of a function of 0
arguments which you can also think of a function of an empty tuple
as an argument but in Scala is actually different you have functions
with zero arguments in Scala which are different from functions of
single argument that's an empty tuple Scala is a bit redundant in
this way and this is because it has to maintain compatibility with
Java but is never a big problem so the syntax helps if you use it
in a way that is suggestive so we make these coefficients we get a
sequence of random numbers and then we map over the sequence with
the functions of two that we implemented just previously the result
will be a sequence of this roots of quadratic that we have so each
element of the sequence could have different configuration of roots
in or roots at one or two rows and it's all in this type because this
is a disjunctive tab now we compute averages so solutions we map over
that sequence with root n rooster remember the function wrote average
takes roots of quadratic and returns option double so when we map
with this function over sequence of roots of quadratic we get a sequence
of option double each element being transformed now that's not what
we want though we now we want to compute average of the sequence but
it's a sequence of option double so some of them are none some of
them are not known how do we get all the ones that are not none to
take the average of them so I will show you several attempts to do
that in the first attempt is to filter the averages by retaining those
that are not null no not none so we do this with a filter with this
matching expression which is actually working but it still gives you
a sequence of option of double it does not eliminate the option type
and that's kind of bothersome so there are two ways in which you can
do it more easily and more safely one way is to use this flatten function
on sequence so it's a special case when you have so flattened usually
what it does is that you get from a sequence of sequences you get
the sequence so usually for example so usually the sequence of sequence
of T and you get from it sequence of T but also it works with sequence
of option of T and you get from it sequence of T so this usually what
flattens do is just flatten does is just every sequence here is concatenated
and you get one big sequence now if you think that option is like
a sequence of at most one element you can do the same operation you
can concatenate all those options that are not empty discard those
that are empty and you get a sequence so that's what flatten does
and that's exactly what we need to do here we have a sequence of optional
double and we need to discard those that are empty and get a sequence
of double as a result so that's what flattening does as another way
of achieving the same result is to use the collect function collect
function is quite useful because you can do partial function here
and match and transform things and transform types also so here I
transform type so this is an option type option of double and this
is double so I have transformed the type and the collect function
will check that this case actually matches and four empty options
it will not match and they will be discarded so that is how these
functions work very useful functions in this case flatten would be
my preferred option my preferred way of implementing it because it
is shorter and very clear I just want to discard all know all empty
options and that's what flatten does but if I have some more complicated
transformation discarding some elements while transforming others
and flatten is only defined for this special case sequence of option
for example flatten is not defined for an option of sequence or for
some others such things then I use collect so but anyway we can run
this test now and either result one or result two will compute exactly
the same thing {[}Music{]} let's see what is Prince for yeah interesting
some interesting number every root fine so this is our result the
final worked example for this tutorial is slightly different so far
we have been computing things now we want to implement a function
with a fully parametric type which is given like this what does this
function do it takes a tuple of two options and returns an option
of a tuple now actually I forgot the double parenthesis in this type
signature this must be double parenthesis and in my code I believe
it is like here a a function that takes a tuple you must have double
parenthesis because in scala the syntax is that the first pair of
parenthesis designates the arguments of the function so we can have
one or more arguments and each argument could be a tuple or not also
so if you have just one argument that's a tuple and you must do this
double parenthesis so I should have done it here too I will check
I will correct this in my slides let's look at the implementation
so I start with a test so if I had such a function of type two co-option
int option string let's say into option of tuple in string how would
I check that this works correctly for example if both options are
non-empty then I want to return a non-empty option of the of the pair
but if if just one of them is empty I cannot return the pair I cannot
have a pair because I don't have the other value and so I must return
none for the entire option of tuple so this is the only way that this
function can work and this test then checks that this is so so it
returns none in all cases except when both of these options are non
empty so here's the implementation one implementation of this function
what's reason about it to see how this implementation can be new right
well firstly we say they said these are the two arguments so let's
match on the first argument the matching of the argument has let me
delete this perhaps and write the code again by reasoning about what
needs to be done so obviously maybe a is a option of a sec maybe is
a empty option maybe not empty so maybe we have a name will be not
so we need to match to do the case closes I generate them so then
let me call this a just for clarity okay so now I have two cases either
a is non-empty or NES empty if it is empty I know what to do there
is nothing else to do except to return empty option of this type because
if I were to return non-empty option of this type I would have to
supply both a and B but I don't have B sorry I don't have a my a option
is empty there is no way for me to get an a value of type a because
I don't know what that type is I'm not given a value of type a and
I cannot create it from nothing so I must return none in case that
the option a is non-empty I have hope that maybe also B is present
so let's see if that is so we'll be dimensional let me again generate
cases so it calls value B all right so if B is present then I can
actually return a and B in the tuple so I'm supposed to return an
option of tuple and so I return non empty option some with tuple as
the value and here I again must return none there's no away so basically
my implementation is more or less fixed except that of course I could
return none here as well and the type would be still correct it will
be a very uninteresting implementation but always returns none whatever
the arguments and this the only interesting implementation is this
one now by interesting what I mean is if does not discard all the
information in the arguments it discards some sometimes some information
sometimes but it doesn't always discard everything so this implementation
is is non-trivial and it's the most information preserving one and
therefore the most interesting now this code actually it is correct
I have tests below that call my check function on this one so I can
check that this is correct but this is verbose all this match case
and then case none goes to none case Nando's no all of that is quite
verbose and if I wanted to modify logic here I would have to modify
a lot of things so remember that option is like sequences it has a
map function defined on it you have map method I use the word method
and function interchangeably not in scholar there is a difference
methods are those things defined with the syntax in a class and functions
are values of function type that cannot be used with this syntax again
this is a legacy of Java Java does not does not have functions at
all it only has methods so Scala must have methods too and yet scholar
wants to have functions function values so this is a compromise we
have both in Scala have methods and we have functions for the purposes
of functional programming methods are just like functions so I use
the words functions and methods interchangeably it's just that this
syntax must be different if map were a function not a method then
the syntax would be map both you may be a F something like that and
it's exactly similar map logically speaking has two arguments maybe
a and F but the syntax is that map is written in between with the
daughter actually there is an alternative syntax like this without
without Dalton without parentheses but I don't like that syntax so
much sometimes I use it but only when it is really in easy to read
and what's happening so let me remove this what I wanted to show it
is that this code is so common and it's exactly equivalent to this
code if you have the school that matches on the option so maybe a
this option some type and you imagine it and if it's not empty then
you return the non-empty option with some transformed value and if
it's empty or returned empty this is exactly the same as doing a map
on a collection if a collection is empty you return an empty collection
again and if it's not empty then you take each element and you transform
it with the function and then you return a collection having those
transformed elements an option being a collection with just one element
only needs one such transformation to be performed at most and so
this code is exactly the same as this code so let's take that code
and simplify it instead of maybe be match we just have now we can
write let me write this as a comment so this actually let me let me
copy the entire piece that I'm going to simplify and do it step by
step looking at this template here so whenever I have this pattern
sum of X going to sum of f of X not going to none I just do a map
so I have this pattern right here maybe be not just like that so instead
of this I say maybe B dot map and then the function is from B to the
tuple a B and that takes care of this thing so now the code is much
shorter it has this shape and it's but it still has the same pattern
match son to their son and or to option none - none so let's do maybe
a dot map and then a going to this so the entire code was replaced
by this does it actually work so let's go and see what happens with
this implementation which I called f2 well where I wrote what we just
saw maybe a dot map it's going to maybe be that map why going to tuple
x1 exactly what we ended up with you know after renaming of variables
let me remove that now actually it's not quite right because the type
of this thing is option of option of a b c this.type is option after
mapping we have an option and then this has a type a so we map X of
type a into an option of something and the result is going to be option
of option let me write a comment explaining how this happened I have
option of a then I do map with a function that goes from a to optional
B or action of tuple a B and the result is going to be C this a is
going to be replaced by this through the map function so result is
going to be the type option of option of a B and that's what IntelliJ
tells us if I delete this that's what it knows the type is so we need
to transform this to an ordinary option how do we transform well this
is the whole whole logic here if both of them are non empty only then
we'll get a non empty option at the end so that is what flatten does
a collection of empty collections gives you an empty collection after
flattening so we just use and that's it now that works so that's a
valid way of doing it but it's not the best because there's this pattern
which is map followed by flatten and this pattern also seems to be
very very often used and so in the standard library there is a method
called flat map which is the same as map followed by flatten and so
actually the code that you could write would be this now it is it
is questionable whether this code is easy to read or easier to read
than this I would actually say this code is a little easier to read
because of things in app and happened here's a flat map and map there
are other ways of making this much easier to read and to write which
I'll talk about later this is the for yield block notation but for
now it is important right all of these things by hand all of the maps
flat maps and so on and to follow the types follow to see how the
types are transformed IntelliJ sometimes gives you help here for example
I tell if I press command and then hover my mouse over symbols it
gives me some information about their types and definitions so it
tells me that for example this is an option of being this is a map
that takes a function and returns an of option of B and {[}Music{]}
these types are not always clear here what is this 8 to be for example
b2b I'm not sure what ageism not be is this oops this is certainly
a contrived example of such a function but is this type a please this
type B but actually this is not the types we're using we're using
option a and so on so IntelliJ is not always right when you do this
on the map but tell J is right when you do control shift p1 symbols
so that for example is always right what option B so to make a long
story short you need to start with code like this and then simplify
it and make it shorter and then gradually you will start thinking
in terms of these map flatmap and so on so that it is much easier
for you to think in terms of transformations on an option collection
and so on rather than transformations done on individual elements
it's very important to follow how types change so let me let me try
to rewrite this function in in a longer fashion here and this is what
you might do initially when you start learning about functional programming
code like this is very short it is not very readable so what you can
do is you can say first of all you can make these functions multiline
by putting curly braces around them and then you can introduce intermediate
values for example Wow C equals this and then you return C it's the
same right you call this value C and right away that is your expression
but now you can see what type it is so it's option LV and you do option
return like click on the keyboard to add the type annotation and so
it tells you that this is actually an option of a B that information
was not obvious here when you look at this code but you can make this
easier for me to understand so first maybe B has type option of B
you map it like this and it becomes option of a B maybe what's what's
rename this X into a and that's why into B so that it becomes easier
to read and then also here you are not sure what are you what your
return it but flat map tells you flat map takes a function from a
to option B returns option B well actually this is confusing because
your B is not therapy so there be here is defined in the standard
library somewhere it's not your B so the definition of flat map is
this there's some be here there's some a here it's not what you wanted
it's not your B and what your a so that is a bit confusion so let's
do the same trick here well result equals this return result and now
let's add a type annotation to this okay so now if you didn't do flat
map let's remove this type annotation and add it again you could do
control shift P to see what it is or you can just put it into the
code to document that you at this point you got a gallery of this
type so these transformations each of them will change the type of
values and it's nice to see what type it is to check that that's exactly
what you want now obviously we want an option of a B and not an option
option of a B so we need to flatten it so now let me see what that
is so in this way you can go step by step within each of these transformations
and see what types then generate and having if you have done this
enough times initially it will take time and you you have many steps
and at the end you will see it becomes easier so here are some more
exercises for you to work with disjoint disjunctive types case classes
and collections of them and implement some functions like like these
also with fully parametric types and so these functions are usually
obvious what is meant so for example option of a pair goes into a
pair of options obviously this option is empty then you must return
to empty options here and if this option is not empty then it makes
sense to return to non-empty options in order to maximize information
and similarly here for either if you have either of a B that could
be a and then you can return here and non-empty optional a but you
must return empty option of B and vice versa in order to not lose
information and in this example also if you have either a either B
C so for example you could have a and then what they return while
you return the left version of either and the left version of this
either with a inside so in this way you can always see what kind of
value it makes sense to return in order to not lose information good
luck with these exercises 
\end{comment}


\subsection{Disjunctive types in other programming languages}

Disjunctive types (and the associated pattern matching) turns out
to be one of the defining features of functional programming languages.
Programming languages that were not designed for functional programming
do not support this feature, while ML, OCaml, Haskell, F\#, Scala,
Swift, Elm, and PureScript support disjunctive types as part of the
language design. 

It is remarkable that the tuple types (or ``records'') are present
in almost every programming language, while disjunctive types are
absent except in languages specifically designed for the functional
programming paradigm.
