
\chapter{The formal logic of types. I. Disjunctive types}

\section{Discussion}

\begin{comment}
 I will talk about disjunction types to introduce that topic I will
have to talk about these classes in Scala this is a feature of Scala
that is also present in most other programming languages but uninstaller
there cold case classes and this can be understood by recalling the
tuple so recall we have tuple types that look like this tuple types
such as this one represents a pair values or generally a certain fixed
set of values of different types possibly now in this notation there
are no names associated with these values or with this entire type
and for convenience we can define names both for the type and for
each of the values each of the parts of the tuple we can define a
name now this is convenient to remind ourselves what is the reason
we are introducing this tuple what are the meanings of each part so
here's an example we can say this is a name of the type my pair we
could say that and then we would do this but this doesn't give us
a lot because my pair would not be different from any other tuple
of int and string maybe with very different interpretation for example
here's a much better way of defining to polis names which in Scala
is called a case class but it's just a tuple with names we put a name
on the tuple itself and on each part so it's still quite the same
as a tuple of double and string but now it is not confused with they're
tuples of the balloon string so for example if I have in some other
part of my code I have a tuple of double and string it represents
the amount I paid and the name of the person I paid to and here it
represents my socks so if I did both of this with a tuple of double
and string then by mistake I could have mixed it up and instead of
using socks I would have used the amount paid which would be a total
disaster because it will in in the in the code that it looks just
like a tuple so we don't know where it came from and introducing this
type with these names helps to prevent this problem so once we wrote
this line this line here this defines a name for the entire tuple
type it defines a new type called my socks and it also defines names
for the two parts of the tuple and once I have defined this I can
use this definition later in the code by writing things like this
I introduced it here a value of type my socks and the value is equal
to this so I can write it like this and the type annotation here is
optional it is not necessary to write it actually in my code I usually
don't write it because it's already obvious it's of type my socks
it is a value whose type is named right here so there is no need to
repeat it next to it so I typed it here for clarity only now case
classes can use other case classes as types of their parts as we have
seen before you could have tuples whose parts are themselves also
tuples so here you can have a definition like this bag of socks is
representing a certain number of identical sock so I'll use this type
I defined here by name so I don't have to say that this is double
pair of double string I just say this is my socks I use the type by
name and here I would say well bag equals bag of socks and then I
would say well the first part I would have to give an any second part
so it's just like a tuple except with name so I have to say you see
if you cross this out if you cross out the names then it won't be
just like a tuple with a nested tuple but this in this way you prevent
a possible errors so it will not let you write a tuple here it says
it's wrong type so in this way I define values of these types which
are called case classes but what they actually mean is named tuples
once you have defined this you can access each part by name and that's
also very convenient I mean remember that with tuples you have to
access parts of them by index so this is number one this is number
two you have to remember you have to remember which which one has
which number and if you want to change this let's say with socks I
want to also say when I bought them with a date so I add another field
here so now I have to remember which one is number one number two
with case classes their names so you access by name you just say bag
dot socks which gives you this and that dot color which gives you
this so then C will be of type string and it will have the value white
now now as before this type annotation is not necessary now another
convenience that Scala provides with its type its case questions is
that the parts of case classes can be specified in any order as long
as you use names if you don't use name you have to do it in this order
otherwise you can do it in any order so if you say to me so here's
an example where I define my socks first specifying the color and
then the size final convenience is that I can specify the default
values for parts and then I for example by default almost shirts are
blue and by default none of them have holes so I define this case
class shirt with two parts which is string and boolean in the first
part is called color and second is called has holes and I gender I
specify default values for both so when I generate values of this
I don't have to specify all fields I can just specify some of them
and the other fields will be generated automatically using the default
values so these are just the features of Scala that make tuples more
convenient and this is the first time I mentioned case classes however
not the last time so here's a comparison of tuples and case classes
in a more systematic way so actually in Scala tuples are just syntax
for this kind of type with two type parameters and this is actually
like a case class so I will give you this table to look at so on the
left are tuples and right there the case classes that have the same
values inside the same types of values inside but with names and there
are very they're different types so you could not in the same program
you could not put this instead of that or vice versa it's just impossible
won't compile so case classes are safe in this sense a case class
that has no parts exists - it's called a case object which is useful
in certain cases so tuples with one element or tuples with zero element
exist in Scala a tuple with zero element is not called two plus zero
is called the unit tuple with one element looks like this it's called
tuple one to pull with two elements looks like this is called tuple
- certainly I don't yet know why I would use this maybe there are
some situations when this is helpful but I just wanted to call your
attention to the system here so everything is systematic so you can
have two pools with zero elements tuples with one element tuple with
two element ins - almonds and so on and corresponding to that if you
want to put names of these tuples what do you do well you put names
so for a tuple with zero elements you put a name on it which is this
and let's call the case object so these are keywords of Scala that
you need to use if you want to put a name on an empty tuple if you
want to put a name on a tuple with one element that's what you do
it's a case class with one part this is already quite useful you you
distinguish this from other kinds of values and this is a case class
with two parts so case classes can have also type parameters as type
so type parameters on a case class means that for each value of this
type variable which could be any type like integer or boolean string
any other case class or anything function it can be any type for any
of these values of a type variable a and values of type variable B
you have a tuple with names and the names are here left right and
count and the first part is of type a in a second of type B and the
third is of type int so the third type is always the same but the
first and the second types could be different whenever you use this
case class you can use it with different types and so obviously you
could define the tuple types like this like tuple to with two type
parameters and names underscore one and underscore two and then the
syntax would be value dot underscore one that will give you the first
value and this value dot underscore two will give you the second value
which is just like this syntax so you say value value dot name and
that gives you the part of the tuple and so here you you'll do the
same so this is the syntax we saw before which will take parts of
a tuple but this is the system so this could be considered as case
class defined like this so for case classes there is another major
convenience which is this pattern matching syntax so before we have
seen pattern matching syntax for tuples a very similar one exists
for case classes you just specify the name of the case class and that's
otherwise the same syntax as with tuples so again if you cross out
the names then you have the same syntax as we had before when we did
pattern matching on tuples so there are two cases where Scala will
do pattern matching one is the value assignment well and then you
can do a pattern and then equal something the second is the partial
function where you have the case expression on the left hand side
of the case expression is a pattern so here are some examples so for
example let's say a is my socks and then I want to get both the size
and the color of my socks so I can write a definition like this and
where I define x and y at the same time using the pattern matching
so before you could do this with tuples as well then you don't specify
the name because tuples have no names in this syntax but a case classes
can be understood as named tuples so then you specify the name and
if a is anything else not of this type then this won't compile this
won't compile the second example is a partial function so suppose
we define this function f which comes from goes from bag of socks
to integer and computes doesn't matter what let's say total price
for what not not not total price let's say {[}Music{]} i total price
we cannot compute because I didn't have any prices in my data but
if I had them and I could compute something so imagine we have this
function that computes something useful and then how do we define
this function well we need some kind of match so we need to get values
out of socks so one way would be to just do the access by name another
name another way is to define it by patronage and then you define
all names at once and this is convenient and this is another syntax
where you define functions on case class with an argument written
on the left see there are these alternative syntax you can write it
like this or I can really pointless and then there's the syntax be
match and then you write as a partial function so like make sure you
you realize that is SC and Z are new variables that are defined only
in this scope they are not defined outside of this block so these
are called pattern variables and the case expression introduces on
the left hand side new pattern variables that are not the same as
anything you had before so remember the shadowing of pattern variables
if here I have value a I already defined I could here have also a
as pattern variable it will be a completely different variable of
different type just by coincidence called a inside this scope only
so it is a good style not too use these names and use different names
but even if you use the same names here and here it will still work
this variable will only exist in the scope and that variable will
be unaccessible and only shadowed so now let's look at disjunction
types the motivation for having disjunction types is that sometimes
we or we have situations when data comes in these different shapes
and can be several different data in one kind of container so for
example if you are asking water what are the roots of a quadratic
equation then the answer is it could have two roots or you could have
one root which means two coincident roots and if you are asking for
real roots now it could have no real roots so if we're interested
in real roots under three cases and it's convenient if we can introduce
a type that means the roots of the real roots of quadratic equation
and inside this type we have this distinction but outside is just
one type so that it's easier to write expressions with it functions
and so on another example suppose you run a binary search and look
for a value now you might find the value or you might not find it
so it is convenient if you could return something that could be a
value in the index or absence of value on the index be convenient
if you could return this as some kind of type {[}Music{]} another
example is you can have computations that may generate an error and
fail to make any any value fail to return the value or they can return
the value and the error could be different so you could you want to
have a message about what error occurred so then it's convenient to
return the type which is either a value or an error so it's kind of
an either-or situation or a disjunction in the mathematical language
another example is the computer games in computer games usually you
have states that there can be can be different for example you can
be in some room of different kind and different kinds of rooms have
different properties for example Rome could he could be a dangerous
or not or have a lot of stuff for have some adversaries and you want
to represent all different kinds of rooms all different kinds of players
uniformly so that you don't don't worry about the values that you
have to store and each kind of room or each kind of player could have
different sets of properties so for example a player who is an adversary
or a player who is just static and and gives you information but otherwise
doesn't participate in anything we have different sets of properties
and so it would be good to come to to say this is a player so the
dream is a type which is a player and then a player would be either
one kind of player or another kind of player so automatically you
want to imprison to say for a quadratic equation you would say it's
a pair of complex numbers or is a complex number well in this case
I wanted to do real not complex because with complex you always have
at least one you cannot have empty well actually you could have empty
if your quadratic equation is degenerate for example 0 times x equals
1 that has no solutions and you could you know 0 times x squared plus
0 times X plus 1 equals 0 that has no solution so you could have that
situation to then in an example of binary search you want to find
a value and an index so you're returning a pair or you found nothing
so you return empty so empty tuple now of course you see it's not
nice that I returned just int int I have no idea which one is which
so it would be helpful if I put names on them so I put names on each
part so this would be found value and this will be found index or
something I could do that with a case class as I just showed the third
example is a computation gives you either a value or a string and
this fourth example is basically case class so each room or player
would be represented by a case class with many properties but different
kinds of players or rooms will have different sets of properties so
you want to have a number of case classes together in the disjunction
basically either one case class or another case passport and third
case class that's what you want that's the kind of type you want so
that's the disjunction type they are available in Scala and they represent
this kind of situations as types let us look a little at the mathematical
point of view usually the type means madam ethically that the function
has an arguments let's say f of X has an argument X the type of X
let's say X is a real number then the type of X represent the domain
of the function so now we would like to represent disjoint domains
so for example X is either a point on the line or as a point on the
surface completely different surface and from a line and so in mathematics
this is not often used but in functional programming it is used quite
a lot because it looks it appears that real life situations and tasks
require a lot of this coming of this disjoint domains I just gave
you examples on the previous slide so how would we do a disjoint domain
between line and surface let's say line is the real numbers and surfaces
are part two the real plane so in functional programming the way it's
done is that the domains are labeled so we introduce some fixed special
set of symbols with which are labels like left Android's say these
are just symbols that come from a fixed set of symbols and then we
first make two sets the first set will be a set of pairs where the
first element of the pair is the symbol left and the second element
of the pair is some real number so this set is a set of all such pairs
and this set is a set of all different pairs where the first element
is a symbol right and the second element is some point from a surface
from r2 and then make union of these two sets now this is a labeled
union because each set has this label and so there's no way that any
even if this were our and this were also our there will be no way
to confuse an element from the left part of the union and lanolin
from the right part of the Union and so the disjoint union is always
an exclusive or it's never inclusive or it could be couldn't be both
from here and from here because the symbols are different so given
any such X from this set from this entire set we can always determine
by looking at the first element of the pair from which side it comes
and we therefore can obtain and know what is the type of the corresponding
other value in each case so there is no confusion if we label the
two parts of the Union even if all these types are worth the same
with this where artists were also her will still be no confusion whereas
a ordinary mathematical Union you would be confused you would think
well our union ours just are so but disjoint Union is labeled and
allows you to always know from which part you come from that from
which parts the value comes so in Scala this kind of type is disjoint
Union or exclusive or between two domains it's denoted like this so
it's special library you find a special type defined in the library
called either it has two type parameters describing the two domains
the first let's say double that's a describing this and second is
a tuple of two doubles which describes the so this was a very close
analogy with a mathematical disjunction between the two domains and
as I just said domains in mathematics corresponds to types of variables
in programming in functions so types of variables is exactly the same
as a set from which the variable comes so like X comes from the set
of real numbers and here double is a type that approximately represents
real numbers and pattern matching is used to define expressions with
such types so let's look at examples with either so we were looking
before at a situation when we wanted to generate error messages with
computation and so let's suppose we have a function that needs to
return an integer but may actually have an error and so it turns this
type either of string and integer which is a disjunction between two
domains the first is the set of all strings the second is the set
of all integers and it is labeled by symbols left and right these
symbols also come from the skull a standard library now if we have
a function let's say log error we want to write this function that
takes an argument of this type how can we construct an expression
using this type and here's how we say X match this is keyword match
so say X match and then you write this partial function which matches
against possible values of X and there are two cases the left having
an error value which is of type string and the right having a result
value which is of type integer in both cases we can specify what needs
to be done or rather the expression that needs to be computed well
we can print of course but we need to return a value and this function
must return integer value so let's return some integer value or not
and then the result now this is just an example now how can we interpret
this code what does it mean case left error case right result it means
these are actually possible values of this type so this and this are
specific possible values of this type remember that we have this labeled
disjunction so this is a possible value with symbol left and a number
and so similarly here a symbol left which is the name of the case
class this is just a symbol it is not itself a value it's it does
not give you a value until you give it this the the string and so
left of blah is actually a value of type either string int and similarly
right of one two three is also a possible value of this type so in
this for in this code we enumerate the possible cases the disjunction
there are only two cases in this disjunction the left and the right
and so we enumerate them and each time we have a pattern variable
of a different type because if we are in the left case of disjunction
when the error is of string type this pattern variable we could have
called it X or Y or whatever it's just a pattern variable and it's
introduced right here and it only is visible within the scope of this
expression so here we cannot have access to error if you want to here
if I cannot make a mistake and try to access this error value when
actually I'm in the right disjunction in the second part of the disjunction
because the error is not defined in this Cobra that I am just showing
in the scope only the rest is defined so these case expressions have
limited scope so this expression from the first case until the second
it is one scope and within this scope the error variable is defined
outside it is not defined and similarly for this so if we call this
function on the value such as write 123 then this function will match
the first case will not match so then the second case will match and
the result will be returned so this will be the value it returns then
the match is performed line by line so if the first line that matches
gives you this expression and that's it not no further lines are evaluated
so log error of left bad result will match this because it matches
the symbol the left and then error will be the variable equal to the
value of it will be equal to bad result and so it'll print got error
bad result and then it will return -1 so case X Russians that choose
among possible values of a given type when this type is a disjunction
and here is another way of using case expressions with types that
don't look like a disjunction like int where you say if so I say X
which is an argument of this function X match and then I enumerate
certain cases 0 1 and then all other cases so if if 0 does not match
if one does not match then this case this line will be evaluated and
then this pattern matches everything is just a variable so this rest
will be equal to this X since we matched it and so then the same X
will be returned so you could think about integers as a type that
has different values like 0 1 and others there are possible values
of this type and so you could use case expression also for those so
case expression is not limited to disjunction types or case classes
integer is not defined as a disjunction type because it has long parts
of disjunction but it has different values and so just to know to
the similarity between this code and this code the case expressions
in the partial function enumerate possible values of the function
and so here also I'm not limited to just writing two cases lines here
case left error case rightness I could write anything I want like
for example case left and then empty string instead of error here
and that will only match when X has that value left of empty string
then on the next line I could say case left of something else and
won't match only when X is net this is just to what you know that
the case expressions are more powerful than just matching the two
parts of a disjunction they're matching anything these patterns can
have many conditions and this can be complicated so either is a example
of disjunction but there are more general disjunctions like for example
well if I want to have a disjunction between three different domains
do I have to do either of either so that is not convenient now in
in principle what I want is something like this I want to just say
this type or this type or let's say this type or this type or this
type this is a disjunction I want to be able to define these junctions
like this but Scala does not have this syntax there are some libraries
like these libraries that provide syntax similar to this one but I
don't want to go into these libraries that are more advanced right
now I want to use the standard syntax in Scala which is sufficient
for most purposes in the more ordinary applications of functional
programming which is most of its applications today later I won't
talk about those libraries and see what they offer but for now let's
use the long syntax which is available in Scala and this is the syntax
okay this is quite long to represent what I would ideally write like
this if I if I compare this with that my type is a name of the type
the type has disjunction of three domains the first domain is a list
of integers so the first domain here has a name all domains must have
a name in the disjunction is a label so here in this context the name
would be implicit something like underscore one or something but in
this syntax in the long syntax the domain has to be explicit so your
name is have list int it has one part so it's a tuple of one with
name have list int and the part is named X let's say then I have to
write this keyword extends my type and in this way I say that this
case class is part of a disjunction which I'm going to define now
so my type is the name of the entire disjunction and these are the
names of its three parts the labels and these are the names of the
tuple parts so each domain is a tuple with names case class as I explained
is a tuple with names so this disjunction has two lists the names
for everything for every part of the disjunction and for every part
of each tuple finally these keywords sealed final case class trait
these keywords are necessary in Scala and what they do is they make
sure that you cannot by mistake change this disjunction later because
that would be a difficult bug that some other part of the program
changes this disjunction and then adds some more stuff to it let's
see some other domain and then your case matches stop working because
you don't know that somebody added domains you have your case State
case expressions like this pattern matching and you expect three domains
in your disjunction so you write it like this but somebody adds a
different domain and this stops working this will crash if if that
word if that happens so to prevent that you say that my trait called
my type is sealed so no so only the ones the the domains of the disjunction
that are listed next to it in the file well not necessarily next day
but in the same file only those exist and no others may be defined
later at any time similarly the case passes are final so they cannot
be extended later as the result the syntax is quite long you have
to write a lot of stuff just to express this kind of disjunction of
three domains but you write it only once and using it is quite short
is not so bad at all so for example first I create a value of this
type so this could be a result of some computation with conditions
if some condition holds then the values have socks with some socks
values and otherwise it's have list int with some list int value so
this is computed and then somebody wants to find out what that X was
and they don't know this could be in a different part of the code
and this could be even in a different library and so you have to match
on the three domains of the disjunction that's how you write it you
put pattern variables in the case classes so these nine names don't
have to be the same as these they can be for convenience but they
don't have to be I'm just specifically selecting all different names
just to show you that these are arbitrary names they don't have to
be the same and then you write expressions here that will be evaluated
in each of these cases and this expression for example is allowed
to use this LST but not this and all that because the scope is is
limited so the scope of definition of this LST is only this expression
the scope of definition of pmq is only this expression if you try
to use P and Q here the compiler would say cannot find symbol or something
like that if very often used disjunction type is called option here
is how I would implement option in a very simple way it has a disjunction
of two domains one domain is a tuple with one element of type T or
T is a type parameter and the second domain is a tuple of zero elements
or unit type which is represented as a case object this is just a
keyword in skeleton doesn't really mean anything different from a
tuple with no elements or a unit type and you notice here it extends
option with type parameter nothing nothing is a special type that
has no values at all so this is used to signal that this is an empty
tuple it does not have any values inside so we cannot use any type
for parameter here but we must specify the parameter so we use this
special type nothing all of this is defined in the standard library
of skeleton nothing option some none so some and none are the two
labels on the two domains of the disjunction now in order to use it
you do pattern match for instance like this here's a function that
performs safe divided divides X by Y but your turns an option of double
and so option list is a disjunction and option parameterize by the
type double is a disjunction of of either double or nothing so no
value rather unit is the type or empty tuple if you prefer is a type
that does not carry any value of type double in it and so here's how
you define a function that computes this it checks the condition and
if Y is 0 you return none which is this label otherwise you return
value X divided by Y labeled by the name and a single Sun now the
symbol is a label on the second part or here on the first part of
the disjunction and here's how I would use it so I would say safe
divide one divided by Q maybe Q is zero maybe not but I then match
so this returns an option of double I match the option with two cases
some X and none so these are the two parts of the disjunction and
I mention them and so if I have some X then I multiply that some whatever
previous result by that X and otherwise I returned previous result
so this is a kind of a default value that I return when I don't get
anything out of this function this function returns none which is
a valid result of type option double mini Scala library functions
return an option type such as find returns so find looks in a collection
and returns an option if it found then it returns some of the value
and if it did not find it returns none had option is the first element
of the collection but if it's an empty sequence there is no head element
no first element so it returns none otherwise it returns some with
the value of the first element and similarly these primary functions
which you can look up in the library or in IntelliJ these functions
return option and the final note is that option has many functions
or methods defined on it in a sense option is like a collection it's
like sequence of tea so option of tea is very much like sequence of
tea in terms of what you can do with it you can see with sequins you
cannot do this match because sequence is not a disjunction between
nan and Sun but sequence has map flatmap filter exists and so on all
of this is also defined on an option and you can understand this in
a simple way if you imagine that the sequence is like a container
and that sequence of tea is like a container where or let's say array
of teas and another kind of sequence it's like a container where you
have 0 or more elements of type T so this container holds values of
type T it can can hold no values empty array or empty sequence or
it could hold one value or two values and so on option is like a container
that can only hold 0 or 1 values of this type T it cannot hold two
so it's like a very limited sequence the sequence that can only be
of length 0 or 1 otherwise it looks like a sequence so it has a map
a function flat map filter and so on so what for example it's a map
on an option I will show you when we go through the worked examples
how that works map on the collection let's say on array of integers
you can do a map with a function that maps integers to strings say
in some way and then you map and you get an array of strings where
each element is transformed by that function option will behave in
a very similar way you do a map with an option and every element in
an option will be transformed using the function you specify however
option can only contain at most one element so it can be empty which
is this disjunction part or it can be non-empty containing one element
of type T one value of type T so it's kind of a very limited simple-minded
collection but otherwise it's similar to collection we will see how
that works in the examples so with the tools we just learned what
problems can we solve we can represent values from disjoint sets or
domains as a single type and we can use these values to define functions
on them or functions producing them and use also these values in collections
as elements of collections or in any other way we can these are types
so there's no restriction on how you can use them so let's go through
some examples now the first example is to define a disjunction type
day of week it represents the seven days of the week let me go to
this example so here's what it would look like so all these keywords
here in IntelliJ you see in bold blue dark blue seal the trade final
case object.extend so these are keywords of Scala and everything else
is our labels that we introduced so day of week is the name of this
entire type the entire disjunction type it has seven domains and these
domains don't carry any values so these are just empty tuples and
the syntax for them is to say case object and then you don't you don't
write this this is a mistake you should know right that empty tuple
empty tuple is written like this indeed but you don't have to write
it here so the syntax is such that you don't write it left so when
you put a name on an empty tuple then it's called a case object and
then you don't write parenthesis so here's how we define the type
how will we use the type like this will define values a and B let's
say of this type and assign these values so we define Monday and Saturday
just like this we don't have to do anything else we don't have to
say new new Monday there's no numa there's only one Monday because
that's a label of the domain and a disjunction is no no sense in that
to say new Monday cannot have different Monday's they're all the same
it's a label on the disjunction now if I don't do this and just say
well a eCos Monday then Scala will actually not know that I want a
to be of this type color we'll think but it has typed Monday type
so monday dot type is just ask our feature that I'm not going to use
right now it is a more advanced feature so with these disjunction
types it is a good idea to write type annotations Scala it can be
too smart about what I want to do and so it is better if I do this
but it would not be an error if I did it that way if I put just any
without type annotation probably my code was to work just some types
will become weird now suppose I want to print now how to print this
well actually case classes and case objects already have a two-string
method defined on them so I can just print like this with string interpolation
and this will run and I will get the string printed after we implement
the function so that this test can pass so how do we implement this
function this function is supposed to give us a boolean which is true
when the day of the week of Saturday and false otherwise so we do
this by pattern matching since the type is a disjunction so we need
to match on the label of the disjunction or in the scala language
we match on the case class or case object so we say Dean match and
then you see there's this red case close as expected sure and then
there's this thing which I can click it says generate case closes
for variants of sealed type now in the scholarly in which this means
this was a sealed trait that I defined and it has seven variants or
disjoint domains in my understanding and so if I click this IntelliJ
will fill in the code actually not sure why is doing it like this
because it's from from another from from another example I guess it's
a bit confused but it allowed me to delete what was not necessary
so it generated most of the code so now I need to put the expressions
that I'm going to return in each case so if this day is Saturday I
need to return true otherwise I need to return false now there's a
lot of I could say false false a lot of work like this so I'm going
to be more clever and I'm going to do this and when it puts Saturday
first and then if there is anything else I'm going to return false
so let's say playing this so in this way I'm expressing my intention
much more clearly so Saturday true I do otherwise anything else false
so there's one little thing so this will work but we can run this
test and this will work there's one little detail here so green notice
what is printed E is Monday B is Saturday so this is the string that
I printed here with interpolation so a was Monday and it can be it's
already printable so this is a convenience that scholar gives now
the little detail I was talking about is that intelligence says Declaration
is never used so I declared the variable X but I never actually used
it there's a syntax which looks like this it needs to be used in this
case to make it more clear like I said this still works this is not
a mistake to do a variable that you don't have to use a variable here
and never actually included anywhere so to left it unused it's not
a mistake but it is a little misleading because you're introducing
a variable and so I'm looking for its use maybe I don't find one so
this syntax means it's a very that matches anything just like X no
conditions and on it variable watches anything and I don't need its
name I'm not going to use that variable so the underscore in this
situation means that it's a pattern variable that I'm not going to
use so I don't need its name and it matches everything and my tests
are that a and B so a was Monday B was Saturday they they pass let's
go to the second example {[}Music{]} modified day a week so that the
values additionally represent a restaurant name and total amount for
Friday's and a wake-up time on Saturdays so what does it mean I want
additional values on list on this disjunction on on the domains in
the disjunction I want these domains to be not just empty tuples as
I did before here but for Friday I want a domain that represents a
string which is restaurant name and an amount paid so here's what
I do i make Friday and Saturday case classes instead of case objects
and then I am free to add parts in there with different types so field
called restaurant name and type string and its own so I can do that
and similarly for Saturday now I think I made I haven't finished this
so this is supposed to be wake up time so I think I want to do a local
date time from the Javadoc time library and that's a wake up time
so this is it so basically I have easily added more data but only
for these two days so these they still have no no data so if if the
day of the week is Monday then I didn't go to restaurant and in pain
thing and and so so now let's define some test data they have weakness
Monday now if I want to define Friday as day a week then I have to
specify the parts of this case class or the fields with names now
here's what I'm doing is like this and now I have defined the value
of type day of week I can still print it and then I want to define
a function that will tell me how much I paid on a given day of the
week now notice on those days I didn't pay anything on only a Friday
okay because I go out so this function will return an option double
and this option will be none or empty option for all the days except
Friday because there is nothing to be paid and on Friday I will return
this amount notice this is cleaner than returning zero for other days
I could return just double here instead of option double and I hope
with a subsidy a zero on those days but this is cleaner what if somehow
the amount paid was zero for some reason let's say I went to restaurant
and I had a coupon and I didn't have to pay anything I was free so
my amount paid was actually zero but I did go to a restaurant so that
information is not lost if I'm returning option double and if if I
give Friday's day of the week I will get a non-empty option with a
value of type double inside it and that value could be zero or anything
else I don't use any special values to denote the absence of amount
paid the type denotes it's the option type that's why it's so useful
that's why it's used so much in the library let's implement this function
again we do ng match and again I'm going to fill in and see what it
tells me oh great this is because I have two different case classes
and case objects and traits defined and with the same name in the
same file so IntelliJ is a bit confused I have defined them in the
scope of this test so they are completely safe and invisible in the
other test but IntelliJ is not able to see that okay I'm just going
to correct this by hand not a lot on work alright and Friday and Saturday
are actually correct now all right so now if I'm on Friday case then
I need to return some amount paid so sum is the constructor for the
domain of option that is not empty so I call this a constructor because
this looks like I'm calling a function which is called sum on a value
so it's like a constructor and the word constructor will be used and
quite frequently there's a type constructor and there is a value constructor
let's talk about how to implement this function will discuss the Constructors
later alright so in all other cases I have to return none so I have
to return none here here okay I'm bored I don't want to write on this
code so I say first case is return this and in every other case I
don't know what that is I don't I don't need to know I returned on
this is how I want to write it and also here this declaration is never
used I'm going to put underscore so now this is how I would run the
code also run this symbol to be nicer so I have a special intelligent
shortcut to insert this symbol and the symbol is exactly the same
as this combination so there's no difference it's just pure aesthetics
I like this symbol this is the way to write this kind of code and
it clearly says here's a disjunct into disjunctive domain which we
match and specify different possibilities one possibility is that
it's a Friday so sub domain of the disjunction that is labeled as
Friday with these two values in it and then I return that otherwise
for any other domain I return them so let's run this test and see
what it prints because we printed here Monday and Friday right so
here's what it prints interesting a is Monday B is Friday of McDonald's
and 23.14 so this is the way scallop Prince case classes this is the
default way to print case classes so you don't have to write code
for your own printing function or to string function the function
to string is already defined in a reasonable way it may not be what
you want to Princeton your users but for debugging - this is pretty
good let us continue the next example is to define a disjunction type
roots of quadratic it represents real valued roots of the equation
x squared plus bx plus c equals 0 for arbitrary real B\&C and there
are three cases no real roots two real equal roots two unequal real
roots notice I make this quadratic equation non degenerate so that
it always has the term x squared if I said ax squared plus BX plus
C there could be a case when a is zero and then we'll have a linear
equation so in this particular example I chose it to be like this
for simplicity and then we want to implement a solve function solve
to or solve quadratic which takes a tuple of two coefficients B and
C and returns the this value of this disjunction type which is a roots
whatever situation of this it returns that value and that value represents
a disjunction of these three cases no real roots 2 equals 2 M equals
and conceptional conceptually this is easy to think about you call
this function you get the value and then you can imagine it and see
what the situation is if you feel like it how do we implement that
let's take a look so I define sealed straight roots of quadratic final
case object no real roots extends the roots of quadratic so I say
again all this all this final extends and sealed trait these are scholar
keywords this is kind of verbose but you just only write this once
for every disjunction and you never look at this more than once so
that's to me that's acceptable although I would prefer for example
that everything is sealed by default and everything else gives me
everything is final by default but I would prefer that that I don't
have to say final all the time but it's okay it's not so bad for the
value it gives us is that we can represent arbitrary disjunctions
of types when this case case classes and other types so there are
three domains in the disjunction as we were over told no real roots
and that has no values obviously no roots so we say this is an empty
tuple and that is represented by a case object also this case object
doesn't have to be a new keyword in principle so but that's what scholar
requires just remember that this needs to be everything like that
second domain is when the roots are equal then there is only one number
to store and that number is X and so the third domain is when there
are two unequal roots and when there are two numbers to store all
right so we have defined a disjunction type and now we define a function
solve - it takes a tuple of its coefficients a B and C and returns
the roots of quadratic so how does it work I always say we I chose
this syntax just to be a little the pure side of things you know value
I could say this is a well functions are values right so I could say
this is a well since I don't have any type parameters here I can do
it well if I had type parameters I would need to do a death alright
as I say here okay so there's a Val the function takes a tuple of
double double as its argument so what will define this function we
say in case BC we we do a case because this is the way to use tuples
as arguments in Scala so this is a syntax if I don't say case not
sure it will be healthy so you see this function has only one argument
this one argument has of it has type tuple of double double and so
that's why I need to do a match on that one argument so I already
need a match right right here okay so here's what I do my B and C
are these two coefficients so I determine the discriminant and if
it's greater than 0 then I have two different roots which are given
by this well-known formula and then so I just for clarity I define
names x1 and x2 temporarily and return to roots X 1 St here if discriminant
is zero I don't need to define any names temporarily it's too easy
to not say just equal root of minus B over 200k in here I could also
put these two expressions directly into the constructor of two roots
case class but this is more clear in this clearer in this in this
way finally if the discriminant is negative there are no real notes
so in this way I return a value of this type I construct this value
as an element of one of the three possible domains each domain having
its own values in there so this is a disjunction of empty to pull
to pull of one and tuple of two but I put names on them so now it's
much more readable it's clear what I'm doing and easy to check for
mistakes so let's now check that this works so here's what I do i
define a sequence of tuples just so that i can check at once {[}Music{]}
all these equations so this is the equation x squared minus 2x plus
1 equals 0 so this equation has a double root X equal 1 obviously
now this equation is x squared plus X plus 1 equals 0 and it has no
reloads its roots are complex this equation is x squared minus X still
to come zero it has two real roots different two different railroads
so in this way I check all three possible domains and all three possible
cases and so I have a sequence of these three two bulls and I map
over the sequence with the functions of two which takes a tuple and
returns roots of connecticut the result is a sequence of roots of
contradict so then I check that the sequence is equal to what I expect
the first one has roots only one root x equals one the second one
has no real roots a third one has two different real roots so that's
test passes and it shows that we have implemented our function correctly
now notice that this function returns a value doesn't bail out or
generate errors it always returns a value this value has three different
domains in some domain there's no result another domain there's some
result so this is the way to have deal with complicated logic and
complicating domains in functional programming your model is domain
with types so you make a type that represents everything you want
to say as much as possible and then you write code with it so you
see it's quite easy to write code with this there are no special values
there is no flag boolean flag that would be true or false when you
have roots or you don't have words you don't do any of this it's much
more visual and clear when your code exactly says what's happening
there are no hidden flags hidden special values this is the advantage
of using disjunction types actually this is one of the main advantages
over using some other methods of representing complicated data next
example is that we want to define a function called route average
which is from roots of quadratic in to option double that computes
the average value of all real roots returning none if the average
is undefined so it means if there's no roots that we return otherwise
we return the average problem so how do we implement this the test
is already written so for example route average of this should be
0 son 0 so it's option right so a non empty option has the form some
zero empty option has the firm none so these are the two domains of
the option and so you you have to always have to write the sum and
this none this is a bit verbose if you have a lot of those values
but you need to think about how to reduce the velocity but you always
have to write specific values like this if you have equal roots then
average is the same as this one value otherwise you get none so how
do you implement well you say roots and then you say generate case
closes I'm just lazy and then clearly if we are in this domain then
it's not here it is some X there the sum of x + y / - not that we're
done no way to make a mistake you see your boolean Flags - check nothing
no way to make a mistake very safe code finally what do we do now
we generate 100 random coefficients B and C and compute the mean of
Route average for all of them let's do that so first we make a function
get random that generates a random number so let's say between minus
1 and the one who generates a uniformly distributed random numbers
for simplicity and we prepare a sequence of coefficients by filling
100 random numbers now each get random will be a new number it is
actually good style in Scala to make these functions syntactically
different from values so that you see that this function actually
computes something new every time it's not just a value because I
could I could call this random could you name it and then if I don't
write these parentheses then it looks like a value it looks like it's
going to be the same every time but it's right now it's not a new
random number so to emphasize that the style convention often in Scala
is that you do the empty parenthesis just kind of a function of 0
arguments which you can also think of a function of an empty tuple
as an argument but in Scala is actually different you have functions
with zero arguments in Scala which are different from functions of
single argument that's an empty tuple Scala is a bit redundant in
this way and this is because it has to maintain compatibility with
Java but is never a big problem so the syntax helps if you use it
in a way that is suggestive so we make these coefficients we get a
sequence of random numbers and then we map over the sequence with
the functions of two that we implemented just previously the result
will be a sequence of this roots of quadratic that we have so each
element of the sequence could have different configuration of roots
in or roots at one or two rows and it's all in this type because this
is a disjunction tab now we compute averages so solutions we map over
that sequence with root n rooster remember the function wrote average
takes roots of quadratic and returns option double so when we map
with this function over sequence of roots of quadratic we get a sequence
of option double each element being transformed now that's not what
we want though we now we want to compute average of the sequence but
it's a sequence of option double so some of them are none some of
them are not known how do we get all the ones that are not none to
take the average of them so I will show you several attempts to do
that in the first attempt is to filter the averages by retaining those
that are not null no not none so we do this with a filter with this
matching expression which is actually working but it still gives you
a sequence of option of double it does not eliminate the option type
and that's kind of bothersome so there are two ways in which you can
do it more easily and more safely one way is to use this flatten function
on sequence so it's a special case when you have so flattened usually
what it does is that you get from a sequence of sequences you get
the sequence so usually for example so usually the sequence of sequence
of T and you get from it sequence of T but also it works with sequence
of option of T and you get from it sequence of T so this usually what
flattens do is just flatten does is just every sequence here is concatenated
and you get one big sequence now if you think that option is like
a sequence of at most one element you can do the same operation you
can concatenate all those options that are not empty discard those
that are empty and you get a sequence so that's what flatten does
and that's exactly what we need to do here we have a sequence of optional
double and we need to discard those that are empty and get a sequence
of double as a result so that's what flattening does as another way
of achieving the same result is to use the collect function collect
function is quite useful because you can do partial function here
and match and transform things and transform types also so here I
transform type so this is an option type option of double and this
is double so I have transformed the type and the collect function
will check that this case actually matches and four empty options
it will not match and they will be discarded so that is how these
functions work very useful functions in this case flatten would be
my preferred option my preferred way of implementing it because it
is shorter and very clear I just want to discard all know all empty
options and that's what flatten does but if I have some more complicated
transformation discarding some elements while transforming others
and flatten is only defined for this special case sequence of option
for example flatten is not defined for an option of sequence or for
some others such things then I use collect so but anyway we can run
this test now and either result one or result two will compute exactly
the same thing {[}Music{]} let's see what is Prince for yeah interesting
some interesting number every root fine so this is our result the
final worked example for this tutorial is slightly different so far
we have been computing things now we want to implement a function
with a fully parametric type which is given like this what does this
function do it takes a tuple of two options and returns an option
of a tuple now actually I forgot the double parenthesis in this type
signature this must be double parenthesis and in my code I believe
it is like here a a function that takes a tuple you must have double
parenthesis because in scala the syntax is that the first pair of
parenthesis designates the arguments of the function so we can have
one or more arguments and each argument could be a tuple or not also
so if you have just one argument that's a tuple and you must do this
double parenthesis so I should have done it here too I will check
I will correct this in my slides let's look at the implementation
so I start with a test so if I had such a function of type two co-option
int option string let's say into option of tuple in string how would
I check that this works correctly for example if both options are
non-empty then I want to return a non-empty option of the of the pair
but if if just one of them is empty I cannot return the pair I cannot
have a pair because I don't have the other value and so I must return
none for the entire option of tuple so this is the only way that this
function can work and this test then checks that this is so so it
returns none in all cases except when both of these options are non
empty so here's the implementation one implementation of this function
what's reason about it to see how this implementation can be new right
well firstly we say they said these are the two arguments so let's
match on the first argument the matching of the argument has let me
delete this perhaps and write the code again by reasoning about what
needs to be done so obviously maybe a is a option of a sec maybe is
a empty option maybe not empty so maybe we have a name will be not
so we need to match to do the case closes I generate them so then
let me call this a just for clarity okay so now I have two cases either
a is non-empty or NES empty if it is empty I know what to do there
is nothing else to do except to return empty option of this type because
if I were to return non-empty option of this type I would have to
supply both a and B but I don't have B sorry I don't have a my a option
is empty there is no way for me to get an a value of type a because
I don't know what that type is I'm not given a value of type a and
I cannot create it from nothing so I must return none in case that
the option a is non-empty I have hope that maybe also B is present
so let's see if that is so we'll be dimensional let me again generate
cases so it calls value B all right so if B is present then I can
actually return a and B in the tuple so I'm supposed to return an
option of tuple and so I return non empty option some with tuple as
the value and here I again must return none there's no away so basically
my implementation is more or less fixed except that of course I could
return none here as well and the type would be still correct it will
be a very uninteresting implementation but always returns none whatever
the arguments and this the only interesting implementation is this
one now by interesting what I mean is if does not discard all the
information in the arguments it discards some sometimes some information
sometimes but it doesn't always discard everything so this implementation
is is non-trivial and it's the most information preserving one and
therefore the most interesting now this code actually it is correct
I have tests below that call my check function on this one so I can
check that this is correct but this is verbose all this match case
and then case none goes to none case Nando's no all of that is quite
verbose and if I wanted to modify logic here I would have to modify
a lot of things so remember that option is like sequences it has a
map function defined on it you have map method I use the word method
and function interchangeably not in scholar there is a difference
methods are those things defined with the syntax in a class and functions
are values of function type that cannot be used with this syntax again
this is a legacy of Java Java does not does not have functions at
all it only has methods so Scala must have methods too and yet scholar
wants to have functions function values so this is a compromise we
have both in Scala have methods and we have functions for the purposes
of functional programming methods are just like functions so I use
the words functions and methods interchangeably it's just that this
syntax must be different if map were a function not a method then
the syntax would be map both you may be a F something like that and
it's exactly similar map logically speaking has two arguments maybe
a and F but the syntax is that map is written in between with the
daughter actually there is an alternative syntax like this without
without Dalton without parentheses but I don't like that syntax so
much sometimes I use it but only when it is really in easy to read
and what's happening so let me remove this what I wanted to show it
is that this code is so common and it's exactly equivalent to this
code if you have the school that matches on the option so maybe a
this option some type and you imagine it and if it's not empty then
you return the non-empty option with some transformed value and if
it's empty or returned empty this is exactly the same as doing a map
on a collection if a collection is empty you return an empty collection
again and if it's not empty then you take each element and you transform
it with the function and then you return a collection having those
transformed elements an option being a collection with just one element
only needs one such transformation to be performed at most and so
this code is exactly the same as this code so let's take that code
and simplify it instead of maybe be match we just have now we can
write let me write this as a comment so this actually let me let me
copy the entire piece that I'm going to simplify and do it step by
step looking at this template here so whenever I have this pattern
sum of X going to sum of f of X not going to none I just do a map
so I have this pattern right here maybe be not just like that so instead
of this I say maybe B dot map and then the function is from B to the
tuple a B and that takes care of this thing so now the code is much
shorter it has this shape and it's but it still has the same pattern
match son to their son and or to option none - none so let's do maybe
a dot map and then a going to this so the entire code was replaced
by this does it actually work so let's go and see what happens with
this implementation which I called f2 well where I wrote what we just
saw maybe a dot map it's going to maybe be that map why going to tuple
x1 exactly what we ended up with you know after renaming of variables
let me remove that now actually it's not quite right because the type
of this thing is option of option of a b c this.type is option after
mapping we have an option and then this has a type a so we map X of
type a into an option of something and the result is going to be option
of option let me write a comment explaining how this happened I have
option of a then I do map with a function that goes from a to optional
B or action of tuple a B and the result is going to be C this a is
going to be replaced by this through the map function so result is
going to be the type option of option of a B and that's what IntelliJ
tells us if I delete this that's what it knows the type is so we need
to transform this to an ordinary option how do we transform well this
is the whole whole logic here if both of them are non empty only then
we'll get a non empty option at the end so that is what flatten does
a collection of empty collections gives you an empty collection after
flattening so we just use and that's it now that works so that's a
valid way of doing it but it's not the best because there's this pattern
which is map followed by flatten and this pattern also seems to be
very very often used and so in the standard library there is a method
called flat map which is the same as map followed by flatten and so
actually the code that you could write would be this now it is it
is questionable whether this code is easy to read or easier to read
than this I would actually say this code is a little easier to read
because of things in app and happened here's a flat map and map there
are other ways of making this much easier to read and to write which
I'll talk about later this is the for yield block notation but for
now it is important right all of these things by hand all of the maps
flat maps and so on and to follow the types follow to see how the
types are transformed IntelliJ sometimes gives you help here for example
I tell if I press command and then hover my mouse over symbols it
gives me some information about their types and definitions so it
tells me that for example this is an option of being this is a map
that takes a function and returns an of option of B and {[}Music{]}
these types are not always clear here what is this 8 to be for example
b2b I'm not sure what ageism not be is this oops this is certainly
a contrived example of such a function but is this type a please this
type B but actually this is not the types we're using we're using
option a and so on so IntelliJ is not always right when you do this
on the map but tell J is right when you do control shift p1 symbols
so that for example is always right what option B so to make a long
story short you need to start with code like this and then simplify
it and make it shorter and then gradually you will start thinking
in terms of these map flatmap and so on so that it is much easier
for you to think in terms of transformations on an option collection
and so on rather than transformations done on individual elements
it's very important to follow how types change so let me let me try
to rewrite this function in in a longer fashion here and this is what
you might do initially when you start learning about functional programming
code like this is very short it is not very readable so what you can
do is you can say first of all you can make these functions multiline
by putting curly braces around them and then you can introduce intermediate
values for example Wow C equals this and then you return C it's the
same right you call this value C and right away that is your expression
but now you can see what type it is so it's option LV and you do option
return like click on the keyboard to add the type annotation and so
it tells you that this is actually an option of a B that information
was not obvious here when you look at this code but you can make this
easier for me to understand so first maybe B has type option of B
you map it like this and it becomes option of a B maybe what's what's
rename this X into a and that's why into B so that it becomes easier
to read and then also here you are not sure what are you what your
return it but flat map tells you flat map takes a function from a
to option B returns option B well actually this is confusing because
your B is not therapy so there be here is defined in the standard
library somewhere it's not your B so the definition of flat map is
this there's some be here there's some a here it's not what you wanted
it's not your B and what your a so that is a bit confusion so let's
do the same trick here well result equals this return result and now
let's add a type annotation to this okay so now if you didn't do flat
map let's remove this type annotation and add it again you could do
control shift P to see what it is or you can just put it into the
code to document that you at this point you got a gallery of this
type so these transformations each of them will change the type of
values and it's nice to see what type it is to check that that's exactly
what you want now obviously we want an option of a B and not an option
option of a B so we need to flatten it so now let me see what that
is so in this way you can go step by step within each of these transformations
and see what types then generate and having if you have done this
enough times initially it will take time and you you have many steps
and at the end you will see it becomes easier so here are some more
exercises for you to work with disjoint disjunction types case classes
and collections of them and implement some functions like like these
also with fully parametric types and so these functions are usually
obvious what is meant so for example option of a pair goes into a
pair of options obviously this option is empty then you must return
to empty options here and if this option is not empty then it makes
sense to return to non-empty options in order to maximize information
and similarly here for either if you have either of a B that could
be a and then you can return here and non-empty optional a but you
must return empty option of B and vice versa in order to not lose
information and in this example also if you have either a either B
C so for example you could have a and then what they return while
you return the left version of either and the left version of this
either with a inside so in this way you can always see what kind of
value it makes sense to return in order to not lose information good
luck with these exercises 
\end{comment}


\subsection{Scala's case classes as ``named tuple'' types}

It is often convenient to use names for the different parts of a tuple.
Scala's ``case classes\index{case class}'' allow programmers to
put names on each tuple part, as well as on the tuple type itself.
The syntax is
\begin{lstlisting}
case class Person(firstName: String, lastName: String, age: Int)
\end{lstlisting}
This data type carries the same information as a tuple \lstinline!(String, String, Int)!.
Without using a case class to hold this information, we could define
a type alias\index{type alias} for this tuple,
\begin{lstlisting}
type PersonTuple = (String, String, Int)
\end{lstlisting}
and write code like this,
\begin{lstlisting}
scala> val p: PersonTuple = ("Albert", "Einstein", 140)
p: PersonTuple = (Albert,Einstein,140)

scala> val einsteinName = p._2
einsteinName: String = Einstein 
\end{lstlisting}
However, this type alias only creates an alternative name for an existing
tuple of data. The declaration of a \lstinline!case class Person!
gives the programmer several methods that make working with this tuple
more convenient.

In one sense, case classes behave as named tuples with named parts.
Creating a value of a case class and accessing its parts looks like
this:
\begin{lstlisting}
scala> val einstein = Person(firstName = "Albert", lastName = "Einstein", age = 140)
einstein: Person = Person(Albert,Einstein,140)

scala> einstein.firstName
res0: String = Albert

scala> einstein.age
res1: Int = 140
\end{lstlisting}
Part names are optional when creating a value:
\begin{lstlisting}
scala> val poincare = Person("Henri", "Poincare", 165)
poincare: Person = Person(Henri,Poincare,165)
\end{lstlisting}
It is a type error to use wrong types with a case class:
\begin{lstlisting}
scala> val p = Person(140, "Einstein", "Albert")
<console>:13: error: type mismatch;
 found   : Int(140)
 required: String
       val p = Person(140, "Einstein", "Albert")
                      ^
<console>:13: error: type mismatch;
 found   : String("Albert")
 required: Int
       val p = Person(140, "Einstein", "Albert")
                                       ^
\end{lstlisting}
However, parts can be specified in any order when using part names:
\begin{lstlisting}
scala> val p = Person(age = 140, lastName = "Einstein", firstName = "Albert")
p: Person = Person(Albert,Einstein,140)
\end{lstlisting}

Another feature of case classes is that eachcase class is a \emph{different
type}, even if the data it contains is the same. A function whose
argument is of type \lstinline!Person! requires an argument of that
type. It will be a type error to call that function with an argument
of type \lstinline!(String, String, Int)!. One cannot make a mistake
using one case class instead of another. 
