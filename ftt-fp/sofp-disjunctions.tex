
\chapter{The logic of types. I. Disjunctive types}

Disjunctive types describe values that belong to a disjoint set of
alternatives. 

To see how Scala implements disjunctive types, we need to begin by
looking at ``case classes''.

\section{Scala's case classes}

\subsection{Tuple types with names}

It is often helpful to use names for the different parts of a tuple.
Suppose that some program represents the size and the color of socks
with the tuple type \inputencoding{latin9}\lstinline!(Double, String)!\inputencoding{utf8}.
What if the same tuple type \inputencoding{latin9}\lstinline!(Double, String)!\inputencoding{utf8}
is used in another place in the program to mean the amount paid and
the payee? A programmer could mix the two values by mistake, and it
would be hard to find out why the program incorrectly computes, say,
the total amount paid.\inputencoding{latin9}
\begin{lstlisting}
def totalAmountPaid(ps: Seq[(Double, String)]): Double = ps.map(_._1).sum
val x = (10.5, "white")       // Sock size and color.
val y = (25.0, "restaurant")  // Payment amount and payee.

scala> totalAmountPaid(Seq(x, y)) // Nonsense.
res0: Double = 35.5
\end{lstlisting}
\inputencoding{utf8}
We would prevent this kind of mistake if we could use two \emph{different}
types, with names such as \inputencoding{latin9}\lstinline!MySock!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Payment!\inputencoding{utf8},
for the two kinds of data. There are  three basic ways of defining
a new named type in Scala: using a type alias, using a class (or ``trait''),
and using an \index{opaque type}opaque type. 

Opaque types (hiding a type under a new name) is a feature of a future
version of Scala 3; so we focus on type aliases and case classes.

A \textbf{type alias}\index{type alias} is an alternative name for
an existing (already defined) type. We could use type aliases in our
example to add clarity to the code:\inputencoding{latin9}
\begin{lstlisting}
type MySockTuple = (Double, String)
type PaymentTuple = (Double, String)

scala> val s: MySockTuple = (10.5, "white")
s: MySockTuple = (10.5,white)

scala> val p: PaymentTuple = (25.0, "restaurant")
p: PaymentTuple = (25.0,restaurant)
\end{lstlisting}
\inputencoding{utf8}But the mix-up error is not prevented:\inputencoding{latin9}
\begin{lstlisting}
scala> totalAmountPaid(Seq(s, p)) // Nonsense again.
res1: Double = 35.5
\end{lstlisting}
\inputencoding{utf8}
Scala's \textbf{case classes}\index{case class} can be seen as ``tuples
with names''. A case class is equivalent to a tuple type that has
a name that we choose when we define the case class. Also, each part
of the case class will have a separate name that we must choose. This
is how to define case classes for the example with socks and payments:\inputencoding{latin9}
\begin{lstlisting}
case class MySock(size: Double, color: String)
case class Payment(amount: Double, name: String)

scala> val sock = MySock(10.5, "white")
sock: MySock = MySock(10.5,white)

scala> val paid = Payment(25.0, "restaurant")
paid: Payment = Payment(25.0,restaurant)                                  ^ 
\end{lstlisting}
\inputencoding{utf8}The new types \inputencoding{latin9}\lstinline!MySock!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Payment!\inputencoding{utf8}
were defined. Values of type \inputencoding{latin9}\lstinline!MySock!\inputencoding{utf8}
are written as \inputencoding{latin9}\lstinline!MySock(10.5, "white")!\inputencoding{utf8},
which is similar to writing the tuple \inputencoding{latin9}\lstinline!(10.5, "white")!\inputencoding{utf8}
except for adding the name \inputencoding{latin9}\lstinline!MySock!\inputencoding{utf8}
in front of the tuple.

To access the parts of a case class, we use the part names:\inputencoding{latin9}
\begin{lstlisting}
scala> sock.size
res2: Double = 10.5

scala> paid.amount
res3: Double = 25.0
\end{lstlisting}
\inputencoding{utf8}The mix-up error is now a type error flagged by the compiler:\inputencoding{latin9}
\begin{lstlisting}
def totalAmountPaid(ps: Seq[Payment]): Double = ps.map(_.amount).sum

scala> totalAmountPaid(Seq(paid, paid))
res4: Double = 50.0

scala> totalAmountPaid(Seq(sock, paid))
<console>:19: error: type mismatch;
 found   : MySock
 required: Payment
       totalAmountPaid(Seq(sock, paid))
                            ^
\end{lstlisting}
\inputencoding{utf8}A function whose argument is of type \inputencoding{latin9}\lstinline!MySock!\inputencoding{utf8}
cannot be applied to an argument of type \inputencoding{latin9}\lstinline!Payment!\inputencoding{utf8}
or of type \inputencoding{latin9}\lstinline!(Double, String)!\inputencoding{utf8}.
Case classes with different names are \emph{different types}, even
if they contain the same types of parts. 

Just as tuples can have any number of parts, case classes can have
any number of parts, but the part names must be distinct, for example:\inputencoding{latin9}
\begin{lstlisting}
case class Person(firstName: String, lastName: String, age: Int)

scala> val noether = Person("Emmy", "Noether", 137)
einstein: Person = Person(Emmy,Noether,137)

scala> noether.firstName
res5: String = Emmy

scala> noether.age
res6: Int = 137
\end{lstlisting}
\inputencoding{utf8}This data type carries the same information as a tuple \inputencoding{latin9}\lstinline!(String, String, Int)!\inputencoding{utf8}.
However, the declaration of a \inputencoding{latin9}\lstinline!case class Person!\inputencoding{utf8}
gives the programmer several features that make working with the tuple's
data more convenient and less error-prone.

Some (or all) part names may be specified when creating a case class
value:\inputencoding{latin9}
\begin{lstlisting}[extendedchars=true]
scala> val poincaré = Person(firstName = "Henri", lastName = "Poincaré", 165)
poincaré: Person = Person(Henri,Poincaré,165)
\end{lstlisting}
\inputencoding{utf8}It is a type error to use wrong types with a case class:\inputencoding{latin9}
\begin{lstlisting}
scala> val p = Person(140, "Einstein", "Albert")
<console>:13: error: type mismatch;
 found   : Int(140)
 required: String
       val p = Person(140, "Einstein", "Albert")
                      ^
<console>:13: error: type mismatch;
 found   : String("Albert")
 required: Int
       val p = Person(140, "Einstein", "Albert")
                                       ^
\end{lstlisting}
\inputencoding{utf8}Here, the error is due to an incorrect order of parts when creating
a case class value. However, parts can be specified in any order when
using part names:\inputencoding{latin9}
\begin{lstlisting}
scala> val p = Person(age = 137, lastName = "Noether", firstName = "Emmy")
p: Person = Person(Emmy,Noether,137)
\end{lstlisting}
\inputencoding{utf8}A part of a case class can have the type of another case class, creating
a type similar to a nested tuple:\inputencoding{latin9}
\begin{lstlisting}
case class BagOfSocks(sock: MySock, count: Int)
val bag = BagOfSocks(MySock(10.5, "white"), 6)

scala> bag.sock.size
res7: Double = 10.5
\end{lstlisting}
\inputencoding{utf8}

\subsection{Case classes with type parameters}

Type classes can be defined with \index{type parameter}type parameters.
As an example, consider a generalization of \inputencoding{latin9}\lstinline!MySock!\inputencoding{utf8}
where, in addition to the size and color, an ``extended sock'' holds
another value. We could define several specialized case classes,\inputencoding{latin9}
\begin{lstlisting}
case class MySock_Int(size: Double, color: String, value: Int)
case class MySock_Boolean(size: Double, color: String, value: Boolean)
\end{lstlisting}
\inputencoding{utf8}but it is better to define a single parameterized case class\inputencoding{latin9}
\begin{lstlisting}
case class MySockX[A](size: Double, color: String, value: A)
\end{lstlisting}
\inputencoding{utf8}This case class can accommodate every type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}.
We may now create values of \inputencoding{latin9}\lstinline!MySockX!\inputencoding{utf8}
containing a \inputencoding{latin9}\lstinline!value!\inputencoding{utf8}
of any type,\inputencoding{latin9}
\begin{lstlisting}
scala> val s = MySockX(10.5, "white", 123)
s: MySockX[Int] = MySockX(10.5,white,123) 
\end{lstlisting}
\inputencoding{utf8}We see that the type parameter \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
was automatically set to the type \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}. 

Each time we create a value of type \inputencoding{latin9}\lstinline!MySockX!\inputencoding{utf8},
a specific type will have to be used instead of the type parameter
\inputencoding{latin9}\lstinline!A!\inputencoding{utf8}. In other
words, we can only create values of types \inputencoding{latin9}\lstinline!MySockX[Int]!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!MySockX[String]!\inputencoding{utf8},
etc. If we want to be explicit, we may write\inputencoding{latin9}
\begin{lstlisting}
scala> val s = MySockX[String](10.5, "white", "last pair")
s: MySockX[String] = MySockX(10.5,white,last pair) 
\end{lstlisting}
\inputencoding{utf8}However, we can write code working with \inputencoding{latin9}\lstinline!MySockX[A]!\inputencoding{utf8}
\textbf{parametrically}\index{parametric code}, that is, keeping
the type parameter \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
in the code. For example, a function that checks whether a sock of
type \inputencoding{latin9}\lstinline!MySockX[A]!\inputencoding{utf8}
fits my foot can be written as\inputencoding{latin9}
\begin{lstlisting}
def fitsMe[A](sock: MySockX[A]): Boolean = sock.size >= 10.5 && sock.size <= 11.0
\end{lstlisting}
\inputencoding{utf8}This function is defined for all types \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
at once, because its code works in the same way regardless of what
\inputencoding{latin9}\lstinline!A!\inputencoding{utf8} is. Scala
will set the type parameter automatically:\inputencoding{latin9}
\begin{lstlisting}
scala> fitsMe(MySockX(10.5, "blue", List(1,2,3))) // Parameter A = List[Int]
res0: Boolean = true
\end{lstlisting}
\inputencoding{utf8}This code forces the type parameter \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
to be \inputencoding{latin9}\lstinline!List[Int]!\inputencoding{utf8},
and so we may omit the type parameter of \inputencoding{latin9}\lstinline!fitsMe!\inputencoding{utf8}.
When types become more complicated, it may be helpful to prevent type
errors by specifying the values of some type parameters. For example,
here is a type error due to a mismatch between the type parameter
\inputencoding{latin9}\lstinline!A!\inputencoding{utf8} used in the
``sock'' value, which is \inputencoding{latin9}\lstinline!List[Int]!\inputencoding{utf8},
and the type parameter in the function \inputencoding{latin9}\lstinline!fitsMe!\inputencoding{utf8},
specified as \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
<console>:15: error: type mismatch;
 found   : List[Int]
 required: Int
       fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
                                             ^ 
\end{lstlisting}
\inputencoding{utf8}
Case classes may have several type parameters, and the types of the
parts may use these type parameters. Here is an artificial example
of a case class using type parameters in different ways,\inputencoding{latin9}
\begin{lstlisting}
case class Complicated[A,B,C,D](x: (A, A), y: (B, Int) => A, z: C => C)
\end{lstlisting}
\inputencoding{utf8}This case class contains parts of different types that use the type
parameters \inputencoding{latin9}\lstinline!A!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!B!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!C!\inputencoding{utf8}
in tuples and functions. The type parameter \inputencoding{latin9}\lstinline!D!\inputencoding{utf8}
is not used at all; this is allowed.

A type with type parameters, such as \inputencoding{latin9}\lstinline!MySockX!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!Complicated!\inputencoding{utf8},
is called a \index{type constructor}\textbf{type constructor}. A
type constructor ``constructs'' a new type, such as \inputencoding{latin9}\lstinline!MySockX[Int]!\inputencoding{utf8},
from a given type parameter \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}.
Values of type \inputencoding{latin9}\lstinline!MySockX!\inputencoding{utf8}
cannot be created without setting the type parameter. So, it is important
to distinguish the type constructor, such as \inputencoding{latin9}\lstinline!MySockX!\inputencoding{utf8},
from a type we can use in our code, such as \inputencoding{latin9}\lstinline!MySockX[Int]!\inputencoding{utf8}.

\subsection{Tuples with one part and with zero parts}

Let us compare tuples and case classes more systematically.

Parts of a case class are accessed by name with a dot syntax, for
example \inputencoding{latin9}\lstinline!sock.color!\inputencoding{utf8}.
Parts of a tuple are accessed with the accessors such as \inputencoding{latin9}\lstinline!x._1!\inputencoding{utf8}.
This syntax is the same as that for a case class whose parts have
names \inputencoding{latin9}\lstinline!_1!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!_2!\inputencoding{utf8},
etc. So, it appears that tuple parts \emph{do} have names in Scala,
although those names are always automatically chosen as \inputencoding{latin9}\lstinline!_1!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!_2!\inputencoding{utf8}, etc. Tuple
types are also automatically named in Scala as \inputencoding{latin9}\lstinline!Tuple2!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!Tuple3!\inputencoding{utf8}, etc.,
and they are parameterized, since each part of the tuple may be of
any chosen type. A tuple type expression such as \inputencoding{latin9}\lstinline!(Int, String)!\inputencoding{utf8}
is just a special syntax for the parameterized type \inputencoding{latin9}\lstinline!Tuple2[Int, String]!\inputencoding{utf8}.
One could define the tuple types as case classes like this,\inputencoding{latin9}
\begin{lstlisting}
case class Tuple2[A, B](_1: A, _2: B)
case class Tuple3[A, B, C](_1: A, _2: B, _3: C)
// And so on with Tuple4, Tuple5, ...
\end{lstlisting}
\inputencoding{utf8}if these types were not already defined in the Scala library.

Proceeding systematically, we ask whether tuple types can have just
one part or even no parts. Indeed, Scala defines \inputencoding{latin9}\lstinline!Tuple1[A]!\inputencoding{utf8}
as a tuple with a single part. (This type is occasionally used in
practice.) 

The tuple with zero parts also exists and is called \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}
(rather than ``\inputencoding{latin9}\lstinline!Tuple0!\inputencoding{utf8}'').
The syntax for the value of the \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}
type is the empty tuple, \inputencoding{latin9}\lstinline!()!\inputencoding{utf8}.
It is clear that there is \emph{only one} value, \inputencoding{latin9}\lstinline!()!\inputencoding{utf8},
of this type; this explains the name ``unit\index{unit type}''. 

At first sight, the \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}
type may appear to be completely useless: it is a tuple that contains
\emph{no} \emph{data}. It turns out, however, that the \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}
type is important in functional programming, and it is used as a type
\emph{guaranteed} to have only a single distinct value. This chapter
will show some examples of using the \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}
type.

Case classes may have one part or zero parts, similarly to the one-part
and zero-part tuples:\inputencoding{latin9}
\begin{lstlisting}
case class B(z: Int)  // Tuple with one part.
case class C()        // Tuple with no parts.
\end{lstlisting}
\inputencoding{utf8}
Scala has a special syntax for empty case class\index{empty case class}es:\inputencoding{latin9}
\begin{lstlisting}
case object C // Similar to `case class C()`.
\end{lstlisting}
\inputencoding{utf8}There are two main differences between \inputencoding{latin9}\lstinline!case class C()!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!case object C!\inputencoding{utf8}:
\begin{itemize}
\item A \inputencoding{latin9}\lstinline!case object!\inputencoding{utf8}
cannot have type parameters, while we may define, if needed, a \inputencoding{latin9}\lstinline!case class C[X, Y, Z]()!\inputencoding{utf8}
with type parameters \inputencoding{latin9}\lstinline!X!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!Y!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!Z!\inputencoding{utf8}.
\item A \inputencoding{latin9}\lstinline!case object!\inputencoding{utf8}
is allocated in memory only once, while new values of a \inputencoding{latin9}\lstinline!case class C()!\inputencoding{utf8}
will be allocated in memory each time \inputencoding{latin9}\lstinline!C()!\inputencoding{utf8}
is evaluated.
\end{itemize}
Other than that, \inputencoding{latin9}\lstinline!case class C()!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!case object C!\inputencoding{utf8}
have the same meaning: a named tuple with zero parts, which we may
also view as a ``named \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}\index{unit type!named}''
type. In this book, I will not use \inputencoding{latin9}\lstinline!case object!\inputencoding{utf8}s
because \inputencoding{latin9}\lstinline!case class!\inputencoding{utf8}es
are more general.

Let us summarize the correspondence between tuples and case classes:
\begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{Tuples} & \textbf{Case classes}\tabularnewline
\hline 
\hline 
\inputencoding{latin9}\lstinline!(123, "xyz"): Tuple2[Int, String]!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!case class A(x: Int, y: String)!\inputencoding{utf8}\tabularnewline
\hline 
\inputencoding{latin9}\lstinline!(123,): Tuple1[Int]!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!case class B(z: Int)!\inputencoding{utf8}\tabularnewline
\hline 
\inputencoding{latin9}\lstinline!(): Unit!\inputencoding{utf8} & \inputencoding{latin9}\lstinline!case class C()!\inputencoding{utf8}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

\subsection{Pattern matching for case classes}

Scala performs pattern matching in two situations:
\begin{itemize}
\item destructuring definition: \inputencoding{latin9}\lstinline[mathescape=true]!val $pattern$ = ...!\inputencoding{utf8}
\item \inputencoding{latin9}\lstinline!case!\inputencoding{utf8} expression:
\inputencoding{latin9}\lstinline[mathescape=true]!case $pattern$ => ...!\inputencoding{utf8}
\end{itemize}
Case classes can be used in both situations. A destructuring definition
can be used in a function whose argument is of case class type \inputencoding{latin9}\lstinline!BagOfSocks!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
case class MySock(size: Double, color: String)
case class BagOfSocks(sock: MySock, count: Int)

def printBag(bag: BagOfSocks): String = {
  val BagOfSocks(MySock(size, color), count) = bag // Destructure the `bag`.
  s"Bag has $count $color socks of size $size"
}

val bag = BagOfSocks(MySock(10.5, "white"), 6)

scala> printBag(bag)
res0: String = Bag has 6 white socks of size 10.5
\end{lstlisting}
\inputencoding{utf8}
An example of using the \inputencoding{latin9}\lstinline!case!\inputencoding{utf8}
expression:\inputencoding{latin9}
\begin{lstlisting}
def fitsMe(bag: BagOfSocks): Boolean = bag match {
  case BagOfSocks(MySock(size, _), _) => size >= 10.5 && size <= 11.0
}
\end{lstlisting}
\inputencoding{utf8}In the implementation of this function, we match the \inputencoding{latin9}\lstinline!bag!\inputencoding{utf8}
value against the pattern \inputencoding{latin9}\lstinline!BagOfSocks(MySock(size, _), _)!\inputencoding{utf8}.
This pattern will always match and will define \inputencoding{latin9}\lstinline!size!\inputencoding{utf8}
as a pattern variable of type \inputencoding{latin9}\lstinline!Double!\inputencoding{utf8}.

The syntax for pattern matching expressions with case classes is similar
to the syntax for pattern matching of tuples, except for the presence
of the \emph{names} of the case classes. For example, removing the
case class names from the pattern\inputencoding{latin9}
\begin{lstlisting}
case BagOfSocks(MySock(size, _), _) => ...
\end{lstlisting}
\inputencoding{utf8}we obtain the nested tuple pattern \inputencoding{latin9}
\begin{lstlisting}
case ((size, _), _) => ...
\end{lstlisting}
\inputencoding{utf8}that could be used for values of type \inputencoding{latin9}\lstinline!((Double, String), Int)!\inputencoding{utf8}.
We see that case classes behave in many ways exactly as tuple types
with names. 

Scala's ``case classes'' got their name from their use in \inputencoding{latin9}\lstinline!case!\inputencoding{utf8}
expressions. It is usually more convenient to use \inputencoding{latin9}\lstinline!match!\inputencoding{utf8}
/ \inputencoding{latin9}\lstinline!case!\inputencoding{utf8} expressions
with case classes than to use destructuring.

\section{Disjunctive types}

\subsection{Motivation and first examples\label{subsec:Disjunctive-Motivation-and-first-examples}}

In many situations, it is useful to have several different shapes
of data within the same type. As a first example, suppose we are looking
for real roots of a quadratic equation $x^{2}+bx+c=0$. There are
three cases: no real roots, one real root, and two real roots. It
is convenient to have a type, say \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8},
that means ``the real roots of a quadratic equation''. Inside that
type, we distinguish between the three cases, but outside it looks
like a single type.

Another example is the binary search algorithm that looks for an integer
$x$ in a sorted array. There are two cases: the algorithm either
finds the index of $x$ or determines that the array does not contain
$x$. It is convenient if the algorithm could return a single value
of a type, say, \inputencoding{latin9}\lstinline!SearchResult!\inputencoding{utf8},
that represents \emph{either} an index at which $x$ is found, \emph{or}
the absence of an index.

More generally, we may have computations that \emph{either} return
a value \emph{or} generate an error and fail to produce a result.
It is then convenient to return a value of type, say, \inputencoding{latin9}\lstinline!Result!\inputencoding{utf8},
that represents either a correct result or an error message. 

In certain computer games, one has different types of ``rooms'',
each room having certain properties depending on its type. Some rooms
are dangerous because of monsters, other rooms contain useful objects,
certain rooms allow you to finish the game, and so on. We want to
represent all the different kinds of rooms uniformly, as a type \inputencoding{latin9}\lstinline!Room!\inputencoding{utf8},
so that a value of type \inputencoding{latin9}\lstinline!Room!\inputencoding{utf8}
automatically stores the correct properties in each case.

In all these situations, data comes in several mutually exclusive
shapes. This data can be represented by a single type if that type
is able to describe a mutually exclusive set of cases:
\begin{itemize}
\item \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8} must
be either the empty tuple \inputencoding{latin9}\lstinline!()!\inputencoding{utf8},
or \inputencoding{latin9}\lstinline!Double!\inputencoding{utf8},
or a tuple \inputencoding{latin9}\lstinline!(Double, Double)!\inputencoding{utf8}
\item \inputencoding{latin9}\lstinline!SearchResult!\inputencoding{utf8}
must be either \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}
or the empty tuple \inputencoding{latin9}\lstinline!()!\inputencoding{utf8}
\item \inputencoding{latin9}\lstinline!Result!\inputencoding{utf8} must
be either an \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}
value or a \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}
message
\end{itemize}
We see that the empty tuple, also known as the \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}
type, is natural to use in this representation. It is also helpful
to assign names to each of the cases:
\begin{itemize}
\item \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8} is
``no roots'' with value \inputencoding{latin9}\lstinline!()!\inputencoding{utf8},
or ``one root'' with value \inputencoding{latin9}\lstinline!Double!\inputencoding{utf8},
or ``two roots'' with value \inputencoding{latin9}\lstinline!(Double, Double)!\inputencoding{utf8}
\item \inputencoding{latin9}\lstinline!SearchResult!\inputencoding{utf8}
is ``index'' with value \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8},
or ``not found'' with value \inputencoding{latin9}\lstinline!()!\inputencoding{utf8}
\item \inputencoding{latin9}\lstinline!Result!\inputencoding{utf8} is ``value''
of type \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}
or ``error message'' of type \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}
\end{itemize}
Scala's case classes provide exactly what we need here â \emph{named
tuples} with zero, one, two and more parts, and so it is natural to
use case classes instead of tuples:
\begin{itemize}
\item \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8} is
a value of type \inputencoding{latin9}\lstinline!case class NoRoots()!\inputencoding{utf8},
or a value of type \inputencoding{latin9}\lstinline!case class OneRoot(x: Double)!\inputencoding{utf8},
or of type \inputencoding{latin9}\lstinline!case class TwoRoots(x: Double, y: Double)!\inputencoding{utf8}
\item \inputencoding{latin9}\lstinline!SearchResult!\inputencoding{utf8}
is a value of type \inputencoding{latin9}\lstinline!case class Index(Int)!\inputencoding{utf8}
or a value of type \inputencoding{latin9}\lstinline!case class NotFound()!\inputencoding{utf8}
\item \inputencoding{latin9}\lstinline!Result!\inputencoding{utf8} is a
value of type \inputencoding{latin9}\lstinline!case class Value(x: Int)!\inputencoding{utf8}
or a value of type \inputencoding{latin9}\lstinline!case class Error(message: String)!\inputencoding{utf8}
\end{itemize}
Our three examples are now described as types that select one case
class out of a given set. It remains to see how Scala defines such
types. For instance, the definition of \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}
needs to indicate that the case classes \inputencoding{latin9}\lstinline!NoRoots!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!OneRoot!\inputencoding{utf8}, and
\inputencoding{latin9}\lstinline!TwoRoots!\inputencoding{utf8} are
exactly the three alternatives described by the type \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}.
The Scala syntax for that definition looks like this:\inputencoding{latin9}
\begin{lstlisting}
sealed trait RootsOfQ
final case class NoRoots() extends RootsOfQ
final case class OneRoot(x: Double) extends RootsOfQ
final case class TwoRoots(x: Double, y: Double) extends RootsOfQ
\end{lstlisting}
\inputencoding{utf8}In the definition of \inputencoding{latin9}\lstinline!SearchResult!\inputencoding{utf8},
we have two cases:\inputencoding{latin9}
\begin{lstlisting}
sealed trait SearchResult
final case class Index(i: Int) extends SearchResult
final case class NotFound() extends SearchResult
\end{lstlisting}
\inputencoding{utf8}The definition of the \inputencoding{latin9}\lstinline!Result!\inputencoding{utf8}
type is parameterized, so that we can describe results of any type
(while error messages are always of type \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}):\inputencoding{latin9}
\begin{lstlisting}
sealed trait Result[A]
final case class Value[A](x: A) extends Result[A]
final case class Error[A](message: String) extends Result[A]
\end{lstlisting}
\inputencoding{utf8}
The ``\inputencoding{latin9}\lstinline!sealed trait!\inputencoding{utf8}
/ \inputencoding{latin9}\lstinline!final case class!\inputencoding{utf8}''
syntax defines a type that represents a choice of one case class from
a fixed set of case classes. This kind of type is called a \textbf{\index{disjunctive type}disjunctive
type} in this book. 

\subsection{Solved examples: Pattern matching for disjunctive types\index{solved examples}}

Our first examples of disjunctive types are \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!SearchResult!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!Result[A]!\inputencoding{utf8}
defined in the previous section. We will now look at the Scala syntax
for creating values of disjunctive types and for using the created
values.

Consider the disjunctive type \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}
having three case classes (\inputencoding{latin9}\lstinline!NoRoots!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!OneRoot!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!TwoRoots!\inputencoding{utf8}).
The only way of creating a value of type \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}
is to create a value of one of these case classes. This is done by
writing expressions such as \inputencoding{latin9}\lstinline!NoRoots()!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!OneRoot(2.0)!\inputencoding{utf8},
or \inputencoding{latin9}\lstinline!TwoRoots(1.0, -1.0)!\inputencoding{utf8}.
Scala will accept these expressions as having the type \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> val x: RootsOfQ = OneRoot(2.0)
x: RootsOfQ = OneRoot(2.0)
\end{lstlisting}
\inputencoding{utf8}
Given a value \inputencoding{latin9}\lstinline!x:RootsOfQ!\inputencoding{utf8},
how can we use it, say, as a function argument? The main tool for
working with values of disjunctive types is pattern matching with
\inputencoding{latin9}\lstinline!match!\inputencoding{utf8} / \inputencoding{latin9}\lstinline!case!\inputencoding{utf8}
expressions. In Chapter~\ref{chap:2-Mathematical-induction}, we
used pattern matching to destructure tuples with syntax such as \inputencoding{latin9}\lstinline!{ case (x, y) => ... }!\inputencoding{utf8}.
We will now see how to use \inputencoding{latin9}\lstinline!match!\inputencoding{utf8}
/ \inputencoding{latin9}\lstinline!case!\inputencoding{utf8} expressions
with disjunctive types. The main difference is that we may have to
write \emph{more than one} \inputencoding{latin9}\lstinline!case!\inputencoding{utf8}
pattern in a \inputencoding{latin9}\lstinline!match!\inputencoding{utf8}
expression, because we need to match several possible cases of the
disjunctive type:\inputencoding{latin9}
\begin{lstlisting}
def f(r: RootsOfQ): String = r match {
  case NoRoots()       => "no real roots"
  case OneRoot(r)      => s"one real root: $r"
  case TwoRoots(x, y)  => s"real roots: ($x, $y)"
}

scala> f(x)
res0: String = "one real root: 2.0"
\end{lstlisting}
\inputencoding{utf8}If we only need to recognize a specific case of a disjunctive type,
we can match all other cases with an underscore:\inputencoding{latin9}
\begin{lstlisting}
scala> x match {
  case OneRoot(r)   => s"one real root: $r"
  case _            => "have something else"
}
res1: String = one real root: 2.0
\end{lstlisting}
\inputencoding{utf8}The \inputencoding{latin9}\lstinline!match!\inputencoding{utf8} /
\inputencoding{latin9}\lstinline!case!\inputencoding{utf8} expression
represents a choice over possible values of a given type. Note the
similarity with this code:

\inputencoding{latin9}\begin{lstlisting}
def f(x: Int): Int = x match {
  case 0    => println(s"error: must be nonzero"); -1
  case 1    => println(s"error: must be greater than 1"); -1
  case _    => x
}
\end{lstlisting}
\inputencoding{utf8}The values \inputencoding{latin9}\lstinline!0!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!1!\inputencoding{utf8} are some
possible values of type \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8},
just as \inputencoding{latin9}\lstinline!OneRoot(1.0)!\inputencoding{utf8}
is a possible value of type \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}.
When used with disjunctive types, \inputencoding{latin9}\lstinline!match!\inputencoding{utf8}
/ \inputencoding{latin9}\lstinline!case!\inputencoding{utf8} expressions
will usually contain a complete list of possibilities. If the list
of cases is incomplete, the Scala compiler will print a warning:\inputencoding{latin9}
\begin{lstlisting}
scala> def g(x: RootsOfQ): String = x match {
     |    case OneRoot(r) => s"one real root: $r"
     | }
<console>:14: warning: match may not be exhaustive.
It would fail on the following inputs: NoRoots(), TwoRoots(_, _)
       def g(x: RootsOfQ): String = x match {
                                    ^
\end{lstlisting}
\inputencoding{utf8}This code defines a \index{partial function}\emph{partial} function
\inputencoding{latin9}\lstinline!g!\inputencoding{utf8} that can
be applied only to values of the form \inputencoding{latin9}\lstinline!OneRoot(...)!\inputencoding{utf8}
and will fail for other values.

Let us look at more examples of using the disjunctive types we just
defined.

\subsubsection{Example \label{subsec:disj-Example-rootsofq-1}\ref{subsec:disj-Example-rootsofq-1}}

Given a sequence of quadratic equations, compute a sequence containing
their real roots as values of type \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}.

\subparagraph{Solution}

Define a case class representing a quadratic equation $x^{2}+bx+c=0$:\inputencoding{latin9}
\begin{lstlisting}
case class QEqu(b: Double, c: Double)
\end{lstlisting}
\inputencoding{utf8}The following function determines how many real roots an equation
has:\inputencoding{latin9}
\begin{lstlisting}
def solve(quadraticEqu: QEqu): RootsOfQ = {
   val QEqu(b, c) = quadraticEqu // Destructure QEqu.
   val d = b * b / 4 - c
   if (d > 0) {
     val s = math.sqrt(d)
     TwoRoots(b / 2 - s, b / 2 + s)
   } else if (d == 0.0) OneRoot(b / 2)
   else NoRoots()
}
\end{lstlisting}
\inputencoding{utf8}Test this function:\inputencoding{latin9}
\begin{lstlisting}
scala> solve(QEqu(1,1))
res1: RootsOfQ = NoRoots()

scala> solve(QEqu(1,-1))
res2: RootsOfQ = TwoRoots(-0.6180339887498949,1.618033988749895) 

scala> solve(QEqu(6,9))
res3: RootsOfQ = OneRoot(3.0) 
\end{lstlisting}
\inputencoding{utf8}We can now implement the required function,\inputencoding{latin9}
\begin{lstlisting}
def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map(solve)
\end{lstlisting}
\inputencoding{utf8}If the function \inputencoding{latin9}\lstinline!solve!\inputencoding{utf8}
is not used often, we may want to write it inline:\inputencoding{latin9}
\begin{lstlisting}
def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map { case QEqu(b, c) =>
  (b * b / 4 - c) match {
    case d if d > 0   =>
      val s = math.sqrt(d)
      TwoRoots(b / 2 - s, b / 2 + s)
    case 0.0          => OneRoot(b / 2)
    case _            => NoRoots()
  }
}
\end{lstlisting}
\inputencoding{utf8}This code uses some features of Scala syntax. We can use the partial
function \inputencoding{latin9}\lstinline!{ case QEqu(b, c) => ... }!\inputencoding{utf8}
directly as the argument of \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
instead of defining this function separately. This avoids having to
destructure \inputencoding{latin9}\lstinline!QEqu!\inputencoding{utf8}
at a separate step. The \inputencoding{latin9}\lstinline!if!\inputencoding{utf8}
/ \inputencoding{latin9}\lstinline!else!\inputencoding{utf8} expression
is replaced by an ``embedded''\index{embedded `if`} \inputencoding{latin9}\lstinline!if!\inputencoding{utf8}
within the \inputencoding{latin9}\lstinline!case!\inputencoding{utf8}
expression, which is easier to read. Test the final code:\inputencoding{latin9}
\begin{lstlisting}
scala> findRoots(Seq(QEqu(1,1), QEqu(2,1)))
res4: Seq[RootsOfQ] = List(NoRoots(), OneRoot(1.0)) 
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:disj-Example-rootsofq}\ref{subsec:disj-Example-rootsofq}}

Given a sequence of values of type \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8},
compute a sequence containing only the single roots. Example test:\inputencoding{latin9}
\begin{lstlisting}
def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] = ???

scala> singleRoots(Seq(TwoRoots(-1, 1), OneRoot(3.0), OneRoot(1.0), NoRoots()))
res5: Seq[Double] = List(3.0, 1.0) 
\end{lstlisting}
\inputencoding{utf8}

\subparagraph{Solution}

We apply \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8} to
the sequence of roots:\inputencoding{latin9}
\begin{lstlisting}
def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] = rs.filter {
  case OneRoot(x) => true
  case _          => false
}.map { case OneRoot(x) => x }
\end{lstlisting}
\inputencoding{utf8}In the \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
operation, we need to cover only the one-root case because the other
two possibilities have been ``filtered out'' by the preceding \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}
operation.

\subsubsection{Example \label{subsec:disj-Example-searchresult}\ref{subsec:disj-Example-searchresult}}

Implement binary search returning a \inputencoding{latin9}\lstinline!SearchResult!\inputencoding{utf8}.
We will modify the binary search implementation from Example~\ref{subsec:ch2Example-binary-search-seq-4}(b)
so that it returns a \inputencoding{latin9}\lstinline!NotFound!\inputencoding{utf8}
value when appropriate.

\subparagraph{Solution}

The code from Example~\ref{subsec:ch2Example-binary-search-seq-4}(b)
will return \emph{some} index even if the given number is not present
in the array: \inputencoding{latin9}
\begin{lstlisting}
scala> binSearch(Array(1, 3, 5, 7), goal = 5)
res6: Int = 2

scala> binSearch(Array(1, 3, 5, 7), goal = 4)
res7: Int = 1
\end{lstlisting}
\inputencoding{utf8}When the number is not present, the array's element at the computed
index will not be equal to \inputencoding{latin9}\lstinline!goal!\inputencoding{utf8}.
We should return \inputencoding{latin9}\lstinline!NotFound()!\inputencoding{utf8}
in that case. The new code can be written as a \inputencoding{latin9}\lstinline!match!\inputencoding{utf8}
/ \inputencoding{latin9}\lstinline!case!\inputencoding{utf8} expression
for clarity:\inputencoding{latin9}
\begin{lstlisting}
def safeBinSearch(xs: Seq[Int], goal: Int): SearchResult =
  binSearch(xs, goal) match {
    case n if xs(n) == goal   => Index(n) 
    case _                    => NotFound()
  }
\end{lstlisting}
\inputencoding{utf8}To test:\inputencoding{latin9}
\begin{lstlisting}
scala> safeBinSearch(Array(1, 3, 5, 7), 5)
res8: SearchResult = Index(2)

scala> safeBinSearch(Array(1, 3, 5, 7), 4)
res9: SearchResult = NotFound()
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:disj-Example-resultA}\ref{subsec:disj-Example-resultA}}

Use the disjunctive type \inputencoding{latin9}\lstinline!Result[Int]!\inputencoding{utf8}
to implement ``safe integer arithmetic'', where a division by zero
or a square root of a negative number will give an error message.
Define arithmetic operations directly for values of type \inputencoding{latin9}\lstinline!Result[Int]!\inputencoding{utf8}.
When errors occur, abandon further computations.

\subparagraph{Solution}

Begin by implementing the square root:\inputencoding{latin9}
\begin{lstlisting}
def sqrt(r: Result[Int]): Result[Int] = r match {
  case Value(x) if x >= 0  => Value(math.sqrt(x).toInt)
  case Value(x)            => Error(s"error: sqrt($x)")
  case Error(m)            => Error(m) // Keep the error message.
}
\end{lstlisting}
\inputencoding{utf8}The square root is computed only if we have the \inputencoding{latin9}\lstinline!Value(x)!\inputencoding{utf8}
case, and only if $x\geq0$. If the argument \inputencoding{latin9}\lstinline!r!\inputencoding{utf8}
was already an \inputencoding{latin9}\lstinline!Error!\inputencoding{utf8}
case, we keep the error message and perform no further computations.

To implement the addition operation, we need a bit more work:\inputencoding{latin9}
\begin{lstlisting}
def add(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match {
  case (Value(x), Value(y)) => Value(x + y)
  case (Error(m), _)        => Error(m) // Keep the error message.
  case (_, Error(m))        => Error(m)
}
\end{lstlisting}
\inputencoding{utf8}This code illustrates nested patterns that match the tuple \inputencoding{latin9}\lstinline!(rx, ry)!\inputencoding{utf8}
against various possibilities. In this way, the code is clearer than
code written with nested \inputencoding{latin9}\lstinline!if!\inputencoding{utf8}
/ \inputencoding{latin9}\lstinline!else!\inputencoding{utf8} expressions.

Implementing the multiplication operation results in almost the same
code:\inputencoding{latin9}
\begin{lstlisting}
def mul(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match {
  case (Value(x), Value(y)) => Value(x * y)
  case (Error(m), _)        => Error(m)
  case (_, Error(m))        => Error(m)
}
\end{lstlisting}
\inputencoding{utf8}To avoid repetition, we may define a general function that ``lifts''\index{lifting}
operations on integers to operations on \inputencoding{latin9}\lstinline!Result[Int]!\inputencoding{utf8}
types:\inputencoding{latin9}
\begin{lstlisting}
def do2(rx: Result[Int], ry: Result[Int])(op: (Int, Int) => Int): Result[Int] =
  (rx, ry) match {
    case (Value(x), Value(y)) => Value(op(x, y))
    case (Error(m), _)        => Error(m)
    case (_, Error(m))        => Error(m)
  }
\end{lstlisting}
\inputencoding{utf8}Now we can easily ``lift'' any binary operation that never generates
an error to an operation on \inputencoding{latin9}\lstinline!Result[Int]!\inputencoding{utf8}.\inputencoding{latin9}
\begin{lstlisting}
def sub(rx: Result[Int], ry: Result[Int]): Result[Int] =
  do2(rx, ry){ (x, y) => x - y }
\end{lstlisting}
\inputencoding{utf8} Custom code is still needed for operations that \emph{may} generate
errors:\inputencoding{latin9}
\begin{lstlisting}
def div(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match {
  case (Value(x), Value(y)) if y != 0  => Value(x / y)
  case (Value(x), Value(y))            => Error(s"error: $x / $y")
  case (Error(m), _)                   => Error(m)
  case (_, Error(m))                   => Error(m)
}
\end{lstlisting}
\inputencoding{utf8}We can now test the new ``safe arithmetic'' on simple calculations:\inputencoding{latin9}
\begin{lstlisting}
scala> add(Value(1), Value(2))
res10: Result[Int] = Value(3)

scala> div(add(Value(1), Value(2)), Value(0))
res11: Result[Int] = Error(error: 3 / 0)
\end{lstlisting}
\inputencoding{utf8}We see that indeed all further computations are abandoned once an
error occurs. An error message shows only the immediate calculation
that generated the error. For instance, the error message for $20+1/0$
never mentions $20$:\inputencoding{latin9}
\begin{lstlisting}
scala> add(Value(20), div(Value(1), Value(0)))
res12: Result[Int] = Error(error: 1 / 0)

scala> add(sqrt(Value(-1)), Value(10))
res13: Result[Int] = Error(error: sqrt(-1))
\end{lstlisting}
\inputencoding{utf8}

\subsection{Standard disjunctive types: \texttt{Option}, \texttt{Either}, \texttt{Try}}

The Scala library defines the disjunctive types \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}, and
\inputencoding{latin9}\lstinline!Try!\inputencoding{utf8} because
they are used often. We now look at each of them in turn.

\paragraph{\texttt{Option}}

The \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
type is a disjunctive type with two cases: the empty tuple and a one-element
tuple. The names of the two case classes are \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Some!\inputencoding{utf8}. If
the \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
type were not already defined in the standard library, one could define
it with the code\inputencoding{latin9}
\begin{lstlisting}
sealed trait Option[T]
final case object None extends Option[Nothing]
final case class Some[T](t: T) extends Option[T]
\end{lstlisting}
\inputencoding{utf8}This code is similar to the type \inputencoding{latin9}\lstinline!SearchResult!\inputencoding{utf8}
defined in Section~\ref{subsec:Disjunctive-Motivation-and-first-examples},
except that \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
has a type parameter instead of a fixed type \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}.
Another difference is the use of a \inputencoding{latin9}\lstinline!case object!\inputencoding{utf8}
for the empty case instead of an empty case class, such as \inputencoding{latin9}\lstinline!None()!\inputencoding{utf8}.
Since Scala's \inputencoding{latin9}\lstinline!case object!\inputencoding{utf8}s
cannot have type parameters, the type parameter in the definition
of \inputencoding{latin9}\lstinline!None!\inputencoding{utf8} must
be set to the special type \inputencoding{latin9}\lstinline!Nothing!\inputencoding{utf8},
which is a type with \emph{no} values (also known as the \textbf{void}
type\index{void type}).

An alternative (implemented in libraries such as \texttt{scalaz})
is to define \inputencoding{latin9}
\begin{lstlisting}
final case class None[T]() extends Option[T]
\end{lstlisting}
\inputencoding{utf8}and write the empty option value as \inputencoding{latin9}\lstinline!None()!\inputencoding{utf8}.
In that implementation, the empty option also has a type parameter.

Several consequences follow from the Scala library's decision to define
\inputencoding{latin9}\lstinline!None!\inputencoding{utf8} without
a type parameter. One consequence is that the single value \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}
can be reused as a value of type \inputencoding{latin9}\lstinline!Option[A]!\inputencoding{utf8}
for any type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> val y: Option[Int] = None
y: Option[Int] = None

scala> val z: Option[String] = None
z: Option[String] = None
\end{lstlisting}
\inputencoding{utf8}
Typically, \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
is used in situations where a value may be either present or missing,
especially when a missing value is \emph{not an error}. The missing-value
case is represented by \inputencoding{latin9}\lstinline!None!\inputencoding{utf8},
while \inputencoding{latin9}\lstinline!Some(x)!\inputencoding{utf8}
means that a value \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
is present.

\subsubsection{Example \label{subsec:Disjunctive-Example-option-1}\ref{subsec:Disjunctive-Example-option-1}\index{solved examples}}

Suppose that information about subscribers to a certain online service
must contain a name and an email address, but a telephone number is
optional. To represent this information, we may define a case class
like this,\inputencoding{latin9}
\begin{lstlisting}
case class Subscriber(name: String, email: String, phone: Option[Long])
\end{lstlisting}
\inputencoding{utf8}What if we represent the missing telephone number by a special value
such as \inputencoding{latin9}\lstinline!-1!\inputencoding{utf8}
and use the simpler type \inputencoding{latin9}\lstinline!Long!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!Option[Long]!\inputencoding{utf8}?
The disadvantage is that we would need to \emph{remember} to check
for the special value \inputencoding{latin9}\lstinline!-1!\inputencoding{utf8}
in all functions that take the telephone number as an argument. Looking
at a function such as \inputencoding{latin9}\lstinline!sendSMS(phone: Long)!\inputencoding{utf8}
at a different place in the code, a programmer might forget that the
telephone number is actually optional. In contrast, the type signature
\inputencoding{latin9}\lstinline!sendSMS(phone: Option[Long])!\inputencoding{utf8}
unambiguously indicates that the telephone number might be missing
and helps the programmer to remember that case.

Pattern-matching code involving \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
needs two cases:\inputencoding{latin9}
\begin{lstlisting}
def getDigits(phone: Option[Long]): Option[Seq[Long]] = phone match {
  case None               => None   // Do nothing.
  case Some(number)       => Some(digitsOf(number))
}
\end{lstlisting}
\inputencoding{utf8}Here we used the function \inputencoding{latin9}\lstinline!digitsOf!\inputencoding{utf8}
defined in Section~\ref{sec:ch2Converting-a-single}. 

At the two sides of \inputencoding{latin9}\lstinline!case None => None!\inputencoding{utf8},
the value \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}
has different types, namely \inputencoding{latin9}\lstinline!Option[Long]!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Option[Seq[Long]]!\inputencoding{utf8}.
Since these types are declared in the type signature of the function
\inputencoding{latin9}\lstinline!getDigits!\inputencoding{utf8},
the Scala compiler is able to figure out the types of all expressions
in the \inputencoding{latin9}\lstinline!match!\inputencoding{utf8}
/ \inputencoding{latin9}\lstinline!case!\inputencoding{utf8} construction.
So, pattern-matching code can be written without explicit type annotations\index{type annotation}
such as \inputencoding{latin9}\lstinline!(None: Option[Long])!\inputencoding{utf8}.

If we now need to compute the number of digits, we can write\inputencoding{latin9}
\begin{lstlisting}
def numberOfDigits(phone: Option[Long]): Option[Long] = getDigits(phone) match {
  case None               => None   // Do nothing.
  case Some(digits)       => Some(digits.length)
}
\end{lstlisting}
\inputencoding{utf8}
These examples perform a computation when an \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
value is non-empty, and leave it empty otherwise. To avoid repeating
this kind of code, we can implement this design pattern as a function
that takes the computation as a parameter: \inputencoding{latin9}
\begin{lstlisting}
def doComputation(x: Option[Long], f: Long => Long): Option[Long] = x match {
  case None               => None   // Do nothing.
  case Some(i)            => Some(f(i))
}
\end{lstlisting}
\inputencoding{utf8}It is then natural to generalize this function to arbitrary types
using type parameters instead of a fixed type \inputencoding{latin9}\lstinline!Long!\inputencoding{utf8}.
The resulting function is usually called \inputencoding{latin9}\lstinline!fmap!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def fmap[A, B](f: A => B): Option[A] => Option[B] = {
  case None               => None   // Do nothing.
  case Some(a)            => Some(f(a))
}

scala> fmap(digitsOf)(Some(4096))
res0: Option[Seq[Long]] = Some(List(4, 0, 9, 6))

scala> fmap(digitsOf)(None)
res1: Option[Seq[Long]] = None
\end{lstlisting}
\inputencoding{utf8}One can say that the \inputencoding{latin9}\lstinline!fmap!\inputencoding{utf8}
operation \textbf{lifts}\index{lifting} a given function of type
\inputencoding{latin9}\lstinline!A => B!\inputencoding{utf8} to the
type \inputencoding{latin9}\lstinline!Option[A] => Option[B]!\inputencoding{utf8}.

The Scala library implements an equivalent function as a method on
the \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
class, with the syntax \inputencoding{latin9}\lstinline!x.map(f)!\inputencoding{utf8}
rather than \inputencoding{latin9}\lstinline!fmap(f)(x)!\inputencoding{utf8}.
We can concisely rewrite the previous code using the standard library
methods as\inputencoding{latin9}
\begin{lstlisting}
def getDigits(phone: Option[Long]): Option[Seq[Long]] = phone.map(digitsOf)
def numberOfDigits(phone: Option[Long]): Option[Long] = phone.map(digitsOf).map(_.length)
\end{lstlisting}
\inputencoding{utf8}We see that the \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
operation for the \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
type is analogous to the \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
operation for sequences. 

The similarity between \inputencoding{latin9}\lstinline!Option[A]!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8}
is made clearer if we view \inputencoding{latin9}\lstinline!Option[A]!\inputencoding{utf8}
as a special kind of ``sequence'' whose length is restricted to
be either $0$ or $1$. So, \inputencoding{latin9}\lstinline!Option[A]!\inputencoding{utf8}
can have all the operations of \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8},
except the operations such as \inputencoding{latin9}\lstinline!.concat!\inputencoding{utf8}
that may increase the length of the sequence. The standard operations
defined on \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
include \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.forall!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.exists!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8}.

\subsubsection{Example \label{subsec:Disjunction-Example-Option-flatMap}\ref{subsec:Disjunction-Example-Option-flatMap}}

Given a phone number as \inputencoding{latin9}\lstinline!Option[Long]!\inputencoding{utf8},
extract the country code if it is present. (Assume that the country
code is any digits in front of the $10$-digit number; for the phone
number $18004151212$, the country code is $1$.) The result must
be again of type \inputencoding{latin9}\lstinline!Option[Long]!\inputencoding{utf8}.

\subparagraph{Solution}

If the phone number is a positive integer $n$, we may compute the
country code simply as \inputencoding{latin9}\lstinline!n / 10000000000L!\inputencoding{utf8}.
However, if the result of that division is zero, we should return
an empty \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
(i.e.~the value \inputencoding{latin9}\lstinline!None!\inputencoding{utf8})
rather than \inputencoding{latin9}\lstinline!0!\inputencoding{utf8}.
To implement this logic, we may begin by writing this code,\inputencoding{latin9}
\begin{lstlisting}
def countryCode(phone: Option[Long]): Option[Long] = phone match {
  case None      => None
  case Some(n)   =>
    val countryCode = n / 10000000000L
    if (countryCode != 0L) Some(countryCode) else None 
}
\end{lstlisting}
\inputencoding{utf8}We may notice that we have reimplemented the design pattern similar
to \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8} in
this code, namely ``if \inputencoding{latin9}\lstinline!None!\inputencoding{utf8},
return \inputencoding{latin9}\lstinline!None!\inputencoding{utf8},
else do a computation''. So we may try to rewrite the code as\inputencoding{latin9}
\begin{lstlisting}
def countryCode(phone: Option[Long]): Option[Long] = phone.map { n =>
    val countryCode = n / 10000000000L
    if (countryCode != 0L) Some(countryCode) else None 
} // Type error: the result is Option[Option[Long]], not Option[Long].
\end{lstlisting}
\inputencoding{utf8}This code does not compile: we are returning an \inputencoding{latin9}\lstinline!Option[Long]!\inputencoding{utf8}
within a function lifted via \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
so the resulting type is \inputencoding{latin9}\lstinline!Option[Option[Long]]!\inputencoding{utf8}.
We may use \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
to convert \inputencoding{latin9}\lstinline!Option[Option[Long]]!\inputencoding{utf8}
to the required type \inputencoding{latin9}\lstinline!Option[Long]!\inputencoding{utf8},\inputencoding{latin9}
\begin{lstlisting}
def countryCode(phone: Option[Long]): Option[Long] = phone.map { n =>
    val countryCode = n / 10000000000L
    if (countryCode != 0L) Some(countryCode) else None 
}.flatten // Types are correct now.
\end{lstlisting}
\inputencoding{utf8}Since the \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
follows a \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
we can rewrite the code using \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def countryCode(phone: Option[Long]): Option[Long] = phone.flatMap { n =>
    val countryCode = n / 10000000000L
    if (countryCode != 0L) Some(countryCode) else None 
} // Types are correct now.
\end{lstlisting}
\inputencoding{utf8}Another way of implementing this example is to notice the design pattern
``if condition does not hold, return \inputencoding{latin9}\lstinline!None!\inputencoding{utf8},
otherwise keep the value''. For an \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
type, this is equivalent to the \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}
operation (recall that \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}
returns an empty sequence if the predicate never holds). So the final
code is\inputencoding{latin9}
\begin{lstlisting}
def countryCode(phone: Option[Long]): Option[Long] = 
  phone.map(_ / 10000000000L).filter(_ != 0L)
\end{lstlisting}
\inputencoding{utf8}Test it:\inputencoding{latin9}
\begin{lstlisting}
scala> countryCode(Some(18004151212L))
res0: Option[Long] = Some(1)

scala> countryCode(Some(8004151212L))
res1: Option[Long] = None
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Disjunction-Example-Option-getOrElse}\ref{subsec:Disjunction-Example-Option-getOrElse}}

Add a new requirement to the phone number example: if the country
code is not present, we should return the default country code $1$.
This is an often used design pattern: ``if empty, substitute a default
value''. The Scala library has the method \inputencoding{latin9}\lstinline!.getOrElse!\inputencoding{utf8}
for this purpose:\inputencoding{latin9}
\begin{lstlisting}
scala> Some(100).getOrElse(1)
res2: Int = 100

scala> None.getOrElse(1)
res3: Int = 1
\end{lstlisting}
\inputencoding{utf8}So we can implement the new requirement as\inputencoding{latin9}
\begin{lstlisting}
scala> countryCode(Some(8004151212L)).getOrElse(1L)
res4: Long = 1
\end{lstlisting}
\inputencoding{utf8}

\paragraph{Using \texttt{Option} with collections}

Many Scala library methods return an \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
as a result. The main examples are \inputencoding{latin9}\lstinline!.find!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.headOption!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!.lift!\inputencoding{utf8} for
sequences, and \inputencoding{latin9}\lstinline!.get!\inputencoding{utf8}
for dictionaries.

The \inputencoding{latin9}\lstinline!.find!\inputencoding{utf8} method
returns the first element satisfying a predicate:\inputencoding{latin9}
\begin{lstlisting}
scala> (1 to 10).find(_ > 5)
res0: Option[Int] = Some(6)

scala> (1 to 10).find(_ > 10) // No element is > 10.
res1: Option[Int] = None
\end{lstlisting}
\inputencoding{utf8}
The \inputencoding{latin9}\lstinline!.lift!\inputencoding{utf8} method
returns the element of a sequence at a given index:\inputencoding{latin9}
\begin{lstlisting}
scala> (10 to 100).lift(0)
res2: Option[Int] = Some(10)

scala> (10 to 100).lift(1000) // No element at index 1000.
res3: Option[Int] = None
\end{lstlisting}
\inputencoding{utf8}
The \inputencoding{latin9}\lstinline!.headOption!\inputencoding{utf8}
method returns the first element of a sequence, unless the sequence
is empty. This is equivalent to \inputencoding{latin9}\lstinline!.lift(0)!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> Seq(1,2,3).headOption
res4: Option[Int] = Some(1)

scala> Seq(1,2,3).filter(_ > 10).headOption
res5: Option[Int] = None
\end{lstlisting}
\inputencoding{utf8}Applying \inputencoding{latin9}\lstinline!.find(p)!\inputencoding{utf8}
computes the same result as \inputencoding{latin9}\lstinline!.filter(p).headOption!\inputencoding{utf8},
but \inputencoding{latin9}\lstinline!.find(p)!\inputencoding{utf8}
may be more efficient.

The \inputencoding{latin9}\lstinline!.get!\inputencoding{utf8} method
for a dictionary returns the value if it exists for a given key, and
returns \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}
if the key is not in the dictionary:\inputencoding{latin9}
\begin{lstlisting}
scala> Map(10 -> "a", 20 -> "b").get(10)
res6: Option[String] = Some(a)

scala> Map(10 -> "a", 20 -> "b").get(30)
res7: Option[String] = None 
\end{lstlisting}
\inputencoding{utf8}The \inputencoding{latin9}\lstinline!.get!\inputencoding{utf8} method
provides safe by-key access to dictionaries, unlike the direct access
method that may fail:\inputencoding{latin9}
\begin{lstlisting}
scala> Map(10 -> "a", 20 -> "b")(10)
res8: String = a 

scala> Map(10 -> "a", 20 -> "b")(30)
java.util.NoSuchElementException: key not found: 30
  at scala.collection.MapLike$class.default(MapLike.scala:228)
  at scala.collection.AbstractMap.default(Map.scala:59)
  ... 32 elided
\end{lstlisting}
\inputencoding{utf8}Similarly, \inputencoding{latin9}\lstinline!.lift!\inputencoding{utf8}
provides safe by-index access to collections, unlike the direct access
that may fail:\inputencoding{latin9}
\begin{lstlisting}
scala> Seq(10,20,30)(0)
res9: Int = 10

scala> Seq(10,20,30)(5)
java.lang.IndexOutOfBoundsException: 5
  at scala.collection.LinearSeqOptimized$class.apply(LinearSeqOptimized.scala:65)
  at scala.collection.immutable.List.apply(List.scala:84)
  ... 32 elided
\end{lstlisting}
\inputencoding{utf8}

\paragraph{\texttt{Either}}

The standard disjunctive type \inputencoding{latin9}\lstinline!Either[A, B]!\inputencoding{utf8}
has two type parameters and is often used for computations that report
errors. By convention, the \emph{first} type (\inputencoding{latin9}\lstinline!A!\inputencoding{utf8})
is the type of error, and the \emph{second} type (\inputencoding{latin9}\lstinline!B!\inputencoding{utf8})
is the type of the (non-error) result. The names of the two cases
are \inputencoding{latin9}\lstinline!Left!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!Right!\inputencoding{utf8}. A possible
definition of \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
may be written as\inputencoding{latin9}
\begin{lstlisting}
sealed trait Either[A, B]
final case class  Left[A, B](value: A) extends Either[A, B]
final case class Right[A, B](value: B) extends Either[A, B]
\end{lstlisting}
\inputencoding{utf8}By convention, a value \inputencoding{latin9}\lstinline!Left(x)!\inputencoding{utf8}
is used to represent an error, and a value \inputencoding{latin9}\lstinline!Right(y)!\inputencoding{utf8}
is used to represent a valid result.

As an example, the following function substitutes a default value
and logs the error information:\inputencoding{latin9}
\begin{lstlisting}
def logError(x: Either[String, Int], default: Int): Int = x match {
  case Left(error)  => println(s"Got error: $error"); default
  case Right(res)   => res
}
\end{lstlisting}
\inputencoding{utf8}To test:\inputencoding{latin9}
\begin{lstlisting}
scala> logError(Right(123), -1)
res1: Int = 123

scala> logError(Left("bad result"), -1)
Got error: bad result
res2: Int = -1
\end{lstlisting}
\inputencoding{utf8}
Why use \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
for computations that may fail? A failing computation such as \inputencoding{latin9}\lstinline!1/0!\inputencoding{utf8}
could return \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}
to indicate that the result is not available. However, the result
is not an optional value that may be missing; usually the result is
required, and if it is not available, we need to know exactly \emph{which}
error prevented the result from being available. The \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
type provides the possibility to store information about the error,
which \inputencoding{latin9}\lstinline!Option!\inputencoding{utf8}
does not provide.

The \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
type generalizes the type \inputencoding{latin9}\lstinline!Result!\inputencoding{utf8}
defined in Section~\ref{subsec:Disjunctive-Motivation-and-first-examples}
with an arbitrary error type instead of \inputencoding{latin9}\lstinline!String!\inputencoding{utf8}.
We have seen its usage in Example~\ref{subsec:disj-Example-resultA},
where the design pattern was ``if value is present, do a computation,
otherwise keep the error''. This design pattern is implemented by
the \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8} method
on \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> Right(1).map(_ + 1)
res0: Either[Nothing, Int] = Right(2)

scala> Left[String, Int]("error").map(_ + 1)
res1: Either[String, Int] = Left("error")
\end{lstlisting}
\inputencoding{utf8}The type \inputencoding{latin9}\lstinline!Nothing!\inputencoding{utf8}
was filled in by the Scala compiler because we did not specify the
full type of \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
in the first line.

The methods \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.fold!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!.getOrElse!\inputencoding{utf8}
are also defined for the \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
class, with the same convention that a \inputencoding{latin9}\lstinline!Left!\inputencoding{utf8}
value represents an error.\footnote{These methods are available in Scala 2.12 or a later version.}

\paragraph{Exceptions and the \texttt{Try} type}

When computations fail for any reason, Scala generates an \textbf{exception\index{exception}}
instead of returning a value. An exception means that the evaluation
of the expression was stopped without returning a result.

An exception is generated when the available memory is too small to
store the resulting data (as we saw in Section~\ref{subsec:Lazy-values-iterators-and-streams}),
or if a stack overflow occurs during the computation (as we saw in
Section~\ref{subsec:Tail-recursion}). Exceptions may also occur
due to programmer's error: when a pattern matching operation fails,
when a requested key does not exist in a dictionary, or when the \inputencoding{latin9}\lstinline!.head!\inputencoding{utf8}
operation is applied to an empty list.

Motivated by these examples, we may distinguish ``planned\index{planned exception}''
and ``unplanned'' exceptions. 

A \textbf{planned} exception is generated by programmer's code via
the \inputencoding{latin9}\lstinline!throw!\inputencoding{utf8} syntax:\inputencoding{latin9}
\begin{lstlisting}
scala> throw new Exception("this is a test... this is only a test")
java.lang.Exception: this is a test... this is only a test
  ... 42 elided
\end{lstlisting}
\inputencoding{utf8}The Scala library contains a \inputencoding{latin9}\lstinline!throw!\inputencoding{utf8}
operation in various places, such as in the code for applying the
\inputencoding{latin9}\lstinline!.head!\inputencoding{utf8} method
to an empty sequence, as well as in other situations where exceptions
are generated due to programmer's errors. These exceptions are generated
deliberately and in well-defined situations. Although these exceptions
indicate errors, these errors are anticipated in advance and so may
be handled by the programmer.

For example, many Java libraries will generate exceptions when function
arguments have unexpected values, when a network operation takes too
long or fails to make a network connection, when a file is not found
or cannot be read, and in many other situations. All these exceptions
are ``planned'' because they are generated explicitly by library
code such as \inputencoding{latin9}\lstinline!throw new FileNotFoundException(...)!\inputencoding{utf8}.
The programmer's code is expected to catch these exceptions, to handle
the problem, and to continue the evaluation of the program.

An \textbf{unplanned} exception\index{unplanned exception} is generated
by the Java runtime system when critical errors occur, such as an
out-of-memory error. It is rare that a programmer writes \inputencoding{latin9}\lstinline!val y = f(x)!\inputencoding{utf8}
while \emph{expecting} that an out-of-memory exception will sometimes
occur at that point. An unplanned exception indicates a serious and
unforeseen problem with memory or another critically important resource,
such as the operating system's threads or file handles. Such problems
usually cannot be fixed and will prevent the program from running
any further. It is reasonable that the program evaluation should immediately
stop (or ``crash'' as programmers say) after such an error.

The use of planned exceptions assumes that the programmer will write
code to handle each exception. This assumption makes it significantly
harder to write programs correctly. It is hard to figure out and to
keep in mind all the possible exceptions that a given library function
may \inputencoding{latin9}\lstinline!throw!\inputencoding{utf8} in
its code (or in the code of all other libraries on which it depends).
Instead of using exceptions for indicating errors, Scala programmers
can write functions that return a disjunctive type such as \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8},
describing both the correct result and a possible error condition.
Users of these functions will need to do pattern matching on the results,
which indicates unambiguously both the possible presence of errors
and the kinds of errors that need to be handled.

However, the programmer will often need to use Java libraries (or
Scala libraries) that \inputencoding{latin9}\lstinline!throw!\inputencoding{utf8}
exceptions. To help write code for these situations, the Scala library
contains a helper function called \inputencoding{latin9}\lstinline!Try()!\inputencoding{utf8}
and a disjunctive type also called \inputencoding{latin9}\lstinline!Try!\inputencoding{utf8}.
The type \inputencoding{latin9}\lstinline!Try[A]!\inputencoding{utf8}
can be seen as similar to \inputencoding{latin9}\lstinline!Either[Throwable, A]!\inputencoding{utf8},
where \inputencoding{latin9}\lstinline!Throwable!\inputencoding{utf8}
is the general type of all exceptions (i.e.~values to which a \inputencoding{latin9}\lstinline!throw!\inputencoding{utf8}
operation can be applied). The two parts of the disjunctive type \inputencoding{latin9}\lstinline!Try[A]!\inputencoding{utf8}
are called \inputencoding{latin9}\lstinline!Failure!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Success[A]!\inputencoding{utf8}
(instead of \inputencoding{latin9}\lstinline!Left[Throwable]!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!Right[A]!\inputencoding{utf8}
in the \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
type). The function \inputencoding{latin9}\lstinline!Try(expr)!\inputencoding{utf8}
will catch all exceptions \inputencoding{latin9}\lstinline!throw!\inputencoding{utf8}n
while the expression \inputencoding{latin9}\lstinline!expr!\inputencoding{utf8}
is evaluated. If the evaluation of \inputencoding{latin9}\lstinline!expr!\inputencoding{utf8}
succeeds and returns a value \inputencoding{latin9}\lstinline!x:A!\inputencoding{utf8},
the value of \inputencoding{latin9}\lstinline!Try(expr)!\inputencoding{utf8}
will be \inputencoding{latin9}\lstinline!Success(x)!\inputencoding{utf8}.
Otherwise it will be \inputencoding{latin9}\lstinline!Failure(t)!\inputencoding{utf8},
where \inputencoding{latin9}\lstinline!t:Throwable!\inputencoding{utf8}
is the value associated with the generated exception. Here is an example
of using \inputencoding{latin9}\lstinline!Try!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
import scala.util.{Try,Success,Failure}

scala> Try(1 / 0)
res0: Try[Int] = Failure(java.lang.ArithmeticException: / by zero)

scala> Try(1 + 1)
res1: Try[Int] = Success(2) 
\end{lstlisting}
\inputencoding{utf8}Unlike computing \inputencoding{latin9}\lstinline!1/0!\inputencoding{utf8}
without an enclosing \inputencoding{latin9}\lstinline!Try()!\inputencoding{utf8},
the computation \inputencoding{latin9}\lstinline!Try(1/0)!\inputencoding{utf8}
does not generate any exceptions and will not crash the program. Any
computation that may \inputencoding{latin9}\lstinline!throw!\inputencoding{utf8}
an exception can be enclosed in a \inputencoding{latin9}\lstinline!Try()!\inputencoding{utf8},
and the exception will be caught and encapsulated within the disjunctive
type as a \inputencoding{latin9}\lstinline!Failure(...)!\inputencoding{utf8}
value.

The methods \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.foldLeft!\inputencoding{utf8} are
defined for the \inputencoding{latin9}\lstinline!Try!\inputencoding{utf8}
class similarly to the \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
type. One additional feature of \inputencoding{latin9}\lstinline!Try!\inputencoding{utf8}
is to catch exceptions generated by the function arguments of \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}, etc.:\inputencoding{latin9}
\begin{lstlisting}
scala> val x = Try(1)
x: scala.util.Try[Int] = Success(1)

scala> val y: Try[Int] = x.map(y => throw new Exception("test1"))
y: scala.util.Try[Int] = Failure(java.lang.Exception: test1)

scala> val z = x.filter(y => throw new Exception("test1"))
z: scala.util.Try[Int] = Failure(java.lang.Exception: test1)
\end{lstlisting}
\inputencoding{utf8}In this example, the values \inputencoding{latin9}\lstinline!y!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!z!\inputencoding{utf8} were
computed \emph{successfully} even though exceptions were thrown while
the function arguments of \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}
were evaluated. Other code can use pattern matching on the values
\inputencoding{latin9}\lstinline!y!\inputencoding{utf8} and \inputencoding{latin9}\lstinline!z!\inputencoding{utf8}
and determine which exceptions occurred. However, it is important
that these exceptions were caught and the other code is \emph{able}
to run. 

Another useful method is \inputencoding{latin9}\lstinline!.toOption!\inputencoding{utf8};
it will discard the error information:\inputencoding{latin9}
\begin{lstlisting}
scala> Try(1 / 0).toOption
res2: Option[Int] = None

scala> Try(1 + 1).toOption
res3: Option[Int] = Some(2)
\end{lstlisting}
\inputencoding{utf8}
Instead of exceptions, programmers can use \emph{values} of type \inputencoding{latin9}\lstinline!Try!\inputencoding{utf8}
or of other disjunctive types in order to represent all anticipated
failures or errors. Representing all errors by ordinary Scala values
gives us assurance that the program will not crash because of an exception
that we did not know about or forgot to handle.

\section{Lists and trees: recursive disjunctive types}

Consider this code:\inputencoding{latin9}
\begin{lstlisting}
sealed trait NInt
final case class One(x: Int) extends NInt
final case class Two(n: NInt) extends NInt
\end{lstlisting}
\inputencoding{utf8}We are defining a new disjunctive type \inputencoding{latin9}\lstinline!NInt!\inputencoding{utf8},
but the case class \inputencoding{latin9}\lstinline!Two!\inputencoding{utf8}
uses the type \inputencoding{latin9}\lstinline!NInt!\inputencoding{utf8}
as if it were already defined. Scala allows us to write such definitions.

A type whose definition uses that same type is called a \index{recursive type}\textbf{recursive
type}. So, \inputencoding{latin9}\lstinline!NInt!\inputencoding{utf8}
is a recursive disjunctive type.

We might imagine a disjunctive type with many case classes whose parts
are recursively using the same type in complicated ways. What would
this data type be useful for, and what kind of data does it represent?
In general, this question is not easy to answer. For instance, the
simple definition\inputencoding{latin9}
\begin{lstlisting}
final case class Bad(x: Bad)
\end{lstlisting}
\inputencoding{utf8}is useless: to create a value of type \inputencoding{latin9}\lstinline!Bad!\inputencoding{utf8}
we already need to have a value of type \inputencoding{latin9}\lstinline!Bad!\inputencoding{utf8}.
This is an example of an infinite type recursion\index{infinite type recursion}.
We will never be able to create any values of type \inputencoding{latin9}\lstinline!Bad!\inputencoding{utf8},
which means that the type \inputencoding{latin9}\lstinline!Bad!\inputencoding{utf8}
is effectively \textbf{void\index{void type}} (has no values, like
the the special type \inputencoding{latin9}\lstinline!Nothing!\inputencoding{utf8}).

Chapter~\ref{chap:Recursive-types} studies recursive types in more
detail. For now, we will look at the main examples of recursive disjunctive
types that are \emph{known} to be useful. These examples are lists
and trees.

\subsection{Lists}

A list of values of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
is either empty, or one value of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8},
or two values of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8},
etc. We can visualize the type \inputencoding{latin9}\lstinline!List[A]!\inputencoding{utf8}
as a disjunctive type defined by\inputencoding{latin9}
\begin{lstlisting}
sealed trait List[A]
final case class List0[A]() extends List[A]
final case class List1[A](x: A) extends List[A]
final case class List2[A](x1: A, x2: A) extends List[A]
??? // Need an infinitely long definition.
\end{lstlisting}
\inputencoding{utf8}However, this definition is not practical â we cannot define a separate
case class for a list of \emph{each} possible length. Instead, we
define the type \inputencoding{latin9}\lstinline!List[A]!\inputencoding{utf8}
via mathematical induction on the length of the list:
\begin{itemize}
\item Base case: empty list, \inputencoding{latin9}\lstinline!case class List0[A]()!\inputencoding{utf8}.
\item Inductive step: given a list of a previously defined length, say \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}$_{n-1}$,
define a new case class \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}$_{n}$
describing a list with one more element of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}.
So we could define \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}$_{n}=\,$\inputencoding{latin9}\lstinline!(List!\inputencoding{utf8}$_{n-1}$\inputencoding{latin9}\lstinline!, A)!\inputencoding{utf8}.
\end{itemize}
Let us try to write this inductive definition as code:\inputencoding{latin9}
\begin{lstlisting}
sealed trait ListI[A] // Inductive definition of a list.
final case class List0[A]() extends ListI[A]
final case class List1[A](prev: List0[A], x: A) extends ListI[A]
final case class List2[A](prev: List1[A], x: A) extends ListI[A]
??? // Still need an infinitely long definition.
\end{lstlisting}
\inputencoding{utf8}To avoid writing an infinitely long type definition, we need to use
a trick. Notice that all definitions of \inputencoding{latin9}\lstinline!List1!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!List2!\inputencoding{utf8}, etc.,
have a similar form (while \inputencoding{latin9}\lstinline!List0!\inputencoding{utf8}
is not similar). We can replace all the definitions \inputencoding{latin9}\lstinline!List1!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!List2!\inputencoding{utf8}, etc.,
by a single definition if we use the type \inputencoding{latin9}\lstinline!ListI[A]!\inputencoding{utf8}
recursively inside the case class:\inputencoding{latin9}
\begin{lstlisting}
sealed trait ListI[A] // Inductive definition of a list.
final case class List0[A]() extends ListI[A]
final case class ListN[A](prev: ListI[A], x: A) extends ListI[A]
\end{lstlisting}
\inputencoding{utf8}The type definition has become recursive. For this trick to work,
it is important to use \inputencoding{latin9}\lstinline!ListI[A]!\inputencoding{utf8}
and not \inputencoding{latin9}\lstinline!ListN[A]!\inputencoding{utf8}
inside the definition \inputencoding{latin9}\lstinline!ListN[A]!\inputencoding{utf8};
or else we would have created an infinite type recursion\index{infinite type recursion}
similar to \inputencoding{latin9}\lstinline!case class Bad!\inputencoding{utf8}
shown above.

Since we obtained the type definition of \inputencoding{latin9}\lstinline!ListI!\inputencoding{utf8}
via a trick, let us verify that the code actually defines the disjunctive
type we wanted. 

To create a value of type \inputencoding{latin9}\lstinline!ListI[A]!\inputencoding{utf8},
we must use one of the two available case classes. Using the first
case class, we may create a value \inputencoding{latin9}\lstinline!List0()!\inputencoding{utf8}.
Since this empty case class does not contain any values of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8},
it effectively represents an empty list (the base case of the induction).
Using the second case class, we may create a value \inputencoding{latin9}\lstinline!ListN(prev, x)!\inputencoding{utf8}
where \inputencoding{latin9}\lstinline!x!\inputencoding{utf8} is
of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!prev!\inputencoding{utf8} is some
previously constructed value of type \inputencoding{latin9}\lstinline!ListI[A]!\inputencoding{utf8}.
This represents the induction step, because the case class \inputencoding{latin9}\lstinline!ListN!\inputencoding{utf8}
is a named tuple containing \inputencoding{latin9}\lstinline!ListI[A]!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}. Now,
the same consideration recursively applies to constructing the value
\inputencoding{latin9}\lstinline!prev!\inputencoding{utf8}, which
must be either an empty list or a pair containing another list and
an element of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}.
The assumption that the value \inputencoding{latin9}\lstinline!prev:ListI[A]!\inputencoding{utf8}
is already constructed is equivalent to the inductive assumption that
we already have a list of a previously defined length. So, we have
verified that \inputencoding{latin9}\lstinline!ListI[A]!\inputencoding{utf8}
implements the inductive definition shown above.

Examples of values of type \inputencoding{latin9}\lstinline!ListI!\inputencoding{utf8}
are the empty list \inputencoding{latin9}\lstinline!List0()!\inputencoding{utf8},
a one-element list \inputencoding{latin9}\lstinline!ListN(List0(), x)!\inputencoding{utf8},
and a two-element list \inputencoding{latin9}\lstinline!ListN(ListN(List0(), x), y)!\inputencoding{utf8}.

To illustrate writing pattern-matching code using this type, let us
implement the method \inputencoding{latin9}\lstinline!headOption!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
@tailrec def headOption[A]: ListI[A] => Option[A] = {
  case List0()               => None
  case ListN(List0(), x)     => Some(x)
  case ListN(prev, _)        => headOption(prev)
}
\end{lstlisting}
\inputencoding{utf8}
The Scala library already defines the type \inputencoding{latin9}\lstinline!List[A]!\inputencoding{utf8},
but its case classes are named differently, and the second case class
uses the name \inputencoding{latin9}\lstinline!::!\inputencoding{utf8}
with an infix syntax and places the value of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
\emph{before} the previously constructed list,\inputencoding{latin9}
\begin{lstlisting}
sealed trait List[A]
final case object Nil extends List[Nothing]
final case class ::[A](head: A, tail: List[A]) extends List[A]
\end{lstlisting}
\inputencoding{utf8}Because ``operator-like'' case class names, such as \inputencoding{latin9}\lstinline!::!\inputencoding{utf8},
support the infix syntax, we may write \inputencoding{latin9}\lstinline!head :: tail!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!::(head, tail)!\inputencoding{utf8}.
Pattern matching with the standard \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}
class looks like this:\inputencoding{latin9}
\begin{lstlisting}
def headOption[A]: List[A] => Option[A] = {
  case Nil            => None
  case head :: tail   => Some(head)
}
\end{lstlisting}
\inputencoding{utf8}Examples of values created using Scala's standard \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}
type are the empty list \inputencoding{latin9}\lstinline!Nil!\inputencoding{utf8},
a one-element list \inputencoding{latin9}\lstinline!x :: Nil!\inputencoding{utf8},
and a two-element list \inputencoding{latin9}\lstinline!x :: y :: Nil!\inputencoding{utf8}.
We see that list values are easier to read in the standard syntax.
The same syntax such as \inputencoding{latin9}\lstinline!x :: y :: Nil!\inputencoding{utf8}
is used both for creating values of type \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}
and for pattern-matching on such values. 

The Scala library also defines the helper function \inputencoding{latin9}\lstinline!List()!\inputencoding{utf8},
so that \inputencoding{latin9}\lstinline!List()!\inputencoding{utf8}
is the same as \inputencoding{latin9}\lstinline!Nil!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!List(1, 2, 3)!\inputencoding{utf8}
is the same as \inputencoding{latin9}\lstinline!1 :: 2 :: 3 :: Nil!\inputencoding{utf8}.

\subsection{Tail recursion with \texttt{List}\label{subsec:Tail-recursion-with-list}}

Because the \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}
type is defined by induction, it is straightforward to implement iterative
computations with the \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}
type using recursion.

A first example is the \inputencoding{latin9}\lstinline!map!\inputencoding{utf8}
function. We use reasoning by induction in order to figure out the
implementation of \inputencoding{latin9}\lstinline!map!\inputencoding{utf8}.
The required type signature is\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](xs: List[A])(f: A => B): List[B] = ???
\end{lstlisting}
\inputencoding{utf8}The base case is an empty list, and we return again an empty list:\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](xs: List[A])(f: A => B): List[B] = xs match {
  case Nil => Nil
  ...
\end{lstlisting}
\inputencoding{utf8}In the induction step, we have a pair \inputencoding{latin9}\lstinline!(head, tail)!\inputencoding{utf8}
in the case class \inputencoding{latin9}\lstinline!::!\inputencoding{utf8},
where \inputencoding{latin9}\lstinline!head:A!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!tail:List[A]!\inputencoding{utf8}.
The pair can be pattern-matched with the syntax \inputencoding{latin9}\lstinline!head :: tail!\inputencoding{utf8}.
The \inputencoding{latin9}\lstinline!map!\inputencoding{utf8} function
should apply the argument \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
to the head value, which will give the first element of the resulting
list. The remaining elements are computed by the induction assumption,
i.e.~by a recursive call to \inputencoding{latin9}\lstinline!map!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](xs: List[A])(f: A => B): List[B] = xs match {
  case Nil           => Nil
  case head :: tail  => f(head) :: map(tail)(f) // Not tail-recursive.
\end{lstlisting}
\inputencoding{utf8}While this implementation is straightforward and concise, it is not
tail-recursive. This will be a problem for large enough lists.

Instead of implementing the often-used methods such as \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!.filter!\inputencoding{utf8}
one by one, let us implement \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
because most of the other methods can be expressed via \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}. 

The required type signature is\inputencoding{latin9}
\begin{lstlisting}
def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R = ???
\end{lstlisting}
\inputencoding{utf8}Reasoning by induction, we start with the base case, where we have
an empty list, and the only possibility is to return the value \inputencoding{latin9}\lstinline!init!\inputencoding{utf8}.\inputencoding{latin9}
\begin{lstlisting}
def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R = xs match {
    case Nil            => init
    ...
\end{lstlisting}
\inputencoding{utf8}The induction step for \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
says that, given the values \inputencoding{latin9}\lstinline!head:A!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!tail:List[A]!\inputencoding{utf8},
we need to apply the updater function to the previous accumulator
value. That value is \inputencoding{latin9}\lstinline!init!\inputencoding{utf8}.
So we apply \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
recursively to the tail of the list once we have the updated accumulator
value:\inputencoding{latin9}
\begin{lstlisting}
@tailrec def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R =
  xs match {
    case Nil            => init
    case head :: tail   => 
      val newInit = f(init, head) // Update the accumulator.
      foldLeft(tail)(newInit)(f)  // Recursive call to `foldLeft`.
  }
\end{lstlisting}
\inputencoding{utf8}This implementation is tail-recursive because the recursive call to
\inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8} is
the last expression returned in its \inputencoding{latin9}\lstinline!case!\inputencoding{utf8}
branch.

Another example is a function for reversing a list. The Scala library
defines the \inputencoding{latin9}\lstinline!.reverse!\inputencoding{utf8}
method for this task, but we will show an implementation using \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}.
The updater function \emph{prepends} an element to a previous list:\inputencoding{latin9}
\begin{lstlisting}
def reverse[A](xs: List[A]): List[A] =
  xs.foldLeft(Nil: List[A])((prev, x) => x :: prev)

scala> reverse(List(1, 2, 3))
res0: List[Int] = List(3, 2, 1) 
\end{lstlisting}
\inputencoding{utf8}Without the explicit type annotation \inputencoding{latin9}\lstinline!Nil:List[A]!\inputencoding{utf8},
the Scala compiler will decide that \inputencoding{latin9}\lstinline!Nil!\inputencoding{utf8}
has type \inputencoding{latin9}\lstinline!List[Nothing]!\inputencoding{utf8},
and the types will not match later in the code.

The \inputencoding{latin9}\lstinline!reverse!\inputencoding{utf8}
function can be used to obtain a tail-recursive implementation of
\inputencoding{latin9}\lstinline!map!\inputencoding{utf8} for \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}.
The idea is to first use \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
to accumulate transformed elements:\inputencoding{latin9}
\begin{lstlisting}
scala> Seq(1, 2, 3).foldLeft(Nil:List[Int])((prev, x) => x*x :: prev)
res0: List[Int] = List(9, 4, 1)
\end{lstlisting}
\inputencoding{utf8}The result is a reversed \inputencoding{latin9}\lstinline!.map(x => x*x)!\inputencoding{utf8},
so we reverse that:\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](xs: List[A])(f: A => B): List[B] =
  xs.foldLeft(Nil: List[B])((prev, x) => f(x) :: prev).reverse

scala> map(List(1, 2, 3))(x => x*x)
res2: List[Int] = List(1, 4, 9)
\end{lstlisting}
\inputencoding{utf8}This achieves stack safety at the cost of traversing the list twice.
(This implementation is shown only as an example. The Scala library
implements \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
for \inputencoding{latin9}\lstinline!List!\inputencoding{utf8} using
low-level tricks in order to achieve better performance.)

\subsubsection{Example \label{subsec:Disjunctive-Example-non-empty-list-foldLeft}\ref{subsec:Disjunctive-Example-non-empty-list-foldLeft}\index{solved examples}}

A definition of the \textbf{non-empty list\index{non-empty list}}
is similar to \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}
except that the empty-list case is replaced by the $1$-element case:\inputencoding{latin9}
\begin{lstlisting}
sealed trait NEL[A]
final case class Last[A](head: A) extends NEL[A]
final case class More[A](head: A, tail: NEL[A]) extends NEL[A]
\end{lstlisting}
\inputencoding{utf8}Values of a non-empty list look like this:\inputencoding{latin9}
\begin{lstlisting}
scala> val xs: NEL[Int] = More(1, More(2, Last(3))) // [1, 2, 3]
xs: NEL[Int] = More(1,More(2,Last(3)))

scala> val ys: NEL[String] = Last("abc") // One element.
ys: NEL[String] = Last(abc)
\end{lstlisting}
\inputencoding{utf8}To create non-empty lists more easily, we implement a conversion function
from an ordinary list. Since the conversion function must guarantee
that the result is a non-empty list, we give it two arguments:\inputencoding{latin9}
\begin{lstlisting}
def toNEL[A](x: A, rest: List[A]): NEL[A] = rest match {
  case Nil        => Last(x)
  case y :: tail  => More(x, toNEL(y, tail))
} // Not tail-recursive: `toNEL()` is used inside `More(...)`.
\end{lstlisting}
\inputencoding{utf8}To test:\inputencoding{latin9}
\begin{lstlisting}
scala> toNEL(1, List()) // Result = [1].
res0: NEL[Int] = Last(1)

scala> toNEL(1, List(2, 3)) // Result = [1, 2, 3].
res1: NEL[Int] = More(1,More(2,Last(3)))
\end{lstlisting}
\inputencoding{utf8}
The \inputencoding{latin9}\lstinline!head!\inputencoding{utf8} method
is safe for non-empty lists, unlike \inputencoding{latin9}\lstinline!.head!\inputencoding{utf8}
for ordinary \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}s:\inputencoding{latin9}
\begin{lstlisting}
def head[A]: NEL[A] => A = {
    case Last(x)        => x
    case More(x, _)     => x
}
\end{lstlisting}
\inputencoding{utf8}
We can also implement a tail-recursive \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
function for non-empty lists:\inputencoding{latin9}
\begin{lstlisting}
@tailrec def foldLeft[A, R](n: NEL[A])(init: R)(f: (R, A) => R): R = n match {
    case Last(x)        => f(init, x)
    case More(x, tail)  => foldLeft(tail)(f(init, x))(f)
  }

scala> foldLeft(More(1, More(2, Last(3))))(0)(_ + _)
res2: Int = 6
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Disjunctive-Example-non-empty-list}\ref{subsec:Disjunctive-Example-non-empty-list}}

Use \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
to implement a \inputencoding{latin9}\lstinline!reverse!\inputencoding{utf8}
function for the type \inputencoding{latin9}\lstinline!NEL!\inputencoding{utf8}.
The required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def reverse[A]: NEL[A] => NEL[A] = ???

scala> reverse(toNEL(1, List(2, 3))) // Result must be [3, 2, 1].
res3: NEL[Int] = More(3, More(2, Last(1)))
\end{lstlisting}
\inputencoding{utf8}

\subparagraph{Solution}

We will use \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
to build up the reversed list as the accumulator value. It remains
to choose the initial value of the accumulator and the updater function.
We have already seen the code for reversing the ordinary list using
\inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8} operation
(Section~\ref{subsec:Tail-recursion-with-list}),\inputencoding{latin9}
\begin{lstlisting}
def reverse[A](xs: List[A]): List[A] =
  xs.foldLeft(Nil: List[A])((prev,x) => x :: prev)
\end{lstlisting}
\inputencoding{utf8}However, we cannot reuse the same code for non-empty lists by writing
\inputencoding{latin9}\lstinline!More(x, prev)!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!x :: prev!\inputencoding{utf8},
because the \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
operation works with non-empty lists differently. Since a list element
is always available, the updater function is always applied to the
initial value, and the code works incorrectly:\inputencoding{latin9}
\begin{lstlisting}
def reverse[A](xs: NEL[A]): NEL[A] =
  foldLeft(xs)(Last(head(xs)):NEL[A])((prev,x) => More(x, prev))

scala> reverse1(toNEL(1,List(2,3))) // Result = [3, 2, 1, 1].
res4: NEL[Int] = More(3,More(2,More(1,Last(1))))
\end{lstlisting}
\inputencoding{utf8}The last element, \inputencoding{latin9}\lstinline!1!\inputencoding{utf8},
should not have been repeated. It was repeated because the initial
accumulator value already contained the head element \inputencoding{latin9}\lstinline!1!\inputencoding{utf8}
of the original list. However, we cannot set the initial accumulator
value to an empty list, since a value of type \inputencoding{latin9}\lstinline!NEL[A]!\inputencoding{utf8}
must be non-empty. It seems that we need to handle the case of a one-element
list separately. So we begin by matching on the argument of \inputencoding{latin9}\lstinline!reverse!\inputencoding{utf8},
and apply \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
only when the list is longer than $1$ element:\inputencoding{latin9}
\begin{lstlisting}
def reverse[A]: NEL[A] => NEL[A] = {
    case Last(x)         => Last(x)  // Trivial reverse.
    case More(x, tail)   => // Use foldLeft on `tail`.
      foldLeft(tail)(Last(x):NEL[A])((prev,x) => More(x, prev))
  }

scala> reverse(toNEL(1, List(2, 3))) // Result = [3, 2, 1].
res5: NEL[Int] = More(3, More(2, Last(1)))
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:Disjunctive-Example-non-empty-list-1}\ref{subsec:Disjunctive-Example-non-empty-list-1}\index{exercises}}

Implement a function \inputencoding{latin9}\lstinline!toList!\inputencoding{utf8}
that converts a non-empty list into an ordinary Scala \inputencoding{latin9}\lstinline!List!\inputencoding{utf8}.
The required type signature and a sample test:\inputencoding{latin9}
\begin{lstlisting}
def toList[A](nel: NEL[A]): List[A] = ???

scala> toList(More(1, More(2, Last(3)))) // This is [1, 2, 3].
res4: List[Int] = List(1, 2, 3)
\end{lstlisting}
\inputencoding{utf8}

\subsection{Binary trees}

We will consider four kinds of trees defined as recursive disjunctive
types: binary trees, rose trees, homogeneous trees, and abstract syntax
trees.

Examples of a \textbf{binary tree\index{binary tree}} with leaves
of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8} can
be drawn as {\tiny{}}{\tiny{} \Tree[  [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] }
or as {\small{}}{\tiny{} \Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] },
where $a_{i}$ are some values of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}. 

An inductive definition says that a binary tree is either a leaf with
a value of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
or a branch containing \emph{two} previously defined binary trees.
Translating this definition into code, we get\inputencoding{latin9}
\begin{lstlisting}
sealed trait Tree2[A]
final case class Leaf[A](a: A) extends Tree2[A]
final case class Branch[A](x: Tree2[A], y: Tree2[A]) extends Tree2[A]
\end{lstlisting}
\inputencoding{utf8}The tree {\tiny{} \Tree[  [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] } is
created by the code \inputencoding{latin9}
\begin{lstlisting}
Branch(Leaf("a1"), Branch(Leaf("a2"), Leaf("a3")))
\end{lstlisting}
\inputencoding{utf8}while the code\inputencoding{latin9}
\begin{lstlisting}
Branch(Branch(Leaf("a1"),Branch(Leaf("a2"), Leaf("a3"))), Branch(Leaf("a4"), Leaf("a5")))
\end{lstlisting}
\inputencoding{utf8}creates the tree {\tiny{} \Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] }.

Recursive functions on trees are translated into concise code. For
instance, the function \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
for trees of type \inputencoding{latin9}\lstinline!Tree2!\inputencoding{utf8}
is defined by\inputencoding{latin9}
\begin{lstlisting}
def foldLeft[A, R](t: Tree2[A])(init: R)(f: (R, A) => R) = t match {
  case Leaf(a)          => f(init, a)
  case Branch(t1, t2)   =>
    val r1 = foldLeft(t1)(init)(f) // Fold the left branch.
    foldLeft(t2)(r1)(f) // Starting from `r1`, fold the right branch.
}
\end{lstlisting}
\inputencoding{utf8}Note that this function cannot be made tail-recursive using the accumulator
trick, because \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
needs to call itself twice in the \inputencoding{latin9}\lstinline!Branch!\inputencoding{utf8}
case.

\subsection{Rose trees}

A \textbf{rose tree}\index{rose tree} is similar to the binary tree
except the branches contain a non-empty list of trees. Because of
that, a rose tree can fork into arbitrarily many branches at each
node, rather than always into two branches as the binary tree does.
Example shapes for a rose tree are {\tiny{} \Tree[ [ [ $a_1$ ] [ $a_2$ ] [ $a_3$ ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] }
and {\tiny{} \Tree[ [ $a_1$ ] [ $a_2$ ] [ $a_3$ ] [ $a_4$ ] ] }.

A possible definition of a data type for the rose tree is\inputencoding{latin9}
\begin{lstlisting}
sealed trait TreeN[A]
final case class Leaf[A](a: A) extends TreeN[A]
final case class Branch[A](ts: NEL[TreeN[A]]) extends TreeN[A]
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:Disjunctive-Exercise-foldLeft-rose-tree}\ref{subsec:Disjunctive-Exercise-foldLeft-rose-tree}\index{exercises}}

Define the function \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
for a rose tree, using \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
for the type \inputencoding{latin9}\lstinline!NEL!\inputencoding{utf8}.
Type signature and a test:\inputencoding{latin9}
\begin{lstlisting}
def foldLeft[A, R](t: TreeN[A])(init: R)(f: (R, A) => R): R = ???

scala> foldLeft(Branch(More(Leaf(1), More(Leaf(2), Last(Leaf(3))))))(0)(_ + _)
res0: Int = 6
\end{lstlisting}
\inputencoding{utf8}

\subsection{Regular-shaped trees}

Binary trees and rose trees may choose to branch or not to branch
at any given node, resulting in structures that may have different
branching depths at different nodes, such as {\tiny{} \Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ $a_4$ ] ] }.
A \textbf{regular-shaped tree\index{regular-shaped tree}} always
branches in the same way at every node until a chosen total depth,
e.g.~{\tiny{} \Tree[ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] },
where all nodes at depth $0$ and $1$ always branch into two, while
nodes at depth $2$ never branch. The branching number is fixed for
a given type of a regular-shaped tree; in this example, the branching
number is $2$, so it is a regular-shaped \emph{binary} tree.

How can we define a data type representing a regular-shaped binary
tree? We need a tree that is either a single value, or a pair of values,
or a pair of pairs, etc. Begin with the non-recursive (but, of course,
impractical) definition\inputencoding{latin9}
\begin{lstlisting}
sealed trait RTree[A]
final case class Leaf[A](x: A) extends RTree[A]
final case class Branch1[A](xs: (A, A)) extends RTree[A]
final case class Branch2[A](xs: ((A, A),(A, A))) extends RTree[A]
??? // Need an infinitely long definition.
\end{lstlisting}
\inputencoding{utf8}The case \inputencoding{latin9}\lstinline!Branch1!\inputencoding{utf8}
describes a regular-shaped tree with total depth $1$, the case \inputencoding{latin9}\lstinline!Branch2!\inputencoding{utf8}
has total depth $2$, and so on. Now, we cannot rewrite this definition
as a recursive type because the case classes do not have the same
structure. The non-trivial trick is to notice that each \inputencoding{latin9}\lstinline!Branch!\inputencoding{utf8}$_{n}$
case class uses the previous case class's data structure \emph{with
the type parameter} set to \inputencoding{latin9}\lstinline!(A, A)!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}.
So we can rewrite this definition as\inputencoding{latin9}
\begin{lstlisting}
sealed trait RTree[A]
final case class Leaf[A](x: A) extends RTree[A]
final case class Branch1[A](xs: Leaf[(A, A)]) extends RTree[A]
final case class Branch2[A](xs: Branch1[(A, A)]) extends RTree[A]
??? // Need an infinitely long definition.
\end{lstlisting}
\inputencoding{utf8}We can now apply the type recursion trick: replace the type \inputencoding{latin9}\lstinline!Branch!\inputencoding{utf8}$_{n-1}$\inputencoding{latin9}\lstinline![(A, A)]!\inputencoding{utf8}
in the definition of \inputencoding{latin9}\lstinline!Branch!\inputencoding{utf8}$_{n}$
by the type \inputencoding{latin9}\lstinline!RTree[(A, A)]!\inputencoding{utf8}
. This gives the type definition for a regular-shaped binary tree:\inputencoding{latin9}
\begin{lstlisting}
sealed trait RTree[A]
final case class Leaf[A](x: A) extends RTree[A]
final case class Branch[A](xs: RTree[(A, A)]) extends RTree[A]
\end{lstlisting}
\inputencoding{utf8}
Since we used some tricks to figure out the definition of \inputencoding{latin9}\lstinline!RTree[A]!\inputencoding{utf8},
let us verify that this definition actually describes the recursive
disjunctive type we wanted. The only way to create a structure of
type \inputencoding{latin9}\lstinline!RTree[A]!\inputencoding{utf8}
is either to have a \inputencoding{latin9}\lstinline!Leaf[A]!\inputencoding{utf8}
or a \inputencoding{latin9}\lstinline!Branch[A]!\inputencoding{utf8}.
A value of type \inputencoding{latin9}\lstinline!Leaf[A]!\inputencoding{utf8}
is a correct regularly-shaped tree; it remains to consider the case
of \inputencoding{latin9}\lstinline!Branch[A]!\inputencoding{utf8}.
To create a \inputencoding{latin9}\lstinline!Branch[A]!\inputencoding{utf8}
requires a previously created \inputencoding{latin9}\lstinline!RTree!\inputencoding{utf8}
with values of type \inputencoding{latin9}\lstinline!(A, A)!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}.
By the inductive assumption, the previously created \inputencoding{latin9}\lstinline!RTree[A]!\inputencoding{utf8}
would have the correct shape. Now, it is clear that if we replace
the type parameter \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
by the pair \inputencoding{latin9}\lstinline!(A, A)!\inputencoding{utf8},
a regular-shaped tree such as {\tiny{} \Tree[ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] }
remains regular-shaped but becomes one level deeper, which can be
drawn (replacing each $a_{i}$ by a pair $a_{i}^{'},a_{i}^{"}$) as{\tiny{} \Tree[ [ [ [ $a_1^{'}$ ] [ $a_1^{''}$ ] ] [ [ $a_2^{'}$ ] [ $a_2^{''}$ ] ] ] [ [ [ $a_3^{'}$ ] [ $a_3^{''}$ ] ] [ [ $a_4^{'}$ ] [ $a_4^{''}$ ] ]  ] ] }.
We see that \inputencoding{latin9}\lstinline!RTree[A]!\inputencoding{utf8}
is the correct definition of a regular-shaped binary tree. 

\subsubsection{Example \label{subsec:Disjunctive-Example-map-regular-tree}\ref{subsec:Disjunctive-Example-map-regular-tree}\index{solved examples}}

Define a (non-tail-recursive) \inputencoding{latin9}\lstinline!map!\inputencoding{utf8}
function for a regular-shaped binary tree. The required type signature
and a test:\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](t: RTree[A])(f: A => B): RTree[B] = ???

scala> map(Branch(Branch(Leaf(((1,2),(3,4))))))(_ * 10)
res0: RTree[Int] = Branch(Branch(Leaf(((10,20),(30,40)))))
\end{lstlisting}
\inputencoding{utf8}

\subparagraph{Solution}

Begin by pattern-matching on the tree:\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
  case Leaf(x)      => ???
  case Branch(xs)   => ???
}
\end{lstlisting}
\inputencoding{utf8}In the base case, we have no choice but to return \inputencoding{latin9}\lstinline!Leaf(f(x))!\inputencoding{utf8}.\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
  case Leaf(x)      => Leaf(f(x))
  case Branch(xs)   => ???
}
\end{lstlisting}
\inputencoding{utf8}In the inductive step, we are given a previous tree value \inputencoding{latin9}\lstinline!xs:RTree[(A, A)]!\inputencoding{utf8}.
It is clear that we need to apply \inputencoding{latin9}\lstinline!map!\inputencoding{utf8}
recursively to \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}.
Let us try:\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
  case Leaf(x)      => Leaf(f(x))
  case Branch(xs)   => Branch(map(xs)(f)) // Type error!
}
\end{lstlisting}
\inputencoding{utf8}Here, \inputencoding{latin9}\lstinline!map(xs)(f)!\inputencoding{utf8}
does not compile because the type of the function \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
is incorrect. Since \inputencoding{latin9}\lstinline!xs!\inputencoding{utf8}
has type \inputencoding{latin9}\lstinline!RTree[(A, A)]!\inputencoding{utf8},
the recursive call \inputencoding{latin9}\lstinline!map(xs)(f)!\inputencoding{utf8}
requires \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
to be of type \inputencoding{latin9}\lstinline!((A, A)) => (B, B)!\inputencoding{utf8}
instead of \inputencoding{latin9}\lstinline!f: A => B!\inputencoding{utf8}.
So, we need to provide a function of the correct type instead of \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}.
A function of type \inputencoding{latin9}\lstinline!((A, A)) => (B, B)!\inputencoding{utf8}
will be obtained out of \inputencoding{latin9}\lstinline!f: A => B!\inputencoding{utf8}
if we apply \inputencoding{latin9}\lstinline!f!\inputencoding{utf8}
to each part of the tuple \inputencoding{latin9}\lstinline!(A, A)!\inputencoding{utf8};
the code for that function is \inputencoding{latin9}\lstinline!{case (x, y) => (f(x), f(y))}!\inputencoding{utf8}.
Therefore, we can implement \inputencoding{latin9}\lstinline!map!\inputencoding{utf8}
as\inputencoding{latin9}
\begin{lstlisting}
def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
  case Leaf(x)      => Leaf(f(x))
  case Branch(xs)   => Branch(map(xs){ case (x, y) => (f(x), f(y)) })
}
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:Disjunctive-Exercise-foldLeft-regular-tree-depth}\ref{subsec:Disjunctive-Exercise-foldLeft-regular-tree-depth}\index{exercises}}

Using tail recursion, compute the depth of a regular-shaped binary
tree of type \inputencoding{latin9}\lstinline!RTree!\inputencoding{utf8}.
(An \inputencoding{latin9}\lstinline!RTree!\inputencoding{utf8} of
depth $n$ has $2^{n}$ leaf values.) The required type signature
and a test:\inputencoding{latin9}
\begin{lstlisting}
@tailrec def depth[A](t: RTree[A]): Int = ???

scala> depth(Branch(Branch(Leaf((("a","b"),("c","d"))))))
res2: Int = 2
\end{lstlisting}
\inputencoding{utf8}\begin{comment}
Solution:

\inputencoding{latin9}\begin{lstlisting}
@tailrec def depth[A](t: RTree[A], acc: Int = 0): Int = t match {
  case Leaf(x)    => acc
  case Branch(xs) => depth(xs, acc + 1)
}
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsubsection{Exercise \label{subsec:Disjunctive-Exercise-foldLeft-regular-tree}\ref{subsec:Disjunctive-Exercise-foldLeft-regular-tree}{*}}

Define a tail-recursive function \inputencoding{latin9}\lstinline!foldLeft!\inputencoding{utf8}
for a regular-shaped binary tree. The required type signature and
a test:\inputencoding{latin9}
\begin{lstlisting}
@tailrec def foldLeft[A, R](t: RTree[A])(init: R)(f: (R, A) => R): R = ???

scala> foldLeft(Branch(Branch(Leaf(((1,2),(3,4))))))(0)(_ + _)
res0: Int = 10

scala> foldLeft(Branch(Branch(Leaf((("a","b"),("c","d"))))))("")(_ + _)
res1: String = abcd
\end{lstlisting}
\inputencoding{utf8}\begin{comment}
Solution:

\inputencoding{latin9}\begin{lstlisting}
@tailrec def foldLeft[A, R](t: RTree[A])(init: R)(f: (R, A) => R): R = t match {
  case Leaf(x)    => f(init, x)
  case Branch(xs) => foldLeft(xs)(init) { case (r, (a, b)) => f(f(r, a), b) } 
}
\end{lstlisting}
\inputencoding{utf8}\end{comment}


\subsection{Abstract syntax trees}

Expressions in formal languages are represented by abstract syntax
trees. An \textbf{abstract syntax tree\index{abstract syntax tree}
}(or \textbf{AST} for short) is defined as either a leaf of one of
the available leaf types, or a branch of one of the available branch
types. All the available leaf and branch types must be specified as
part of the definition of an AST. In other words, one must specify
the data carried by leaves and branches, as well as the branching
numbers.

To illustrate how ASTs are used, let us rewrite Example~\ref{subsec:disj-Example-resultA}
via an AST. We view Example~\ref{subsec:disj-Example-resultA} as
a small sub-language that deals with ``safe integers'' and supports
the ``safe arithmetic'' operations \inputencoding{latin9}\lstinline!Sqrt!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!Add!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!Mul!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!Div!\inputencoding{utf8}. Example
calculations in this sub-language are $\sqrt{16}*(1+2)=12$; $20+1/0=\text{error}$;
and $10+\sqrt{-1}=\text{error}$. 

We can implement this sub-language in two stages. The first stage
will create a data structure (an AST) that represents an unevaluated
expression\index{unevaluated expression} in the sub-language. The
second stage will evaluate that AST to obtain either a number or an
error message.

A straightforward way of defining a data structure for an AST is to
use a disjunctive type whose cases describe all the possible operations
of the sub-language. We will need one case class for each of \inputencoding{latin9}\lstinline!Sqrt!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!Add!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!Mul!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!Div!\inputencoding{utf8}. An
additional operation, \inputencoding{latin9}\lstinline!Num!\inputencoding{utf8},
will lift ordinary integers into ``safe integers''. So, we define
the disjunctive type for ``arithmetic sub-language expressions''
as\inputencoding{latin9}
\begin{lstlisting}
sealed trait Arith
final case class Num(x: Int) extends Arith
final case class Sqrt(x: Arith) extends Arith
final case class Add(x: Arith, y: Arith) extends Arith
final case class Mul(x: Arith, y: Arith) extends Arith
final case class Div(x: Arith, y: Arith) extends Arith
\end{lstlisting}
\inputencoding{utf8}A value of type \inputencoding{latin9}\lstinline!Arith!\inputencoding{utf8}
is either a \inputencoding{latin9}\lstinline!Num(x)!\inputencoding{utf8}
for some integer \inputencoding{latin9}\lstinline!x!\inputencoding{utf8},
or an \inputencoding{latin9}\lstinline!Add(x, y)!\inputencoding{utf8}
where \inputencoding{latin9}\lstinline!x!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!y!\inputencoding{utf8} are previously
defined \inputencoding{latin9}\lstinline!Arith!\inputencoding{utf8}
expressions, or another operation.

This type definition is similar to the binary tree type\inputencoding{latin9}
\begin{lstlisting}
sealed trait Tree
final case class Leaf(x: Int) extends Tree
final case class Branch(x: Tree, y: Tree) extends Tree
\end{lstlisting}
\inputencoding{utf8}if we rename \inputencoding{latin9}\lstinline!Leaf!\inputencoding{utf8}
to \inputencoding{latin9}\lstinline!Num!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!Branch!\inputencoding{utf8} to \inputencoding{latin9}\lstinline!Add!\inputencoding{utf8}.
However, the \inputencoding{latin9}\lstinline!Arith!\inputencoding{utf8}
type contains $4$ different types of ``branches'', some with branching
number $1$ and others with branching number $2$. 

This example illustrates the structure of an AST: it is a tree of
a general shape, where leaves and branches are chosen from a specified
set of allowed possibilities. In this example, we have a single allowed
type of leaf (\inputencoding{latin9}\lstinline!Num!\inputencoding{utf8})
and $4$ allowed types of branches (\inputencoding{latin9}\lstinline!Sqrt!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!Add!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!Mul!\inputencoding{utf8},
and \inputencoding{latin9}\lstinline!Div!\inputencoding{utf8}).

This completes the first stage of implementing the sub-language of
``safe arithmetic''. Using the definition of the disjunctive type
\inputencoding{latin9}\lstinline!Arith!\inputencoding{utf8}, we may
now create expressions in the sub-language. For example, $\sqrt{16}*(1+2)$
is represented by\inputencoding{latin9}
\begin{lstlisting}
scala> val x: Arith = Mul(Sqrt(Num(16)), Add(Num(1), Num(2)))
x: Arith = Mul(Sqrt(Num(16)),Add(Num(1),Num(2))) 
\end{lstlisting}
\inputencoding{utf8}We can visualize \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
as the abstract syntax tree{\tiny{} \Tree[.\texttt{Mul} [.\texttt{Sqrt} [.\texttt{Num} $16$ ] ] [.\texttt{Add} [ [.\texttt{Num} [ $1$ ] ] [.\texttt{Num} [ $2$ ] ] ] ] ] }. 

The expressions $20+1/0$ and $10*\sqrt{-1}$ are represented by\inputencoding{latin9}
\begin{lstlisting}
scala> val y: Arith = Add(Num(20), Div(Num(1), Num(0)))
y: Arith = Add(Num(20),Div(Num(1),Num(0)))

scala> val z: Arith = Add(Num(10), Sqrt(Num(-1)))
z: Arith = Add(Num(10),Sqrt(Num(-1)))
\end{lstlisting}
\inputencoding{utf8}As we see, the expressions \inputencoding{latin9}\lstinline!x!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!y!\inputencoding{utf8}, and \inputencoding{latin9}\lstinline!z!\inputencoding{utf8}
\emph{remain} \emph{unevaluated}; they are data structures that encode
a tree of operations of the sub-language. These operations will be
evaluated at the second stage of implementing the sub-language.

To evaluate the expressions in the ``safe arithmetic'', we can write
a function \inputencoding{latin9}\lstinline!run: Arith => Either[String, Int]!\inputencoding{utf8}.
That function plays the role of an \textbf{interpreter}\index{interpreter}
or ``\textbf{runner}\index{runner}'' for programs written in the
sub-language. The runner will destructure the expression tree and
execute all the operations, taking care of possible errors. 

To implement \inputencoding{latin9}\lstinline!run!\inputencoding{utf8},
we need to define the ``safe arithmetic'' operations for the result
type \inputencoding{latin9}\lstinline!Either[String, Int]!\inputencoding{utf8}.
Instead of custom code from Example~\ref{subsec:disj-Example-resultA},
we can use the \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}
operations defined for the \inputencoding{latin9}\lstinline!Either!\inputencoding{utf8}
type. For example, addition and multiplication of two ``safe integers''
is written as \inputencoding{latin9}
\begin{lstlisting}
def add(x: Either[String, Int], y: Either[String, Int]):
    Either[String, Int] = x.flatMap { r1 => y.map(r2 => r1 + r2) }
def mul(x: Either[String, Int], y: Either[String, Int]):
    Either[String, Int] = x.flatMap { r1 => y.map(r2 => r1 * r2) }
\end{lstlisting}
\inputencoding{utf8}while the ``safe division'' is\inputencoding{latin9}
\begin{lstlisting}
def div(x: Either[String, Int], y: Either[String, Int]):
    Either[String, Int] = x.flatMap { r1 => y.flatMap(r2 =>
  if (r2 == 0) Left(s"error: $r1 / $r2") else Right(r1 / r2) )
}
\end{lstlisting}
\inputencoding{utf8}With this code, we can implement the runner as\inputencoding{latin9}
\begin{lstlisting}
def run: Arith => Either[String, Int] = {
  case Num(x)     => Right(x)
  case Sqrt(x)    => run(x).flatMap { r =>
   if (r < 0) Left(s"error: sqrt($r)") else
       Right(math.sqrt(r).toInt)
  }
  case Add(x, y)  => add(run(x), run(y))
  case Mul(x, y)  => mul(run(x), run(y))
  case Div(x, y)  => div(run(x), run(y))
}
\end{lstlisting}
\inputencoding{utf8}Test with the values \inputencoding{latin9}\lstinline!x!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!y!\inputencoding{utf8}, \inputencoding{latin9}\lstinline!z!\inputencoding{utf8}
defined previously:\inputencoding{latin9}
\begin{lstlisting}
scala> run(x)
res0: Either[String, Int] = Right(12)

scala> run(y)
res1: Either[String, Int] = Left("error: 1 / 0")

scala> run(z)
res2: Either[String, Int] = Left("error: sqrt(-1)")
\end{lstlisting}
\inputencoding{utf8}

\section{Summary}

What problems can we solve now?
\begin{itemize}
\item Represent values from disjoint domains as a single disjunctive type.
\item Use disjunctive types instead of exceptions to indicate failures.
\item Use disjunctive types to define and work with lists and trees. 
\end{itemize}
The following examples and exercises illustrate the use of disjunctive
types.

\subsection{Solved examples\index{solved examples}}

\subsubsection{Example \label{subsec:Example-disjunctive-1}\ref{subsec:Example-disjunctive-1}}

Define a disjunctive type \inputencoding{latin9}\lstinline!DayOfWeek!\inputencoding{utf8}
representing the seven days.

\subparagraph{Solution}

Since there is no information other than the label on each day, we
use empty case classes:\inputencoding{latin9}
\begin{lstlisting}
sealed trait DayOfWeek
final case class Sunday() extends DayOfWeek
final case class Monday() extends DayOfWeek
final case class Tuesday() extends DayOfWeek
final case class Wednesday() extends DayOfWeek
final case class Thursday() extends DayOfWeek
final case class Friday() extends DayOfWeek
final case class Saturday() extends DayOfWeek
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-disjunctive-2}\ref{subsec:Example-disjunctive-2}}

Modify \inputencoding{latin9}\lstinline!DayOfWeek!\inputencoding{utf8}
so that the values additionally represent a restaurant name and total
amount for Fridays and a wake-up time on Saturdays. 

\subparagraph{Solution}

For the days where additional information is given, we use non-empty
case classes:\inputencoding{latin9}
\begin{lstlisting}
sealed trait DayOfWeekX
final case class Sunday() extends DayOfWeekX
final case class Monday() extends DayOfWeekX
final case class Tuesday() extends DayOfWeekX
final case class Wednesday() extends DayOfWeekX
final case class Thursday() extends DayOfWeekX
final case class Friday(restaurant: String, amount: Int) extends DayOfWeekX
final case class Saturday(wakeUpAt: java.time.LocalTime) extends DayOfWeekX
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:disj-Example-rootsofq-2}\ref{subsec:disj-Example-rootsofq-2}}

Define a disjunctive type that describes the real roots of the equation
$ax^{2}+bx+c=0$, where $a$, $b$, $c$ are arbitrary real numbers.

\subparagraph{Solution}

Begin by solving the equation and enumerating all possible cases.
It may happen that $a=b=c=0$, and then all $x$ are roots. If $a=b=0$
but $c\neq0$, the equation is $c=0$, which has no roots. If $a=0$
but $b\neq0$, the equation becomes $bx+c=0$, having a single root.
If $a\neq0$ and $b^{2}>4ac$, we have two distinct real roots. If
$a\neq0$ and $b^{2}=4ac$, we have one real root. If $b^{2}<4ac$,
we have no real roots. The resulting type definition can be written
as\inputencoding{latin9}
\begin{lstlisting}
sealed trait RootsOfQ2
final case class AllRoots() extends RootsOfQ2
final case class ConstNoRoots() extends RootsOfQ2
final case class Linear(x: Double) extends RootsOfQ2
final case class NoRealRoots() extends RootsOfQ2
final case class OneRootQ(x: Double) extends RootsOfQ2
final case class TwoRootsQ(x: Double, y: Double) extends RootsOfQ2
\end{lstlisting}
\inputencoding{utf8}This disjunctive type contains six parts, among which three parts
are empty tuples and two parts are single-element tuples; but this
is not a useless redundancy. We would lose information if we reuse
\inputencoding{latin9}\lstinline!Linear!\inputencoding{utf8} for
the two cases $a=0$, $b\neq0$ and $a\neq0$, $b^{2}=4ac$, or if
we reuse \inputencoding{latin9}\lstinline!NoRoots()!\inputencoding{utf8}
for representing all three different no-roots cases.

\subsubsection{Example \label{subsec:Example-disjunctive-3}\ref{subsec:Example-disjunctive-3}}

Define a function \inputencoding{latin9}\lstinline!rootAverage!\inputencoding{utf8}
that computes the average value of all real roots of a general quadratic
equation, where the roots are represented by the type \inputencoding{latin9}\lstinline!RootsOfQ2!\inputencoding{utf8}
defined in Example~\ref{subsec:disj-Example-rootsofq-2}. The required
type signature is\inputencoding{latin9}
\begin{lstlisting}
val rootAverage: RootsOfQ2 => Option[Double] = ???
\end{lstlisting}
\inputencoding{utf8}The function should return \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}
if the average is undefined.

\subparagraph{Solution}

The average is defined only in cases \inputencoding{latin9}\lstinline!Linear!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!OneRootQ!\inputencoding{utf8}, and
\inputencoding{latin9}\lstinline!TwoRootsQ!\inputencoding{utf8}.
In all other cases, we must return \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}.
We implement this via pattern matching:\inputencoding{latin9}
\begin{lstlisting}
val rootAverage: RootsOfQ2 => Option[Double] = { roots =>
  roots match {
    case Linear(x)       => Some(x)
    case OneRootQ(x)     => Some(x)
    case TwoRootsQ(x, y) => Some((x + y) * 0.5)
    case _               => None
  }
}
\end{lstlisting}
\inputencoding{utf8}We do not need to enumerate all other cases since the underscore ($\_$)
matches everything that the previous cases did not match.

The often-used code pattern of the form \inputencoding{latin9}\lstinline!x => x match { case ... }!\inputencoding{utf8}
can be shortened to the nameless function syntax \inputencoding{latin9}\lstinline!{ case ...}!\inputencoding{utf8}.
The code then becomes\inputencoding{latin9}
\begin{lstlisting}
val rootAverage: RootsOfQ2 => Option[Double] = {
  case Linear(x)       => Some(x)
  case OneRootQ(x)     => Some(x)
  case TwoRootsQ(x, y) => Some((x + y) * 0.5)
  case _               => None
}
\end{lstlisting}
\inputencoding{utf8}Test it:\inputencoding{latin9}
\begin{lstlisting}
scala> Seq(NoRealRoots(),OneRootQ(1.0), TwoRootsQ(1.0, 2.0), AllRoots()).
  map(rootAverage)
res0: Seq[Option[Double]] = List(None, Some(1.0), Some(1.5), None)
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-disjunctive-4}\ref{subsec:Example-disjunctive-4}}

Generate $100$ quadratic equations $x^{2}+bx+c=0$ with random coefficients
$b$, $c$ (uniformly distributed between $-1$ and $1$) and compute
the mean of the largest real roots from all these equations.

\subparagraph{Solution}

We use the type \inputencoding{latin9}\lstinline!QEqu!\inputencoding{utf8}
and the \inputencoding{latin9}\lstinline!solve!\inputencoding{utf8}
function from Example~\ref{subsec:disj-Example-rootsofq-1}. Create
a sequence of equations with random coefficients via the method \inputencoding{latin9}\lstinline!Seq.fill!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
def random(): Double = scala.util.Random.nextDouble() * 2 - 1
val coeffs: Seq[QEqu] = Seq.fill(100)(QEqu(random(), random()))
\end{lstlisting}
\inputencoding{utf8}Then use the \inputencoding{latin9}\lstinline!solve!\inputencoding{utf8}
function to compute all roots:\inputencoding{latin9}
\begin{lstlisting}
val solutions: Seq[RootsOfQ] = coeffs.map(solve)
\end{lstlisting}
\inputencoding{utf8}For each set of roots, compute the largest root:\inputencoding{latin9}
\begin{lstlisting}
scala> val largest: Seq[Option[Double]] = solutions.map {
  case OneRoot(x)     => Some(x)
  case TwoRoots(x, y) => Some(math.max(x, y))
  case _              => None
}
largest: Seq[Option[Double]] = List(None, Some(0.9346072365885472), Some(1.1356234869160806), Some(0.9453181931646322), Some(1.1595052441078866), None, Some(0.5762252742788)...
\end{lstlisting}
\inputencoding{utf8}It remains to remove the \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}
values and to compute the mean of the resulting sequence. The Scala
library defines the \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
method that removes \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}s
and transforms \inputencoding{latin9}\lstinline!Seq[Option[A]]!\inputencoding{utf8}
into \inputencoding{latin9}\lstinline!Seq[A]!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
scala> largest.flatten
res0: Seq[Double] = List(0.9346072365885472, 1.1356234869160806, 0.9453181931646322, 1.1595052441078866, 0.5762252742788...
\end{lstlisting}
\inputencoding{utf8}Now we can compute the mean of the last sequence. Since the \inputencoding{latin9}\lstinline!.flatten!\inputencoding{utf8}
operation is preceded by \inputencoding{latin9}\lstinline!.map!\inputencoding{utf8},
we can replace it by a \inputencoding{latin9}\lstinline!.flatMap!\inputencoding{utf8}.
The final code is\inputencoding{latin9}
\begin{lstlisting}
val largest = Seq.fill(100)(QEqu(random(), random()))
  .map(solve)
  .flatMap {
    case OneRoot(x)     => Some(x)
    case TwoRoots(x, y) => Some(math.max(x, y))
    case _              => None
  }

scala> largest.sum / largest.size
res1: Double = 0.7682649774589514
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-disjunctive-5}\ref{subsec:Example-disjunctive-5}}

Implement a function with type signature\inputencoding{latin9}
\begin{lstlisting}
def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = ???
\end{lstlisting}
\inputencoding{utf8}The function should preserve as much information as possible.

\subparagraph{Solution}

Begin by pattern matching on the argument:\inputencoding{latin9}
\begin{lstlisting}
def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
  case None                    => ???
  case Some(eab:Either[A, B])  => ???
}
\end{lstlisting}
\inputencoding{utf8}The \textbf{type annotation}\index{type annotation} \inputencoding{latin9}\lstinline!:Either[A, B]!\inputencoding{utf8}
was written only for clarity; it is not required here because the
Scala compiler can deduce the type of the pattern variable \inputencoding{latin9}\lstinline!eab!\inputencoding{utf8}
from the fact that we are matching a value of type \inputencoding{latin9}\lstinline!Option[Either[A, B]]!\inputencoding{utf8}.

In the scope of \inputencoding{latin9}\lstinline!case None => ???!\inputencoding{utf8},
we need to return a value of type \inputencoding{latin9}\lstinline!Either[A, Option[B]]!\inputencoding{utf8}.
A value of that type must be either a \inputencoding{latin9}\lstinline!Left(x)!\inputencoding{utf8}
for some \inputencoding{latin9}\lstinline!x:A!\inputencoding{utf8},
or a \inputencoding{latin9}\lstinline!Right(y)!\inputencoding{utf8}
for some \inputencoding{latin9}\lstinline!y:Option[B]!\inputencoding{utf8},
where \inputencoding{latin9}\lstinline!y!\inputencoding{utf8} must
be either \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!Some(z)!\inputencoding{utf8}
with a \inputencoding{latin9}\lstinline!z:B!\inputencoding{utf8}.
However, in our case the code is of the form \inputencoding{latin9}\lstinline!case None => ???!\inputencoding{utf8},
and we cannot produce any values \inputencoding{latin9}\lstinline!x:A!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!z:B!\inputencoding{utf8} since
\inputencoding{latin9}\lstinline!A!\inputencoding{utf8} and \inputencoding{latin9}\lstinline!B!\inputencoding{utf8}
are arbitrary, unknown types. The only remaining possibility is to
return \inputencoding{latin9}\lstinline!Right(y)!\inputencoding{utf8}
with \inputencoding{latin9}\lstinline!y = None!\inputencoding{utf8},
and so the code must be\inputencoding{latin9}
\begin{lstlisting}
  ...
  case None => Right(None) // No other choice here.
\end{lstlisting}
\inputencoding{utf8}
In the next scope, we can perform pattern matching on the value \inputencoding{latin9}\lstinline!eab!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
  ...
  case Some(eab: Either[A, B]) = eab match {
    case Left(a)   => ???
    case Right(b)  => ???
  }
\end{lstlisting}
\inputencoding{utf8}It remains to figure out what expressions to compute in each case.
In the case \inputencoding{latin9}\lstinline!Left(a) => ???!\inputencoding{utf8},
we have a value of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8},
and we need to compute a value of type \inputencoding{latin9}\lstinline!Either[A, Option[B]]!\inputencoding{utf8}.
We execute the same argument as before: The return value must be \inputencoding{latin9}\lstinline!Left(x)!\inputencoding{utf8}
for some \inputencoding{latin9}\lstinline!x:A!\inputencoding{utf8},
or \inputencoding{latin9}\lstinline!Right(y)!\inputencoding{utf8}
for some \inputencoding{latin9}\lstinline!y:Option[B]!\inputencoding{utf8}.
At this point, we have a value of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}
but no values of type \inputencoding{latin9}\lstinline!B!\inputencoding{utf8}.
So we have two possibilities: to return \inputencoding{latin9}\lstinline!Left(a)!\inputencoding{utf8}
or to return \inputencoding{latin9}\lstinline!Right(None)!\inputencoding{utf8}.
If we decide to return \inputencoding{latin9}\lstinline!Left(a)!\inputencoding{utf8},
the code is\inputencoding{latin9}
\begin{lstlisting}
def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
  case None       => Right(None) // No other choice here.
  case Some(eab)  => eab match {
    case Left(a)  => Left(a)   // Could also return Right(None) here.
    case Right(b) => ???
  }
}
\end{lstlisting}
\inputencoding{utf8}Let us consider the choice of whether to return \inputencoding{latin9}\lstinline!Left(a)!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!Right(None)!\inputencoding{utf8}
in the line \inputencoding{latin9}\lstinline!case Left(a) => ...!\inputencoding{utf8}.
Both choices will satisfy the required return type \inputencoding{latin9}\lstinline!Either[A, Option[B]]!\inputencoding{utf8}.
However, if we return \inputencoding{latin9}\lstinline!Right(None)!\inputencoding{utf8}
in that line, we will ignore the given value \inputencoding{latin9}\lstinline!a:A!\inputencoding{utf8},
which loses information. So we return \inputencoding{latin9}\lstinline!Left(a)!\inputencoding{utf8}
in that line.

Reasoning similarly for the last line \inputencoding{latin9}\lstinline!case Right(b) => ???!\inputencoding{utf8},
we find that we have a choice of returning \inputencoding{latin9}\lstinline!Right(None)!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!Right(Some(b))!\inputencoding{utf8}.
The first choice ignores the given value of \inputencoding{latin9}\lstinline!b:B!\inputencoding{utf8}.
To preserve information, we make the second choice:\inputencoding{latin9}
\begin{lstlisting}
def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
  case None       => Right(None)
  case Some(eab)  => eab match {
      case Left(a)    => Left(a)
      case Right(b)   => Right(Some(b))
  }
}
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Example \label{subsec:Example-disjunctive-6}\ref{subsec:Example-disjunctive-6}}

Implement a function with the type signature \inputencoding{latin9}
\begin{lstlisting}
def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = ???
\end{lstlisting}
\inputencoding{utf8}The function should preserve as much information as possible.

\subparagraph{Solution}

Begin by pattern matching on the argument:\inputencoding{latin9}
\begin{lstlisting}
def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
  case (Some(a), Some(b)) => ???
  case ???                => ???
\end{lstlisting}
\inputencoding{utf8}In the first case, we have values \inputencoding{latin9}\lstinline!a:A!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!b:B!\inputencoding{utf8}, and
we are required to return a value of type \inputencoding{latin9}\lstinline!Option[(A, B)]!\inputencoding{utf8}.
A value of that type is either \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}
or \inputencoding{latin9}\lstinline!Some((x, y))!\inputencoding{utf8}
where \inputencoding{latin9}\lstinline!x:A!\inputencoding{utf8} and
\inputencoding{latin9}\lstinline!y:B!\inputencoding{utf8}. Since
\inputencoding{latin9}\lstinline!A!\inputencoding{utf8} and \inputencoding{latin9}\lstinline!B!\inputencoding{utf8}
are arbitrary types, we cannot produce new values \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!y!\inputencoding{utf8} from
scratch. The only way to satisfy the required type is to set \inputencoding{latin9}\lstinline!x = a!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!y = b!\inputencoding{utf8},
returning \inputencoding{latin9}\lstinline!Some((a, b))!\inputencoding{utf8}.
Now we have two choices: to return \inputencoding{latin9}\lstinline!Some((a, b))!\inputencoding{utf8}
or to return \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}.
Returning \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}
would unnecessarily lose information, so we write\inputencoding{latin9}
\begin{lstlisting}
def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
  case (Some(a), Some(b)) => Some((a, b))
  case (Some(a), None)    => ???
  ...
\end{lstlisting}
\inputencoding{utf8}In the branch of \inputencoding{latin9}\lstinline!case (Some(a), None)!\inputencoding{utf8},
we have a value \inputencoding{latin9}\lstinline!a:A!\inputencoding{utf8}
but no values of type \inputencoding{latin9}\lstinline!B!\inputencoding{utf8}.
Since the type \inputencoding{latin9}\lstinline!B!\inputencoding{utf8}
is arbitrary, we cannot produce any values of type \inputencoding{latin9}\lstinline!B!\inputencoding{utf8}
to return a value of the form \inputencoding{latin9}\lstinline!Some((x, y))!\inputencoding{utf8}.
So, in this \inputencoding{latin9}\lstinline!case!\inputencoding{utf8}
branch, the only computable value of type \inputencoding{latin9}\lstinline!Option[(A, B)]!\inputencoding{utf8}
is \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}. We
continue to write the code of the function:\inputencoding{latin9}
\begin{lstlisting}
def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
  case (Some(a), Some(b)) => Some((a, b))
  case (Some(a), None)    => None // No other choice here.
  case (None, Some(b))    => ???
  case (None, None)       => ???
}
\end{lstlisting}
\inputencoding{utf8}Writing out the remaining cases, we find that in all those cases we
have no choice other than returning \inputencoding{latin9}\lstinline!None!\inputencoding{utf8}.
So we can simplify the code:\inputencoding{latin9}
\begin{lstlisting}
def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
  case (Some(a), Some(b)) => Some((a, b))
  case _                  => None // No other choice here.
}
\end{lstlisting}
\inputencoding{utf8}

\subsection{Exercises\index{exercises}}

\subsubsection{Exercise \label{subsec:Exercise-disjunctive-1}\ref{subsec:Exercise-disjunctive-1}}

Define a disjunctive type \inputencoding{latin9}\lstinline!CellState!\inputencoding{utf8}
representing the visual state of one cell in the ``\href{https://en.wikipedia.org/wiki/Minesweeper_(video_game)}{Minesweeper}''
game: A cell can be closed (showing nothing), or show a bomb, or be
open and show the number of bombs in neighbor cells.

\subsubsection{Exercise \label{subsec:Exercise-disjunctive-2}\ref{subsec:Exercise-disjunctive-2}}

Define a function from \inputencoding{latin9}\lstinline!Seq[Seq[CellState]]!\inputencoding{utf8}
to \inputencoding{latin9}\lstinline!Int!\inputencoding{utf8}, counting
the total number of cells with zero neighbor bombs shown.

\subsubsection{Exercise \label{subsec:Exercise-disjunctive-3}\ref{subsec:Exercise-disjunctive-3}}

Define a disjunctive type \inputencoding{latin9}\lstinline!RootOfLinear!\inputencoding{utf8}
representing all possibilities for the solution of the equation $ax+b=0$
for arbitrary real $a$, $b$. (The possibilities are: no roots; one
root; all $x$ are roots.) Implement the solution as a function \inputencoding{latin9}\lstinline!solve1!\inputencoding{utf8}
with type signature \inputencoding{latin9}
\begin{lstlisting}
def solve1: ((Double, Double)) => RootOfLinear = ???
\end{lstlisting}
\inputencoding{utf8}

\subsubsection{Exercise \label{subsec:Exercise-disjunctive-4}\ref{subsec:Exercise-disjunctive-4}}

Given a \inputencoding{latin9}\lstinline!Seq[(Double, Double)]!\inputencoding{utf8}
containing pairs $\left(a,b\right)$ of the coefficients of $ax+b=0$,
produce a \inputencoding{latin9}\lstinline!Seq[Double]!\inputencoding{utf8}
containing the roots of that equation when a unique root exists. Use
the type \inputencoding{latin9}\lstinline!RootOfLinear!\inputencoding{utf8}
and the function \inputencoding{latin9}\lstinline!solve1!\inputencoding{utf8}
defined in Exercise~\ref{subsec:Exercise-disjunctive-3}.

\subsubsection{Exercise \label{subsec:Exercise-disjunctive-4-1-1}\ref{subsec:Exercise-disjunctive-4-1-1}}

The case class \inputencoding{latin9}\lstinline!Subscriber!\inputencoding{utf8}
was defined in Example~\ref{subsec:Disjunctive-Example-option-1}.
Given a \inputencoding{latin9}\lstinline!Seq[Subscriber]!\inputencoding{utf8},
compute the sequence of email addresses for all subscribers that did
\emph{not} provide a phone number.

\subsubsection{Exercise \label{subsec:Exercise-disjunctive-4-1}\ref{subsec:Exercise-disjunctive-4-1}}

In this exercise, a ``procedure\index{procedure}'' is a function
of type \inputencoding{latin9}\lstinline!Unit => Unit!\inputencoding{utf8};
an example of a procedure is \inputencoding{latin9}\lstinline!{() => println("hello")}!\inputencoding{utf8}.
Define a disjunctive type \inputencoding{latin9}\lstinline!Proc!\inputencoding{utf8}
for an abstract syntax tree representing three operations on procedures:
1) \inputencoding{latin9}\lstinline!Func[A]!\inputencoding{utf8},
creating a procedure from a function of type \inputencoding{latin9}\lstinline!Unit => A!\inputencoding{utf8},
where \inputencoding{latin9}\lstinline!A!\inputencoding{utf8} is
a type parameter. 2) \inputencoding{latin9}\lstinline!Sequ(p1, p2)!\inputencoding{utf8},
executing two procedures sequentially. 3) \inputencoding{latin9}\lstinline!Para(p1, p2)!\inputencoding{utf8},
executing two procedures in parallel. Then implement a ``runner''
that converts a \inputencoding{latin9}\lstinline!Proc!\inputencoding{utf8}
into a \inputencoding{latin9}\lstinline!Future[Unit]!\inputencoding{utf8},
running the computations either sequentially or in parallel as appropriate.
Test with this code:\inputencoding{latin9}
\begin{lstlisting}
sealed trait Proc; final case class ??? // etc.
def runner: Proc => Future[Unit] = ???
val proc1: Proc = Func{_ => Thread.sleep(200); println("hello1")}
val proc2: Proc = Func{_ => Thread.sleep(400); println("hello2")}

scala> runner(Sequ(Para(proc2, proc1), proc2))
hello1
hello2
hello2
\end{lstlisting}
\inputencoding{utf8}
\smallskip{}


\subsubsection{Exercise \label{subsec:Exercise-disjunctive-5}\ref{subsec:Exercise-disjunctive-5}}

Implement functions that have a given type signature and preserve
as much information as possible: \inputencoding{latin9}
\begin{lstlisting}
def f1[A, B]: Option[(A, B)] => (Option[A], Option[B]) = ???
def f2[A, B]: Either[A, B] => (Option[A], Option[B]) = ???
def f3[A,B,C]: Either[A, Either[B,C]] => Either[Either[A,B], C] = ???
\end{lstlisting}
\inputencoding{utf8}

\section{Discussion}

\subsection{Disjunctive types as mathematical sets}

To understand the properties of disjunctive types from the mathematical
point of view, consider a function whose argument is a disjunctive
type, such as\inputencoding{latin9}
\begin{lstlisting}
def isDoubleRoot(r: RootsOfQ) = ...
\end{lstlisting}
\inputencoding{utf8}The type of the argument \inputencoding{latin9}\lstinline!r:RootsOfQ!\inputencoding{utf8}
represents the mathematical domain of the function, that is, the set
of admissible values of the argument \inputencoding{latin9}\lstinline!r!\inputencoding{utf8}.
We could imagine a function on a \emph{disjoint} domain, for example
a domain consisting of a line and a surface, where the surface and
the line do not intersect (have no common points). Such domains are
called \textbf{\index{disjoint domain}disjoint}.

The set of real roots of a quadratic equation $x^{2}+bx+c=0$ is an
example of a disjoint domain containing three connected parts: the
no-roots case, the one-root case where the root is represented by
a single number $x$, and the two-roots case where the roots are represented
by a pair of numbers $\left(x,y\right)$. Geometrically, a number
$x$ is pictured as a point on a line (a one-dimensional space), and
pair of numbers $\left(x,y\right)$ is pictured as a point on a Cartesian
plane (a two-dimensional space). The no-roots case corresponds to
a zero-dimensional space, which is pictured as a single point (see
Figure~\ref{fig:RootsOfQ-disjoint-domain}).

\begin{figure}
\begin{centering}
%\begin{pdfpic}
   \newrgbcolor{lightpastel}{0.90 0.93 0.87}
   \psset{unit=0.5\textwidth}
   \begin{pspicture}(0,0)(1,1)
      \pscircle(0.3,0.5){0.005}
      \psline{->}(0.5,0.2)(0.5,0.8)
      \rput(0.535,0.77){$x$}
      \pspolygon[fillstyle=solid,fillcolor=lightpastel](0.8,0.8)(0.8,0.3)(0.7,0.2)(0.7,0.7)(0.8,0.8)
      \psline{->}(0.7,0.2)(0.775,0.275)
      \rput(0.67,0.28){$x$} \rput(0.79,0.24){$y$}
      \psline{->}(0.7,0.2)(0.7,0.3)
      \rput(0.30,0.45){\smaller\texttt{NoRoots()}}
      \rput(0.49,0.85){\smaller\texttt{OneRoot(x)}}
      \rput(0.75,0.15){\smaller\texttt{TwoRoots(x, y)}}
   \end{pspicture}
%\end{pdfpic}
\par\end{centering}
\caption{The disjoint domain represented by the \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}
type.}
\label{fig:RootsOfQ-disjoint-domain}
\end{figure}

In the mathematical notation, a one-dimensional real space is denoted
by $\mathbb{R}$, a two-dimensional space by $\mathbb{R}^{2}$, and
a zero-dimensional space by $\mathbb{R}^{0}$. 

At first sight, we may think that the mathematical representation
of the type \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}
is a union of the three sets, $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}$.
But an ordinary union of sets would not work for two reasons. First,
usually a point is considered as a subset of a line, and a line as
a subset of a plane. This amounts to the assumption $\mathbb{R}^{0}\subset\mathbb{R}^{1}\subset\mathbb{R}^{2}$,
which means $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}=\mathbb{R}^{2}$.
If we do not make the assumption $\mathbb{R}^{0}\subset\mathbb{R}^{1}\subset\mathbb{R}^{2}$,
we encounter the second problem: the need to distinguish the parts
of the union unambiguously, even if some parts have the same type.
The disjunctive type shown in Example~\ref{subsec:disj-Example-rootsofq-2}
cannot be correctly represented by the mathematical union
\[
\mathbb{R}^{0}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}
\]
because $\mathbb{R}^{0}\cup\mathbb{R}^{0}=\mathbb{R}^{0}$ and $\mathbb{R}^{1}\cup\mathbb{R}^{1}=\mathbb{R}^{1}$,
so 
\[
\mathbb{R}^{0}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}=\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}\quad,
\]
but this is not the set we need.

In the Scala code, each part of a disjunctive type must be distinguished
by a unique name such as \inputencoding{latin9}\lstinline!NoRoots!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!OneRoot!\inputencoding{utf8}, and
\inputencoding{latin9}\lstinline!TwoRoots!\inputencoding{utf8}. To
represent this mathematically, we can attach a distinct label to each
part of the union. Labels are symbols without any special meaning,
and we can just assume that labels are names of Scala case classes.
Parts of the union are then represented by sets of pairs such as $(\text{\texttt{OneRoot}},x)_{x\in\mathbb{R}^{1}}$.
Then the domain \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}
is expressed as
\[
\text{\texttt{RootsOfQ}}=(\text{\texttt{NoRoots}},u)_{u\in\mathbb{R}^{0}}\cup(\text{\texttt{OneRoot}},x)_{x\in\mathbb{R}^{1}}\cup(\text{\texttt{TwoRoots}},\left(x,y\right))_{\left(x,y\right)\in\mathbb{R}^{2}}\quad.
\]
This is an ordinary union of mathematical sets, but each of the sets
has a unique label, so no two values from different parts of the union
could possibly be equal. This kind of labeled union is called a \index{disjoint union}\textbf{disjoint
union}. Each element of the disjoint union is a pair of the form \inputencoding{latin9}\lstinline!(label, data)!\inputencoding{utf8},
where the label uniquely identifies the part of the union, and the
data can have any chosen type such as $\mathbb{R}^{1}$. If we use
disjoint unions, we cannot confuse different parts of the union even
if their data have the same type, because labels are required to be
distinct.

Disjoint unions are not often explicitly denoted in mathematics, but
they are needed in software engineering because real-life data often
has that form.

\paragraph{Named \texttt{Unit} types}

At first sight, it may seem strange that the zero-dimensional space
is represented by a set containing \emph{one} point. Why should we
not use an empty set (rather than a set with one point) to represent
the case where the equation has no real roots? The reason is that
we are required to represent not only the values of the roots but
also the information \emph{about} the existence of the roots. The
case with no real roots needs to be represented by some \emph{value}
of type \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}.
This value cannot be missing, which would happen if we used an empty
set to represent the no-roots case. It is natural to use the named
empty tuple \inputencoding{latin9}\lstinline!NoRoots()!\inputencoding{utf8}
to represent this case, since we used a named $2$-tuple \inputencoding{latin9}\lstinline!TwoRoots(x, y)!\inputencoding{utf8}
to represent the case of two roots.

Consider the value $u$ used by the mathematical set $\left(\text{\texttt{NoRoots}},u\right)_{u\in\mathbb{R}^{0}}$.
Since $\mathbb{R}^{0}$ consists of a single point, there is only
one possible value of $u$. Similarly, the \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}
type in Scala has only one distinct value, written as \inputencoding{latin9}\lstinline!()!\inputencoding{utf8}.
A case class with no parts, such as \inputencoding{latin9}\lstinline!NoRoots!\inputencoding{utf8},
has only one distinct value, written as \inputencoding{latin9}\lstinline!NoRoots()!\inputencoding{utf8}.
This value is syntactically and semantically analogous to $\left(\text{\texttt{NoRoots}},u\right)_{u\in\mathbb{R}^{0}}$.

We see that case classes with no parts are quite similar to \inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}
except for an added name. For this reason, they can be viewed as ``named
\inputencoding{latin9}\lstinline!Unit!\inputencoding{utf8}'' types.\index{unit type!named}

\subsection{Disjunctive types in other programming languages}

Disjunctive types and the associated pattern matching turns out to
be one of the defining features of functional programming languages.
Programming languages that were not designed for functional programming
do not support these features, while ML, OCaml, Haskell, F\#, Scala,
Swift, Elm, and PureScript support disjunctive types and pattern matching
as part of the language design. 

It is remarkable that the named tuple types (also called ``structs''
or ``records'') are provided in almost every programming language,
while disjunctive types are almost never present except in languages
designed for the FP paradigm.\footnote{See \href{https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(basic_instructions)\#Other_types}{this Wikipedia page}
for a detailed comparison between programming languages. Ada and Pascal
are the only languages that have disjunctive types without other FP
features.} 

The \inputencoding{latin9}\lstinline!union!\inputencoding{utf8} types
in C and C++ are not disjunctive types because it is not possible
to determine which part of the union is being represented by a given
value. A \inputencoding{latin9}\lstinline!union!\inputencoding{utf8}
declaration in C looks like this,\inputencoding{latin9}
\begin{lstlisting}
union { int x; double y; long z; } di;
\end{lstlisting}
\inputencoding{utf8}The problem is that we cannot determine whether a given value \inputencoding{latin9}\lstinline!di!\inputencoding{utf8}
represents an \inputencoding{latin9}\lstinline!int!\inputencoding{utf8},
a \inputencoding{latin9}\lstinline!double!\inputencoding{utf8}, or
a \inputencoding{latin9}\lstinline!long!\inputencoding{utf8}. This
leads to errors that are hard to detect.

Programming languages of the C family (C, C++, Objective C, Java)
have ``enumeration'' (\inputencoding{latin9}\lstinline!enum!\inputencoding{utf8})
types, which \emph{are} a limited form of disjunctive types. An \inputencoding{latin9}\lstinline!enum!\inputencoding{utf8}
type declaration in Java looks like this:\inputencoding{latin9}
\begin{lstlisting}
enum Color { RED, GREEN, BLUE; } 
\end{lstlisting}
\inputencoding{utf8}In Scala, this is equivalent to a disjunctive type containing three
\emph{empty} tuples,\inputencoding{latin9}
\begin{lstlisting}
sealed trait Color
final case class RED() extends Color
final case class GREEN() extends Color
final case class BLUE() extends Color
\end{lstlisting}
\inputencoding{utf8}If the \inputencoding{latin9}\lstinline!enum!\inputencoding{utf8}
construction were ``enriched'' with extra data, so that each tuple
could be non-empty, we would obtain the full functionality of disjunctive
types. A definition of \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}
could then look like this: \inputencoding{latin9}
\begin{lstlisting}
// This is not valid in Java!
enum RootsOfQ {
  NoRoots(), OneRoot(x: Double), TwoRoots(x: Double, y: Double);
}
\end{lstlisting}
\inputencoding{utf8}A future version of Scala 3 will have a shorter syntax for disjunctive
types\footnote{See \href{https://dotty.epfl.ch/docs/reference/enums/adts.html}{https://dotty.epfl.ch/docs/reference/enums/adts.html}
for details.} that indeed looks like an ``enriched \inputencoding{latin9}\lstinline!enum!\inputencoding{utf8}'',\inputencoding{latin9}
\begin{lstlisting}
enum RootsOfQ {
  case NoRoots
  case OneRoot(x: Double)
  case TwoRoots(x: Double, y: Double)
}
\end{lstlisting}
\inputencoding{utf8}
For comparison, here is the OCaml and the Haskell syntax for a disjunctive
type equivalent to \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}:\inputencoding{latin9}
\begin{lstlisting}
{* OCaml *}
type RootsOfQ = NoRoots | OneRoot of float | TwoRoots of float*float

-- Haskell
data RootsOfQ = NoRoots | OneRoot Double | TwoRoots (Double,Double)
\end{lstlisting}
\inputencoding{utf8}This syntax is more concise than the Scala syntax. When reasoning
about disjunctive types, it is inconvenient to write out long type
definitions. Chapter~\ref{chap:3-3-The-formal-logic-curry-howard}
will define a short mathematical notation designed for efficient reasoning
about types and code.

\subsection{Disjunctions and conjunctions in formal logic\label{subsec:Disjunctions-and-conjunctions}}

In logic, a \textbf{proposition\index{proposition in logic}} is a
logical formula that could be true or false. A \textbf{disjunction\index{disjunction in logic}}
of propositions $A$, $B$, $C$ is denoted by $A\vee B\vee C$ and
is true if and only if \emph{at least one} of $A$, $B$, $C$ is
true. A \textbf{conjunction}\index{conjunction in logic} of $A$,
$B$, $C$ is denoted by $A\wedge B\wedge C$ and is true if and only
if \emph{all} of the propositions $A$, $B$, $C$ are true.

There is a similarity between a disjunctive data type and a logical
disjunction of propositions. A value of the disjunctive data type
\inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8} can
be constructed only if we have one of the values \inputencoding{latin9}\lstinline!NoRoots()!\inputencoding{utf8},
\inputencoding{latin9}\lstinline!OneRoot(x)!\inputencoding{utf8},
or \inputencoding{latin9}\lstinline!TwoRoots(x, y)!\inputencoding{utf8}
for some specific \inputencoding{latin9}\lstinline!x!\inputencoding{utf8}
and \inputencoding{latin9}\lstinline!y!\inputencoding{utf8}. Let
us now rewrite the previous sentence as a logical formula. Denote
by ${\cal CH}(A)$ the logical proposition ``this ${\cal C}$ode
${\cal H}$as a value of type \inputencoding{latin9}\lstinline!A!\inputencoding{utf8}'',
where ``this code'' refers to a particular expression or function
in our program. So, the proposition ``a function \emph{can} return
a value of type \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}''
is denoted by ${\cal CH}(\text{\texttt{RootsOfQ}})$. We can then
write the above sentence about \inputencoding{latin9}\lstinline!RootsOfQ!\inputencoding{utf8}
as the logical formula
\begin{equation}
{\cal CH}(\text{\texttt{RootsOfQ}})={\cal CH}(\text{\texttt{NoRoots}})\vee{\cal CH}(\text{\texttt{OneRoot}})\vee{\cal CH}(\text{\texttt{TwoRoots}})\quad.\label{eq:curry-howard-example-disjunction}
\end{equation}

There is also a a similarity between logical \emph{conjunctions} and
named tuple types. Consider the named tuple \inputencoding{latin9}\lstinline!TwoRoots(x: Double, y: Double)!\inputencoding{utf8}.
When can we have a value of type \inputencoding{latin9}\lstinline!TwoRoots!\inputencoding{utf8}?
Only when we have two values of type \inputencoding{latin9}\lstinline!Double!\inputencoding{utf8}.
Rewriting this sentence as a logical formula, we get
\[
{\cal CH}(\text{\texttt{TwoRoots}})={\cal CH}(\text{\texttt{Double}})\wedge{\cal CH}(\text{\texttt{Double}})\quad.
\]
Now, formal logic admits the simplification
\[
{\cal CH}(\text{\texttt{Double}})\wedge{\cal CH}(\text{\texttt{Double}})={\cal CH}(\text{\texttt{Double}})\quad.
\]
However, no such simplification will be available in the general case,
e.g.\inputencoding{latin9}
\begin{lstlisting}
case class Data3(x: Int, y: String, z: Double)
\end{lstlisting}
\inputencoding{utf8}For this type, we will have the formula 
\begin{equation}
{\cal CH}(\text{\texttt{Data3}})={\cal CH}(\text{\texttt{Int}})\wedge{\cal CH}(\text{\texttt{String}})\wedge{\cal CH}(\text{\texttt{Double}})\quad.\label{eq:curry-howard-example-case-class}
\end{equation}

We find that tuples are related to logical conjunctions in the same
way as disjunctive types are related to logical disjunctions. This
is the main motivation for choosing the name ``disjunctive types''.\footnote{These types are also called ``variants'', ``sum types'', ``co-product
types'', and ``tagged union types''.}

The correspondence between disjunctions, conjunctions, and data types
is explained in more detail in Chapter~\ref{chap:3-3-The-formal-logic-curry-howard}.
For now, we note that the operations of conjunction and disjunction
are not sufficient to produce all possible logical expressions. To
obtain a complete logic, it is also necessary to have a logical negation
$\neg A$ (``$A$ is not true'') or, equivalently, a logical implication
$A\Rightarrow B$ (``if $A$ is true than $B$ is true''). It turns
out that the logical implication $A\Rightarrow B$ is related to the
function type \inputencoding{latin9}\lstinline!A => B!\inputencoding{utf8}.
In Chapter~\ref{chap:Higher-order-functions}, we will study function
types in depth.
