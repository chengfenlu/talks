
\chapter{The formal logic of types I. Disjunctive types}

Disjunctive types describe values that belong to a disjoint set of
alternatives. 

To see how Scala implements disjunctive types, we need to begin by
looking at ``case classes''.

\section{Scala's case classes}

\subsection{Case classes as ``named tuple'' types}

It is often helpful to use names for the different parts of a tuple.
Suppose that some program represents the size and the color of socks
with the tuple type \lstinline!(Double, String)!. What if the same
tuple type \lstinline!(Double, String)! is used in another place
in the program to mean the amount paid and the name of the payee?
A programmer could mix the two values by mistake, and it would be
hard to find out why the program incorrectly computes, say, the total
amount paid.
\begin{lstlisting}
def totalAmountPaid(ps: Seq[(Double, String)]): Double = ps.map(_._1).sum
val x = (10.5, "white") // Sock size and color.
val y = (25.0, "friend") // Payment amount and payee.

scala> totalAmountPaid(Seq(x, y)) // Nonsense.
res0: Double = 35.5
\end{lstlisting}

We would prevent this kind of mistake if we could use two \emph{different}
types, with names such as \lstinline!MySock! and \lstinline!Payment!,
for the two kinds of data. There are  three basic ways of defining
a new named type in Scala that replaces a tuple: using a type alias,
using a case class, and using an \index{opaque type}opaque type. 

Opaque types (hiding a given type under a new name) is a feature that
will become standard in a future version of Scala 3; so let us focus
on type aliases and case classes.

A \textbf{type alias}\index{type alias} is an alternative name for
an existing (already defined) type. We could use type aliases in our
example to add clarity to the code:
\begin{lstlisting}
type MySockTuple = (Double, String)
type PaymentTuple = (Double, String)

scala> val s: MySockTuple = (10.5, "white")
s: MySockTuple = (10.5,white)

scala> val p: PaymentTuple = (25.0, "friend")
p: PaymentTuple = (25.0,friend)
\end{lstlisting}
But the mix-up error is not prevented:
\begin{lstlisting}
scala> totalAmountPaid(Seq(s, p)) // Nonsense again.
res1: Double = 35.5
\end{lstlisting}

Scala's \textbf{case classes}\index{case class} can be seen as ``tuples
with names''. A case class is equivalent to a tuple type that has
a name that we choose when we define the case class. Also, each part
of the case class will have a separate name that we must choose. This
is how to define case classes for the example with socks and payments:
\begin{lstlisting}
case class MySock(size: Double, color: String)
case class Payment(amount: Double, name: String)

scala> val sock = MySock(10.5, "white")
sock: MySock = MySock(10.5,white)

scala> val paid = Payment(25.0, "friend")
paid: Payment = Payment(25.0,friend)                                  ^ 
\end{lstlisting}
The new types \lstinline!MySock! and \lstinline!Payment! were defined.
Values of type \lstinline!MySock! are written as \lstinline!MySock(10.5, "white")!,
which is similar to writing the tuple \lstinline!(10.5, "white")!
except for adding the name \lstinline!MySock!.

To access the parts of a case class, we use the part names:
\begin{lstlisting}
scala> sock.size
res2: Double = 10.5

scala> paid.amount
res3: Double = 25.0
\end{lstlisting}
The mix-up error is now a type error flagged by the compiler:
\begin{lstlisting}
def totalAmountPaid(ps: Seq[Payment]): Double = ps.map(_.amount).sum

scala> totalAmountPaid(Seq(paid, paid))
res4: Double = 50.0

scala> totalAmountPaid(Seq(sock, paid))
<console>:19: error: type mismatch;
 found   : MySock
 required: Payment
       totalAmountPaid(Seq(sock, paid))
                            ^
\end{lstlisting}
A function whose argument is of type \lstinline!MySock! cannot be
applied to an argument of type \lstinline!Payment! or of type \lstinline!(Double, String)!.
Case classes with different names are \emph{different types}, even
if they contain the same types of parts. 

Just as tuples can have any number of parts, case classes can have
any number of parts, but the part names must be distinct, for example:
\begin{lstlisting}
case class Person(firstName: String, lastName: String, age: Int)

scala> val einstein = Person("Albert", "Einstein", 140)
einstein: Person = Person(Albert,Einstein,140)

scala> einstein.firstName
res5: String = Albert

scala> einstein.age
res6: Int = 140
\end{lstlisting}
This data type carries the same information as a tuple \lstinline!(String, String, Int)!.
However, the declaration of a \lstinline!case class Person! gives
the programmer several methods that make working with the tuple's
data more convenient.

Some (or all) part names may be specified when creating a case class
value:
\begin{lstlisting}
scala> val poincare = Person(firstName = "Henri", lastName = "Poincaré", 165)
poincare: Person = Person(Henri,Poincaré,165)
\end{lstlisting}
It is a type error to use wrong types with a case class:
\begin{lstlisting}
scala> val p = Person(140, "Einstein", "Albert")
<console>:13: error: type mismatch;
 found   : Int(140)
 required: String
       val p = Person(140, "Einstein", "Albert")
                      ^
<console>:13: error: type mismatch;
 found   : String("Albert")
 required: Int
       val p = Person(140, "Einstein", "Albert")
                                       ^
\end{lstlisting}
Here, the error is due to an incorrect order of parts when creating
a case class value. However, parts can be specified in any order when
using part names:
\begin{lstlisting}
scala> val p = Person(age = 140, lastName = "Einstein", firstName = "Albert")
p: Person = Person(Albert,Einstein,140)
\end{lstlisting}
A part of a case class can have the type of another case class, creating
a ``nested'' type:
\begin{lstlisting}
case class BagOfSocks(sock: MySock, count: Int)
val bag = BagOfSocks(MySock(10.5, "white"), 6)

scala> bag.socks.size
res7: Double = 10.5
\end{lstlisting}


\subsection{Case classes with type parameters}

Generally, type classes can be defined with \index{type parameter}type
parameters. As an example, consider a generalization of \lstinline!MySock!
where, in addition to the size and color, a ``sock'' may hold another
value. We could define several specialized case classes,
\begin{lstlisting}
case class MySockInt(size: Double, color: String, value: Int)
case class MySockBoolean(size: Double, color: String, value: Boolean)
\end{lstlisting}
but it is better to define a single parameterized case class
\begin{lstlisting}
case class MySockX[A](size: Double, color: String, value: A)
\end{lstlisting}
that works for every type \lstinline!A!. When we create values of
\lstinline!MySockX!, we will use a specific type, for instance
\begin{lstlisting}
scala> val s = MySockX(10.5, "white", 123)
s: MySockX[Int] = MySockX(10.5,white,123) 
\end{lstlisting}
Here, the type variable \lstinline!A! was automatically set to a
specific type, \lstinline!Int!. 

Specific types \lstinline!A! will be used by each specific value
of type \lstinline!MySockX[A]!, but we can write code working with
\lstinline!MySockX[A]! \textbf{parametrically}\index{parametric code},
that is, keeping the type parameter \lstinline!A! in the code. For
example, a function that checks whether a sock of type \lstinline!MySockX[A]!
fits my foot can be written as
\begin{lstlisting}
def fitsMe[A](sock: MySockX[A]): Boolean = sock.size >= 10.5 && sock.size <= 11.0
\end{lstlisting}
This function is defined for all types \lstinline!A! at once, because
its code works in the same way regardless of the type \lstinline!A!.
Scala will set the type parameter automatically:
\begin{lstlisting}
scala> fitsMe(MySockX(10.5, "blue", List(1,2,3))) // Parameter A = List[Int]
res0: Boolean = true
\end{lstlisting}
In this case it is clear that the type parameter \lstinline!A! must
be set to \lstinline!List[Int]!, and we may omit the type parameter
when calling \lstinline!fitsMe!. When types become more complicated,
it may be helpful to avoid type errors by specifying the values of
type parameters. For example, here is a type error due to a mismatch
between the type parameter \lstinline!A! used in the ``sock'' value,
which is \lstinline!List[Int]!, and the type parameter in the function
\lstinline!fitsMe!, specified as \lstinline!Int!:
\begin{lstlisting}
scala> fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
<console>:15: error: type mismatch;
 found   : List[Int]
 required: Int
       fitsMe[Int](MySockX(10.5, "blue", List(1,2,3)))
                                             ^ 
\end{lstlisting}

Case classes may have several type parameters, and the types of the
parts may use these type parameters. Here is an artificial example
of a case class using type parameters in different ways,
\begin{lstlisting}
case class Complicated[A,B,C,D](x: (A, A), y: (B, Int) => A, z: C => C)
\end{lstlisting}
This case class contains parts of different types that use the type
parameters \lstinline!A!, \lstinline!B!, \lstinline!C! in tuples
and functions. The type parameter \lstinline!D! is not used at all;
this is allowed as well.

\subsection{Tuples with one part and with zero parts}

Let us compare tuples and case classes more systematically.

Parts of a case class are accessed by name with a dot syntax, for
example \lstinline!sock.color!. Parts of a tuple are accessed with
the accessors such as \lstinline!x._1!. This syntax is the same as
that for a case class whose parts have names \lstinline!_1!, \lstinline!_2!,
etc. So, it appears that tuple parts \emph{do} have names in Scala,
although those names are always automatically assigned as \lstinline!_1!,
\lstinline!_2!, etc. It turns out that tuple types also have automatically
assigned names in Scala; these names are \lstinline!Tuple2!, \lstinline!Tuple3!,
etc., and they correspond to parameterized types, since each part
of the tuple may be of any type. So, a tuple type expression such
as \lstinline!(Int, String)! is just a special syntax for the parameterized
type \lstinline!Tuple2[Int, String]!. One could define the tuple
types as case classes like this,
\begin{lstlisting}
case class Tuple2[A, B](_1: A, _2: B)
case class Tuple3[A, B, C](_1: A, _2: B, _3: C)
// And so on with Tuple4, Tuple5, ...
\end{lstlisting}
if these types were not already defined in the Scala library.

Proceeding systematically, we ask whether tuple types can have just
one part or even no parts. Indeed, Scala defines \lstinline!Tuple1[A]!
as a tuple with a single part. (This type is occasionally useful in
practice.) 

The tuple with zero parts exists as well, and is called \lstinline!Unit!
(rather than ``\lstinline!Tuple0!''). At first sight, the \lstinline!Unit!
type may appear to be completely useless; it is a tuple that contains
\emph{no} elements. The syntax for the value of the \lstinline!Unit!
type is the empty tuple, \lstinline!()!. It is clear that there is
\emph{only one} value, \lstinline!()!, of this type; this explains
the name ``unit''. It turns out, however, that the \lstinline!Unit!
type is important in functional programming, and it is used as a type
\emph{guaranteed} to have only a single distinct value. This chapter
will show some examples of using the \lstinline!Unit! type.

Case classes can be defined similarly to the one-part and zero-part
tuples like this:
\begin{lstlisting}
case class B(z: Int) // Tuple with one part.
case class C() // Tuple with no parts.
\end{lstlisting}
Let us summarize the correspondence between tuples and case classes:
\begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{Tuples} & \textbf{Case classes}\tabularnewline
\hline 
\hline 
\lstinline!(123, "xyz"): Tuple2[Int, String]! & \lstinline!case class A(x: Int, y: String)!\tabularnewline
\hline 
\lstinline!(123,): Tuple1[Int]! & \lstinline!case class B(z: Int)!\tabularnewline
\hline 
\lstinline!(): Unit! & \lstinline!case class C()!\tabularnewline
\hline 
\end{tabular}
\par\end{center}

Scala has a special syntax for empty case class\index{empty case class}es:
\begin{lstlisting}
case object C // Similar to `case class C()`.
\end{lstlisting}
There are two main differences between \lstinline!case class C()!
and \lstinline!case object C!:
\begin{itemize}
\item A \lstinline!case object! cannot have type parameters, while we may
define a \lstinline!case class C[X, Y, Z]()! if needed.
\item A \lstinline!case object! is allocated in memory only once, while
new values of a \lstinline!case class C()! will be allocated in memory
each time \lstinline!C()! is evaluated.
\end{itemize}
Other than that, \lstinline!case class C()! and \lstinline!case object C!
have the same meaning: a named tuple with zero parts, which we may
also call a ``named \lstinline!Unit!\index{named Unit}'' type.
In this book, I will not use \lstinline!case object!s because \lstinline!case class!es
are more general.

\subsection{Pattern matching for case classes}

Scala performs pattern matching in two situations:
\begin{itemize}
\item destructuring definition: \lstinline[mathescape=true]!val $pattern$ = ...!
\item \lstinline!case! expression: \lstinline[mathescape=true]!case $pattern$ => ...!
\end{itemize}
Case classes can be used in both situations. Here is an example of
a destructuring definition, used to implement a function whose argument
is of case class type \lstinline!BagOfSocks!:
\begin{lstlisting}
case class MySock(size: Double, color: String)
case class BagOfSocks(sock: MySock, count: Int)

def printBag(bag: BagOfSocks): String = {
  val BagOfSocks(MySock(size, color), count) = bag // Destructure the `bag`.
  s"Bag has $count $color socks of size $size"
}

val bag = BagOfSocks(MySock(10.5, "white"), 6)

scala> printBag(bag)
res0: String = Bag has 6 white socks of size 10.5
\end{lstlisting}

An example of using the \lstinline!case! expression:
\begin{lstlisting}
def fitsMe(bag: BagOfSocks): Boolean = bag match {
  case BagOfSocks(MySock(size, _), _) => size >= 10.5 && size <= 11.0
}
\end{lstlisting}
In the implementation of this function, we match the \lstinline!bag!
value against the pattern \lstinline!BagOfSocks(MySock(size, _), _)!.
This pattern will always match and will define \lstinline!size! as
the pattern variable of type \lstinline!Double!.

The syntax for pattern matching expressions that use case classes
is similar to the syntax for pattern matching of tuples, except for
the presence of the \emph{names} of the case classes. For example,
if we remove the type names from the pattern
\begin{lstlisting}
case BagOfSocks(MySock(size, _), _) => ...
\end{lstlisting}
we obtain the nested tuple pattern 
\begin{lstlisting}
case ((size, _), _) => ...
\end{lstlisting}
that could be used for values of type \lstinline!((Double, String), Int)!.
We see that case classes behave in many ways exactly as named tuple
types. 

Scala's ``case classes'' got their name from their use in \lstinline!case!
expressions. It is usually more convenient to use \lstinline!match!
/ \lstinline!case! expressions with case classes than to use destructuring.

\section{Disjunctive types}

\subsection{Motivation and first examples\label{subsec:Disjunctive-Motivation-and-first-examples}}

In many situations, it is useful to have several different shapes
of data within the same type. As a first example, suppose we are looking
for real roots of a quadratic equation $x^{2}+bx+c=0$. There are
three cases: no real roots, one real root, and two real roots. It
would be convenient if we had a type, such as \lstinline!RootsOfQ!,
that means ``the real roots of a quadratic equation''. Inside that
type, we can distinguish between the three cases, but outside it looks
like a single type, so that it is easier to work with.

Another example is the binary search algorithm that looks for an integer
$x$ in a sorted array. There are two cases: the algorithm either
finds the index of $x$ or determines that the array does not contain
$x$. It is convenient if the algorithm could return a single value
of a type, say, \lstinline!SearchResult!, that represents \emph{either}
an index at which $x$ is found, \emph{or} the absence of an index.

More generally, we may have computations that \emph{either} return
a value \emph{or} generate an error and fail to produce a result.
It is then convenient to return a value of type, say, \lstinline!Result!,
that could represent either a correct result or an error message. 

In certain computer games, one has different types of ``rooms'',
each room having certain properties depending on its type, \textendash{}
some rooms are dangerous because of monsters, other rooms contain
useful objects, certain rooms allow you to finish the game, and so
on. We want to represent all the different kinds of rooms uniformly,
as a type \lstinline!Room!, so that each ``room value'' automatically
stores the correct properties in each case.

In all these situations, data comes in several mutually exclusive
shapes. This data can be represented by a single type only if that
type is able to describe a mutually exclusive set of cases:
\begin{itemize}
\item \lstinline!RootsOfQ! must be either the empty tuple \lstinline!()!
or \lstinline!Double! or a tuple \lstinline!(Double, Double)!
\item \lstinline!SearchResult! must be either \lstinline!Int! or the empty
tuple \lstinline!()!
\item \lstinline!Result! must be either an \lstinline!Int! value or a
\lstinline!String! message
\end{itemize}
We see that the empty tuple, also known as the \lstinline!Unit! type,
is convenient to use in this representation! It is also helpful to
assign names to each of the cases:
\begin{itemize}
\item \lstinline!RootsOfQ! is ``no roots'' with value \lstinline!()!,
or ``one root'' with value \lstinline!Double!, or ``two roots''
with value \lstinline!(Double, Double)!
\item \lstinline!SearchResult! is ``index'' with value \lstinline!Int!,
or ``not found'' with value \lstinline!()!
\item \lstinline!Result! is ``value'' of type \lstinline!Int! or ``error
message'' of type \lstinline!String!
\end{itemize}
Scala's case classes provide exactly what we need here \textendash{}
\emph{named tuples} with zero, one, two and more parts, and so it
is natural to use case classes instead of tuples:
\begin{itemize}
\item \lstinline!RootsOfQ! is a value of type \lstinline!case class NoRoots()!,
or a value of type \lstinline!case class OneRoot(x: Double)!, or
of type \lstinline!case class TwoRoots(x: Double, y: Double)!
\item \lstinline!SearchResult! is a value of type \lstinline!case class Index(Int)!
or a value of type \lstinline!case class None()!
\item \lstinline!Result! is a value of type \lstinline!case class Value(x: Int)!
or a value of type \lstinline!case class Error(message: String)!
\end{itemize}
Our three examples are now described as types that select one case
class out of a given set. The only remaining question is how Scala
defines such types. For instance, the definition of \lstinline!RootsOfQ!
somehow needs to indicate that the case classes \lstinline!NoRoots!,
\lstinline!OneRoot!, and \lstinline!TwoRoots! are exactly the three
alternatives described by the type \lstinline!RootsOfQ!. The Scala
syntax for this definition looks like this:
\begin{lstlisting}
sealed trait RootsOfQ
final case class NoRoots() extends RootsOfQ
final case class OneRoot(x: Double) extends RootsOfQ
final case class TwoRoots(x: Double, y: Double) extends RootsOfQ
\end{lstlisting}
In the definition of \lstinline!SearchResult!, we we have two cases:
\begin{lstlisting}
sealed trait SearchResult
final case class Index(i: Int) extends SearchResult
final case class NotFound() extends SearchResult
\end{lstlisting}
The definition of the \lstinline!Result! type can be parameterized,
so that we can describe results of any type (but error messages are
always of type \lstinline!String!):
\begin{lstlisting}
sealed trait Result[A]
final case class Value[A](x: A) extends Result[A]
final case class Error[A](message: String) extends Result[A]
\end{lstlisting}

The ``\lstinline!sealed trait! / \lstinline!final case class!''
syntax defines a type that represents a choice of one case class from
a fixed set of case classes. This kind of type is called the \textbf{\index{disjunctive type}disjunctive
type} in this book. 

\subsection{Solved examples: Pattern matching with disjunctive types}

Our first examples of disjunctive types are \lstinline!RootsOfQ!,
\lstinline!SearchResult!, and \lstinline!Result[A]! defined in the
previous section. We will now look at the Scala syntax for \emph{creating}
values of disjunctive types and for \emph{using} the created values.

Consider the disjunctive type \lstinline!RootsOfQ! that has three
case classes (\lstinline!NoRoots!, \lstinline!OneRoot!, \lstinline!TwoRoots!).
The only way of creating a value of type \lstinline!RootsOfQ! is
to create a value of one of these case classes. This is done by writing
expressions such as \lstinline!NoRoots()!, \lstinline!OneRoot(2.0)!,
or \lstinline!TwoRoots(1.0, -1.0)!. Scala will accept these expressions
as having the type \lstinline!RootsOfQ!.
\begin{lstlisting}
scala> val x: RootsOfQ = OneRoot(2.0)
x: RootsOfQ = OneRoot(2.0)
\end{lstlisting}

Given a value \lstinline!x:RootsOfQ!, how can we use it, say, as
a function argument? The main tool for working with values of disjunctive
types is pattern matching with \lstinline!match! / \lstinline!case!
expressions. In Chapter~\ref{chap:2-Mathematical-induction}, we
used pattern matching to destructure tuples; that required expressions
such as \lstinline!{ case (x, y) => ... }!. We will now see how the
\lstinline!match! / \lstinline!case! expressions are used to match
disjunctive types. We may need to have \emph{more than one} \lstinline!case!
pattern in a \lstinline!match! expression, because we need to match
all possible cases of the disjunctive type:
\begin{lstlisting}
def f(x: RootsOfQ): String = x match {
  case NoRoots()       => "no real roots"
  case OneRoot(r)      => s"one real root: $r"
  case TwoRoots(x, y)  => s"real roots: ($x, $y)"
}

scala> f(OneRoot(2.0))
res0: String = "one real root: 2.0"
\end{lstlisting}
If we only need to recognize a specific case of a disjunctive type,
we can match all other cases with an underscore:
\begin{lstlisting}
scala> x match {
  case OneRoot(r)   => s"have one root $r"
  case _            => "have something else"
}
res0: String = have one root 2.0
\end{lstlisting}
The \lstinline!match! / \lstinline!case! expression represents a
choice over possible values of a given type. Note the similarity with
this code:

\begin{lstlisting}
def f(x: Int): Int = x match {
  case 0    => println(s"error: must be nonzero"); -1
  case 1    => println(s"error: must be greater than 1"); -1
  case _    => x
} // 0 and 1 are some possible values of type Int.
\end{lstlisting}
The values \lstinline!0! and \lstinline!1! are possible values of
type \lstinline!Int!, just as \lstinline!OneRoot(1.0)! is a possible
value of type \lstinline!RootsOfQ!. As a rule, \lstinline!match!
/ \lstinline!case! expressions will contain a complete list of possibilities
to match. If the list of cases is incomplete, the Scala compiler will
print a warning
\begin{lstlisting}
scala> def g(x: RootsOfQ): String = x match {
     |    case OneRoot(r) => s"have one root $r"
     | }
<console>:14: warning: match may not be exhaustive.
It would fail on the following inputs: NoRoots(), TwoRoots(_, _)
       def g(x: RootsOfQ): String = x match {
                                    ^
\end{lstlisting}
This code defines a \index{partial function}partial function \lstinline!g!
that can be applied only to values of the form \lstinline!OneRoot(...)!. 

Let us look at more examples of using the disjunctive types we just
defined.

\subsubsection{Example \label{subsec:disj-Example-rootsofq-1}\ref{subsec:disj-Example-rootsofq-1}}

Given a sequence of quadratic equations, compute the sequence that
contains their real roots as values of type \lstinline!RootsOfQ!.

\subparagraph{Solution}

Define a case class representing a quadratic equation $x^{2}+bx+c=0$:
\begin{lstlisting}
case class QEqu(b: Double, c: Double)
\end{lstlisting}
The following function determines how many real roots an equation
has:
\begin{lstlisting}
def solve(quadraticEqu: QEqu): RootsOfQ = {
   val QEqu(b, c) = quadraticEqu // Destructure QEqu.
   val d = b * b / 4 - c
   if (d > 0) {
     val s = math.sqrt(d)
     TwoRoots(b / 2 - s, b / 2 + s)
   } else if (d == 0.0) OneRoot(b / 2)
   else NoRoots()
}
\end{lstlisting}
Test this function:
\begin{lstlisting}
scala> solve(QEqu(1,1))
res1: RootsOfQ = NoRoots()

scala> solve(QEqu(1,-1))
res2: RootsOfQ = TwoRoots(-0.6180339887498949,1.618033988749895) 

scala> solve(QEqu(6,9))
res3: RootsOfQ = OneRoot(3.0) 
\end{lstlisting}
We can now solve this example via this code,
\begin{lstlisting}
def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map(solve)
\end{lstlisting}
If the function \lstinline!solve! is not used often, we may want
to write it inline:
\begin{lstlisting}
def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map { case QEqu(b, c) =>
  (b * b / 4 - c) match {
    case d if d > 0   =>
      val s = math.sqrt(d)
      TwoRoots(b / 2 - s, b / 2 + s)
    case 0.0          => OneRoot(b / 2)
    case _            => NoRoots()
  }
}
\end{lstlisting}
This code uses some features of Scala syntax. We can use the partial
function \lstinline!{ case QEqu(b, c) => ... }! directly as the argument
of \lstinline!.map! instead of defining this function separately.
This avoids the need to destructure \lstinline!QEqu! at a separate
step. The \lstinline!if! / \lstinline!else! expression is replaced
by an ``embedded''\index{embedded `if`} \lstinline!if! within
the \lstinline!case! expression, which is easier to read. Test the
final code:
\begin{lstlisting}
scala> findRoots(Seq(QEqu(1,1), QEqu(2,1)))
res4: Seq[RootsOfQ] = List(NoRoots(), OneRoot(1.0)) 
\end{lstlisting}


\subsubsection{Example \label{subsec:disj-Example-rootsofq}\ref{subsec:disj-Example-rootsofq}}

Given a sequence of values of type \lstinline!RootsOfQ!, compute
the sequence that contains only the single roots. Example test:
\begin{lstlisting}
def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] = ???

scala> singleRoots(Seq(TwoRoots(-1, 1), OneRoot(3.0), OneRoot(1.0), NoRoots()))
res5: Seq[Double] = List(3.0, 1.0) 
\end{lstlisting}


\subparagraph{Solution}

We apply \lstinline!.filter! and \lstinline!.map! to the sequence
of roots:
\begin{lstlisting}
def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] = rs.filter {
  case OneRoot(x) => true
  case _          => false
}.map { case OneRoot(x) => x }
\end{lstlisting}
In the \lstinline!.map! operation, we only need to cover the one-root
case because the other two possibilities have been ``filtered out''
by the preceding \lstinline!.filter! operation.

\subsubsection{Example \label{subsec:disj-Example-searchresult}\ref{subsec:disj-Example-searchresult}}

Implement binary search returning a \lstinline!SearchResult!. We
will modify the binary search implementation from Example~\ref{subsec:ch2Example-binary-search-seq-4}(b)
so that it returns a \lstinline!NotFound! value when appropriate.

\subparagraph{Solution}

The code from Example~\ref{subsec:ch2Example-binary-search-seq-4}(b)
will return \emph{some} index even if the given number is not present
in the array: 
\begin{lstlisting}
scala> binSearch(Array(1, 3, 5, 7), 5)
res6: Int = 2

scala> binSearch(Array(1, 3, 5, 7), 4)
res7: Int = 1
\end{lstlisting}
When the number is not present, the array's element at the computed
index will not be equal to \lstinline!goal!. We can return \lstinline!NotFound!
in that case. The new code can be written as a \lstinline!match!
/ \lstinline!case! expression for clarity:
\begin{lstlisting}
def safeBinSearch(xs: Seq[Int], goal: Int): SearchResult = binSearch(xs, goal) match {
  case n if xs(n) == goal   => Index(n) 
  case _                    => NotFound()
}
\end{lstlisting}
To test:
\begin{lstlisting}
scala> safeBinSearch(Array(1, 3, 5, 7), 5)
res8: SearchResult = Index(2)

scala> safeBinSearch(Array(1, 3, 5, 7), 4)
res9: SearchResult = NotFound()
\end{lstlisting}


\subsubsection{Example \label{subsec:disj-Example-resultA}\ref{subsec:disj-Example-resultA}}

Use the disjunctive type \lstinline!Result[Int]! to implement a ``safe
integer arithmetic'', where a division by zero or a square root of
a negative number will give an error message. Define arithmetic operations
directly for values of type \lstinline!Result[Int]!; abandon computations
if an error occurs.

\subparagraph{Solution}

Begin by implementing the square root:
\begin{lstlisting}
def sqrt(rx: Result[Int]): Result[Int] = rx match {
  case Value(x) if x >= 0  => Value(math.sqrt(x).toInt)
  case Value(x)            => Error(s"error: sqrt($x)")
  case Error(m)            => Error(m) // Keep the error message.
}
\end{lstlisting}
The square root is computed only if we have the \lstinline!Value(x)!
case, and only if $x\geq0$. If the argument \lstinline!rx! was already
an \lstinline!Error! case, we keep the error message and perform
no further operations.

To implement the addition operation, we need a bit more work:
\begin{lstlisting}
def add(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match {
  case (Value(x), Value(y)) => Value(x + y)
  case (Error(m), _)        => Error(m) // On any error, do no further computations.
  case (_, Error(m))        => Error(m)
}
\end{lstlisting}
This code illustrates nested patterns that match the tuple \lstinline!(rx, ry)!
against various possibilities. In this way, the code is clearer than
it would be if written with nested \lstinline!if! / \lstinline!else!
expressions.

Implementing the multiplication operation results in almost the same
code:
\begin{lstlisting}
def mul(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match {
  case (Value(x), Value(y)) => Value(x * y)
  case (Error(m), _)        => Error(m)
  case (_, Error(m))        => Error(m)
}
\end{lstlisting}
To avoid the repetition of code, we may define a general function
that ``promotes'' operations on integers to operations on \lstinline!Result[Int]!
types:
\begin{lstlisting}
def do2(rx: Result[Int], ry: Result[Int])(op: (Int, Int) => Int): Result[Int] =
  (rx, ry) match {
    case (Value(x), Value(y)) => Value(op(x, y))
    case (Error(m), _)        => Error(m)
    case (_, Error(m))        => Error(m)
  }
\end{lstlisting}
Now we can easily ``promote'' any binary operation that never generates
an error to an operation on \lstinline!Result[Int]!.
\begin{lstlisting}
def sub(rx: Result[Int], ry: Result[Int]): Result[Int] = do2(rx, ry){ (x, y) => x - y }
\end{lstlisting}
 Custom code is still needed for operations that may generate errors:
\begin{lstlisting}
def div(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match {
  case (Value(x), Value(y)) if y != 0  => Value(x / y)
  case (Value(x), Value(y))            => Error(s"error: $x / $y")
  case (Error(m), _)                   => Error(m)
  case (_, Error(m))                   => Error(m)
}
\end{lstlisting}
We can now test the new ``safe arithmetic'' on simple calculations:
\begin{lstlisting}
scala> add(Value(1), Value(2))
res10: Result[Int] = Value(3)

scala> div(add(Value(1), Value(2)), Value(0))
res11: Result[Int] = Error(error: 3 / 0)
\end{lstlisting}
We see that indeed all further computations are abandoned once an
error occurs. An error message shows only the immediate calculation
that generated the error. For instance, the error message for $20+\frac{1}{0}$
never mentions $20$:
\begin{lstlisting}
scala> add(Value(20), div(Value(1), Value(0)))
res12: Result[Int] = Error(error: 1 / 0)

scala> add(sqrt(Value(-1)), Value(10))
res13: Result[Int] = Error(error: sqrt(-1))
\end{lstlisting}


\subsection{Standard disjunctive types: \texttt{Option}, \texttt{Either}, \texttt{Try}}

The Scala library defines the disjunctive types \lstinline!Option!,
\lstinline!Either!, and \lstinline!Try! because they are used often. 

\paragraph{\texttt{Option}}

The \lstinline!Option! type is a disjunctive type with two cases:
the empty tuple and a one-element tuple. The names of the two case
classes are \lstinline!None! and \lstinline!Some!. If the \lstinline!Option!
type were not already defined in the standard library, one could define
it with the code
\begin{lstlisting}
sealed trait Option[T]
final case object None extends Option[Nothing]
final case class Some[T](t: T) extends Option[T]
\end{lstlisting}
This code is similar to the type \lstinline!SearchResult! defined
in Section~\ref{subsec:Disjunctive-Motivation-and-first-examples}
except that \lstinline!Option! has a type parameter instead of a
fixed type \lstinline!Int!. Another difference is the use of a \lstinline!case object!
for the empty case instead of an empty case class, such as \lstinline!None()!.
Since Scala's \lstinline!case object!s cannot have type parameters,
the type parameter in the definition of \lstinline!None! must be
set to the special type \lstinline!Nothing!, which is a type with
\emph{no} values.

An alternative (implemented in libraries such as \texttt{scalaz})
is to define 
\begin{lstlisting}
final case class None[T]() extends Option[T]
\end{lstlisting}
and write the empty option value as \lstinline!None()!. In that implementation,
the empty option also has a type parameter.

Several consequences follow from the Scala standard library's decision
to define \lstinline!None! without a type parameter. One consequence
is that the value \lstinline!None! can be reused as a value of type
\lstinline!Option[A]! for any type \lstinline!A!:
\begin{lstlisting}
scala> val y: Option[Int] = None
y: Option[Int] = None

scala> val z: Option[String] = None
z: Option[String] = None
\end{lstlisting}

Typical usage of \lstinline!Option! is for situations where a value
may be either present or missing, especially when the missing value
is \emph{not an error}. The missing-value case is then represented
by \lstinline!None!, while \lstinline!Some(...)! represents the
case where a value is present.

\subsubsection{Example \label{subsec:Disjunctive-Example-option-1}\ref{subsec:Disjunctive-Example-option-1}}

Suppose that information about subscribers to a certain online service
must contain a name and an email address, but a telephone number is
optional. To represent this information, we may define a case class
like this,
\begin{lstlisting}
case class Subscriber(name: String, email: String, phone: Option[Long])
\end{lstlisting}
What if we represent the missing telephone number by a special integer
value such as \lstinline!-1!, which allows us to use the simpler
type \lstinline!Long! instead of \lstinline!Option[Long]!? The disadvantage
is that we need to remember to check for this special value in every
function that takes the telephone number as an argument. Looking at
a function such as \lstinline!sendSMS(phone: Long)! in a different
place in the code, another software developer might forget that the
telephone number is actually optional. The type signature \lstinline!sendSMS(phone: Option[Long])!
unambiguously indicates to everyone that the telephone number might
be missing.

Pattern-matching code involving \lstinline!Option! needs two cases:
\begin{lstlisting}
def getDigits(phone: Option[Long]): Option[Seq[Long]] = phone match {
  case None               => None // Do nothing.
  case Some(number)       => Some(digitsOf(number))
}
\end{lstlisting}
Here we used the function \lstinline!digitsOf! defined in Section~\ref{sec:ch2Converting-a-single}. 

Note that the value \lstinline!None! is used with different types
on the two sides of \lstinline!case None => None!, namely \lstinline!Option[Long]!
and \lstinline!Option[Seq[Long]]!. Since these types are declared
in the type signature of the function \lstinline!getDigits!, the
Scala compiler is able to deduce the correct types of all expressions
in the \lstinline!match! / \lstinline!case! construction. This allows
us to write shorter pattern-matching code.

If we now need to compute the number of digits, we can write
\begin{lstlisting}
def numberOfDigits(phone: Option[Long]): Option[Long] = getDigits(phone) match {
  case None               => None // Do nothing.
  case Some(digits)       => Some(digits.length)
}
\end{lstlisting}

It is often useful to perform some computation when an \lstinline!Option!
value is not empty, and to leave it empty otherwise. Rather than keep
repeating this kind of code, we can implement this logic as a function
that takes the computation as a parameter: 
\begin{lstlisting}
def doComputation(x: Option[Long], f: Long => Long): Option[Long] = x match {
  case None               => None // Do nothing.
  case Some(i)            => Some(f(i))
}
\end{lstlisting}
It is then natural to generalize this function to arbitrary types
using type parameters, rather than a fixed type \lstinline!Long!.
The result is a function called \lstinline!fmap!:
\begin{lstlisting}
def fmap[A, B](f: A => B): Option[A] => Option[B] = {
  case None               => None // Do nothing.
  case Some(a)            => Some(f(a))
}

scala> fmap(digitsOf)(Some(4096))
res0: Option[Seq[Long]] = Some(List(4, 0, 9, 6))

scala> fmap(digitsOf)(None)
res1: Option[Seq[Long]] = None
\end{lstlisting}
One can say that the \lstinline!fmap! operation ``lifts'' or ``raises''
a given function of type \lstinline!A => B! to the type \lstinline!Option[A] => Option[B]!.

The Scala library implements an equivalent function as a method on
the \lstinline!Option! class, with the syntax \lstinline!x.map(f)!
rather than \lstinline!fmap(f)(x)!. We can concisely rewrite the
previous code using the library methods as
\begin{lstlisting}
def getDigits(phone: Option[Long]): Option[Seq[Long]] = phone.map(digitsOf)
def numberOfDigits(phone: Option[Long]): Option[Long] = phone.map(digitsOf).map(_.length)
\end{lstlisting}
We see that the \lstinline!.map! operation for the \lstinline!Option!
type is analogous to the \lstinline!.map! operation for sequences. 

The similarity between \lstinline!Option[A]! and \lstinline!Seq[A]!
is made clearer if we imagine \lstinline!Option[A]! to be a sequence
whose length is restricted to be either $0$ or $1$. So, \lstinline!Option[A]!
can have all the operations of \lstinline!Seq[A]!, except the operations
such as \lstinline!.concat! that may increase the length of the sequence.
The admissible operations defined on \lstinline!Option! include \lstinline!.map!,
\lstinline!.filter!, \lstinline!.forall!, \lstinline!.exists!,
\lstinline!.flatMap!, and \lstinline!.foldLeft!.

\subsubsection{Example \label{subsec:Disjunction-Example-Option-flatMap}\ref{subsec:Disjunction-Example-Option-flatMap}}

Given a phone number as \lstinline!Option[Long]!, extract the country
code if it is present. (Assume that the country code is any digits
in front of the $10$-digit number; for the phone number $18004151212$,
the country code is $1$.) The result must be again of type \lstinline!Option[Long]!. 

If the phone number is a positive integer $n$, we may compute the
country code simply as \lstinline!n / 10000000000L!. However, if
the result is zero, we should return an empty \lstinline!Option!
(i.e.~the value \lstinline!None!) rather than \lstinline!0!. To
implement this logic, we may begin by writing this code,
\begin{lstlisting}
def countryCode(phone: Option[Long]): Option[Long] = phone match {
  case None => None
  case Some(n) =>
    val countryCode = n / 10000000000L
    if (countryCode != 0L) Some(countryCode) else None 
}
\end{lstlisting}
We may notice that we have reimplemented the design pattern similar
to \lstinline!.map! in this code, namely ``if \lstinline!None!,
return \lstinline!None!, else do a computation''. So we may try
to rewrite the code as
\begin{lstlisting}
def countryCode(phone: Option[Long]): Option[Long] = phone.map { n =>
    val countryCode = n / 10000000000L
    if (countryCode != 0L) Some(countryCode) else None 
} // Type error: the result is Option[Option[Long]].
\end{lstlisting}
But this code will not compile: we are returning an \lstinline!Option[Long]!
within a function that we raise using \lstinline!.map!, so the resulting
type is \lstinline!Option[Option[Long]]!. To convert it to the required
\lstinline!Option[Long]!, we may use \lstinline!.flatten!, and since
this follows a \lstinline!.map!, we can rewrite the code using a
\lstinline!.flatMap! operation:
\begin{lstlisting}
def countryCode(phone: Option[Long]): Option[Long] = phone.flatMap { n =>
    val countryCode = n / 10000000000L
    if (countryCode != 0L) Some(countryCode) else None 
} // Types are correct now.
\end{lstlisting}
Another way of implementing this code is to notice the design pattern
``if condition does not hold, return \lstinline!None!, otherwise
keep the value''. For an \lstinline!Option! type, this is equivalent
to the \lstinline!.filter! operation. So the final code is
\begin{lstlisting}
def countryCode(phone: Option[Long]): Option[Long] = 
  phone.map(_ / 10000000000L).filter(_ != 0L)
\end{lstlisting}
Test it:
\begin{lstlisting}
scala> countryCode(Some(18004151212L))
res0: Option[Long] = Some(1)

scala> countryCode(Some(8004151212L))
res1: Option[Long] = None
\end{lstlisting}


\subsubsection{Example \label{subsec:Disjunction-Example-Option-getOrElse}\ref{subsec:Disjunction-Example-Option-getOrElse}}

Continue with the phone number example, and suppose that we have a
new requirement: if the country code is not present, we need return
the default country code $1$. This is an often used design pattern:
``if empty, substitute a default value''. The Scala library has
the method \lstinline!.getOrElse! for this purpose:
\begin{lstlisting}
scala> Some(100).getOrElse(1)
res2: Int = 100

scala> None.getOrElse(1)
res3: Int = 1
\end{lstlisting}
So we can implement the new requirement as
\begin{lstlisting}
scala> countryCode(Some(8004151212L)).getOrElse(1L)
res4: Long = 1
\end{lstlisting}


\paragraph{Using \texttt{Option} with collections}

Many Scala library methods return an \lstinline!Option! as a result.
The main examples are \lstinline!.find!, \lstinline!.headOption!,
and \lstinline!.lift! for sequences, and \lstinline!.get! for dictionaries.

The \lstinline!.find! method returns the first element satisfying
a predicate:
\begin{lstlisting}
scala> (1 to 10).find(_ > 5)
res0: Option[Int] = Some(6)

scala> (1 to 10).find(_ > 10) // No element is > 10.
res1: Option[Int] = None
\end{lstlisting}

The \lstinline!.lift! method returns the element of a sequence at
a given index:
\begin{lstlisting}
scala> (10 to 100).lift(0)
res2: Option[Int] = Some(10)

scala> (10 to 100).lift(1000) // No element at index 1000.
res3: Option[Int] = None
\end{lstlisting}

The \lstinline!.headOption! method returns the first element of a
sequence, unless the sequence is empty. This is equivalent to \lstinline!.lift(0)!:
\begin{lstlisting}
scala> Seq(1,2,3).headOption
res4: Option[Int] = Some(1)

scala> Seq(1,2,3).filter(_ > 10).headOption
res5: Option[Int] = None
\end{lstlisting}
The \lstinline!.find(p)! method computes the same result as \lstinline!.filter(p).headOption!,
but \lstinline!.find(p)! may be more efficient.

The \lstinline!.get! method for a dictionary returns the value if
it exists for a given key, and returns \lstinline!None! if the key
is not in the dictionary:
\begin{lstlisting}
scala> Map(10 -> "a", 20 -> "b").get(10)
res6: Option[String] = Some(a)

scala> Map(10 -> "a", 20 -> "b").get(30)
res7: Option[String] = None 
\end{lstlisting}
The \lstinline!.get! method provides safe by-key access to dictionaries,
unlike the direct access method that may fail:
\begin{lstlisting}
scala> Map(10 -> "a", 20 -> "b")(10)
res8: String = a 

scala> Map(10 -> "a", 20 -> "b")(30)
java.util.NoSuchElementException: key not found: 30
  at scala.collection.MapLike$class.default(MapLike.scala:228)
  at scala.collection.AbstractMap.default(Map.scala:59)
  ... 32 elided
\end{lstlisting}
Similarly, \lstinline!.lift! provides safe by-index access to collections,
unlike the direct access that may fail:
\begin{lstlisting}
scala> Seq(10,20,30)(0)
res9: Int = 10

scala> Seq(10,20,30)(5)
java.lang.IndexOutOfBoundsException: 5
  at scala.collection.LinearSeqOptimized$class.apply(LinearSeqOptimized.scala:65)
  at scala.collection.immutable.List.apply(List.scala:84)
  ... 32 elided
\end{lstlisting}


\paragraph{\texttt{Either}}

The standard disjunctive type \lstinline!Either[A, B]! has two type
parameters and is often used for computations that may report errors.
By convention, the \emph{first} type (\lstinline!A!) is the type
of error, and the \emph{second} type (\lstinline!B!) is the type
of the (non-error) result. The names of the two cases are \lstinline!Left!
and \lstinline!Right!. A possible definition of \lstinline!Either!
is
\begin{lstlisting}
sealed trait Either[A, B]
final case class  Left[A, B](value: A) extends Either[A, B]
final case class Right[A, B](value: B) extends Either[A, B]
\end{lstlisting}
By convention, a value \lstinline!Left(x)! is used to represent an
error, and a value \lstinline!Right(y)! is used to represent a valid
result.

As an example, the following function substitutes a default value
and logs the error information given by an \lstinline!Either! value:
\begin{lstlisting}
def logError(x: Either[String, Int], default: Int): Int = x match {
  case Left(error) => println(s"Got error: $error"); default
  case Right(res) => res
}
\end{lstlisting}
To test:
\begin{lstlisting}
scala> logError(Right(123), -1)
res1: Int = 123

scala> logError(Left("bad result"), -1)
Got error: bad result
res2: Int = -1
\end{lstlisting}

Why use \lstinline!Either! instead of \lstinline!Option! for computations
that may fail? A failing computation such as \lstinline!1/0! could
return \lstinline!None! to indicate that the result is not available.
However, the result is not an optional value that may be missing;
usually the result is required, and if it is not available, we need
to know exactly \emph{which} error occurred. The \lstinline!Either!
type provides the possibility to store information about the error,
which \lstinline!Option! does not provide.

The \lstinline!Either! type generalizes the type \lstinline!Result!
defined in Section~\ref{subsec:Disjunctive-Motivation-and-first-examples}
with an arbitrary error type instead of \lstinline!String!. We have
seen its usage in Example~\ref{subsec:disj-Example-resultA}, where
the design pattern was ``if value is present, do a computation, otherwise
keep the error''. This design pattern is implemented by the \lstinline!.map!
method on \lstinline!Either!:
\begin{lstlisting}
scala> Right(1).map(_ + 1)
res0: Either[Nothing, Int] = Right(2)

scala> Left[String, Int]("error").map(_ + 1)
res1: Either[String, Int] = Left("error")
\end{lstlisting}
The type \lstinline!Nothing! was filled in by the Scala compiler
because we did not specify the full type of \lstinline!Either! in
the first line.

The methods \lstinline!.filter!, \lstinline!.flatMap!, \lstinline!.fold!,
and \lstinline!.getOrElse! are also defined for the \lstinline!Either!
class, with the same convention that the \lstinline!Left(...)! values
represent error information.\footnote{These methods are defined in Scala 2.12 or a later version.}

\paragraph{Exceptions and \texttt{Try}}

When computations fail for any reason, Scala generates an \textbf{exception\index{exception}}
instead of returning a value. An exception means that a value cannot
be computed because the evaluation of the expression stopped without
returning a result.

For instance, an exception will be generated when the resulting data
cannot be stored in memory because the memory is full (as we saw in
Section~\ref{subsec:Lazy-values-iterators-and-streams}), or if a
stack overflow occurs during the computation (as we saw in Section~\ref{subsec:Tail-recursion}).
We have also seen exceptions occur due to programmer's error \textendash{}
when a pattern matching operation fails, when a requested key does
not exist in a dictionary, or when the \lstinline!.head! operation
is applied to an empty list.

We could call these two kinds of exceptions ``planned\index{planned exception}''
and ``unplanned\index{unplanned exception}''. 

A \textbf{planned} exception is generated by programmer's code using
the \lstinline!throw! operation,
\begin{lstlisting}
scala> throw new Exception("this is a test... this is only a test")
java.lang.Exception: this is a test... this is only a test
  ... 42 elided
\end{lstlisting}
The Scala library contains a \lstinline!throw! operation in various
places, such as in the code for applying the \lstinline!.head! operation
to an empty sequence, as well as in other situations where exceptions
are generated due to programmer's errors. These exceptions are generated
deliberately and in well-defined situations. Although these exceptions
indicate errors, these errors can be fixed and the program evaluation
can proceed.

For example, many Java libraries will generate exceptions when function
arguments have unexpected values, when a network download takes too
long or fails to make a network connection, when a file is not found
or cannot be read, and in many other situations. All these error situations
are ``planned'' exceptions because they are generated explicitly
by library code such as \lstinline!throw new Exception("...")!. The
programmer's code is expected to catch these exceptions, to fix the
problem, and to continue the evaluation of the program. 

An \textbf{unplanned} exception is generated by the Java runtime system
when critical errors occur, such as an out-of-memory error. It is
rare that a programmer writes \lstinline!val y = f(x)! while \emph{expecting}
that an out-of-memory exception will sometimes occur at that point.
An unplanned exception indicates a serious and unforeseen problem
with memory or other critically important resources such as the operating
system's threads and file handles. Such a problem usually cannot be
fixed and prevents the program from evaluating any further. It is
reasonable that the program evaluation should immediately stop (or
``crash'' as programmers say) after such an error.

Planned exceptions make programs significantly harder to write correctly.
It is often hard to indicate explicitly all the possible exceptions
that a given library function may \lstinline!throw! in its code or
in the code of some other libraries on which it depends. Instead of
using exceptions, Scala programmers can write functions that return
a disjunctive type such as \lstinline!Either!, describing both the
correct result and a possible error condition. Users of these functions
will need to do pattern matching on the results, which indicates unambiguously
both the possible presence of errors and the kinds of errors.

However, the programmer will often need to use Java libraries (or
Scala libraries) that generate planned exceptions. To help write code
for these situations, the Scala library contains a utility function
called \lstinline!Try! and a disjunctive type also called \lstinline!Try!.
The type \lstinline!Try[A]! can be seen as equivalent to \lstinline!Either[Throwable, A]!,
where \lstinline!Throwable! is the parent type of all exceptions
(i.e.~any value that can appear under a \lstinline!throw! operation).
The two parts of the disjunctive type \lstinline!Try[A]! are called
\lstinline!Success[A]! and \lstinline!Failure! (instead of \lstinline!Left!
and \lstinline!Right! in the \lstinline!Either! type). The function
\lstinline!Try(expr)! will catch all exceptions thrown while the
expression \lstinline!expr! is evaluated. If the evaluation of \lstinline!expr!
succeeded and returned a value \lstinline!x:A!, the value of \lstinline!Try(expr)!
will be \lstinline!Success(x)!. Otherwise it will be \lstinline!Failure(t)!
where \lstinline!t:Throwable! is the value associated with the generated
exception. That value Here is an example of using \lstinline!Try!:
\begin{lstlisting}
import scala.util.{Try,Success,Failure}

scala> Try(1/0)
res0: Try[Int] = Failure(java.lang.ArithmeticException: / by zero)

scala> Try(1+1)
res1: Try[Int] = Success(2) 
\end{lstlisting}
Unlike computing \lstinline!1/0! without an enclosing \lstinline!Try()!,
the computation \lstinline!Try(1/0)! does not generate any exceptions
and will not crash the program. Any computation that may throw an
exception can be enclosed in a \lstinline!Try()!, and the exception
will be caught and contained within the disjunctive type.

The methods \lstinline!.map!, \lstinline!.filter!, \lstinline!.flatMap!,
\lstinline!.foldLeft! are defined for the \lstinline!Try! class
similarly to the \lstinline!Either! type.

Another useful method is \lstinline!.toOption!; it will discard the
error information.
\begin{lstlisting}
scala> Try(1/0).toOption
res2: Option[Int] = None

scala> Try(1+1).toOption
res3: Option[Int] = Some(2)
\end{lstlisting}


\section{Lists and trees: recursive disjunctive types}

Consider this code:
\begin{lstlisting}
sealed trait NInt
final case class One(x: Int) extends NInt
final case class Two(n: NInt) extends NInt
\end{lstlisting}
We are defining a new disjunctive type \lstinline!NInt!, but the
case class \lstinline!Two! uses the type \lstinline!NInt! as if
it were already defined. Scala allows us to write such definitions.

A type whose definition uses that same type is called a \index{recursive type}\textbf{recursive
type}. So, \lstinline!NInt! is a recursive disjunctive type.

We might imagine a disjunctive type with many case classes whose parts
are recursively using the same type in complicated ways. What would
this data type be useful for, and what kind of data does it represent?
In general, this question is not easy to answer. For instance, the
simple definition
\begin{lstlisting}
final case class Bad(x: Bad)
\end{lstlisting}
is useless because to create a value of type \lstinline!Bad! we already
need to have a value of type \lstinline!Bad!. This is, in a sense,
an example of infinite type recursion\index{infinite type recursion}.
For this reason, we will never be able to create any values of type
\lstinline!Bad!, which means that the type \lstinline!Bad! is effectively
\textbf{void\index{void type}} (has no values, like the the special
type \lstinline!Nothing!).

Chapter~\ref{chap:Recursive-types} studies recursive types in more
detail. For now, we will look at the main examples of recursive disjunctive
types that are \emph{known} to be useful. These examples are the list
type and the tree type.

\subsection{Lists}

A list of values of type \lstinline!A! is either empty, or one value
of type \lstinline!A!, or two values of type \lstinline!A!, etc.
We can visualize the type \lstinline!List[A]! as a disjunctive type
defined like this,
\begin{lstlisting}
sealed trait List[A]
final case class List0[A]() extends List[A]
final case class List1[A](x: A) extends List[A]
final case class List2[A](x1: A, x2: A) extends List[A]
??? // Need an infinitely long definition.
\end{lstlisting}
However, this definition is not practical since we cannot define a
separate case class for a lists of \emph{each} possible length. Instead,
we define the type List{[}A{]} via mathematical induction in the length
of the list:
\begin{itemize}
\item Base case: empty list, \lstinline!case class List0[A]()!.
\item Inductive step: given a list of a previously defined length, say \lstinline!List!$_{n-1}$,
define a new case class \lstinline!List!$_{n}$ describing a list
with one more element of type \lstinline!A!. So we could define \lstinline!List!$_{n}=$\lstinline!(List!$_{n-1}$\lstinline!, A)!.
\end{itemize}
Let us try to write this inductive definition as code:
\begin{lstlisting}
sealed trait ListI[A] // Inductive definition of a list.
final case class List0[A]() extends ListI[A]
final case class List1[A](prev: List0[A], x: A) extends ListI[A]
final case class List2[A](prev: List1[A], x: A) extends ListI[A]
??? // Still need an infinitely long definition.
\end{lstlisting}
To avoid writing an infinitely long type definition, we need to use
a trick. Notice that all definitions of \lstinline!List1!, \lstinline!List2!,
etc., have a similar form (while \lstinline!List0! is not similar).
We can replace all the definitions \lstinline!List1!, \lstinline!List2!,
etc., by a single recursive definition if we use the type \lstinline!ListI[A]!
itself inside the case class:
\begin{lstlisting}
sealed trait ListI[A] // Inductive definition of a list.
final case class List0[A]() extends ListI[A]
final case class ListN[A](prev: ListI[A], x: A) extends ListI[A]
\end{lstlisting}
The type definition has become recursive. For this trick to work,
it is important that we use \lstinline!ListI[A]! and not \lstinline!ListN[A]!
inside the definition \lstinline!ListN[A]!; if we did, we would have
created an infinite type recursion\index{infinite type recursion}
similar to \lstinline!case class Bad! shown above.

Since we have used a trick rather than derived the above Let us verify
that this code defines the disjunctive type we wanted. The only way
to create a value of type \lstinline!ListI[A]! is to use one of the
two available case classes. Using the first case class, we may create
a value \lstinline!List0()!. Since this value does not contain any
values of type \lstinline!A!, it effectively represents an empty
list (the base case of the induction). Using the second case class,
we may create a value \lstinline!ListN(prev, x)! where \lstinline!x:A!
and \lstinline!prev! is another, previously constructed value of
type \lstinline!ListI[A]!. This represents the induction step because
the case class \lstinline!ListN! is a named tuple containing \lstinline!ListI[A]!
and \lstinline!A!. Now, the same consideration recursively applies
to constructing the value \lstinline!prev!, which must be either
an empty list or a pair containing another list and an element of
type \lstinline!A!. The assumption that the value \lstinline!prev:ListI[A]!
is already constructed is equivalent to the inductive assumption that
we already have a list of a previously defined length. So, we have
verified that \lstinline!ListI[A]! implements the inductive definition
shown above.

Examples of list values are the empty list \lstinline!List0()!, a
one-element list \lstinline!ListN(List0(), x)!, and a two-element
list \lstinline!ListN(ListN(List0(), x), y)!.

To illustrate writing pattern-matching code using this type, let us
implement the method \lstinline!headOption!:
\begin{lstlisting}
@tailrec def headOption[A]: ListI[A] => Option[A] = {
  case List0()               => None
  case ListN(List0(), x)     => Some(x)
  case ListN(prev, _)        => headOption(prev)
}
\end{lstlisting}

The Scala library already defines the type \lstinline!List[A]!, but
its case classes are named differently, and the second case class
uses the name \lstinline!::! with an infix syntax and places \lstinline!A!
before the previously constructed list.
\begin{lstlisting}
sealed trait List[A]
final case object Nil extends List[Nothing]
final case class ::[A](head: A, tail: List[A]) extends List[A]
\end{lstlisting}
Because ``operator-like'' case class names, such as \lstinline!::!,
support the infix syntax, we may write \lstinline!head :: tail! instead
of \lstinline!::(head, tail)!. Pattern matching with the standard
\lstinline!List! class looks like this:
\begin{lstlisting}
def headOption[A]: List[A] => Option[A] = {
  case Nil            => None
  case head :: tail   => Some(head)
}
\end{lstlisting}
Examples of list values created using the standard Scala List type
are the empty list \lstinline!Nil! (the Scala library also defines
the helper function \lstinline!List()! so that \lstinline!List()!
is the same as \lstinline!Nil!), a one-element list \lstinline!x :: Nil!,
and a two-element list \lstinline!x :: y :: Nil!. We see that list
values are easier to read in the standard syntax. The same syntax
such as \lstinline!x :: y :: Nil! is used both for creating values
of type \lstinline!List! and for pattern-matching on such values.

\subsection{Tail recursion with \texttt{List}}

Because the \lstinline!List! type is defined by induction, it is
straightforward to implement iterative computations with the \lstinline!List!
type using recursion. The first example is the \lstinline!map! function.
We use reasoning by induction in order to figure out the implementation
of \lstinline!map!. The required type signature is
\begin{lstlisting}
def map[A, B](xs: List[A])(f: A => B): List[B] = ???
\end{lstlisting}
The base case is an empty list, and we return again an empty list:
\begin{lstlisting}
def map[A, B](xs: List[A])(f: A => B): List[B] = xs match {
  case Nil => Nil
  ...
\end{lstlisting}
In the induction step, we have a pair \lstinline!(head, tail)! in
the case class \lstinline!::!, where \lstinline!head:A! and \lstinline!tail:List[A]!.
The pair can be pattern-matched with the syntax \lstinline!head :: tail!.
The \lstinline!map! function should apply the argument \lstinline!f!
to the head value, which will give the first element of the resulting
list. The remaining elements are computed by the induction assumption,
i.e.~by a recursive call to \lstinline!map!:
\begin{lstlisting}
def map[A, B](xs: List[A])(f: A => B): List[B] = xs match {
  case Nil           => Nil
  case head :: tail  => f(head) :: map(tail)(f) // Not tail-recursive.
\end{lstlisting}
While this implementation is straightforward and concise, it is not
tail-recursive. This \emph{will} be a problem for long enough lists.

Instead of implementing the often-used iterative methods such as \lstinline!.map!
or \lstinline!.filter! one by one, let us implement \lstinline!foldLeft!
because it allows us to implement most of the other methods. We will
be able to implement \lstinline!foldLeft! as a tail-recursive function.

The required type signature is
\begin{lstlisting}
def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R = ???
\end{lstlisting}
Reasoning by induction, we start with the base case, where we have
an empty list, and the only possibility is to return the value \lstinline!init!.
\begin{lstlisting}
def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R =
  xs match {
    case Nil            => init
    ...
\end{lstlisting}
The induction step for \lstinline!foldLeft! is that, given the values
\lstinline!head:A! and \lstinline!tail:List[A]!, we need to apply
the updater function to the previous accumulator value. That value
is \lstinline!init!. So we can apply \lstinline!foldLeft! recursively
to the tail of the list once we have the updated accumulator value:\lstinline!@tailrec def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R =  xs match {    case Nil            => init    case head :: tail   =>       val newInit = f(init, head) // Update the accumulator.      foldLeft(tail)(newInit)(f) // Recursive call to foldLeft.  }!This
implementation is tail-recursive because the recursive call to \lstinline!foldLeft!
is the last expression returned in its \lstinline!case! branch.

Another instructive example is a function for reversing a list. The
Scala library defines the \lstinline!.reverse! method for this purpose,
but we will show an implementation using \lstinline!foldLeft!. The
updater function prepends an element to a previous list:
\begin{lstlisting}
def reverse[A](xs: List[A]): List[A] =
  xs.foldLeft(Nil: List[A])((prev, x) => x :: prev)

scala> reverse(List(1, 2, 3))
res0: List[Int] = List(3, 2, 1) 
\end{lstlisting}
Without the explicit type annotation \lstinline!Nil:List[A]!, the
Scala compiler will decide that \lstinline!Nil! has type \lstinline!List[Nothing]!,
and the types will not match later in the code.

The \lstinline!reverse! function can be used, in principle, to implement
\lstinline!map! in a tail-recursive way. The idea is to first use
\lstinline!foldLeft! to accumulate transformed elements:
\begin{lstlisting}
scala> Seq(1, 2, 3).foldLeft(Nil:List[Int])((prev, x) => x*x :: prev)
res0: List[Int] = List(9, 4, 1)
\end{lstlisting}
The result is a reversed \lstinline!.map(x => x*x)!, so we reverse
that:
\begin{lstlisting}
def map[A, B](xs: List[A])(f: A => B): List[B] =
  xs.foldLeft(Nil: List[B])((prev, x) => f(x) :: prev).reverse

scala> map(List(1, 2, 3))(x => x*x)
res2: List[Int] = List(1, 4, 9)
\end{lstlisting}
This achieves stack safety at the cost of traversing the list twice.
(This implementation is only good for illustration purposes. The Scala
library uses a more low-level implementation of \lstinline!.map!
for List, in order to achieve better performance.)

\subsubsection{Example \label{subsec:Disjunctive-Example-non-empty-list-foldLeft}\ref{subsec:Disjunctive-Example-non-empty-list-foldLeft}}

A \textbf{non-empty list\index{non-empty list}} is similar to \lstinline!List!
except that the empty-list case is not supported. A definition of
this data type is
\begin{lstlisting}
sealed trait NEL[A]
final case class Last[A](head: A) extends NEL[A]
final case class More[A](head: A, tail: NEL[A]) extends NEL[A]
\end{lstlisting}
To make creating non-empty lists more convenient, implement a conversion
function from an ordinary list. Since the conversion function must
guarantee that the result is a non-empty list, let us give it two
arguments:
\begin{lstlisting}
def toNEL[A](x: A, rest: List[A]): NEL[A] = rest match {
  case Nil        => Last(x)
  case y :: tail  => More(x, toNEL(y, tail))
}
\end{lstlisting}
This function is not tail-recursive. To test:
\begin{lstlisting}
scala> toNEL(1, List())
res0: NEL[Int] = Last(1)

scala> toNEL(1, List(2, 3))
res1: NEL[Int] = More(1,More(2,Last(3)))
\end{lstlisting}

The \lstinline!head! method is safe for non-empty lists:
\begin{lstlisting}
def head[A]: NEL[A] => A = {
  case Last(x)      => x
  case More(x, _)   => x
}
\end{lstlisting}

We can also implement a tail-recursive \lstinline!foldLeft! function
for non-empty lists:
\begin{lstlisting}
@tailrec def foldLeft[A, R](nel: NEL[A])(init: R)(f: (R, A) => R): R = nel match {
  case Last(x) => f(init, x)
  case More(x, tail) => foldLeft(tail)(f(init, x))(f)
}
\end{lstlisting}
To test:
\begin{lstlisting}
scala> foldLeft(More(1, More(2, Last(3))))(0)(_ + _)
res2: Int = 6
\end{lstlisting}


\subsubsection{Example \label{subsec:Disjunctive-Example-non-empty-list}\ref{subsec:Disjunctive-Example-non-empty-list}}

Use \lstinline!foldLeft! to implement a \lstinline!reverse! function
for the type \lstinline!NEL!. The required type signature and a sample
test:
\begin{lstlisting}
def reverse[A]: NEL[A] => NEL[A] = ???

scala> reverse(toNEL(List(1, 2, 3)))
res3: NEL[Int] = More(3, More(2, Last(1)))
\end{lstlisting}


\subparagraph{Solution}

We will use recursion with the accumulator trick. The accumulator
will be equal to a reversed initial portion of the list, and it is
convenient to choose the accumulator type as an ordinary \lstinline!List!.
The initial value of the accumulator can then be an empty list:
\begin{lstlisting}
@tailrec def reverse[A](nel: NEL[A], acc: List[A] = Nil): NEL[A] =
  nel match {
    case Last(x)         => toNEL(x, acc)
    case More(x, tail)   => reverse(tail, x :: acc)
  }

scala> reverse(toNEL(1, List(2, 3)))
res3: NEL[Int] = More(3, More(2, Last(1)))
\end{lstlisting}


\subsubsection{Exercise \label{subsec:Disjunctive-Example-non-empty-list-1}\ref{subsec:Disjunctive-Example-non-empty-list-1}}

Implement a function \lstinline!toList! that converts a non-empty
list of type \lstinline!NEL! into an ordinary Scala \lstinline!List!.
The required type signature and a sample test:
\begin{lstlisting}
def toList[A](nel: NEL[A]): List[A] = ???

scala> toList(More(1, More(2, Last(3))))
res4: List[Int] = List(1, 2, 3)
\end{lstlisting}


\subsection{Trees}

We will consider four kinds of trees defined as recursive disjunctive
types: binary trees, rose trees, homogeneous trees, and abstract syntax
trees.

Examples of a \textbf{binary tree\index{binary tree}} with leaves
of type \lstinline!A! can be visualized as  \Tree[  [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] 
or  \Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] ,
where $a_{i}$ are some values of type \lstinline!A!. An inductive
definition says that a binary tree is either a leaf with a value of
type \lstinline!A! or a branch containing two previously defined
binary trees. Translating this definition into code, we get
\begin{lstlisting}
sealed trait Tree2[A]
final case class Leaf[A](a: A) extends Tree2[A]
final case class Branch[A](x: Tree2[A], y: Tree2[A]) extends Tree2[A]
\end{lstlisting}
The tree  \Tree[  [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ]  is created
by the code 
\begin{lstlisting}
Branch(Leaf("a1"), Branch(Leaf("a2"), Leaf("a3")))
\end{lstlisting}
while the tree  \Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] 
is created by the code
\begin{lstlisting}
Branch(Branch(Leaf("a1"),Branch(Leaf("a2"), Leaf("a3"))), Branch(Leaf("a4"), Leaf("a5")))
\end{lstlisting}

Recursive functions on trees are translated into concise code. For
instance, the function \lstinline!foldLeft! on the tree structure
is defined by
\begin{lstlisting}
def foldLeft[A, R](t: Tree2[A])(init: R)(f: (R, A) => R) = t match {
  case Leaf(a)          => f(init, a)
  case Branch(t1, t2)   =>
    val r1 = foldLeft(t1)(init)(f) // Begin with the left branch.
    foldLeft(t2)(r1)(f) // Continue with the right branch.
}
\end{lstlisting}
Note that this function cannot be made tail-recursive using the accumulator
trick, because \lstinline!foldLeft! needs to call itself twice in
the \lstinline!Branch! case.

\subsection{Rose trees}

A rose tree\index{rose tree} is similar to the binary tree except
the branches contain a non-empty list of other trees. So the tree
can fork into arbitrarily many branches at each node, rather than
always into two branches as the binary tree does. Example shapes for
a rose tree are  \Tree[ [ [ $a_1$ ] [ $a_2$ ] [ $a_3$ ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] 
and  \Tree[ [ $a_1$ ] [ $a_2$ ] [ $a_3$ ] [ $a_4$ ] ] .

A possible definition of the rose tree data type is
\begin{lstlisting}
sealed trait TreeN[A]
final case class Leaf[A](a: A) extends TreeN[A]
final case class Branch[A](ts: NEL[TreeN[A]]) extends TreeN[A]
\end{lstlisting}


\subsubsection{Exercise \label{subsec:Disjunctive-Exercise-foldLeft-rose-tree}\ref{subsec:Disjunctive-Exercise-foldLeft-rose-tree}}

Define the function \lstinline!foldLeft! for a rose tree, using \lstinline!foldLeft!
for the type \lstinline!NEL!. Type signature and a test:
\begin{lstlisting}
def foldLeft[A, R](t: TreeN[A])(init: R)(f: (R, A) => R): R = ???

scala> foldLeft(Branch(More(Leaf(1), More(Leaf(2), Last(Leaf(3))))))(0)(_ + _)
res0: Int = 6
\end{lstlisting}


\subsection{Regular-shaped trees}

Binary trees and rose trees may choose to branch or not to branch
at any given node, resulting in structures that may have a different
branching depth at different places, such as  \Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] .
A \textbf{regular-shaped tree\index{regular-shaped tree}} always
branches in the same way at every place until a given depth, for example
 \Tree[ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] , where
the nodes at depth $0$ and $1$ always branch into two, while nodes
at depth $2$ never branch. The branching number is always fixed for
a given type of a regular-shaped tree; in this example, the branching
number is $2$.

How can we define a data type representing a regular-shaped tree?
We need a tree that is either a single value, or a pair of values,
or a pair of pairs, etc. Begin with the non-recursive (but, of course,
impractical) definition
\begin{lstlisting}
sealed trait RTree[A]
final case class Leaf[A](x: A) extends RTree[A]
final case class Branch1[A](xs: (A, A)) extends RTree[A]
final case class Branch2[A](xs: ((A, A),(A, A))) extends RTree[A]
??? // Need an infinitely long definition.
\end{lstlisting}
The case \lstinline!Branch1! describes a regular-shaped tree that
branches until depth $1$, the case \lstinline!Branch2! branches
until depth $2$, and so on. Now, we cannot rewrite this definition
as a recursive type because the case classes do not have the same
structure. The non-trivial trick is to notice that each \lstinline!Branch!$_{n}$case
class uses the previous case class's data structure \emph{in the type
parameter} \lstinline!(A, A)! instead of \lstinline!A!. So we can
rewrite this definition as
\begin{lstlisting}
sealed trait RTree[A]
final case class Leaf[A](x: A) extends RTree[A]
final case class Branch1[A](xs: Leaf[(A, A)]) extends RTree[A]
final case class Branch2[A](xs: Branch1[(A, A)]) extends RTree[A]
??? // Need an infinitely long definition.
\end{lstlisting}
Now we can use the type recursion trick: replace the previous \lstinline!Branch!$_{n-1}$
type in the definition of \lstinline!Branch!$_{n}$ by the type \lstinline!RTree[...]!
. Now we finally obtain the type definition for a regular-shaped binary
tree:
\begin{lstlisting}
sealed trait RTree[A]
final case class Leaf[A](x: A) extends RTree[A]
final case class Branch[A](xs: RTree[(A, A)]) extends RTree[A]
\end{lstlisting}

Since we used some tricks to figure out the definition of \lstinline!RTree[A]!,
let us verify that this definition actually describes the recursive
disjunctive type we wanted. The only way to create a structure of
type \lstinline!RTree[A]! is either to have a \lstinline!Leaf[A]!
or a \lstinline!Branch[A]!. A value of type \lstinline!Leaf[A]!
is a correct regularly-shaped tree; it remains to consider the case
of \lstinline!Branch[A]!. To create a \lstinline!Branch[A]! requires
a previously created \lstinline!RTree! with values of type \lstinline!(A, A)!
instead of \lstinline!A!. By the inductive assumption, the previuosly
created \lstinline!RTree[A]! would have the correct shape. Now, it
is clear that if we replace the type parameter \lstinline!A! by the
pair \lstinline!(A, A)!, a regular-shaped tree such as  \Tree[ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] 
remains regular-shaped and becomes one level deeper,  \Tree[ [ [ [ $a_1^{'}$ ] [ $a_1^{''}$ ] ] [ [ $a_2^{'}$ ] [ $a_2^{''}$ ] ] ] [ [ [ $a_3^{'}$ ] [ $a_3^{''}$ ] ] [ [ $a_4^{'}$ ] [ $a_4^{''}$ ] ]  ] ] .
We see that \lstinline!RTree[A]! is indeed the correct definition
of a regular-shaped binary tree. 

\subsubsection{Example \label{subsec:Disjunctive-Example-map-regular-tree}\ref{subsec:Disjunctive-Example-map-regular-tree}}

Define a (non-tail-recursive) \lstinline!map! function for a regular-shaped
binary tree. The required type signature and a test:
\begin{lstlisting}
def map[A, B](t: RTree[A])(f: A => B): RTree[B] = ???

scala> map(Branch(Branch(Leaf(((1,2),(3,4))))))(_ * 10)
res0: RTree[Int] = Branch(Branch(Leaf(((10,20),(30,40)))))
\end{lstlisting}


\subparagraph{Solution}

Begin by pattern-matching on the tree:
\begin{lstlisting}
def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
  case Leaf(x)      => ???
  case Branch(xs)   => ???
}
\end{lstlisting}
The base case is clear: we need to return \lstinline!Leaf(f(x))!.
\begin{lstlisting}
def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
  case Leaf(x)      => Leaf(f(x))
  case Branch(xs)   => ???
}
\end{lstlisting}
In the inductive step, we are given a previous tree value \lstinline!xs:RTree[(A, A)]!.
It is clear that we need to apply \lstinline!map! recursively to
\lstinline!xs!.
\begin{lstlisting}
def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
  case Leaf(x)      => Leaf(f(x))
  case Branch(xs)   => Branch(map(xs)(f)) // Type error!
}
\end{lstlisting}
However, \lstinline!map(xs)(f)! does not compile because the type
of the function \lstinline!f! is incorrect. Since \lstinline!xs!
has type \lstinline!RTree[(A, A)]!, the recursive call \lstinline!map(xs)(f)!
requires \lstinline!f! to be of type \lstinline!f: ((A, A)) => (B, B)!
instead of \lstinline!f: A => B!. So we just need to substitute a
function of the correct type instead of \lstinline!f!. A function
of type \lstinline!((A, A)) => (B, B)! will be obtained out of \lstinline!f: A => B!
if we apply \lstinline!f! to each part of the tuple \lstinline!(A, A)!.
The resulting code is
\begin{lstlisting}
def map[A, B](t: RTree[A])(f: A => B): RTree[B] = t match {
  case Leaf(x)      => Leaf(f(x))
  case Branch(xs)   => Branch(map(xs){ case (a1, a2) => (f(a1), f(a2)) })
}
\end{lstlisting}


\subsubsection{Exercise \label{subsec:Disjunctive-Exercise-foldLeft-regular-tree-depth}\ref{subsec:Disjunctive-Exercise-foldLeft-regular-tree-depth}}

Using tail recursion, compute the depth of a regular-shaped binary
tree \lstinline!RTree!. (An \lstinline!RTree! of depth $n$ has
$2^{n}$ leaf values.) The required type signature and a test:
\begin{lstlisting}
@tailrec def depth[A](t: RTree[A]): Int = ???

scala> depth(Branch(Branch(Leaf((("a","b"),("c","d"))))))
res2: Int = 2
\end{lstlisting}
\begin{comment}
Solution:

\begin{lstlisting}
@tailrec def depth[A](t: RTree[A], acc: Int = 0): Int = t match {
  case Leaf(x)    => acc
  case Branch(xs) => depth(xs, 1 + acc)
}
\end{lstlisting}
\end{comment}


\subsubsection{Exercise \label{subsec:Disjunctive-Exercise-foldLeft-regular-tree}\ref{subsec:Disjunctive-Exercise-foldLeft-regular-tree}{*}}

Define a tail-recursive function \lstinline!foldLeft! for a regular-shaped
binary tree. The required type signature and a test:
\begin{lstlisting}
def foldLeft[A, R](t: RTree[A])(init: R)(f: (R, A) => R): R = ???

scala> foldLeft(Branch(Branch(Leaf(((1,2),(3,4))))))(0)(_ + _)
res0: Int = 10

scala> foldLeft(Branch(Branch(Leaf((("a","b"),("c","d"))))))("")(_ + _)
res1: String = abcd
\end{lstlisting}
\begin{comment}
Solution:

\begin{lstlisting}
@tailrec def foldLeft[A, R](t: RTree[A])(init: R)(f: (R, A) => R): R = t match {
  case Leaf(x)    => f(init, x)
  case Branch(xs) => foldLeft(xs)(init) { case (r, (a, b)) => f(f(r, a), b) } 
}
\end{lstlisting}
\end{comment}


\subsection{Abstract syntax trees}

Expressions in formal languages are represented by abstract syntax
trees. An \textbf{abstract syntax tree\index{abstract syntax tree}
}(or \textbf{AST} for short) is defined as either a leaf of one of
the available leaf types, or a branch of one of the available branch
types. All the available leaf and branch types must be specified as
part of the definition of an AST. In other words, one must specify
the data carried by leaves and branches, as well as the branching
numbers.

To illustrate how ASTs are used, we rewrite Example~\ref{subsec:disj-Example-resultA}
via an AST. We view Example~\ref{subsec:disj-Example-resultA} as
a small programming sub-language that deals with ``safe integers''
and supports the ``safe arithmetic'' operations \lstinline!Sqrt!,
\lstinline!Add!, \lstinline!Mul!, and \lstinline!Div!. Example
calculations in this sub-language are $\sqrt{16}*(1+2)=12$; $20+1/0=\text{error}$;
$10+\sqrt{-1}=\text{error}$. 

We can implement this sub-language in two stages. The first stage
will create a data structure (an AST) that represents an unevaluated
expression\index{unevaluated expression} in the sub-language. The
second stage will evaluate that AST into a number or into an error
message.

A straightforward way of defining a data structure for an AST is to
use a disjunctive type whose cases describe all the possible operations
of the sub-language. In our case, we will need one case for each of
\lstinline!Sqrt!, \lstinline!Add!, \lstinline!Mul!, and \lstinline!Div!,
and an additional operation to create ``safe integers'' from ordinary
integers. So we define the disjunctive type for ``arithmetic sub-language
expressions'' as
\begin{lstlisting}
sealed trait Arith
final case class Num(x: Int) extends Arith
final case class Sqrt(x: Arith) extends Arith
final case class Add(x: Arith, y: Arith) extends Arith
final case class Mul(x: Arith, y: Arith) extends Arith
final case class Div(x: Arith, y: Arith) extends Arith
\end{lstlisting}
It follows that a value of type \lstinline!Arith! is either a \lstinline!Num(x)!
for some integer \lstinline!x!, or an \lstinline!Add(x, y)! where
\lstinline!x! and \lstinline!y! are previously defined \lstinline!Arith!
expressions, or another operation.

This type definition is similar to the binary tree type
\begin{lstlisting}
sealed trait Tree
final case class Leaf(x: Int) extends Tree
final case class Branch(x: Tree, y: Tree) extends Tree
\end{lstlisting}
if we rename \lstinline!Leaf! to \lstinline!Num! and \lstinline!Branch!
to \lstinline!Add!. However, the \lstinline!Arith! type contains
$4$ different types of ``branches'', some with branching number
$1$ and others with branching number $2$. 

This example illustrates the structure of an AST: it is a tree of
a general shape, where leaves and branches are chosen from a specified
set of allowed possibilities. In this example, we have a single allowed
type of leaf, \lstinline!Num!, and $4$ allowed types of branches
(\lstinline!Sqrt!, \lstinline!Add!, \lstinline!Mul!, and \lstinline!Div!).

This completes the first stage of implementing the ``safe arithmetic''
sub-language. Using the definition of the disjunctive type \lstinline!Arith!,
we may now create expressions in the sub-language. For example, $\sqrt{16}*(1+2)$
is represented by
\begin{lstlisting}
scala> val x: Arith = Mul(Sqrt(Num(16)), Add(Num(1), Num(2)))
x: Arith = Mul(Sqrt(Num(16)),Add(Num(1),Num(2))) 
\end{lstlisting}
We can picture \lstinline!x! as an abstract syntax tree \Tree[.\texttt{Mul} [.\texttt{Sqrt} [.\texttt{Num} $16$ ] ] [.\texttt{Add} [ [.\texttt{Num} [ $1$ ] ] [.\texttt{Num} [ $2$ ] ] ] ] ] . 

The expressions $20+1/0$ and $10*\sqrt{-1}$ are represented by
\begin{lstlisting}
scala> val y: Arith = Add(Num(20), Div(Num(1), Num(0)))
y: Arith = Add(Num(20),Div(Num(1),Num(0)))

scala> val z: Arith = Add(Num(10), Sqrt(Num(-1)))
z: Arith = Add(Num(10),Sqrt(Num(-1)))
\end{lstlisting}
As we see, the expressions \lstinline!x!, \lstinline!y!, and \lstinline!z!
\emph{remain} \emph{unevaluated}; they are data structures that encode
a tree of operations of the sub-language. These operations will be
evaluated at the second stage of implementing the sub-language.

To evaluate the expressions in the ``safe arithmetic'', we can write
a function \lstinline!run: Arith => Either[String, Int]!. That function
plays the role of an \textbf{interpreter}\index{interpreter} for
the sub-language. The interpreter will decompose the expression tree
and execute all the operations, taking care of possible errors. Instead
of custom code written in Example~\ref{subsec:disj-Example-resultA},
we can use the \lstinline!.map! and \lstinline!.flatMap! operations
defined for the \lstinline!Either! type. For example, addition and
multiplication of two ``safe integers'' is written as 
\begin{lstlisting}
def add(x: Either[String, Int], y: Either[String, Int]):
    Either[String, Int] = x.flatMap { r1 => y.map(r2 => r1 + r2) }
def mul(x: Either[String, Int], y: Either[String, Int]):
    Either[String, Int] = x.flatMap { r1 => y.map(r2 => r1 * r2) }
\end{lstlisting}
while the ``safe division'' is
\begin{lstlisting}
def div(x: Either[String, Int], y: Either[String, Int]):
    Either[String, Int] = x.flatMap { r1 => y.flatMap(r2 =>
  if (r2 == 0) Left(s"error: $r1 / $r2") else Right(r1/r2) )
}
\end{lstlisting}
With this code, we can implement the interpreter as
\begin{lstlisting}
def run: Arith => Either[String, Int] = {
  case Num(x)     => Right(x)
  case Sqrt(x)    => run(x).flatMap { r =>
   if (r < 0) Left(s"error: sqrt($r)") else
       Right(math.sqrt(r).toInt)
  }
  case Add(x, y)  => add(run(x), run(y))
  case Mul(x, y)  => mul(run(x), run(y))
  case Div(x, y)  => div(run(x), run(y))
}
\end{lstlisting}
Test with the values \lstinline!x!, \lstinline!y!, \lstinline!z!:
\begin{lstlisting}
scala> run(x)
res0: Either[String, Int] = Right(12)

scala> run(y)
res1: Either[String, Int] = Left("error: 1 / 0")

scala> run(z)
res2: Either[String, Int] = Left("error: sqrt(-1)")
\end{lstlisting}


\section{Summary}

What problems can we solve now?
\begin{itemize}
\item Represent values from disjoint domains as a single disjunctive type.
\item Use disjunctive types in collections safely.
\item Use disjunctive types instead of exceptions to indicate failures.
\end{itemize}
The following examples and exercises illustrate the use of disjunctive
types.

\subsection{Solved examples}

\subsubsection{Example \label{subsec:Example-disjunctive-1}\ref{subsec:Example-disjunctive-1}}

Define a disjunctive type \lstinline!DayOfWeek! representing the
seven days.

\subparagraph{Solution}

Since there is no information other than the label on each day, we
use empty case classes:
\begin{lstlisting}
sealed trait DayOfWeek
final case class Sunday() extends DayOfWeek
final case class Monday() extends DayOfWeek
final case class Tuesday() extends DayOfWeek
final case class Wednesday() extends DayOfWeek
final case class Thursday() extends DayOfWeek
final case class Friday() extends DayOfWeek
final case class Saturday() extends DayOfWeek
\end{lstlisting}


\subsubsection{Example \label{subsec:Example-disjunctive-2}\ref{subsec:Example-disjunctive-2}}

Modify \lstinline!DayOfWeek! so that the values additionally represent
a restaurant name and total amount for Fridays and a wake-up time
on Saturdays. 

\subparagraph{Solution}

For the days where additional information is given, we use non-empty
case classes:
\begin{lstlisting}
sealed trait DayOfWeekWithBanquets
final case class Sunday() extends DayOfWeekWithBanquets
final case class Monday() extends DayOfWeekWithBanquets
final case class Tuesday() extends DayOfWeekWithBanquets
final case class Wednesday() extends DayOfWeekWithBanquets
final case class Thursday() extends DayOfWeekWithBanquets
final case class Friday(restaurant: String, amount: Int) extends DayOfWeekWithBanquets
final case class Saturday(wakeUpAt: java.time.LocalTime) extends DayOfWeekWithBanquets
\end{lstlisting}


\subsubsection{Example \label{subsec:disj-Example-rootsofq-2}\ref{subsec:disj-Example-rootsofq-2}}

Define a disjunctive type that describes real roots of the equation
$ax^{2}+bx+c=0$ where $a$, $b$, $c$ are arbitrary real numbers.

\subparagraph{Solution}

Begin by solving the equation and enumerating all possible cases.
It may happen that $a=b=c=0$, and then all $x$ are roots. If $a=b=0$
but $c\neq0$, the equation is $c=0$, which has no roots. If $a=0$
but $b\neq0$, the equation becomes $bx+c=0$, having a single root.
If $a\neq0$ and $b^{2}>4ac$, we have two distinct real roots. If
$a\neq0$ and $b^{2}=4ac$, we have one real root. If $b^{2}<4ac$,
we have no real roots. The resulting type definition can be written
as
\begin{lstlisting}
sealed trait RootsOfQ2
final case class AllRoots() extends RootsOfQ2
final case class ConstNoRoots() extends RootsOfQ2
final case class Linear(x: Double) extends RootsOfQ2
final case class NoRealRoots() extends RootsOfQ2
final case class OneRootQ(x: Double) extends RootsOfQ2
final case class TwoRootsQ(x: Double, y: Double) extends RootsOfQ2
\end{lstlisting}
This disjunctive type contains six parts, among which three parts
are empty tuples and two parts have a single-element tuple; but this
is not a useless redundancy. It would be a loss of information to
reuse the \lstinline!Linear! for the case $a=0$, $b\neq0$ and for
the case $a\neq0$, $b^{2}=4ac$, or to reuse \lstinline!NoRoots!
for representing the three different no-roots cases.

\subsubsection{Example \label{subsec:Example-disjunctive-3}\ref{subsec:Example-disjunctive-3}}

Define a function \lstinline!rootAverage! that computes the average
value of all real roots of a general quadratic equation, where the
roots are represented by the type \lstinline!RootsOfQ2! defined in
Example~\ref{subsec:disj-Example-rootsofq-2}. The required type
signature is
\begin{lstlisting}
val rootAverage: RootsOfQ2 => Option[Double] = ???
\end{lstlisting}
The function should return \lstinline!None! if the average is undefined.

\subparagraph{Solution}

The average is defined only in cases \lstinline!Linear!, \lstinline!OneRootQ!,
and \lstinline!TwoRootsQ!. All other cases must result in an empty
option. We implement this via pattern matching:
\begin{lstlisting}
val rootAverage: RootsOfQ2 => Option[Double] = { roots =>
  roots match {
    case Linear(x)       => Some(x)
    case OneRootQ(x)     => Some(x)
    case TwoRootsQ(x, y) => Some((x + y) * 0.5)
    case _               => None
  }
}
\end{lstlisting}
We do not need to enumerate all other cases since the underscore pattern,
$\_$, matches everything that the previous cases did not match.

The often-used code pattern of the form \lstinline!x => x match { case ... }!
can be shortened to simply \lstinline!{ case ...}!. The code then
becomes
\begin{lstlisting}
val rootAverage: RootsOfQ2 => Option[Double] = {
  case Linear(x)       => Some(x)
  case OneRootQ(x)     => Some(x)
  case TwoRootsQ(x, y) => Some((x + y) * 0.5)
  case _               => None
}
\end{lstlisting}
Test it:
\begin{lstlisting}
scala> Seq(NoRealRoots(),OneRootQ(1.0), TwoRootsQ(1.0, 2.0), AllRoots()).map(rootAverage)
res0: Seq[Option[Double]] = List(None, Some(1.0), Some(1.5), None)
\end{lstlisting}


\subsubsection{Example \label{subsec:Example-disjunctive-4}\ref{subsec:Example-disjunctive-4}}

Generate $100$ quadratic equations $x^{2}+bx+c=0$ with random coefficients
$b$, $c$ (uniformly distributed between $-1$ and $1$) and compute
the mean of the largest real roots from all these equations.

\subparagraph{Solution}

We use the type \lstinline!QEqu! and the \lstinline!solve! function
from Example~\ref{subsec:disj-Example-rootsofq-1}. First, we create
a sequence of equations with random coefficients using the method
\lstinline!Seq.fill!:
\begin{lstlisting}
def random(): Double = scala.util.Random.nextDouble() * 2 - 1
val coeffs: Seq[QEqu] = Seq.fill(100)(QEqu(random(), random()))
\end{lstlisting}
We can now use the \lstinline!solve! function to compute all roots:
\begin{lstlisting}
val solutions: Seq[RootsOfQ] = coeffs.map(solve)
\end{lstlisting}
For each set of roots, we compute the largest root:
\begin{lstlisting}
scala> val largest: Seq[Option[Double]] = solutions.map {
  case OneRoot(x)     => Some(x)
  case TwoRoots(x, y) => Some(math.max(x, y))
  case _              => None
}
largest: Seq[Option[Double]] = List(None, Some(0.9346072365885472), Some(1.1356234869160806), Some(0.9453181931646322), Some(1.1595052441078866), None, Some(0.5762252742788), Some(1.1896332718057907), None...
\end{lstlisting}
It remains to remove the \lstinline!None! values and to compute the
mean of the resulting sequence. This operation is used often, so the
Scala library defines the \lstinline!.flatten! method that works
for sequences of \lstinline!Option! values:
\begin{lstlisting}
scala> largest.flatten
res0: Seq[Double] = List(0.9346072365885472, 1.1356234869160806, 0.9453181931646322, 1.1595052441078866, 0.5762252742788, 1.1896332718057907...
\end{lstlisting}
Now we can compute the mean of the last sequence. Since the \lstinline!.flatten!
operation is preceded by \lstinline!.map!, we can replace it by a
\lstinline!.flatMap!. The final code is
\begin{lstlisting}
val largest = Seq.fill(100)(QEqu(random(), random()))
  .map(solve)
  .flatMap {
    case OneRoot(x)     => Some(x)
    case TwoRoots(x, y) => Some(math.max(x, y))
    case _              => None
  }

scala> largest.sum / largest.size
res1: Double = 0.7682649774589514
\end{lstlisting}


\subsubsection{Example \label{subsec:Example-disjunctive-5}\ref{subsec:Example-disjunctive-5}}

Implement a function with type signature
\begin{lstlisting}
def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = ???
\end{lstlisting}
The function should preserve as much information as possible.

\subparagraph{Solution}

Begin by pattern matching on the argument:
\begin{lstlisting}
def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
  case None                    => ???
  case Some(eab: Either[A, B]) => ???
}
\end{lstlisting}
The type annotation \lstinline!: Either[A, B]! was written only for
clarity; it is not required here because the Scala compiler can deduce
the type of the pattern variable \lstinline!eab! from the fact that
we are matching a value of type \lstinline!Option[Either[A, B]]!.

What expression will we compute in the first case? We need to return
a value of type \lstinline!Either[A, Option[B]]!. A value of that
type must be either a \lstinline!Left(x)! for some \lstinline!x:A!,
or a \lstinline!Right(y)! for some \lstinline!y:Option[B]!, where
the value \lstinline!y! must be either \lstinline!None! or \lstinline!Some(z)!
with a \lstinline!z:B!. However, in our case the code is of the form
\lstinline!case None => ???!, and we cannot produce any values \lstinline!x:A!
or \lstinline!z:B! since \lstinline!A! and \lstinline!B! are arbitrary,
unknown types. The only remaining possibility is to return \lstinline!Right(y)!
with \lstinline!y = None!, and so the code must be
\begin{lstlisting}
  ...
  case None => Right(None) // No other choice here.
\end{lstlisting}

In the second case, we clearly need to pattern match on the value
\lstinline!eab!:
\begin{lstlisting}
  ...
  case Some(eab: Either[A, B]) = eab match {
    case Left(a)   => ???
    case Right(b)  => ???
  }
\end{lstlisting}
It remains to figure out what expressions to compute in each case.
In the case \lstinline!Left(a) => ???!, we have a value of type \lstinline!A!,
and we need to compute a value of type \lstinline!Either[A, Option[B]]!.
We again follow the same argument: we can return \lstinline!Left(x)!
for some \lstinline!x:A!, or \lstinline!Right(y)! for some \lstinline!y:Option[B]!.
At this point, we do have a value of type \lstinline!A!, but not
of type \lstinline!B!. So we have two possibilities: to return \lstinline!Left(a)!
or to return \lstinline!Right(None)! as before. If we decide to return
\lstinline!Left(a)!, the code is
\begin{lstlisting}
def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
  case None       => Right(None) // No other choice here.
  case Some(eab)  => eab match {
    case Left(a)  => Left(a) // Could also return Right(None) here.
    case Right(b) => ???
  }
}
\end{lstlisting}
Let us consider the choice of whether to return \lstinline!Left(a)!
or \lstinline!Right(None)! in the line \lstinline!case Left(a) => !.
Both choices will satisfy the required return type \lstinline!Either[A, Option[B]]!.
However, if we return \lstinline!Right(None)! in that line, we will
ignore the given value \lstinline!a:A!, which is a loss of information.
Returning \lstinline!Left(a)! will preserve more information, which
is likely to be more useful.

Similarly, in the last line \lstinline!case Right(b) => ???!, we
have a choice of returning \lstinline!Right(None)! or \lstinline!Right(Some(b))!.
The first choice ignores the given value of \lstinline!b:B!. Since
we want to preserve information as much as possible, we make the second
choice. The final code is
\begin{lstlisting}
def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
  case None       => Right(None)
  case Some(eab)  => eab match {
    case Left(a)  => Left(a)
    case Right(b) => Right(Some(b))
  }
}
\end{lstlisting}


\subsubsection{Example \label{subsec:Example-disjunctive-6}\ref{subsec:Example-disjunctive-6}}

Implement a function with the type signature 
\begin{lstlisting}
def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = ???
\end{lstlisting}
The function should preserve as much information as possible.

\subparagraph{Solution}

Begin by pattern matching on the argument:
\begin{lstlisting}
def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
  case (Some(a), Some(b)) => ???
  case ???                => ???
}
\end{lstlisting}
In the first case, we have values \lstinline!a:A! and \lstinline!b:B!,
and we are required to return a value of type \lstinline!Option[(A, B)]!.
A value of that type is either \lstinline!None! or \lstinline!Some((x,y))!
where \lstinline!x:A! and \lstinline!y:B!. Since \lstinline!A!
and \lstinline!B! are arbitrary types, we cannot produce new values
\lstinline!x! and \lstinline!y! from scratch. The only way to satisfy
the required type is to set \lstinline!x=a! and \lstinline!y=b!,
returning \lstinline!Some((a, b))!. Now we have two choices: to return
\lstinline!Some((a, b))! or to return \lstinline!None!. Returning
\lstinline!None! would unnecessarily lose information; so we write
\begin{lstlisting}
def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
  case (Some(a), Some(b)) => Some((a, b))
  case (Some(a), None)    => ???
  ...
}
\end{lstlisting}
In the branch of \lstinline!case (Some(a), None)!, we have a value
\lstinline!a:A! but no values of type \lstinline!B!. Since the type
\lstinline!B! is arbitrary, we cannot produce any values of type
\lstinline!B!, and so we cannot return a value of the form \lstinline!Some((x, y))!.
So, in this \lstinline!case! branch, the only computable value of
type \lstinline!Option[(A, B)]! is \lstinline!None!.
\begin{lstlisting}
def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
  case (Some(a), Some(b)) => Some((a, b))
  case (Some(a), None)    => None // No other choice here.
  case (None, Some(b))    => ???
  case (None, None)       => ???
}
\end{lstlisting}
Writing out the remaining cases, we find that in all those cases we
have no choice other than returning \lstinline!None!. So we can simplify
the code:
\begin{lstlisting}
def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
  case (Some(a), Some(b)) => Some((a, b))
  case _                  => None // No other choice here.
}
\end{lstlisting}


\subsection{Exercises}

\subsubsection{Exercise \label{subsec:Exercise-disjunctive-1}\ref{subsec:Exercise-disjunctive-1}}

Define a disjunctive type \lstinline!CellState! representing the
visual state of one cell in the ``\href{https://en.wikipedia.org/wiki/Minesweeper_(video_game)}{Minesweeper}''
game: A cell can be either closed (showing nothing), or show a bomb,
or be open and show the number of bombs in neighbor cells.

\subsubsection{Exercise \label{subsec:Exercise-disjunctive-2}\ref{subsec:Exercise-disjunctive-2}}

Define a function from \lstinline!Seq[Seq[CellState]]! to \lstinline!Int!,
counting the total number of cells with zero neighbor bombs shown.

\subsubsection{Exercise \label{subsec:Exercise-disjunctive-3}\ref{subsec:Exercise-disjunctive-3}}

Define a disjunctive type \lstinline!RootOfLinear! representing all
possibilities for the solution of the equation $ax+b=0$ for arbitrary
real $a$, $b$. (The possibilities are: no roots; one root; all $x$
are roots.) Implement the solution as a function \lstinline!solve1!
with type signature 
\begin{lstlisting}
def solve1: ((Double, Double)) => RootOfLinear = ???
\end{lstlisting}


\subsubsection{Exercise \label{subsec:Exercise-disjunctive-4}\ref{subsec:Exercise-disjunctive-4}}

Given a \lstinline!Seq[(Double, Double)]! containing pairs $\left(a,b\right)$
of the coefficients of $ax+b=0$, produce a \lstinline!Seq[Double]!
containing the roots of that equation when a unique root exists. Use
the type \lstinline!RootOfLinear! and the function \lstinline!solve1!
defined in Exercise~\ref{subsec:Exercise-disjunctive-3}.

\subsubsection{Exercise \label{subsec:Exercise-disjunctive-4-1}\ref{subsec:Exercise-disjunctive-4-1}}

The case class \lstinline!Subscriber! was defined in Example~\ref{subsec:Disjunctive-Example-option-1}.
Given a \lstinline!Seq[Subscriber]!, compute the sequence of email
addresses for all subscribers that did \emph{not} give their phone
numbers.

\medskip{}

In the following exercises, the goal is to implement a function that
preserves as much information as possible and has a given type signature.

\subsubsection{Exercise \label{subsec:Exercise-disjunctive-5}\ref{subsec:Exercise-disjunctive-5}}

Implement a function with type signature
\begin{lstlisting}
def f1[A, B]: Option[(A, B)] => (Option[A], Option[B]) = ???
\end{lstlisting}


\subsubsection{Exercise \label{subsec:Exercise-disjunctive-6}\ref{subsec:Exercise-disjunctive-6}}

Implement a function with type signature
\begin{lstlisting}
def f2[A, B]: Either[A, B] => (Option[A], Option[B]) = ???
\end{lstlisting}


\subsubsection{Exercise \label{subsec:Exercise-disjunctive-7}\ref{subsec:Exercise-disjunctive-7}}

Implement a function with type signature
\begin{lstlisting}
def f3[A,B,C]: Either[A, Either[B,C]] => Either[Either[A,B], C] = ???
\end{lstlisting}


\section{Discussion}

\begin{comment}
now let's look at disjunctive types 

and try to access this error value when actually I'm in the right
disjunctive in the second part of the disjunctive because the error
is not defined in this Cobra that I am just showing in the scope only
the rest is defined so these case expressions have limited scope so
this expression from the first case until the second it is one scope
and within this scope the error variable is defined outside it is
not defined and similarly for this so if we call this function on
the value such as write 123 then this function will match the first
case will not match so then the second case will match and the result
will be returned so this will be the value it returns then the match
is performed line by line so if the first line that matches gives
you this expression and that's it not no further lines are evaluated
so log error of left bad result will match this because it matches
the symbol the left and then error will be the variable equal to the
value of it will be equal to bad result and so it'll print got error
bad result and then it will return -1 so case X Russians that choose
among possible values of a given type when this type is a disjunctive
and here is another way of using case expressions with types that
don't look like a disjunctive like int where you say if so I say X
which is an argument of this function X match and then I enumerate
certain cases 0 1 and then all other cases so if if 0 does not match
if one does not match then this case this line will be evaluated and
then this pattern matches everything is just a variable so this rest
will be equal to this X since we matched it and so then the same X
will be returned so you could think about integers as a type that
has different values like 0 1 and others there are possible values
of this type and so you could use case expression also for those so
case expression is not limited to disjunctive types or case classes
integer is not defined as a disjunctive type because it has long parts
of disjunctive but it has different values and so just to know to
the similarity between this code and this code the case expressions
in the partial function enumerate possible values of the function
and so here also I'm not limited to just writing two cases lines here
case left error case rightness I could write anything I want like
for example case left and then empty string instead of error here
and that will only match when X has that value left of empty string
then on the next line I could say case left of something else and
won't match only when X is net this is just to what you know that
the case expressions are more powerful than just matching the two
parts of a disjunctive they're matching anything these patterns can
have many conditions and this can be complicated so either is a example
of disjunctive but there are more general disjunctives like for example
well if I want to have a disjunctive between three different domains
do I have to do either of either so that is not convenient now in
in principle what I want is something like this I want to just say
this type or this type or let's say this type or this type or this
type this is a disjunctive I want to be able to define these junctions
like this but Scala does not have this syntax there are some libraries
like these libraries that provide syntax similar to this one but I
don't want to go into these libraries that are more advanced right
now I want to use the standard syntax in Scala which is sufficient
for most purposes in the more ordinary applications of functional
programming which is most of its applications today later I won't
talk about those libraries and see what they offer but for now let's
use the long syntax which is available in Scala and this is the syntax
okay this is quite long to represent what I would ideally write like
this if I if I compare this with that my type is a name of the type
the type has disjunctive of three domains the first domain is a list
of integers so the first domain here has a name all domains must have
a name in the disjunctive is a label so here in this context the name
would be implicit something like underscore one or something but in
this syntax in the long syntax the domain has to be explicit so your
name is have list int it has one part so it's a tuple of one with
name have list int and the part is named X let's say then I have to
write this keyword extends my type and in this way I say that this
case class is part of a disjunctive which I'm going to define now
so my type is the name of the entire disjunctive and these are the
names of its three parts the labels and these are the names of the
tuple parts so each domain is a tuple with names case class as I explained
is a tuple with names so this disjunctive has two lists the names
for everything for every part of the disjunctive and for every part
of each tuple finally these keywords sealed final case class trait
these keywords are necessary in Scala and what they do is they make
sure that you cannot by mistake change this disjunctive later because
that would be a difficult bug that some other part of the program
changes this disjunctive and then adds some more stuff to it let's
see some other domain and then your case matches stop working because
you don't know that somebody added domains you have your case State
case expressions like this pattern matching and you expect three domains
in your disjunctive so you write it like this but somebody adds a
different domain and this stops working this will crash if if that
word if that happens so to prevent that you say that my trait called
my type is sealed so no so only the ones the the domains of the disjunctive
that are listed next to it in the file well not necessarily next day
but in the same file only those exist and no others may be defined
later at any time similarly the case passes are final so they cannot
be extended later as the result the syntax is quite long you have
to write a lot of stuff just to express this kind of disjunctive of
three domains but you write it only once and using it is quite short
is not so bad at all so for example first I create a value of this
type so this could be a result of some computation with conditions
if some condition holds then the values have socks with some socks
values and otherwise it's have list int with some list int value so
this is computed and then somebody wants to find out what that X was
and they don't know this could be in a different part of the code
and this could be even in a different library and so you have to match
on the three domains of the disjunctive that's how you write it you
put pattern variables in the case classes so these nine names don't
have to be the same as these they can be for convenience but they
don't have to be I'm just specifically selecting all different names
just to show you that these are arbitrary names they don't have to
be the same and then you write expressions here that will be evaluated
in each of these cases and this expression for example is allowed
to use this LST but not this and all that because the scope is is
limited so the scope of definition of this LST is only this expression
the scope of definition of pmq is only this expression if you try
to use P and Q here the compiler would say cannot find symbol or something
like that if very often used disjunctive type is called option here
is how I would implement option in a very simple way it has a disjunctive
of two domains one domain is a tuple with one element of type T or
T is a type parameter and the second domain is a tuple of zero elements
or unit type which is represented as a case object this is just a
keyword in skeleton doesn't really mean anything different from a
tuple with no elements or a unit type and you notice here it extends
option with type parameter nothing nothing is a special type that
has no values at all so this is used to signal that this is an empty
tuple it does not have any values inside so we cannot use any type
for parameter here but we must specify the parameter so we use this
special type nothing all of this is defined in the standard library
of skeleton nothing option some none so some and none are the two
labels on the two domains of the disjunctive now in order to use it
you do pattern match for instance like this here's a function that
performs safe divided divides X by Y but your turns an option of double
and so option list is a disjunctive and option parameterize by the
type double is a disjunctive of of either double or nothing so no
value rather unit is the type or empty tuple if you prefer is a type
that does not carry any value of type double in it and so here's how
you define a function that computes this it checks the condition and
if Y is 0 you return none which is this label otherwise you return
value X divided by Y labeled by the name and a single Sun now the
symbol is a label on the second part or here on the first part of
the disjunctive and here's how I would use it so I would say safe
divide one divided by Q maybe Q is zero maybe not but I then match
so this returns an option of double I match the option with two cases
some X and none so these are the two parts of the disjunctive and
I mention them and so if I have some X then I multiply that some whatever
previous result by that X and otherwise I returned previous result
so this is a kind of a default value that I return when I don't get
anything out of this function this function returns none which is
a valid result of type option double mini Scala library functions
return an option type such as find returns so find looks in a collection
and returns an option if it found then it returns some of the value
and if it did not find it returns none had option is the first element
of the collection but if it's an empty sequence there is no head element
no first element so it returns none otherwise it returns some with
the value of the first element and similarly these primary functions
which you can look up in the library or in IntelliJ these functions
return option and the final note is that option has many functions
or methods defined on it in a sense option is like a collection it's
like sequence of tea so option of tea is very much like sequence of
tea in terms of what you can do with it you can see with sequins you
cannot do this match because sequence is not a disjunctive between
nan and Sun but sequence has map flatmap filter exists and so on all
of this is also defined on an option and you can understand this in
a simple way if you imagine that the sequence is like a container
and that sequence of tea is like a container where or let's say array
of teas and another kind of sequence it's like a container where you
have 0 or more elements of type T so this container holds values of
type T it can can hold no values empty array or empty sequence or
it could hold one value or two values and so on option is like a container
that can only hold 0 or 1 values of this type T it cannot hold two
so it's like a very limited sequence the sequence that can only be
of length 0 or 1 otherwise it looks like a sequence so it has a map
a function flat map filter and so on so what for example it's a map
on an option I will show you when we go through the worked examples
how that works map on the collection let's say on array of integers
you can do a map with a function that maps integers to strings say
in some way and then you map and you get an array of strings where
each element is transformed by that function option will behave in
a very similar way you do a map with an option and every element in
an option will be transformed using the function you specify however
option can only contain at most one element so it can be empty which
is this disjunctive part or it can be non-empty containing one element
of type T one value of type T so it's kind of a very limited simple-minded
collection but otherwise it's similar to collection we will see how
that works in the examples so with the tools we just learned what
problems can we solve we can represent values from disjoint sets or
domains as a single type and we can use these values to define functions
on them or functions producing them and use also these values in collections
as elements of collections or in any other way we can these are types
so there's no restriction on how you can use them so let's go through
some examples now the first example is to define a disjunctive type
day of week it represents the seven days of the week let me go to
this example so here's what it would look like so all these keywords
here in IntelliJ you see in bold blue dark blue seal the trade final
case object.extend so these are keywords of Scala and everything else
is our labels that we introduced so day of week is the name of this
entire type the entire disjunctive type it has seven domains and these
domains don't carry any values so these are just empty tuples and
the syntax for them is to say case object and then you don't you don't
write this this is a mistake you should know right that empty tuple
empty tuple is written like this indeed but you don't have to write
it here so the syntax is such that you don't write it left so when
you put a name on an empty tuple then it's called a case object and
then you don't write parenthesis so here's how we define the type
how will we use the type like this will define values a and B let's
say of this type and assign these values so we define Monday and Saturday
just like this we don't have to do anything else we don't have to
say new new Monday there's no numa there's only one Monday because
that's a label of the domain and a disjunctive is no no sense in that
to say new Monday cannot have different Monday's they're all the same
it's a label on the disjunctive now if I don't do this and just say
well a eCos Monday then Scala will actually not know that I want a
to be of this type color we'll think but it has typed Monday type
so monday dot type is just ask our feature that I'm not going to use
right now it is a more advanced feature so with these disjunctive
types it is a good idea to write type annotations Scala it can be
too smart about what I want to do and so it is better if I do this
but it would not be an error if I did it that way if I put just any
without type annotation probably my code was to work just some types
will become weird now suppose I want to print now how to print this
well actually case classes and case objects already have a two-string
method defined on them so I can just print like this with string interpolation
and this will run and I will get the string printed after we implement
the function so that this test can pass so how do we implement this
function this function is supposed to give us a boolean which is true
when the day of the week of Saturday and false otherwise so we do
this by pattern matching since the type is a disjunctive so we need
to match on the label of the disjunctive or in the scala language
we match on the case class or case object so we say Dean match and
then you see there's this red case close as expected sure and then
there's this thing which I can click it says generate case closes
for variants of sealed type now in the scholarly in which this means
this was a sealed trait that I defined and it has seven variants or
disjoint domains in my understanding and so if I click this IntelliJ
will fill in the code actually not sure why is doing it like this
because it's from from another from from another example I guess it's
a bit confused but it allowed me to delete what was not necessary
so it generated most of the code so now I need to put the expressions
that I'm going to return in each case so if this day is Saturday I
need to return true otherwise I need to return false now there's a
lot of I could say false false a lot of work like this so I'm going
to be more clever and I'm going to do this and when it puts Saturday
first and then if there is anything else I'm going to return false
so let's say playing this so in this way I'm expressing my intention
much more clearly so Saturday true I do otherwise anything else false
so there's one little thing so this will work but we can run this
test and this will work there's one little detail here so green notice
what is printed E is Monday B is Saturday so this is the string that
I printed here with interpolation so a was Monday and it can be it's
already printable so this is a convenience that scholar gives now
the little detail I was talking about is that intelligence says Declaration
is never used so I declared the variable X but I never actually used
it there's a syntax which looks like this it needs to be used in this
case to make it more clear like I said this still works this is not
a mistake to do a variable that you don't have to use a variable here
and never actually included anywhere so to left it unused it's not
a mistake but it is a little misleading because you're introducing
a variable and so I'm looking for its use maybe I don't find one so
this syntax means it's a very that matches anything just like X no
conditions and on it variable watches anything and I don't need its
name I'm not going to use that variable so the underscore in this
situation means that it's a pattern variable that I'm not going to
use so I don't need its name and it matches everything and my tests
are that a and B so a was Monday B was Saturday they they pass let's
go to the second example {[}Music{]} modified day a week so that the
values additionally represent a restaurant name and total amount for
Friday's and a wake-up time on Saturdays so what does it mean I want
additional values on list on this disjunctive on on the domains in
the disjunctive I want these domains to be not just empty tuples as
I did before here but for Friday I want a domain that represents a
string which is restaurant name and an amount paid so here's what
I do i make Friday and Saturday case classes instead of case objects
and then I am free to add parts in there with different types so field
called restaurant name and type string and its own so I can do that
and similarly for Saturday now I think I made I haven't finished this
so this is supposed to be wake up time so I think I want to do a local
date time from the Javadoc time library and that's a wake up time
so this is it so basically I have easily added more data but only
for these two days so these they still have no no data so if if the
day of the week is Monday then I didn't go to restaurant and in pain
thing and and so so now let's define some test data they have weakness
Monday now if I want to define Friday as day a week then I have to
specify the parts of this case class or the fields with names now
here's what I'm doing is like this and now I have defined the value
of type day of week I can still print it and then I want to define
a function that will tell me how much I paid on a given day of the
week now notice on those days I didn't pay anything on only a Friday
okay because I go out so this function will return an option double
and this option will be none or empty option for all the days except
Friday because there is nothing to be paid and on Friday I will return
this amount notice this is cleaner than returning zero for other days
I could return just double here instead of option double and I hope
with a subsidy a zero on those days but this is cleaner what if somehow
the amount paid was zero for some reason let's say I went to restaurant
and I had a coupon and I didn't have to pay anything I was free so
my amount paid was actually zero but I did go to a restaurant so that
information is not lost if I'm returning option double and if if I
give Friday's day of the week I will get a non-empty option with a
value of type double inside it and that value could be zero or anything
else I don't use any special values to denote the absence of amount
paid the type denotes it's the option type that's why it's so useful
that's why it's used so much in the library let's implement this function
again we do ng match and again I'm going to fill in and see what it
tells me oh great this is because I have two different case classes
and case objects and traits defined and with the same name in the
same file so IntelliJ is a bit confused I have defined them in the
scope of this test so they are completely safe and invisible in the
other test but IntelliJ is not able to see that okay I'm just going
to correct this by hand not a lot on work alright and Friday and Saturday
are actually correct now all right so now if I'm on Friday case then
I need to return some amount paid so sum is the constructor for the
domain of option that is not empty so I call this a constructor because
this looks like I'm calling a function which is called sum on a value
so it's like a constructor and the word constructor will be used and
quite frequently there's a type constructor and there is a value constructor
let's talk about how to implement this function will discuss the Constructors
later alright so in all other cases I have to return none so I have
to return none here here okay I'm bored I don't want to write on this
code so I say first case is return this and in every other case I
don't know what that is I don't I don't need to know I returned on
this is how I want to write it and also here this declaration is never
used I'm going to put underscore so now this is how I would run the
code also run this symbol to be nicer so I have a special intelligent
shortcut to insert this symbol and the symbol is exactly the same
as this combination so there's no difference it's just pure aesthetics
I like this symbol this is the way to write this kind of code and
it clearly says here's a disjunct into disjunctive domain which we
match and specify different possibilities one possibility is that
it's a Friday so sub domain of the disjunctive that is labeled as
Friday with these two values in it and then I return that otherwise
for any other domain I return them so let's run this test and see
what it prints because we printed here Monday and Friday right so
here's what it prints interesting a is Monday B is Friday of McDonald's
and 23.14 so this is the way scallop Prince case classes this is the
default way to print case classes so you don't have to write code
for your own printing function or to string function the function
to string is already defined in a reasonable way it may not be what
you want to Princeton your users but for debugging - this is pretty
good let us continue the next example is to define a disjunctive type
roots of quadratic it represents real valued roots of the equation
x squared plus bx plus c equals 0 for arbitrary real B\&C and there
are three cases no real roots two real equal roots two unequal real
roots notice I make this quadratic equation non degenerate so that
it always has the term x squared if I said ax squared plus BX plus
C there could be a case when a is zero and then we'll have a linear
equation so in this particular example I chose it to be like this
for simplicity and then we want to implement a solve function solve
to or solve quadratic which takes a tuple of two coefficients B and
C and returns the this value of this disjunctive type which is a roots
whatever situation of this it returns that value and that value represents
a disjunctive of these three cases no real roots 2 equals 2 M equals
and conceptional conceptually this is easy to think about you call
this function you get the value and then you can imagine it and see
what the situation is if you feel like it how do we implement that
let's take a look so I define sealed straight roots of quadratic final
case object no real roots extends the roots of quadratic so I say
again all this all this final extends and sealed trait these are scholar
keywords this is kind of verbose but you just only write this once
for every disjunctive and you never look at this more than once so
that's to me that's acceptable although I would prefer for example
that everything is sealed by default and everything else gives me
everything is final by default but I would prefer that that I don't
have to say final all the time but it's okay it's not so bad for the
value it gives us is that we can represent arbitrary disjunctives
of types when this case case classes and other types so there are
three domains in the disjunctive as we were over told no real roots
and that has no values obviously no roots so we say this is an empty
tuple and that is represented by a case object also this case object
doesn't have to be a new keyword in principle so but that's what scholar
requires just remember that this needs to be everything like that
second domain is when the roots are equal then there is only one number
to store and that number is X and so the third domain is when there
are two unequal roots and when there are two numbers to store all
right so we have defined a disjunctive type and now we define a function
solve - it takes a tuple of its coefficients a B and C and returns
the roots of quadratic so how does it work I always say we I chose
this syntax just to be a little the pure side of things you know value
I could say this is a well functions are values right so I could say
this is a well since I don't have any type parameters here I can do
it well if I had type parameters I would need to do a death alright
as I say here okay so there's a Val the function takes a tuple of
double double as its argument so what will define this function we
say in case BC we we do a case because this is the way to use tuples
as arguments in Scala so this is a syntax if I don't say case not
sure it will be healthy so you see this function has only one argument
this one argument has of it has type tuple of double double and so
that's why I need to do a match on that one argument so I already
need a match right right here okay so here's what I do my B and C
are these two coefficients so I determine the discriminant and if
it's greater than 0 then I have two different roots which are given
by this well-known formula and then so I just for clarity I define
names x1 and x2 temporarily and return to roots X 1 St here if discriminant
is zero I don't need to define any names temporarily it's too easy
to not say just equal root of minus B over 200k in here I could also
put these two expressions directly into the constructor of two roots
case class but this is more clear in this clearer in this in this
way finally if the discriminant is negative there are no real notes
so in this way I return a value of this type I construct this value
as an element of one of the three possible domains each domain having
its own values in there so this is a disjunctive of empty to pull
to pull of one and tuple of two but I put names on them so now it's
much more readable it's clear what I'm doing and easy to check for
mistakes so let's now check that this works so here's what I do i
define a sequence of tuples just so that i can check at once {[}Music{]}
all these equations so this is the equation x squared minus 2x plus
1 equals 0 so this equation has a double root X equal 1 obviously
now this equation is x squared plus X plus 1 equals 0 and it has no
reloads its roots are complex this equation is x squared minus X still
to come zero it has two real roots different two different railroads
so in this way I check all three possible domains and all three possible
cases and so I have a sequence of these three two bulls and I map
over the sequence with the functions of two which takes a tuple and
returns roots of connecticut the result is a sequence of roots of
contradict so then I check that the sequence is equal to what I expect
the first one has roots only one root x equals one the second one
has no real roots a third one has two different real roots so that's
test passes and it shows that we have implemented our function correctly
now notice that this function returns a value doesn't bail out or
generate errors it always returns a value this value has three different
domains in some domain there's no result another domain there's some
result so this is the way to have deal with complicated logic and
complicating domains in functional programming your model is domain
with types so you make a type that represents everything you want
to say as much as possible and then you write code with it so you
see it's quite easy to write code with this there are no special values
there is no flag boolean flag that would be true or false when you
have roots or you don't have words you don't do any of this it's much
more visual and clear when your code exactly says what's happening
there are no hidden flags hidden special values this is the advantage
of using disjunctive types actually this is one of the main advantages
over using some other methods of representing complicated data next
example is that we want to define a function called route average
which is from roots of quadratic in to option double that computes
the average value of all real roots returning none if the average
is undefined so it means if there's no roots that we return otherwise
we return the average problem so how do we implement this the test
is already written so for example route average of this should be
0 son 0 so it's option right so a non empty option has the form some
zero empty option has the firm none so these are the two domains of
the option and so you you have to always have to write the sum and
this none this is a bit verbose if you have a lot of those values
but you need to think about how to reduce the velocity but you always
have to write specific values like this if you have equal roots then
average is the same as this one value otherwise you get none so how
do you implement well you say roots and then you say generate case
closes I'm just lazy and then clearly if we are in this domain then
it's not here it is some X there the sum of x + y / - not that we're
done no way to make a mistake you see your boolean Flags - check nothing
no way to make a mistake very safe code finally what do we do now
we generate 100 random coefficients B and C and compute the mean of
Route average for all of them let's do that so first we make a function
get random that generates a random number so let's say between minus
1 and the one who generates a uniformly distributed random numbers
for simplicity and we prepare a sequence of coefficients by filling
100 random numbers now each get random will be a new number it is
actually good style in Scala to make these functions syntactically
different from values so that you see that this function actually
computes something new every time it's not just a value because I
could I could call this random could you name it and then if I don't
write these parentheses then it looks like a value it looks like it's
going to be the same every time but it's right now it's not a new
random number so to emphasize that the style convention often in Scala
is that you do the empty parenthesis just kind of a function of 0
arguments which you can also think of a function of an empty tuple
as an argument but in Scala is actually different you have functions
with zero arguments in Scala which are different from functions of
single argument that's an empty tuple Scala is a bit redundant in
this way and this is because it has to maintain compatibility with
Java but is never a big problem so the syntax helps if you use it
in a way that is suggestive so we make these coefficients we get a
sequence of random numbers and then we map over the sequence with
the functions of two that we implemented just previously the result
will be a sequence of this roots of quadratic that we have so each
element of the sequence could have different configuration of roots
in or roots at one or two rows and it's all in this type because this
is a disjunctive tab now we compute averages so solutions we map over
that sequence with root n rooster remember the function wrote average
takes roots of quadratic and returns option double so when we map
with this function over sequence of roots of quadratic we get a sequence
of option double each element being transformed now that's not what
we want though we now we want to compute average of the sequence but
it's a sequence of option double so some of them are none some of
them are not known how do we get all the ones that are not none to
take the average of them so I will show you several attempts to do
that in the first attempt is to filter the averages by retaining those
that are not null no not none so we do this with a filter with this
matching expression which is actually working but it still gives you
a sequence of option of double it does not eliminate the option type
and that's kind of bothersome so there are two ways in which you can
do it more easily and more safely one way is to use this flatten function
on sequence so it's a special case when you have so flattened usually
what it does is that you get from a sequence of sequences you get
the sequence so usually for example so usually the sequence of sequence
of T and you get from it sequence of T but also it works with sequence
of option of T and you get from it sequence of T so this usually what
flattens do is just flatten does is just every sequence here is concatenated
and you get one big sequence now if you think that option is like
a sequence of at most one element you can do the same operation you
can concatenate all those options that are not empty discard those
that are empty and you get a sequence so that's what flatten does
and that's exactly what we need to do here we have a sequence of optional
double and we need to discard those that are empty and get a sequence
of double as a result so that's what flattening does as another way
of achieving the same result is to use the collect function collect
function is quite useful because you can do partial function here
and match and transform things and transform types also so here I
transform type so this is an option type option of double and this
is double so I have transformed the type and the collect function
will check that this case actually matches and four empty options
it will not match and they will be discarded so that is how these
functions work very useful functions in this case flatten would be
my preferred option my preferred way of implementing it because it
is shorter and very clear I just want to discard all know all empty
options and that's what flatten does but if I have some more complicated
transformation discarding some elements while transforming others
and flatten is only defined for this special case sequence of option
for example flatten is not defined for an option of sequence or for
some others such things then I use collect so but anyway we can run
this test now and either result one or result two will compute exactly
the same thing {[}Music{]} let's see what is Prince for yeah interesting
some interesting number every root fine so this is our result the
final worked example for this tutorial is slightly different so far
we have been computing things now we want to implement a function
with a fully parametric type which is given like this what does this
function do it takes a tuple of two options and returns an option
of a tuple now actually I forgot the double parenthesis in this type
signature this must be double parenthesis and in my code I believe
it is like here a a function that takes a tuple you must have double
parenthesis because in scala the syntax is that the first pair of
parenthesis designates the arguments of the function so we can have
one or more arguments and each argument could be a tuple or not also
so if you have just one argument that's a tuple and you must do this
double parenthesis so I should have done it here too I will check
I will correct this in my slides let's look at the implementation
so I start with a test so if I had such a function of type two co-option
int option string let's say into option of tuple in string how would
I check that this works correctly for example if both options are
non-empty then I want to return a non-empty option of the of the pair
but if if just one of them is empty I cannot return the pair I cannot
have a pair because I don't have the other value and so I must return
none for the entire option of tuple so this is the only way that this
function can work and this test then checks that this is so so it
returns none in all cases except when both of these options are non
empty so here's the implementation one implementation of this function
what's reason about it to see how this implementation can be new right
well firstly we say they said these are the two arguments so let's
match on the first argument the matching of the argument has let me
delete this perhaps and write the code again by reasoning about what
needs to be done so obviously maybe a is a option of a sec maybe is
a empty option maybe not empty so maybe we have a name will be not
so we need to match to do the case closes I generate them so then
let me call this a just for clarity okay so now I have two cases either
a is non-empty or NES empty if it is empty I know what to do there
is nothing else to do except to return empty option of this type because
if I were to return non-empty option of this type I would have to
supply both a and B but I don't have B sorry I don't have a my a option
is empty there is no way for me to get an a value of type a because
I don't know what that type is I'm not given a value of type a and
I cannot create it from nothing so I must return none in case that
the option a is non-empty I have hope that maybe also B is present
so let's see if that is so we'll be dimensional let me again generate
cases so it calls value B all right so if B is present then I can
actually return a and B in the tuple so I'm supposed to return an
option of tuple and so I return non empty option some with tuple as
the value and here I again must return none there's no away so basically
my implementation is more or less fixed except that of course I could
return none here as well and the type would be still correct it will
be a very uninteresting implementation but always returns none whatever
the arguments and this the only interesting implementation is this
one now by interesting what I mean is if does not discard all the
information in the arguments it discards some sometimes some information
sometimes but it doesn't always discard everything so this implementation
is is non-trivial and it's the most information preserving one and
therefore the most interesting now this code actually it is correct
I have tests below that call my check function on this one so I can
check that this is correct but this is verbose all this match case
and then case none goes to none case Nando's no all of that is quite
verbose and if I wanted to modify logic here I would have to modify
a lot of things so remember that option is like sequences it has a
map function defined on it you have map method I use the word method
and function interchangeably not in scholar there is a difference
methods are those things defined with the syntax in a class and functions
are values of function type that cannot be used with this syntax again
this is a legacy of Java Java does not does not have functions at
all it only has methods so Scala must have methods too and yet scholar
wants to have functions function values so this is a compromise we
have both in Scala have methods and we have functions for the purposes
of functional programming methods are just like functions so I use
the words functions and methods interchangeably it's just that this
syntax must be different if map were a function not a method then
the syntax would be map both you may be a F something like that and
it's exactly similar map logically speaking has two arguments maybe
a and F but the syntax is that map is written in between with the
daughter actually there is an alternative syntax like this without
without Dalton without parentheses but I don't like that syntax so
much sometimes I use it but only when it is really in easy to read
and what's happening so let me remove this what I wanted to show it
is that this code is so common and it's exactly equivalent to this
code if you have the school that matches on the option so maybe a
this option some type and you imagine it and if it's not empty then
you return the non-empty option with some transformed value and if
it's empty or returned empty this is exactly the same as doing a map
on a collection if a collection is empty you return an empty collection
again and if it's not empty then you take each element and you transform
it with the function and then you return a collection having those
transformed elements an option being a collection with just one element
only needs one such transformation to be performed at most and so
this code is exactly the same as this code so let's take that code
and simplify it instead of maybe be match we just have now we can
write let me write this as a comment so this actually let me let me
copy the entire piece that I'm going to simplify and do it step by
step looking at this template here so whenever I have this pattern
sum of X going to sum of f of X not going to none I just do a map
so I have this pattern right here maybe be not just like that so instead
of this I say maybe B dot map and then the function is from B to the
tuple a B and that takes care of this thing so now the code is much
shorter it has this shape and it's but it still has the same pattern
match son to their son and or to option none - none so let's do maybe
a dot map and then a going to this so the entire code was replaced
by this does it actually work so let's go and see what happens with
this implementation which I called f2 well where I wrote what we just
saw maybe a dot map it's going to maybe be that map why going to tuple
x1 exactly what we ended up with you know after renaming of variables
let me remove that now actually it's not quite right because the type
of this thing is option of option of a b c this.type is option after
mapping we have an option and then this has a type a so we map X of
type a into an option of something and the result is going to be option
of option let me write a comment explaining how this happened I have
option of a then I do map with a function that goes from a to optional
B or action of tuple a B and the result is going to be C this a is
going to be replaced by this through the map function so result is
going to be the type option of option of a B and that's what IntelliJ
tells us if I delete this that's what it knows the type is so we need
to transform this to an ordinary option how do we transform well this
is the whole whole logic here if both of them are non empty only then
we'll get a non empty option at the end so that is what flatten does
a collection of empty collections gives you an empty collection after
flattening so we just use and that's it now that works so that's a
valid way of doing it but it's not the best because there's this pattern
which is map followed by flatten and this pattern also seems to be
very very often used and so in the standard library there is a method
called flat map which is the same as map followed by flatten and so
actually the code that you could write would be this now it is it
is questionable whether this code is easy to read or easier to read
than this I would actually say this code is a little easier to read
because of things in app and happened here's a flat map and map there
are other ways of making this much easier to read and to write which
I'll talk about later this is the for yield block notation but for
now it is important right all of these things by hand all of the maps
flat maps and so on and to follow the types follow to see how the
types are transformed IntelliJ sometimes gives you help here for example
I tell if I press command and then hover my mouse over symbols it
gives me some information about their types and definitions so it
tells me that for example this is an option of being this is a map
that takes a function and returns an of option of B and {[}Music{]}
these types are not always clear here what is this 8 to be for example
b2b I'm not sure what ageism not be is this oops this is certainly
a contrived example of such a function but is this type a please this
type B but actually this is not the types we're using we're using
option a and so on so IntelliJ is not always right when you do this
on the map but tell J is right when you do control shift p1 symbols
so that for example is always right what option B so to make a long
story short you need to start with code like this and then simplify
it and make it shorter and then gradually you will start thinking
in terms of these map flatmap and so on so that it is much easier
for you to think in terms of transformations on an option collection
and so on rather than transformations done on individual elements
it's very important to follow how types change so let me let me try
to rewrite this function in in a longer fashion here and this is what
you might do initially when you start learning about functional programming
code like this is very short it is not very readable so what you can
do is you can say first of all you can make these functions multiline
by putting curly braces around them and then you can introduce intermediate
values for example Wow C equals this and then you return C it's the
same right you call this value C and right away that is your expression
but now you can see what type it is so it's option LV and you do option
return like click on the keyboard to add the type annotation and so
it tells you that this is actually an option of a B that information
was not obvious here when you look at this code but you can make this
easier for me to understand so first maybe B has type option of B
you map it like this and it becomes option of a B maybe what's what's
rename this X into a and that's why into B so that it becomes easier
to read and then also here you are not sure what are you what your
return it but flat map tells you flat map takes a function from a
to option B returns option B well actually this is confusing because
your B is not therapy so there be here is defined in the standard
library somewhere it's not your B so the definition of flat map is
this there's some be here there's some a here it's not what you wanted
it's not your B and what your a so that is a bit confusion so let's
do the same trick here well result equals this return result and now
let's add a type annotation to this okay so now if you didn't do flat
map let's remove this type annotation and add it again you could do
control shift P to see what it is or you can just put it into the
code to document that you at this point you got a gallery of this
type so these transformations each of them will change the type of
values and it's nice to see what type it is to check that that's exactly
what you want now obviously we want an option of a B and not an option
option of a B so we need to flatten it so now let me see what that
is so in this way you can go step by step within each of these transformations
and see what types then generate and having if you have done this
enough times initially it will take time and you you have many steps
and at the end you will see it becomes easier so here are some more
exercises for you to work with disjoint disjunctive types case classes
and collections of them and implement some functions like like these
also with fully parametric types and so these functions are usually
obvious what is meant so for example option of a pair goes into a
pair of options obviously this option is empty then you must return
to empty options here and if this option is not empty then it makes
sense to return to non-empty options in order to maximize information
and similarly here for either if you have either of a B that could
be a and then you can return here and non-empty optional a but you
must return empty option of B and vice versa in order to not lose
information and in this example also if you have either a either B
C so for example you could have a and then what they return while
you return the left version of either and the left version of this
either with a inside so in this way you can always see what kind of
value it makes sense to return in order to not lose information good
luck with these exercises 
\end{comment}


\subsection{Disjunctive types as mathematical sets}

To understand the properties of disjunctive types from the mathematical
point of view, consider a function whose argument is a disjunctive
type, such as
\begin{lstlisting}
def isDoubleRoot(r: RootsOfQ) = ...
\end{lstlisting}
The type of the argument \lstinline!r:RootsOfQ! represents the mathematical
domain of the function, that is, the set of admissible values of the
argument \lstinline!r!. We could imagine a function on a \emph{disjoint}
domain, for example $r$ is either a point on a line or a point on
a surface, where the surface is completely separate from the line.
Such domains are called \textbf{\index{disjoint domain}disjoint}
because the line and the surface have no common points.

The set of real roots of a quadratic equation $x^{2}+bx+c=0$ is an
example of a disjoint domain containing three parts: the no-roots
case, the one-root case where the root is represented by a single
number $x$, and the two-roots case where the roots are represented
by a pair of numbers $\left(x,y\right)$. Geometrically, a number
$x$ is pictured as a point on a line (a one-dimensional space), and
pair of numbers $\left(x,y\right)$ is pictured as a point on a Cartesian
plane (a two-dimensional space). The no-roots case corresponds to
a zero-dimensional space, which is pictured as a single point (see
Figure~\ref{fig:RootsOfQ-disjoint-domain}).

\begin{figure}
\begin{centering}
%\begin{pdfpic}
   \newrgbcolor{lightpastel}{0.90 0.93 0.87}
   \psset{unit=0.5\textwidth}
   \begin{pspicture}(0,0)(1,1)
      \pscircle*(0.3,0.5){0.005}
      \psline{->}(0.5,0.2)(0.5,0.8)
      \rput(0.535,0.77){$x$}
      \pspolygon[fillstyle=solid,fillcolor=lightpastel](0.8,0.8)(0.8,0.3)(0.7,0.2)(0.7,0.7)(0.8,0.8)
      \psline{->}(0.7,0.2)(0.775,0.275)
      \rput(0.67,0.28){$x$} \rput(0.79,0.24){$y$}
      \psline{->}(0.7,0.2)(0.7,0.3)
      \rput(0.30,0.45){\smaller\texttt{NoRoots()}}
      \rput(0.49,0.85){\smaller\texttt{OneRoot(x)}}
      \rput(0.75,0.15){\smaller\texttt{TwoRoots(x, y)}}
   \end{pspicture}
%\end{pdfpic}
\par\end{centering}
\caption{The disjoint domain represented by the \lstinline!RootsOfQ! type.}
\label{fig:RootsOfQ-disjoint-domain}
\end{figure}

In the mathematical notation, a one-dimensional real space is denoted
by $\mathbb{R}$, a two-dimensional space by $\mathbb{R}^{2}$, and
a zero-dimensional space may be denoted by $\mathbb{R}^{0}$. 

At first sight, we may think that the mathematical representation
of the type \lstinline!RootsOfQ! is a union of the three sets, $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}$.
But an ordinary union of sets would not work for two reasons. First,
usually one considers that a point is a subset of a line, and a line
is a subset of a plance, so $\mathbb{R}^{0}\subset\mathbb{R}^{1}\subset\mathbb{R}^{2}$
and therefore $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}=\mathbb{R}^{2}$.
Even if we somehow avoided this conclusion, we would still confuse
several sets of the same type since $\mathbb{R}^{1}\cup\mathbb{R}^{1}=\mathbb{R}^{1}$.
We need to distinguish the parts of the union unambiguously, even
if some parts have the same type. The disjunctive type shown in Example~\ref{subsec:disj-Example-rootsofq-2}
cannot be correctly represented by the mathematical set 
\[
\mathbb{R}^{0}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}
\]
because this set is mathematically equivalent to $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}$,
which is not the set we need.

In the Scala code, each part of a disjunctive type must be distinguished
by a unique name such as \lstinline!NoRoots!, \lstinline!OneRoot!,
and \lstinline!TwoRoots!. To represent this mathematically, we need
to attach a distinct label to each part of the union. Labels are symbols
without any special meaning, so we can just say that labels are Scala
identifiers. So, we will use sets of pairs such as $(\text{\texttt{OneRoot}},x)_{x\in\mathbb{R}^{1}}$
to represent the parts of the union, and write
\[
\text{\texttt{RootsOfQ}}=(\text{\texttt{NoRoots}},u)_{u\in\mathbb{R}^{0}}\cup(\text{\texttt{OneRoot}},x)_{x\in\mathbb{R}^{1}}\cup(\text{\texttt{TwoRoots}},\left(x,y\right))_{\left(x,y\right)\in\mathbb{R}^{2}}\quad.
\]
This kind of labeled union is called a \index{disjoint union}\textbf{disjoint
union}. Each element of the disjoint union has a label that clearly
identifies the part of the union. If we use disjoint unions, we cannot
confuse different parts of the union even if they all have the same
type, because labels are required to be distinct. Because of the different
labels, any two values from different parts of the union cannot possibly
be equal.

Disjoint unions are not often explicitly denoted in mathematics, but
they are needed in software engineering because real-life data often
has that form.

\paragraph{Named \texttt{Unit} types}

At first sight, it may seem confusing that the zero-dimensional space
is represented by a set containing \emph{one} point. Why should we
not use an empty set (rather than a set with one point) to represent
the case where the equation has no real roots? The reason is that
we are required to represent not only the values of the roots but
also the information \emph{about} the existence of the roots. The
case with no real roots needs to be represented by some \emph{value}
of type \lstinline!RootsOfQ!. This value cannot be missing, which
would happen if we used an empty set to represent the no-roots case.
It is natural to use the named empty tuple \lstinline!NoRoots()!
to represent this case, since we used a named tuple \lstinline!TwoRoots(x, y)!
to represent the case of two roots.

The set containing a single point corresponds to the \lstinline!Unit!
type in Scala because this type has only one distinct value, written
as \lstinline!()!. A case class with no parts, such as \lstinline!NoRoots!,
has only one distinct value, written as \lstinline!NoRoots()!. We
see that case classes with no parts are quite similar to \lstinline!Unit!
except for an added name. For this reason, they can be viewed as ``named
\lstinline!Unit!'' types.

\subsection{Disjunctive types in other programming languages}

Disjunctive types (and the associated pattern matching) turns out
to be one of the defining features of functional programming languages.
Programming languages that were not designed for functional programming
do not support this feature, while ML, OCaml, Haskell, F\#, Scala,
Swift, Elm, and PureScript support disjunctive types as part of the
language design. 

It is remarkable that the named tuple types (or ``records'') are
present in almost every programming language, while disjunctive types
are present almost exclusively in languages specifically designed
for the functional programming paradigm.\footnote{See \href{https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(basic_instructions)\#Other_types}{this Wikipedia page}
for a detailed comparison between programming languages. Ada and Pascal
are the only older languages that provided disjunctive types without
other features of the FP paradigm.} 

The \lstinline!union! types in C and C++ are not disjunctive types
because it is not possible to determine which part of the union is
being represented. A \lstinline!union! declaration in C looks like
this,
\begin{lstlisting}
union { int x; double y; long z; } di;
\end{lstlisting}
The problem is that the parts of the union are not labeled. So, it
is impossible to determine or to verify which part of the union is
represented by a given value \lstinline!di!. This leads to coding
errors that are hard to track.

Older programming languages such as C, C++, and Java had ``enumeration''
(\lstinline!enum!) types), which are a limited form of disjunctive
types. An \lstinline!enum! type declaration in Java looks like this,
\begin{lstlisting}
enum Color { RED, GREEN, BLUE; } 
\end{lstlisting}
This is equivalent to a labeled union of three \emph{empty} tuples,
\begin{lstlisting}
sealed trait Color
final case class RED() extends Color
final case class GREEN() extends Color
final case class BLUE() extends Color
\end{lstlisting}
If the \lstinline!enum! construction were ``enriched'' with extra
data, so that each tuple could be non-empty, we would obtain disjunctive
types. A definition of \lstinline!RootsOfQ! would then look like
this: 
\begin{lstlisting}
// This is not valid in Java!
enum RootsOfQ {
  NoRoots, OneRoot(x: Double), TwoRoots(x: Double, y: Double);
}
\end{lstlisting}
A future version of Scala 3 will have a shorter syntax for disjunctive
types\footnote{\href{https://dotty.epfl.ch/docs/reference/enums/adts.html}{https://dotty.epfl.ch/docs/reference/enums/adts.html}}
that indeed looks like an ``enriched \lstinline!enum!'',
\begin{lstlisting}
enum RootsOfQ {
  case NoRoots
  case OneRoot(x: Double)
  case TwoRoots(x: Double, y: Double)
}
\end{lstlisting}

For comparison, here is the OCaml and the Haskell syntax for a disjunctive
type equivalent to \lstinline!RootsOfQ!:
\begin{lstlisting}
{* OCaml *}
type RootsOfQ = NoRoots | OneRoot of float | TwoRoots of float*float

-- Haskell
data RootsOfQ = NoRoots | OneRoot Double | TwoRoots (Double,Double)
\end{lstlisting}
This syntax is more concise than the Scala syntax. When reasoning
about disjunctive types, it is inconvenient to write out long type
definitions. Chapter~\ref{chap:3-3-The-formal-logic-curry-howard}
will define a short mathematical notation designed for efficient reasoning
about types and code.

\subsection{Disjunctions and conjunctions in formal logic\label{subsec:Disjunctions-and-conjunctions}}

In formal logic, a \textbf{proposition\index{proposition in logic}}
is a statement that may be proven true or false. A \textbf{disjunction\index{disjunction in logic}}
of propositions $A$, $B$, $C$ is denoted by $A\vee B\vee C$ and
is true if only if \emph{at least one} of the propositions $A$, $B$,
$C$ is true. A \textbf{conjunction}\index{conjunction in logic}
of propositions $A$, $B$, $C$ is denoted by $A\wedge B\wedge C$
and is true if only if \emph{all} of the propositions $A$, $B$,
$C$ are true.

There is a similarity between a disjunctive data type and a logical
\emph{disjunction} of propositions. A value of the disjunctive data
type \lstinline!RootsOfQ! can be constructed only if we have at least
one of the values \lstinline!NoRoots()!, \lstinline!OneRoot(x)!,
or \lstinline!TwoRoots(x, y)! for some specific \lstinline!x! and
\lstinline!y!. To save words, denote by ${\cal CH}(A)$ the logical
proposition ``this ${\cal C}$ode ${\cal H}$as a value of type \lstinline!A!'',
where ``this code'' refers to a particular expression or function
in our program. So, the proposition ``a function can return a value
of type \lstinline!RootsOfQ!'' is denoted by ${\cal CH}(\text{\texttt{RootsOfQ}})$.
We can then write the sentence about \lstinline!RootsOfQ! as the
logical formula
\[
{\cal CH}(\text{\texttt{RootsOfQ}})={\cal CH}(\text{\texttt{NoRoots}})\vee{\cal CH}(\text{\texttt{OneRoot}})\vee{\cal CH}(\text{\texttt{TwoRoots}})\quad.
\]

There is also a a similarity between logical \emph{conjunctions} and
a named tuple type. Consider the named tuple \lstinline!TwoRoots(x: Double, y: Double)!.
When can we have a value of type \lstinline!TwoRoots!? Only when
we have two values of type \lstinline!Double!. Writing this statement
as a formula, we get
\[
{\cal CH}(\text{\texttt{TwoRoots}})={\cal CH}(\text{\texttt{Double}})\wedge{\cal CH}(\text{\texttt{Double}})\quad.
\]
Now, in logic we have the simplification
\[
{\cal CH}(\text{\texttt{Double}})\wedge{\cal CH}(\text{\texttt{Double}})={\cal CH}(\text{\texttt{Double}})\quad.
\]
However, no such simplification will be available for an arbitrary
tuple such as 
\begin{lstlisting}
case class Data3(x: Int, y: String, z: Double)
\end{lstlisting}
For this type, we will have the statement
\[
{\cal CH}(\text{\texttt{Data3}})={\cal CH}(\text{\texttt{Int}})\wedge{\cal CH}(\text{\texttt{String}})\wedge{\cal CH}(\text{\texttt{Double}})\quad.
\]

We find that disjunctive types are related to logical disjunctions
in the same way as tuples are related to logical conjunctions. This
is the main motivation behind the name ``disjunctive types''.

The correspondence between disjunctions, conjunctions, and data types
is explained in more detail in Chapter~\ref{chap:3-3-The-formal-logic-curry-howard}.
For now, we note that the operations of conjunction and disjunction
are not sufficient to produce all possible logical expressions. To
obtain a complete logic, it is also necessary to have a logical negation
$\neg A$ (``$A$ is not true'') or, equivalently, a logical implication
$A\Rightarrow B$ (``if $A$ is true than $B$ is true''). It turns
out that the logical implication is related to the function types
\lstinline!A => B!. In the next chapter, we will study the function
types in more depth.
