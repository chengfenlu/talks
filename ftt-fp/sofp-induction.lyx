#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% Better formatting of tables.
%\usepackage{booktabs}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.0pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.
\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt,utf8
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7in
\paperheight 9in
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Success,Failure,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Mathematical formulas as code.
 II.
 Mathematical induction
\begin_inset CommandInset label
LatexCommand label
name "chap:2-Mathematical-induction"

\end_inset


\end_layout

\begin_layout Standard
We will now study more flexible ways of working with data collections in
 the functional programming paradigm.
 The Scala standard library has methods for performing general iterative
 computations, that is, computations defined by induction.
 Translating mathematical induction into code is the focus of this chapter.
\end_layout

\begin_layout Standard
But first we need to become fluent in using tuple types with Scala collections.
\end_layout

\begin_layout Section
Tuple types
\end_layout

\begin_layout Subsection
Examples of using tuples
\end_layout

\begin_layout Standard
Many standard library methods in Scala require working with 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples
\end_layout

\end_inset

tuple
\series default
 types.
 A simple example of a tuple is a 
\emph on
pair
\emph default
 of values, â€“ such as, a pair of an integer and a string.
 The Scala syntax for this type of pair is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val a: (Int, String) = (123, 
\begin_inset Quotes eld
\end_inset

xyz
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

The type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, String)
\end_layout

\end_inset

 denotes this tuple type.
\end_layout

\begin_layout Standard
A 
\series bold
triple
\series default
 is defined in Scala like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val b: (Boolean, Int, Int) = (true, 3, 4)
\end_layout

\end_inset

Pairs and triples are examples of tuples.
 A 
\series bold
tuple
\series default
 can contain any number of values, which I call 
\series bold
parts
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples!parts
\end_layout

\end_inset


\series default
 of a tuple.
 The parts of a tuple can have different types, but the type of each part
 is fixed once and for all.
 Also, the number of parts in a tuple is fixed.
 It is a 
\series bold
type error
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

 to use incorrect types in a tuple, or an incorrect number of parts of a
 tuple:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val bad: (Int, String) = (1,2)
\end_layout

\begin_layout Plain Layout

<console>:11: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : Int(2)
\end_layout

\begin_layout Plain Layout

 required: String
\end_layout

\begin_layout Plain Layout

       val bad: (Int, String) = (1,2)
\end_layout

\begin_layout Plain Layout

                                   ^
\end_layout

\begin_layout Plain Layout

scala> val bad: (Int, String) = (1,"a",3)
\end_layout

\begin_layout Plain Layout

<console>:11: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : (Int, String, Int)
\end_layout

\begin_layout Plain Layout

 required: (Int, String)
\end_layout

\begin_layout Plain Layout

       val bad: (Int, String) = (1,"a",3)
\end_layout

\begin_layout Plain Layout

                                ^
\end_layout

\end_inset

Parts of a tuple can be accessed by number, starting from 
\begin_inset Formula $1$
\end_inset

.
 The Scala syntax for 
\series bold
tuple accessor
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuple accessor
\end_layout

\end_inset


\series default
 methods looks like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

._1
\end_layout

\end_inset

, for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val a = (123, 
\begin_inset Quotes eld
\end_inset

xyz
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

a: (Int, String) = (123,xyz)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> a._1
\end_layout

\begin_layout Plain Layout

res0: Int = 123
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> a._2
\end_layout

\begin_layout Plain Layout

res1: String = xyz 
\end_layout

\end_inset

It is a type error to access a tuple part that does not exist:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> a._0
\end_layout

\begin_layout Plain Layout

<console>:13: error: value _0 is not a member of (Int, String)
\end_layout

\begin_layout Plain Layout

       a._0
\end_layout

\begin_layout Plain Layout

         ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> a._5
\end_layout

\begin_layout Plain Layout

<console>:13: error: value _5 is not a member of (Int, String)
\end_layout

\begin_layout Plain Layout

       a._5
\end_layout

\begin_layout Plain Layout

         ^
\end_layout

\end_inset

Type errors
\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

 are detected at compile time, before any computations begin.
\end_layout

\begin_layout Standard
Tuples can be 
\series bold
nested
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples!nested
\end_layout

\end_inset

: any part of a tuple can be itself of a tuple type.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val c: (Boolean, (String, Int), Boolean) = (true, (
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

, 3), false)
\end_layout

\begin_layout Plain Layout

c: (Boolean, (String, Int), Boolean) = (true,(abc,3),false)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> c._1
\end_layout

\begin_layout Plain Layout

res0: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> c._2
\end_layout

\begin_layout Plain Layout

res1: (String, Int) = (abc,3)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To define functions whose arguments are tuples, we could use the tuple accessors.
 An example of such a function is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(p: (Boolean, Int), q: Int): Boolean = p._1 && (p._2 > q) 
\end_layout

\end_inset

The first argument, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

, of this function, has a tuple type.
 The function body uses accessor methods (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

._1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

._2
\end_layout

\end_inset

) to compute the result value.
 Note that the second part of the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, so it is valid to compare it with an integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

.
 It would be a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

type error to compare the 
\emph on
tuple
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 with an 
\emph on
integer
\emph default
 using the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p > q
\end_layout

\end_inset

.
 It would be also a type error to apply the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 that has a wrong type, e.g.
\begin_inset space ~
\end_inset

the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Boolean, Int)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Pattern matching for tuples
\end_layout

\begin_layout Standard
Instead of using accessor methods when working with tuples, it is often
 convenient to use 
\series bold
pattern matching
\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern matching
\end_layout

\end_inset


\series default
.
 Pattern matching occurs in two situations in Scala:
\end_layout

\begin_layout Itemize
destructuring definition: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

val $pattern$ = ...
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

case $pattern$ => ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An example of a 
\series bold
destructuring
\begin_inset Index idx
status open

\begin_layout Plain Layout
destructuring
\end_layout

\end_inset

 definition
\series default
 is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val g = (1, 2, 3)
\end_layout

\begin_layout Plain Layout

g: (Int, Int, Int) = (1,2,3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val (x, y, z) = g
\end_layout

\begin_layout Plain Layout

x: Int = 1
\end_layout

\begin_layout Plain Layout

y: Int = 2
\end_layout

\begin_layout Plain Layout

z: Int = 3
\end_layout

\end_inset

The value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 is a tuple of three integers.
 After defining 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

, we define the three variables 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 
\emph on
at once
\emph default
 in a single 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 definition.
 We imagine that this definition 
\begin_inset Quotes eld
\end_inset

destructures
\begin_inset Quotes erd
\end_inset

 the data structure contained in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 and decomposes it into three parts, then assigns the names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 to these parts.
 The types of the new values are also assigned automatically.
\end_layout

\begin_layout Standard
The left-hand side of the destructuring definition contains the tuple pattern
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y, z)
\end_layout

\end_inset

 that looks like a tuple, except that its parts are names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 that are so far 
\emph on
undefined
\emph default
.
 These names are called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern variables
\end_layout

\end_inset

pattern variables
\series default
.
 The destructuring definition checks whether the structure of the value
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

matches
\begin_inset Quotes erd
\end_inset

 the three 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern variables
\end_layout

\end_inset

pattern variables.
 (If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 does not contain a tuple with exactly three parts, the definition will
 fail.) This computation is called 
\series bold
pattern matching
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern matching
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Pattern matching is often used when working with tuples:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1, 2, 3) match { case (a, b, c) => a + b + c }
\end_layout

\begin_layout Plain Layout

res0: Int = 6
\end_layout

\end_inset

The 
\series bold
case expression
\begin_inset Index idx
status open

\begin_layout Plain Layout
case expression
\end_layout

\end_inset


\series default
 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case (a, b, c) => ...
\end_layout

\end_inset

) performs pattern matching on the tuple argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 The pattern matching will 
\begin_inset Quotes eld
\end_inset

destructure
\begin_inset Quotes erd
\end_inset

 (i.e.
\begin_inset space ~
\end_inset

decompose) the tuple and try to match it to the given pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b, c)
\end_layout

\end_inset

.
 In this pattern, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 are as yet undefined new variables, â€“ that is, they are 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern variables
\end_layout

\end_inset

pattern variables.
 If the pattern matching succeeds, the pattern variables 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 are assigned their values, and the function body can proceed to perform
 its computation.
 In this example, the pattern variables 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 will be assigned values 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, and 
\begin_inset Formula $3$
\end_inset

, so the function returns 
\begin_inset Formula $6$
\end_inset

 as its result value.
\end_layout

\begin_layout Standard
Pattern matching is especially convenient when working with nested tuples.
 Here is an example of such code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t1(p: (Int, (String, Int))): String = p match {
\end_layout

\begin_layout Plain Layout

  case (x, (str, y)) => str + (x + y).toString
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> t((10, ("result is ", 2)))
\end_layout

\begin_layout Plain Layout

res0: String = result is 12
\end_layout

\end_inset

The type structure of the argument is visually repeated in the pattern.
 It is easy to see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 become integers and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

str
\end_layout

\end_inset

 becomes a string after pattern matching.
 If we rewrite the same code using the tuple accessor methods instead of
 pattern matching, the code will look like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t2(p: (Int, (String, Int))): String = p._2._1 + (p._1 + p._2._2).toString
\end_layout

\end_inset

This code is shorter but harder to read: For example, it is not immediately
 clear what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._2._1
\end_layout

\end_inset

 refers to.
 It is also harder to change this code: Suppose we want to change the type
 of the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((Int, String), Int)
\end_layout

\end_inset

.
 Then the new code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t3(p: ((Int, String), Int)): String = p._1._2 + (p._1._1 + p._2).toString
\end_layout

\end_inset

It takes time to verify, by going through every accessor method, that the
 function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t3
\end_layout

\end_inset

 computes the same expression as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

.
 In contrast, the code is changed easily when using the pattern matching
 expression instead of the accessor methods:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t4(p: ((Int, String), Int)): String = p match {
\end_layout

\begin_layout Plain Layout

  case ((x, str), y) => str + (x + y).toString
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The only change in the function body, compared to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t1
\end_layout

\end_inset

, is in the pattern matcher, so it is visually clear that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t4
\end_layout

\end_inset

 computes the same expression as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t1
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Sometimes we do not need some of the tuple parts in a pattern match.
 The following syntax is used to make this intention clear:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val (x, _, _, z) = ("abc", 123, false, true)
\end_layout

\begin_layout Plain Layout

x: String = abc
\end_layout

\begin_layout Plain Layout

z: Boolean = true
\end_layout

\end_inset

The underscore symbol 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_
\end_layout

\end_inset

 denotes the parts of the pattern that we want to ignore.
 The underscore will always match any value regardless of type.
\end_layout

\begin_layout Standard
A feature of Scala is a short syntax for functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{case (x, y) => y}
\end_layout

\end_inset

 that extract elements from tuples.
 The shorter syntax is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(t => t._2)
\end_layout

\end_inset

 or even shorter, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(_._2)
\end_layout

\end_inset

, as illustrated here:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p: ((Int, Int )) => Int = { case (x, y) => y }
\end_layout

\begin_layout Plain Layout

p: ((Int, Int)) => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> p((1, 2))
\end_layout

\begin_layout Plain Layout

res0: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val q: ((Int, Int )) => Int = (_._2)
\end_layout

\begin_layout Plain Layout

q: ((Int, Int)) => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> q((1, 2))
\end_layout

\begin_layout Plain Layout

res1: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq( (1,10), (2,20), (3,30) ).map(_._2)
\end_layout

\begin_layout Plain Layout

res2: Seq[Int] = List(10, 20, 30)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Using tuples with collections
\end_layout

\begin_layout Standard
Tuples can be combined with any other types without restrictions.
 For instance, we can define a tuple of functions,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val q: (Int => Int, Int => Int) = (x => x + 1, x => x - 1)
\end_layout

\end_inset

We can create a list of tuples,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val r: List[(String, Int)] = List((
\begin_inset Quotes eld
\end_inset

apples
\begin_inset Quotes erd
\end_inset

, 3), (
\begin_inset Quotes eld
\end_inset

oranges
\begin_inset Quotes erd
\end_inset

, 2), (
\begin_inset Quotes eld
\end_inset

pears
\begin_inset Quotes erd
\end_inset

, 0))
\end_layout

\end_inset

We could define a tuple of lists of tuples of functions, or any other combinatio
n.
\end_layout

\begin_layout Standard
Here is an example of using the standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 to transform a list of tuples.
 The argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 must be a function taking a tuple as its argument.
 It is convenient to use pattern matching for writing such functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val basket: List[(String, Int)] = List((
\begin_inset Quotes eld
\end_inset

apples
\begin_inset Quotes erd
\end_inset

, 3), (
\begin_inset Quotes eld
\end_inset

pears
\begin_inset Quotes erd
\end_inset

, 2), (
\begin_inset Quotes eld
\end_inset

lemons
\begin_inset Quotes erd
\end_inset

, 0))
\end_layout

\begin_layout Plain Layout

basket: List[(String, Int)] = List((apples,3), (pears,2), (lemons,0))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> basket.map { case (fruit, count) => count * 2 }
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(6, 4, 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> basket.map { case (fruit, count) => count * 2 }.sum
\end_layout

\begin_layout Plain Layout

res1: Int = 10
\end_layout

\end_inset

In this way, we can use the standard methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

 to manipulate sequences of tuples.
 The names 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fruit
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 are chosen to help us remember the meaning of the parts of tuples.
\end_layout

\begin_layout Standard
We can easily transform a list of tuples into a list of values of a different
 type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> basket.map { case (fruit, count) =>
\end_layout

\begin_layout Plain Layout

  val isAcidic = fruit == 
\begin_inset Quotes eld
\end_inset

lemons
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  (fruit, isAcidic)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

res2: List[(String, Boolean)] = List((apples,false), (pears,false), (lemons,true
)) 
\end_layout

\end_inset

In the Scala syntax, a nameless function written with braces 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ ...
 }
\end_layout

\end_inset

 can define local values in its body.
 The return value of the function is the last expression written in the
 function body.
 In this example, the return value of the nameless function is the tuple
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(fruit, isAcidic)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Treating dictionaries (Scala's 
\family typewriter
Map
\family default
s) as collections
\end_layout

\begin_layout Standard
In the Scala standard library, tuples are frequently used as types of intermedia
te values.
 For instance, tuples are used when iterating over dictionaries.
 The Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[K,V]
\end_layout

\end_inset

 represents a dictionary with keys of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

K
\end_layout

\end_inset

 and values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

V
\end_layout

\end_inset

.
 Here 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

K
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

V
\end_layout

\end_inset

 are 
\series bold
type parameters
\begin_inset Index idx
status open

\begin_layout Plain Layout
type parameter
\end_layout

\end_inset


\series default
.
 Type parameters represent unknown types that will be chosen later, when
 working with values having specific types.
\end_layout

\begin_layout Standard
In order to create a dictionary with given keys and values, we can write
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Map((
\begin_inset Quotes eld
\end_inset

apples
\begin_inset Quotes erd
\end_inset

, 3), (
\begin_inset Quotes eld
\end_inset

oranges
\begin_inset Quotes erd
\end_inset

, 2), (
\begin_inset Quotes eld
\end_inset

pears
\begin_inset Quotes erd
\end_inset

, 0))
\end_layout

\end_inset

This is equivalent to first creating a sequence of key/value 
\emph on
pairs
\emph default
 and then converting that sequence into a dictionary.
\end_layout

\begin_layout Standard
Pairs are used often, so the Scala library defines a special infix syntax
 for pairs via the arrow symbol 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

->
\end_layout

\end_inset

.
 The expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x -> y
\end_layout

\end_inset

 is equivalent to the pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> 
\begin_inset Quotes eld
\end_inset

apples
\begin_inset Quotes erd
\end_inset

 -> 3
\end_layout

\begin_layout Plain Layout

res0: (String, Int) = (apples,3)
\end_layout

\end_inset

With this syntax, it is easier to read the code for creating a dictionary:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Map(
\begin_inset Quotes eld
\end_inset

apples
\begin_inset Quotes erd
\end_inset

 -> 3, 
\begin_inset Quotes eld
\end_inset

oranges
\begin_inset Quotes erd
\end_inset

 -> 2, 
\begin_inset Quotes eld
\end_inset

pears
\begin_inset Quotes erd
\end_inset

 -> 0)
\end_layout

\end_inset

A list of pairs can be converted to a dictionary using the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toMap
\end_layout

\end_inset

.
 The same method works for other collection types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vector
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toSeq
\end_layout

\end_inset

 converts a dictionary into a sequence of pairs:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map("apples" -> 3, "oranges" -> 2, "pears" -> 0).toSeq
\end_layout

\begin_layout Plain Layout

res20: Seq[(String, Int)] = ArrayBuffer((apples,3), (oranges,2), (pears,0))
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ArrayBuffer
\end_layout

\end_inset

 is one of the many list-like data structures in the Scala library.
 All these data structures are gathered under the common 
\begin_inset Quotes eld
\end_inset

sequence
\begin_inset Quotes erd
\end_inset

 type called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

.
 The methods defined in the Scala standard library sometimes return different
 implementations of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 type for reasons of performance.
\end_layout

\begin_layout Standard
The standard library has several useful methods that use tuple types, such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 (with dictionaries), 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zipWithIndex
\end_layout

\end_inset

.
 The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.groupBy
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sliding
\end_layout

\end_inset

 also work with most collection types, including dictionaries and sets.
 It is important to become familiar with these methods, because it will
 help writing code that uses sequences, sets, and dictionaries.
 Let us now look at these methods one by one.
\end_layout

\begin_layout Paragraph*
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toMap
\end_layout

\end_inset

 methods
\end_layout

\begin_layout Standard
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:1-Values,-types,-expressions,"
plural "false"
caps "false"
noprefix "false"

\end_inset

 showed how the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method works on sequences: the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.map(f)
\end_layout

\end_inset

 applies a given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to each element of the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

, gathering the results in a new sequence.
 In this sense, we can say that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method 
\begin_inset Quotes eld
\end_inset

iterates over
\begin_inset Quotes erd
\end_inset

 sequences.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method works similarly on dictionaries, except that iterating over a dictionary
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[K, V]
\end_layout

\end_inset

 when applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 looks like iterating over a sequence of 
\emph on
pairs
\emph default
, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(K,V)]
\end_layout

\end_inset

.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

d:Map[K,V]
\end_layout

\end_inset

 is a dictionary, the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

d.map(f)
\end_layout

\end_inset

 must be a function operating on tuples of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(K,V)
\end_layout

\end_inset

.
 Typically, such functions are written using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val m1 = Map("apples" -> 3, "pears" -> 2, "lemons" -> 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> m1.map { case (fruit, count) => count * 2 }
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = ArrayBuffer(6, 4, 0)
\end_layout

\end_inset

If we want to transform a dictionary into another dictionary, we can first
 create a sequence of pairs and then convert it to a dictionary with the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toMap
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> m1.map { case (fruit, count) => (fruit, count * 2) }.toMap
\end_layout

\begin_layout Plain Layout

res1: Map[String,Int] = Map(apples -> 6, pears -> 4, lemons -> 0)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 method 
\end_layout

\begin_layout Standard
works on dictionaries by iterating on key/value pairs.
 The filtering predicate must be a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((K, V)) => Boolean
\end_layout

\end_inset

.
 For example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> m1.filter { case (fruit, count) => count > 0 }.toMap
\end_layout

\begin_layout Plain Layout

res2: Map[String,Int] = Map(apples -> 6, pears -> 4)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zipWithIndex
\end_layout

\end_inset

 methods
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

 method takes 
\emph on
two
\emph default
 sequences and produces a sequence of pairs, taking one element from each
 sequence:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3)
\end_layout

\begin_layout Plain Layout

s: List[Int] = List(1, 2, 3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val t = List(true, false, true)
\end_layout

\begin_layout Plain Layout

t: List[Boolean] = List(true, false, true)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s.zip(t)
\end_layout

\begin_layout Plain Layout

res3: List[(Int, Boolean)] = List((1,true), (2,false), (3,true))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s zip t
\end_layout

\begin_layout Plain Layout

res4: List[(Int, Boolean)] = List((1,true), (2,false), (3,true)) 
\end_layout

\end_inset

In the last line, the equivalent 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 infix syntax (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s zip t
\end_layout

\end_inset

) is shown just to illustrate the flexibility of syntax conventions in Scala.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

 method works equally well on dictionaries: in that case, dictionaries are
 automatically converted to sequences of tuples before applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zipWithIndex
\end_layout

\end_inset

 method transforms a sequence into a sequence of pairs, where the second
 part of the pair is the zero-based index:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List("a", "b", "c").zipWithIndex
\end_layout

\begin_layout Plain Layout

res5: List[(String, Int)] = List((a,0), (b,1), (c,2)) 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 method
\end_layout

\begin_layout Standard
converts nested sequences to 
\begin_inset Quotes eld
\end_inset

flattened
\begin_inset Quotes erd
\end_inset

 ones:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(List(1, 2), List(2, 3), List(3, 4)).flatten
\end_layout

\begin_layout Plain Layout

res6: List[Int] = List(1, 2, 2, 3, 3, 4)
\end_layout

\end_inset

The 
\begin_inset Quotes eld
\end_inset

flattening
\begin_inset Quotes erd
\end_inset

 operation computes the concatenation of all inner sequences.
 In Scala, sequences are concatenated using the operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

++
\end_layout

\end_inset

, e.g.:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3) ++ List(4, 5, 6) ++ List(0)
\end_layout

\begin_layout Plain Layout

res7: List[Int] = List(1, 2, 3, 4, 5, 6, 0)
\end_layout

\end_inset

So the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 method inserts the operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

++
\end_layout

\end_inset

 between all the inner sequences.
\end_layout

\begin_layout Standard
Keep in mind that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 removes 
\emph on
only one
\emph default
 level of nesting, which is at the 
\begin_inset Quotes eld
\end_inset

outside
\begin_inset Quotes erd
\end_inset

 of the data structure.
 If applied to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[List[Int]]]
\end_layout

\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 method returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[Int]]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(List(List(1), List(2)), List(List(2), List(3))).flatten
\end_layout

\begin_layout Plain Layout

res8: List[List[Int]] = List(List(1), List(2), List(2), List(3))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 method
\end_layout

\begin_layout Standard
is closely related to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 and can be seen as a shortcut, equivalent to first applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 and then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1,2,3,4).map(n => (1 to n).toList)
\end_layout

\begin_layout Plain Layout

res9: List[List[Int]] = List(List(1), List(1, 2), List(1, 2, 3), List(1,
 2, 3, 4))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> List(1,2,3,4).map(n => (1 to n).toList).flatten
\end_layout

\begin_layout Plain Layout

res10: List[Int] = List(1, 1, 2, 1, 2, 3, 1, 2, 3, 4)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> List(1,2,3,4).flatMap(n => (1 to n).toList)
\end_layout

\begin_layout Plain Layout

res11: List[Int] = List(1, 1, 2, 1, 2, 3, 1, 2, 3, 4)
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 operation transforms a sequence by mapping each element to a potentially
 different number of new elements.
\end_layout

\begin_layout Standard
At first sight, it may be unclear why 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 is useful.
 (Should we perhaps combine 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 into a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatFilter
\end_layout

\end_inset

, or combine 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 into a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatZip
\end_layout

\end_inset

?) However, we will see later in this book that the use of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, which is related to 
\begin_inset Quotes eld
\end_inset

monads
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
monads
\end_layout

\end_inset

, is one of the most versatile and powerful design patterns in functional
 programming.
 In this chapter, several examples and exercises will illustrate the use
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 for working on sequences.
\end_layout

\begin_layout Paragraph*
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.groupBy
\end_layout

\end_inset

 method
\end_layout

\begin_layout Standard
rearranges a sequence into a dictionary where some elements of the original
 sequence are grouped together into subsequences.
 For example, given a sequence of words, we can group all words that start
 with the letter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 into one subsequence, and all other words into another subsequence.
 This is accomplished by the following code,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(
\begin_inset Quotes eld
\end_inset

wombat
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

xanthan
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

yoghurt
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

zebra
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Plain Layout

  groupBy(s => if (s startsWith 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

) 1 else 2)
\end_layout

\begin_layout Plain Layout

res12: Map[Int,Seq[String]] = Map(1 -> List(yoghurt), 2 -> List(wombat,
 xanthan, zebra))
\end_layout

\end_inset

The argument of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.groupBy
\end_layout

\end_inset

 method is a 
\emph on
function
\emph default
 that computes a 
\begin_inset Quotes eld
\end_inset

key
\begin_inset Quotes erd
\end_inset

 out of each sequence element.
 The key can have an arbitrarily chosen type.
 (In the current example, that type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.) The result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.groupBy
\end_layout

\end_inset

 is a dictionary that maps each key to the sub-sequence of values that have
 that key.
 (In the current example, the type of the dictionary is therefore 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Int, Seq[String]]
\end_layout

\end_inset

.) The order of elements in the sub-sequences remains the same as in the
 original sequence.
\end_layout

\begin_layout Standard
As another example of using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.groupBy
\end_layout

\end_inset

, the following code will group together all numbers that have the same
 remainder after division by 
\begin_inset Formula $3$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1,2,3,4,5).groupBy(k => k % 3)
\end_layout

\begin_layout Plain Layout

res13: Map[Int,List[Int]] = Map(2 -> List(2, 5), 1 -> List(1, 4), 0 -> List(3))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sliding
\end_layout

\end_inset

 method
\end_layout

\begin_layout Standard
creates a sliding window of a given width and returns a sequence of nested
 sequences:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).sliding(4).toList
\end_layout

\begin_layout Plain Layout

res14: List[IndexedSeq[Int]] = List(Vector(1, 2, 3, 4), Vector(2, 3, 4,
 5), Vector(3, 4, 5, 6), Vector(4, 5, 6, 7), Vector(5, 6, 7, 8), Vector(6,
 7, 8, 9), Vector(7, 8, 9, 10))
\end_layout

\end_inset

Usually, this method is used together with an aggregation operation on the
 inner sequences.
 For example, the following code computes a sliding-window average with
 window width 
\begin_inset Formula $50$
\end_inset

 over an array of 
\begin_inset Formula $100$
\end_inset

 numbers:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 100).map(x => math.cos(x)).sliding(50).
\end_layout

\begin_layout Plain Layout

  map(_.sum / 50).take(5).toList
\end_layout

\begin_layout Plain Layout

res15: List[Double] = List(-0.005153079196990285, -0.0011160413780774369,
 0.003947079736951305, 0.005381273944717851, 0.0018679497047270743)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sortBy
\end_layout

\end_inset

 method
\end_layout

\begin_layout Standard
sorts a sequence according to a sorting key.
 The argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sortBy
\end_layout

\end_inset

 is a 
\emph on
function
\emph default
 that computes the sorting key from a sequence element.
 In this way, we can sort elements in an arbitrary way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1, 2, 3).sortBy(x => -x)
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(3, 2, 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(
\begin_inset Quotes eld
\end_inset

z
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

xxx
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

yy
\begin_inset Quotes erd
\end_inset

).sortBy(word => word)
\end_layout

\begin_layout Plain Layout

res1: Seq[String] = List("xxx", "yy", "z")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(
\begin_inset Quotes eld
\end_inset

z
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

xxx
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

yy
\begin_inset Quotes erd
\end_inset

).sortBy(word => word.length)
\end_layout

\begin_layout Plain Layout

res2: Seq[String] = List("z", "yy", "xxx")
\end_layout

\end_inset

Sorting by the elements themselves, as we have done here with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sortBy(word => word)
\end_layout

\end_inset

, is only possible if the element's type has a well-defined ordering.
 For strings, this is the alphabetic ordering, and for integers, the standard
 arithmetic ordering.
 For such types, a convenience method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sorted
\end_layout

\end_inset

 is defined, and works equivalently to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sortBy(x => x)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(
\begin_inset Quotes eld
\end_inset

z
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

xxx
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

yy
\begin_inset Quotes erd
\end_inset

).sorted
\end_layout

\begin_layout Plain Layout

res3: Seq[String] = List("xxx", "yy", "z")
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solved examples: Tuples and collections
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "enu:tuples-Example1-for"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "enu:tuples-Example1-for"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given sequence 
\begin_inset Formula $x_{i}$
\end_inset

, compute the sequence of pairs 
\begin_inset Formula $b_{i}=\left(\cos x_{i},\sin x_{i}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, assume 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs:Seq[Double]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution: 
\end_layout

\begin_layout Standard
We need to produce a sequence that has a pair of values corresponding to
 each element of the original sequence.
 This transformation is exactly what the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method does.
 So the code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xs.map { x => (math.cos(x), math.sin(x)) }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "enu:tuples-Example2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "enu:tuples-Example2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Count how many times 
\begin_inset Formula $\cos x_{i}>\sin x_{i}$
\end_inset

 occurs in a sequence 
\begin_inset Formula $x_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.count
\end_layout

\end_inset

, assume 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs:Seq[Double]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution: 
\end_layout

\begin_layout Standard
The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.count
\end_layout

\end_inset

 takes a predicate and returns the number of times the predicate was 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 while evaluated on the elements of the sequence:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xs.count { x => math.cos(x) > math.sin(x) }
\end_layout

\end_inset

We could also reuse the solution of Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "enu:tuples-Example1-for"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that computed the cosine and the sine values.
 The code would then become
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xs.map { x => (math.cos(x), math.sin(x)) }
\end_layout

\begin_layout Plain Layout

  .count { case (cosine, sine) => cosine > sine }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "enu:tuples-Example3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "enu:tuples-Example3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For given sequences 
\begin_inset Formula $a_{i}$
\end_inset

 and 
\begin_inset Formula $b_{i}$
\end_inset

, compute the sequence of differences 
\begin_inset Formula $c_{i}=a_{i}-b_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, and assume 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

as
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bs
\end_layout

\end_inset

 are of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Double]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution: 
\end_layout

\begin_layout Standard
We can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

 on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

as
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bs
\end_layout

\end_inset

, which gives a sequence of pairs,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

as.zip(bs) : Seq[(Double, Double)]
\end_layout

\end_inset

We then compute the differences 
\begin_inset Formula $a_{i}-b_{i}$
\end_inset

 by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 to this sequence:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

as.zip(bs).map { case (a, b) => a - b }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "enu:tuples-Example4-in"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "enu:tuples-Example4-in"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
In a given sequence 
\begin_inset Formula $p_{i}$
\end_inset

, count how many times 
\begin_inset Formula $p_{i}>p_{i+1}$
\end_inset

 occurs.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.tail
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
Given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps:Seq[Double]
\end_layout

\end_inset

, we can compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps.tail
\end_layout

\end_inset

.
 The result is a sequence that is 
\begin_inset Formula $1$
\end_inset

 element shorter than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps
\end_layout

\end_inset

, for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val ps = Seq(1,2,3,4)
\end_layout

\begin_layout Plain Layout

ps: Seq[Int] = List(1, 2, 3, 4)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> ps.tail
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(2, 3, 4)
\end_layout

\end_inset

Taking a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

 of the two sequences 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps.tail
\end_layout

\end_inset

, we get a sequence of pairs:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ps.zip(ps.tail)
\end_layout

\begin_layout Plain Layout

res1: Seq[(Int, Int)] = List((1,2), (2,3), (3,4))
\end_layout

\end_inset

Note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps.tail
\end_layout

\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 element shorter than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps
\end_layout

\end_inset

, and the resulting sequence of pairs is also 
\begin_inset Formula $1$
\end_inset

 element shorter than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps
\end_layout

\end_inset

.
 In other words, it is not necessary to truncate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps
\end_layout

\end_inset

 before computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps.zip(ps.tail)
\end_layout

\end_inset

.
 Now apply the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.count
\end_layout

\end_inset

 method:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ps.zip(ps.tail).count { case (a, b) => a > b }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given 
\begin_inset Formula $k>0$
\end_inset

, compute the sequence 
\begin_inset Formula $c_{i}=\max(b_{i-k},...,b_{i+k})$
\end_inset

.
\end_layout

\begin_layout Standard
Hint:  use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sliding
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
Applying the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sliding
\end_layout

\end_inset

 method to a list gives a list of nested lists:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val bs = List(1, 2, 3, 4, 5)
\end_layout

\begin_layout Plain Layout

bs: List[Int] = List(1, 2, 3, 4, 5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> bs.sliding(3).toList
\end_layout

\begin_layout Plain Layout

res0: List[List[Int]] = List(List(1, 2, 3), List(2, 3, 4), List(3, 4, 5))
 
\end_layout

\end_inset

For each 
\begin_inset Formula $b_{i}$
\end_inset

, we need to obtain a list of 
\begin_inset Formula $2k+1$
\end_inset

 nearby elements 
\begin_inset Formula $\left(b_{i-k},...,b_{i+k}\right)$
\end_inset

.
 So we need to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sliding(2*k+1)
\end_layout

\end_inset

 to obtain a window of the required size.
 Now we can compute the maximum of each of the nested lists by using the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method on the outer list, with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

 method applied to the nested lists.
 So the argument of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method must be the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nested => nested.max
\end_layout

\end_inset

.
 The final code is
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

bs.sliding(2 * k + 1).map(nested => nested.max)
\end_layout

\end_inset

In Scala, this code can be written more concisely using the syntax
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

bs.sliding(2 * k + 1).map(_.max)
\end_layout

\end_inset

because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.max
\end_layout

\end_inset

 means the nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x.max
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Create a 
\begin_inset Formula $10\times10$
\end_inset

 multiplication table as a dictionary of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[(Int, Int), Int]
\end_layout

\end_inset

.
 For example, a 
\begin_inset Formula $3\times3$
\end_inset

 multiplication table would be given by this dictionary,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Map( (1, 1) -> 1, (1, 2) -> 2, (1, 3) -> 3, (2, 1) -> 2,
\end_layout

\begin_layout Plain Layout

  (2, 2) -> 4, (2, 3) -> 6, (3, 1) -> 3, (3, 2) -> 6, (3, 3) -> 9 )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution: 
\end_layout

\begin_layout Standard
We are required to make a dictionary that maps pairs of integers 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x * y
\end_layout

\end_inset

.
 Begin by creating the list of 
\emph on
keys
\emph default
 for that dictionary, which must be a list of pairs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

 of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List((1,1), (1,2), ..., (2,1), (2,2), ...)
\end_layout

\end_inset

.
 We need to start with a sequence of values of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, and for each 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 from that sequence, iterate over another sequence to provide values for
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

.
 Try this computation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).map(x => List(1, 2, 3))
\end_layout

\begin_layout Plain Layout

s: List[List[Int]] = List(List(1, 2, 3), List(1, 2, 3), List(1, 2, 3))
\end_layout

\end_inset

We would like to get 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List((1,1), (1,2), 1,3))
\end_layout

\end_inset

 etc., and so we use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 on the inner list with a nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y => (x, y)
\end_layout

\end_inset

 that converts a number into a tuple,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3).map{ y => (x, y) }
\end_layout

\begin_layout Plain Layout

res0: List[(Int, Int)] = List((1,1), (1,2), (1,3))
\end_layout

\end_inset

Here the curly braces 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ y => (x, y) }
\end_layout

\end_inset

 are used only for clarity; we could equivalently use parentheses and write
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(y => (x, y))
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Using this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 operation, we obtain the code for a nested list of tuples:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).map(x => List(1, 2, 3).map{ y => (x, y) })
\end_layout

\begin_layout Plain Layout

s: List[List[(Int, Int)]] = List(List((1,1), (1,2), (1,3)), List((2,1),
 (2,2), (2,3)), List((3,1), (3,2), (3,3)))
\end_layout

\end_inset

This is almost what we need, except that the nested lists need to be concatenate
d into a single list.
 This is exactly what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 does:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).map(x => List(1, 2, 3).map{ y => (x, y) }).flatten
\end_layout

\begin_layout Plain Layout

s: List[(Int, Int)] = List((1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1),
 (3,2), (3,3))
\end_layout

\end_inset

It is shorter to write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap(...)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map(...).flatten
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).flatMap(x => List(1, 2, 3).map{ y => (x, y) })
\end_layout

\begin_layout Plain Layout

s: List[(Int, Int)] = List((1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1),
 (3,2), (3,3)) 
\end_layout

\end_inset

This is the list of keys for the required dictionary, which should map each
 
\emph on
pair
\emph default
 of integers 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x,y)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x*y
\end_layout

\end_inset

.
 In Scala, a dictionary is usually created by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toMap
\end_layout

\end_inset

 to a sequence of pairs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(key,value)
\end_layout

\end_inset

.
 So we need to create a sequence of nested tuples of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((x,y), product)
\end_layout

\end_inset

.
 To achieve this, we use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 with a function that computes the product and creates a nested tuple:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).flatMap(x => List(1, 2, 3).
\end_layout

\begin_layout Plain Layout

  map{ y => (x, y) }).map{ case (x, y) => ((x, y), x * y) }
\end_layout

\begin_layout Plain Layout

s: List[((Int, Int), Int)] = List(((1,1),1), ((1,2),2), ((1,3),3), ((2,1),2),
 ((2,2),4), ((2,3),6), ((3,1),3), ((3,2),6), ((3,3),9))
\end_layout

\end_inset

We can simplify this code if we notice that we are first mapping each 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 to a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

, and later map each tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x,y)
\end_layout

\end_inset

 to a nested tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((x,y), x*y)
\end_layout

\end_inset

.
 Instead, the entire computation can be done in the inner 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 operation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).flatMap(x => List(1, 2, 3).
\end_layout

\begin_layout Plain Layout

  map{ y => ((x,y), x*y) })
\end_layout

\begin_layout Plain Layout

s: List[((Int, Int), Int)] = List(((1,1),1), ((1,2),2), ((1,3),3), ((2,1),2),
 ((2,2),4), ((2,3),6), ((3,1),3), ((3,2),6), ((3,3),9))
\end_layout

\end_inset

It remains to convert this list of tuples to a dictionary with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toMap
\end_layout

\end_inset

.
 Also, for better readability, we can use Scala's pair syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

key -> value
\end_layout

\end_inset

, which is completely equivalent to writing the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(key,value)
\end_layout

\end_inset

.
 The final code is
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to 10).flatMap(x => (1 to 10).map{ y => (x,y) -> x*y }).toMap
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given sequence 
\begin_inset Formula $x_{i}$
\end_inset

, compute the maximum of all of the numbers 
\begin_inset Formula $x_{i}$
\end_inset

, 
\begin_inset Formula $\cos x_{i}$
\end_inset

, 
\begin_inset Formula $\sin x_{i}$
\end_inset

.
 Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
We will compute the required value if we take 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

 of a list containing all of the numbers.
 To do that, first map each element of the list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs:Seq[Double]
\end_layout

\end_inset

 into a sequence of three numbers:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(0.1, 0.5, 0.9)
\end_layout

\begin_layout Plain Layout

res0: List[Double] = List(0.1, 0.5, 0.9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> res0.map{ x => Seq(x, math.cos(x), math.sin(x)) }
\end_layout

\begin_layout Plain Layout

res1: List[Seq[Double]] = List(List(0.1, 0.9950041652780258, 0.09983341664682815),
 List(0.5, 0.8775825618903728, 0.479425538604203), List(0.9, 0.6216099682706644,
 0.7833269096274834))
\end_layout

\end_inset

This list is almost what we need, except we need to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> res1.flatten
\end_layout

\begin_layout Plain Layout

res2: List[Double] = List(0.1, 0.9950041652780258, 0.09983341664682815, 0.5,
 0.8775825618903728, 0.479425538604203, 0.9, 0.6216099682706644, 0.7833269096274834)
\end_layout

\end_inset

Now we just need to take the maximum of the resulting numbers:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> res2.max
\end_layout

\begin_layout Plain Layout

res3: Double = 0.9950041652780258
\end_layout

\end_inset

The final code (starting from a given sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

) is
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xs.flatMap{ x => Seq(x, math.cos(x), math.sin(x)) }.max
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
From a dictionary of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[String, String]
\end_layout

\end_inset

 mapping names to addresses, and assuming that the addresses do not repeat,
 compute a dictionary of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[String, String]
\end_layout

\end_inset

 mapping the addresses back to names.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
Keep in mind that iterating over a dictionary looks like iterating over
 a list of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(key, value)
\end_layout

\end_inset

 pairs, and use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 to reverse each pair:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

dict.map{ case (name, addr) => (addr, name) }.toMap
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the solution of Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example8"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a function with type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Name
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Addr
\end_layout

\end_inset

 instead of the fixed type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
In Scala, the syntax for type parameters in a function definition is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def rev[Name, Addr](...) = ...
\end_layout

\end_inset

The type of the argument is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Name, Addr]
\end_layout

\end_inset

, while the type of the result is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Addr, Name]
\end_layout

\end_inset

.
 So we use the type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Name
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Addr
\end_layout

\end_inset

 in the type signature of the function.
 The final code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def rev[Name, Addr](dict: Map[Name, Addr]): Map[Addr, Name] =
\end_layout

\begin_layout Plain Layout

  dict.map { case (name, addr) => (addr, name) }.toMap
\end_layout

\end_inset

The body of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rev
\end_layout

\end_inset

 remains the same as in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example8"
plural "false"
caps "false"
noprefix "false"

\end_inset

; only the type signature changed.
 This is because the procedure for reversing a dictionary works in the same
 way for dictionaries of any type.
 So the body of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rev
\end_layout

\end_inset

 does not actually need to know the types of the keys and values in the
 dictionary.
 For this reason, it was easy for us to change the specific types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

) into type parameters in this function.
\end_layout

\begin_layout Standard
When the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rev
\end_layout

\end_inset

 is applied to a dictionary of a specific type, the Scala compiler will
 automatically set the type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Name
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Addr
\end_layout

\end_inset

 that fit the required types of the dictionary's keys and values.
 For example, if we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rev
\end_layout

\end_inset

 to a dictionary of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Boolean, Seq[String]]
\end_layout

\end_inset

, the type parameters will be set automatically as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Name = Boolean
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Addr = Seq[String]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val d = Map(true -> Seq("x", "y"), false -> Seq("z", "t"))
\end_layout

\begin_layout Plain Layout

d: Map[Boolean, Seq[String]] = Map(true -> List(x, y), false -> List(z,
 t))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> rev(d)
\end_layout

\begin_layout Plain Layout

res0: Map[Seq[String], Boolean] = Map(List(x, y) -> true, List(z, t) ->
 false)
\end_layout

\end_inset

Type parameters can be also set explicitly when using the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rev
\end_layout

\end_inset

.
 If the type parameters are chosen incorrectly, the program will not compile:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> rev[Boolean, Seq[String]](d)
\end_layout

\begin_layout Plain Layout

res1: Map[Seq[String],Boolean] = Map(List(x, y) -> true, List(z, t) -> false)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> rev[Int, Double](d)
\end_layout

\begin_layout Plain Layout

<console>:14: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : Map[Boolean,Seq[String]]
\end_layout

\begin_layout Plain Layout

 required: Map[Int,Double]
\end_layout

\begin_layout Plain Layout

       rev[Int, Double](d)
\end_layout

\begin_layout Plain Layout

                        ^
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example10"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Given a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

words:Seq[String]
\end_layout

\end_inset

 of words, compute a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[ (Seq[String], Int) ]
\end_layout

\end_inset

, where each inner sequence contains all the words having the same length,
 paired with the integer value showing that length.
 So, the input 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(
\begin_inset Quotes eld
\end_inset

the
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

food
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 should produce the output 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Seq( (Seq(
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

), 2), (Seq(
\begin_inset Quotes eld
\end_inset

the
\begin_inset Quotes erd
\end_inset

), 3), (Seq(
\begin_inset Quotes eld
\end_inset

food
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

), 4) )
\end_layout

\end_inset

The resulting sequence must be ordered by increasing length of words.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
It is clear that we need to begin by grouping the words by length.
 The library method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.groupBy
\end_layout

\end_inset

 takes a function that computes a grouping key from each element of a sequence.
 In our case, we need to group by word length, which is computed with the
 method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.length
\end_layout

\end_inset

 if applied to a string.
 So the first step is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words.groupBy{ word => word.length }
\end_layout

\end_inset

or, more concisely, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

words.groupBy(_.length)
\end_layout

\end_inset

.
 The result of this expression is a dictionary that maps each length to
 the list of words having that length:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> words.groupBy(_.length)
\end_layout

\begin_layout Plain Layout

res0: scala.collection.immutable.Map[Int,Seq[String]] = Map(2 -> List(is),
 4 -> List(food, good), 3 -> List(the))
\end_layout

\end_inset

This is already close to what we need.
 If we convert this dictionary to a sequence, we will get a list of pairs
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> words.groupBy(_.length).toSeq
\end_layout

\begin_layout Plain Layout

res1: Seq[(Int, Seq[String])] = ArrayBuffer((2,List(is)), (4,List(food,
 good)), (3,List(the))) 
\end_layout

\end_inset

It remains to swap the length and the list of words and to sort the result
 by increasing length.
 We can do this in any order: first sort, then swap; or first swap, then
 sort.
 The final code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words
\end_layout

\begin_layout Plain Layout

  .groupBy(_.length)
\end_layout

\begin_layout Plain Layout

  .toSeq
\end_layout

\begin_layout Plain Layout

  .sortBy { case (len, words) => len }
\end_layout

\begin_layout Plain Layout

  .map { case (len, words) => (words, len) }
\end_layout

\end_inset

This code can be written somewhat shorter if we use the syntax _._1 for selecting
 the first part of the tuple, and .swap for swapping the two elements of
 the pair:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words.groupBy(_.length).toSeq.sortBy(_._1).map(_.swap)
\end_layout

\end_inset

However, the program may now be harder to read and to modify.
\end_layout

\begin_layout Subsection
Reasoning about types of sequences
\end_layout

\begin_layout Standard
In Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example10"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we have applied a chain of operations to a sequence.
 Let us add comments showing the type of the intermediate result after each
 operation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words // Seq[String]
\end_layout

\begin_layout Plain Layout

  .groupBy(_.length) // Map[Int, Seq[String]]
\end_layout

\begin_layout Plain Layout

  .toSeq // Seq[ (Int, Seq[String]) ]
\end_layout

\begin_layout Plain Layout

  .sortBy { case (len, words) => len } // Seq[ (Int, Seq[String]) ]
\end_layout

\begin_layout Plain Layout

  .map { case (len, words) => (words, len) } // Seq[ (Seq[String], Int) ]
\end_layout

\end_inset

In computations like this, the Scala compiler verifies at each step that
 the operations are applied to values of the correct type.
\end_layout

\begin_layout Standard
For instance, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sortBy
\end_layout

\end_inset

 is defined for sequences but not for dictionaries, so it would be a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

type error to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sortBy
\end_layout

\end_inset

 to a dictionary without first converting it to a sequence using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toSeq
\end_layout

\end_inset

.
 The type of the intermediate result after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toSeq
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[ (Int, Seq[String]) ]
\end_layout

\end_inset

, and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sortBy
\end_layout

\end_inset

 operation is applied to that sequence.
 So the sequence element matched by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case (len, words) => len }
\end_layout

\end_inset

 is a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Seq[String])
\end_layout

\end_inset

, which means that the pattern variables 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

len
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

words
\end_layout

\end_inset

 must have types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[String]
\end_layout

\end_inset

 respectively.
 It would be a type error to use the sorting key function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case (len, words) => words }
\end_layout

\end_inset

: the sorting key can be an integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

len
\end_layout

\end_inset

, but not a string sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

words
\end_layout

\end_inset

 (because sorting by string sequences is not defined).
\end_layout

\begin_layout Standard
If we visualize how the type of the sequence should change at every step,
 we can more quickly understand how to implement the required task.
 Begin by writing down the intermediate types that would be needed during
 the computation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words: Seq[String] // Need to group by word length.
\end_layout

\begin_layout Plain Layout

Map[Int, Seq[String]]  // Need to sort by word length; can't sort a dictionary!
\end_layout

\begin_layout Plain Layout

// Need to convert this dictionary to a sequence:
\end_layout

\begin_layout Plain Layout

Seq[ (Int, Seq[String]) ] // Now sort this! Sorting does not change the
 type.
\end_layout

\begin_layout Plain Layout

// It remains to swap the parts of all tuples in the sequence:
\end_layout

\begin_layout Plain Layout

Seq[ (Seq[String], Int) ] // We are done.
\end_layout

\end_inset

Having written down these types, we are better assured that the computation
 can be done correctly.
 Writing the code becomes straightforward, since we are guided by the already
 known types of the intermediate results:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words.groupBy(_.length).toSeq.sortBy(_._1).map(_.swap)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example illustrates the main benefits of reasoning about types: it
 gives direct guidance about how to organize the computation, together with
 a greater assurance in the correctness of the code.
\end_layout

\begin_layout Subsection
Exercises: Tuples and collections
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find all pairs 
\begin_inset Formula $i,j$
\end_inset

 within 
\begin_inset Formula $\left(0,1,...,9\right)$
\end_inset

 such that 
\begin_inset Formula $i+4*j>i*j$
\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Same task as in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, but for 
\begin_inset Formula $i,j,k$
\end_inset

 and the condition 
\begin_inset Formula $i+4*j+9*k>i*j*k$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given two sequences 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: Seq[String]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q: Seq[Boolean]
\end_layout

\end_inset

 of equal length, compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[String]
\end_layout

\end_inset

 with those elements of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 for which the corresponding element of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Convert a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Int]
\end_layout

\end_inset

 into a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(Int, Boolean)]
\end_layout

\end_inset

 where the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 value is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 when the element is followed by a larger value.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(1,3,2,4)
\end_layout

\end_inset

 is to be converted into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq((1,true),(3,false),(2,true),(4,false))
\end_layout

\end_inset

.
 (The last element, 4, has no following element.)
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: Seq[String]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q: Seq[Int]
\end_layout

\end_inset

 of equal length, and assuming that elements of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 do not repeat, compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Int, String]
\end_layout

\end_inset

 that maps numbers from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 to their corresponding strings from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the solution of Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a function with type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q
\end_layout

\end_inset

 instead of the fixed types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 Test it with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = Boolean
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q = Set[Int]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: Seq[String]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q: Seq[Int]
\end_layout

\end_inset

 of equal length, compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[String]
\end_layout

\end_inset

 that contains the strings from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 ordered according to the corresponding numbers from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

.
 For example, if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p = Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q = Seq(10, -1, 5)
\end_layout

\end_inset

 then the result must be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the solution of Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-7"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a function with type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 instead of the fixed type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reorder[S](p: Seq[S], q: Seq[Int]): Seq[S] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> reorder(Seq(6.0,2.0,8.0,4.0), Seq(20,10,40,30))
\end_layout

\begin_layout Plain Layout

res0: Seq[Double] = List(2.0, 6.0, 4.0, 8.0)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(String, Int)]
\end_layout

\end_inset

 showing a list of purchased items (where item names may repeat), compute
 a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[String, Int]
\end_layout

\end_inset

 showing the total counts: e.g.
\begin_inset space ~
\end_inset

for the input 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Seq((
\begin_inset Quotes eld
\end_inset

apple
\begin_inset Quotes erd
\end_inset

, 2), (
\begin_inset Quotes eld
\end_inset

pear
\begin_inset Quotes erd
\end_inset

, 3), (
\begin_inset Quotes eld
\end_inset

apple
\begin_inset Quotes erd
\end_inset

, 5))
\end_layout

\end_inset

the output must be 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Map(
\begin_inset Quotes eld
\end_inset

apple
\begin_inset Quotes erd
\end_inset

 -> 7, 
\begin_inset Quotes eld
\end_inset

pear
\begin_inset Quotes erd
\end_inset

 -> 3)
\end_layout

\end_inset

Implement this computation as a function with type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.groupBy
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[List[Int]]
\end_layout

\end_inset

, compute a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[List[Int]]
\end_layout

\end_inset

 where each inner list contains 
\emph on
three
\emph default
 largest elements from the initial inner list (or fewer than three if the
 initial inner list is shorter).
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sortBy
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.take
\end_layout

\end_inset

.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

numsLists.map(_.sortBy(-_).take(3))
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-11"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-11"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Given two sets 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p:Set[Int]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q:Set[Int]
\end_layout

\end_inset

, compute a set of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set[(Int, Int)]
\end_layout

\end_inset

 as the Cartesian product of the sets 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

; that is, the set of all pairs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 is from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Implement this computation as a function with type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

I
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

J
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cartesian[I,J](p: Set[I], q: Set[J]): Set[(I, J)] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cartesian(Set(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

), Set(10, 20))
\end_layout

\begin_layout Plain Layout

res0: Set[(String, Int)] = Set((a,10), (a,20), (b,10), (b,20))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 on sets.
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a.flatMap(x => b.map(y => (x, y)))
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-12"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-12"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Map[Person, Amount]]
\end_layout

\end_inset

, showing the amounts various people paid on each day, compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Person, Seq[Amount]]
\end_layout

\end_inset

, showing the sequence of payments for each person.
 Assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Person
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Amount
\end_layout

\end_inset

 are type parameters.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def payments[Person, Amount](data: Seq[Map[Person, Amount]]): Map[Person,
 Seq[Amount]] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> payments(Seq(Map(
\begin_inset Quotes eld
\end_inset

Tarski
\begin_inset Quotes erd
\end_inset

 -> 10, 
\begin_inset Quotes eld
\end_inset

Church
\begin_inset Quotes erd
\end_inset

 -> 20), Map(
\begin_inset Quotes eld
\end_inset

Church
\begin_inset Quotes erd
\end_inset

 -> 100, 
\begin_inset Quotes eld
\end_inset

Gentzen
\begin_inset Quotes erd
\end_inset

 -> 40), Map(
\begin_inset Quotes eld
\end_inset

Tarski
\begin_inset Quotes erd
\end_inset

 -> 50)))
\end_layout

\begin_layout Plain Layout

res0: Map[String, Seq[Int]] = Map(Genzten -> List(40), Church -> List(20,
 100), Tarski -> List(10, 50))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.groupBy
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.mapValues
\end_layout

\end_inset

 on dictionaries.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def payments[Person, Amount](data: Seq[Map[Person, Amount]]): Map[Person,
 Seq[Amount]] = data.flatMap(_.toSeq).groupBy(_._1).mapValues(_.map(_._2))
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Converting a sequence into a single value
\end_layout

\begin_layout Standard
Until this point, we have been working with sequences using methods such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

.
 These techniques are powerful but still insufficient for solving certain
 problems.
\end_layout

\begin_layout Standard
A simple computation that is impossible to do using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 is to compute the sum of a sequence of numbers.
 The standard library method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

 already does this; but we cannot implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

 ourselves by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

.
 These operations always compute 
\emph on
new
\emph default
 
\emph on
sequences
\emph default
, while we need to compute a single value (the sum of all elements) from
 a sequence.
 
\end_layout

\begin_layout Standard
We have seen a few library methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.count
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.length
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

 that compute a single value from a sequence; but we still cannot implement
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

 using these methods.
 What we need is a more general way of converting a sequence to a single
 value, such that we could ourselves implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.count
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

, and other similar computations.
\end_layout

\begin_layout Standard
Another task not solvable with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

, etc., is to compute a floating-point number from a given sequence of decimal
 digits (including a 
\begin_inset Quotes eld
\end_inset

dot
\begin_inset Quotes erd
\end_inset

 character):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsToDouble(ds: Seq[Char]): Double = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsToDouble(Seq('2', '0', '4', '.', '5'))
\end_layout

\begin_layout Plain Layout

res0: Double = 204.5
\end_layout

\end_inset

Why is it impossible to implement this function using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

 and other methods we have seen so far? In fact, the same task for 
\emph on
integer
\emph default
 numbers (not for floating-point numbers) is solvable using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.length
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsToInt(ds: Seq[Int]): Int = {
\end_layout

\begin_layout Plain Layout

  val n = ds.length
\end_layout

\begin_layout Plain Layout

  // Compute a sequence of powers of 10, e.g.
 [1000, 100, 100, 1]
\end_layout

\begin_layout Plain Layout

  val powers: Seq[Int] = (0 to n-1).map(k => math.pow(10, n-1-k).toInt)
\end_layout

\begin_layout Plain Layout

  // Sum the powers of 10 with coefficients from `ds`.
\end_layout

\begin_layout Plain Layout

  (ds zip powers).map { case (d, p) => d * p }.sum                       
           
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsToInt(Seq(2,4,0,5))
\end_layout

\begin_layout Plain Layout

res0: Int = 2405
\end_layout

\end_inset

The computation can be written as the formula
\begin_inset Formula 
\[
r=\sum_{k=0}^{n-1}d_{k}*10^{n-1-k}\quad.
\]

\end_inset

The sequence of powers of 
\begin_inset Formula $10$
\end_inset

 can be computed separately and 
\begin_inset Quotes eld
\end_inset

zipped
\begin_inset Quotes erd
\end_inset

 with the sequence of digits 
\begin_inset Formula $d_{k}$
\end_inset

.
 However, for floating-point numbers, the sequence of powers of 
\begin_inset Formula $10$
\end_inset

 depends on the position of the 
\begin_inset Quotes eld
\end_inset

dot
\begin_inset Quotes erd
\end_inset

 character.
 Methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

 cannot compute a sequence whose next elements are not known in advance
 but depend on previous elements via a custom function.
\end_layout

\begin_layout Subsection
Inductive definitions of aggregation functions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Inductive-definitions-of-aggregation-functions"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Mathematical induction
\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction
\end_layout

\end_inset


\series default
 is a general way of expressing the dependence of next values on previously
 computed values.
 To define a function from sequence to a single value (e.g.
\begin_inset space ~
\end_inset

an aggregation function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f:Seq[Int] => Int
\end_layout

\end_inset

) by using mathematical induction, we need to specify two computations:
\end_layout

\begin_layout Itemize
(
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction!base case
\end_layout

\end_inset


\series default
The 
\series bold
base case
\series default
 of the induction.) We need to specify what value the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 returns for an empty sequence, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq()
\end_layout

\end_inset

.
 If the function is only defined for non-empty sequences, we need to specify
 what the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 returns for a one-element sequence such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x)
\end_layout

\end_inset

, with any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
(
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction!inductive step
\end_layout

\end_inset


\series default
The 
\series bold
inductive step
\series default
.) Assuming that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is already computed for some sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 (the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction!inductive assumption
\end_layout

\end_inset

inductive assumption
\series default
), how to compute the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 for a sequence with one more element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

? The sequence with one more element is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs ++ Seq(x)
\end_layout

\end_inset

.
 So, we need to specify how to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(xs ++ Seq(x))
\end_layout

\end_inset

 assuming that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(xs)
\end_layout

\end_inset

 is already known.
\end_layout

\begin_layout Standard
Once these two computations are specified, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is defined (and can in principle be computed) for an arbitrary input sequence.
 This is how induction works in mathematics, and it works in the same way
 in functional programming.
 With this approach, the inductive definition of the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

 looks like this:
\end_layout

\begin_layout Itemize
The sum of an empty sequence is 
\begin_inset Formula $0$
\end_inset

.
 That is, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq().sum = 0
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
If the result is already known for a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

, and we have a sequence that has one more element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, the new result is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.sum + x
\end_layout

\end_inset

.
 In code, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(xs ++ Seq(x)).sum = xs.sum + x
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The inductive definition of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 is:
\end_layout

\begin_layout Itemize
For an empty sequence of digits, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq()
\end_layout

\end_inset

, the result is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
 This is a convenient base case, even if we never call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 on an empty sequence.
\end_layout

\begin_layout Itemize
If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt(xs)
\end_layout

\end_inset

 is already known for a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 of digits, and we have a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs ++ Seq(x)
\end_layout

\end_inset

 with one more digit 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, then
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

digitsToInt(xs ++ Seq(x)) = digitsToInt(xs) * 10 + x
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us write inductive definitions for methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.length
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.count
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
The length of a sequence:
\end_layout

\begin_deeper
\begin_layout Itemize
for an empty sequence, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq().length = 0
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.length
\end_layout

\end_inset

 is known then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(xs ++ Seq(x)).length = xs.length + 1
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Maximum element of a sequence (undefined for empty sequences):
\end_layout

\begin_deeper
\begin_layout Itemize
for a one-element sequence, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x).max = x
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.max
\end_layout

\end_inset

 is known then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(xs ++ Seq(x)).max = math.max(xs.max, x)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Count the sequence elements satisfying a predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
for an empty sequence, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq().count(p) = 0
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.count(p)
\end_layout

\end_inset

 is known then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(xs ++ Seq(x)).count(p) = xs.count(p) + c
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c = 1
\end_layout

\end_inset

 when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(x) == true
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c = 0
\end_layout

\end_inset

 otherwise
\end_layout

\end_deeper
\begin_layout Standard
There are two main ways of translating mathematical induction into code.
 The first way is to write a recursive function.
 The second way is to use a standard library function, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

.
 Most often it is better to use the standard library functions, but sometimes
 the code is more transparent when using explicit recursion.
 So let us consider each of these ways in turn.
\end_layout

\begin_layout Subsection
Implementing functions by recursion
\end_layout

\begin_layout Standard
A 
\series bold
recursive function
\begin_inset Index idx
status open

\begin_layout Plain Layout
recursive function
\end_layout

\end_inset


\series default
 is any function that calls itself somewhere within its own body.
 The call to itself is the 
\series bold
recursive call
\series default
.
\end_layout

\begin_layout Standard
When the body of a recursive function is evaluated, it may repeatedly call
 itself with different arguments until the result value can be computed
 
\emph on
without
\emph default
 any recursive calls.
 The last recursive call corresponds to the base case of the induction.
 It is an error if the base case is never reached, as in this example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def infiniteLoop(x: Int): Int = infiniteLoop(x+1)
\end_layout

\begin_layout Plain Layout

infiniteLoop: (x: Int)Int
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> infiniteLoop(2) // You will need to press Ctrl-C to stop this.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We translate mathematical induction into code by first writing a condition
 to decide whether we are in the base case or in the inductive step.
 As an example, consider how we would define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

 by recursion.
 The base case returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, and the inductive step returns a value computed from the recursive call:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sum(s: Seq[Int]): Int = if (s == Seq()) 0 else {
\end_layout

\begin_layout Plain Layout

  val x = s.head // To split s = Seq(x) ++ xs, compute x
\end_layout

\begin_layout Plain Layout

  val xs = s.tail //  and xs.
\end_layout

\begin_layout Plain Layout

  sum(prev) + next // Call sum(...) recursively.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In this example, we use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset

 expression to separate the base case from the inductive step.
 In the inductive step, we split the given sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 into a single-element sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x)
\end_layout

\end_inset

, the 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

, and the remainder (
\begin_inset Quotes eld
\end_inset

tail
\begin_inset Quotes erd
\end_inset

) sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
 So, we split 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s = Seq(x) ++ xs
\end_layout

\end_inset

 rather than as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s = xs ++ Seq(x)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
For computing the sum of a numerical sequence, the order of summation does
 not matter.
 However, the order of operations 
\emph on
will
\emph default
 matter for many other computational tasks.
 We need to choose whether the inductive step should split the sequence
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s = Seq(x) ++ xs
\end_layout

\end_inset

 or as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s = xs ++ Seq(x)
\end_layout

\end_inset

, according to the task at hand.
\end_layout

\begin_layout Standard
Consider the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 according to the inductive definition shown in the previous subsection:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsToInt(s: Seq[Int]): Int = if (s == Seq()) 0 else {
\end_layout

\begin_layout Plain Layout

  val x = s.last  // To split s = xs ++ Seq(x), compute x
\end_layout

\begin_layout Plain Layout

  val xs = s.take(s.length - 1) //  and xs.
\end_layout

\begin_layout Plain Layout

  digitsToInt(xs) * 10 + x // Call digitstoInt(...) recursively.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In this example, it is important to split the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s = xs ++ Seq(x)
\end_layout

\end_inset

 in this order, and not in the order 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x) ++ xs
\end_layout

\end_inset

.
 The reason is that digits increase their numerical value from right to
 left, so we need to multiply the value of the 
\emph on
left
\emph default
 subsequence, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt(xs)
\end_layout

\end_inset

, by 
\begin_inset Formula $10$
\end_inset

, in order to compute the correct result.
\end_layout

\begin_layout Standard
These examples show how mathematical induction is converted into recursive
 code.
 This approach often works but has two technical problems.
 The first problem is that the code will fail due to the 
\begin_inset Quotes eld
\end_inset

stack overflow
\begin_inset Quotes erd
\end_inset

 when the input sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 is long enough.
 In the next subsection, we will see how this problem is solved (at least
 in some cases) using 
\begin_inset Quotes eld
\end_inset

tail recursion
\begin_inset Quotes erd
\end_inset

.
 The second problem is that each inductively defined function repeats the
 code for checking the base case and the code for splitting the sequence
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 into the subsequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 and the extra element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 This repeated common code can be put into a library function, and the Scala
 library provides such functions.
 We will look at using them in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:implementing-generic-aggregation-foldleft"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Tail recursion
\begin_inset CommandInset label
LatexCommand label
name "subsec:Tail-recursion"

\end_inset


\end_layout

\begin_layout Standard
The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

 will fail for large enough sequences.
 To see why, consider an inductive definition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.length
\end_layout

\end_inset

 method as a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def lengthS(s: Seq[Int]): Int =
\end_layout

\begin_layout Plain Layout

  if (s == Seq()) 0
\end_layout

\begin_layout Plain Layout

  else 1 + lengthS(s.tail)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> lengthS((1 to 1000).toList)
\end_layout

\begin_layout Plain Layout

res0: Int = 1000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val s = (1 to 100000).toList
\end_layout

\begin_layout Plain Layout

s: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> lengthS(s)
\end_layout

\begin_layout Plain Layout

java.lang.StackOverflowError
\end_layout

\begin_layout Plain Layout

  at .lengthS(<console>:12)
\end_layout

\begin_layout Plain Layout

  at .lengthS(<console>:12)
\end_layout

\begin_layout Plain Layout

  at .lengthS(<console>:12)
\end_layout

\begin_layout Plain Layout

  at .lengthS(<console>:12)
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset

The problem is not due to insufficient main memory: we 
\emph on
are
\emph default
 able to compute and hold in memory the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

.
 The problem is with the code of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

.
 This function calls itself 
\emph on
inside
\emph default
 an expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 + lengthS(...)
\end_layout

\end_inset

.
 So we can visualize how the computer evaluates this code: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lengthS(Seq(1, 2, ..., 100000))
\end_layout

\begin_layout Plain Layout

  = 1 + lengthS(Seq(2, ..., 100000))
\end_layout

\begin_layout Plain Layout

  = 1 + (1 + lengthS(Seq(3, ..., 100000)))
\end_layout

\begin_layout Plain Layout

  = ...
\end_layout

\end_inset

The function body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

 will evaluate the inductive step, that is, the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 part of the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, about 
\begin_inset Formula $100000$
\end_inset

 times.
 Each time, the sub-expression with nested computations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1+(1+(...))
\end_layout

\end_inset

 will get larger.
 This intermediate sub-expression needs to be held somewhere in memory,
 until at some point the function body goes into the base case and returns
 a value.
 When that happens, the entire intermediate sub-expression will contain
 about 
\begin_inset Formula $100000$
\end_inset

 nested function calls still waiting to be evaluated.
 This sub-expression is held in a special area of memory called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
stack memory
\end_layout

\end_inset

stack memory
\series default
, where the not-yet-evaluated nested function calls are held in the order
 of their calls, as if on a 
\begin_inset Quotes eld
\end_inset

stack
\begin_inset Quotes erd
\end_inset

.
 Due to the way computer memory is managed, the stack memory has a fixed
 size and cannot grow automatically.
 So, when the intermediate expression becomes large enough, it causes an
 overflow of the stack memory, and the program may crash.
\end_layout

\begin_layout Standard
A way to solve this problem is to use a trick called 
\series bold
tail recursion
\begin_inset Index idx
status open

\begin_layout Plain Layout
tail recursion
\end_layout

\end_inset


\series default
.
 Using tail recursion means rewriting the code so that all recursive calls
 occur at the end positions (at the 
\begin_inset Quotes eld
\end_inset

tails
\begin_inset Quotes erd
\end_inset

) of the function body.
 In other words, each recursive call must be 
\emph on
itself
\emph default
 the last computation in the function body.
 Recursive calls cannot be placed inside other computations.
 
\end_layout

\begin_layout Standard
As an example, we can rewrite the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

 in this way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def lengthT(s: Seq[Int], res: Int): Int =
\end_layout

\begin_layout Plain Layout

  if (s == Seq()) res
\end_layout

\begin_layout Plain Layout

  else lengthT(s.tail, 1 + res)
\end_layout

\end_inset

In this code, one of the branches of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset

 returns a fixed value without doing any recursive calls, while the other
 branch returns the result of recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT(...)
\end_layout

\end_inset

.
 In the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

, recursive calls do not occur within sub-expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 + lengthT(...)
\end_layout

\end_inset

, unlike in the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
It is not a problem that the recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 has some sub-expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1+res
\end_layout

\end_inset

 as its arguments, because all these sub-expressions will be computed 
\emph on
before
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 is recursively called.
 The recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 is the 
\emph on
last
\emph default
 computation performed by this branch of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset

.
 This shows that the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 is tail-recursive.
\end_layout

\begin_layout Standard
A tail-recursive function can have many 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match/case
\end_layout

\end_inset

 branches, with or without recursive calls; but all recursive calls must
 be always the last expressions returned.
\end_layout

\begin_layout Standard
The Scala compiler has a feature for checking automatically that a function's
 code is tail-recursive: the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@tailrec
\end_layout

\end_inset

 annotation.
 If a function with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@tailrec
\end_layout

\end_inset

 annotation is not tail-recursive, or is not recursive at all, the program
 will not compile.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def lengthT(s: Seq[Int], res: Int): Int = 
\end_layout

\begin_layout Plain Layout

  if (s == Seq()) res
\end_layout

\begin_layout Plain Layout

  else lengthT(s.tail, 1 + res)
\end_layout

\end_inset

Let us trace the evaluation of this function on a short example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lengthT(Seq(1,2,3), 0)
\end_layout

\begin_layout Plain Layout

  = lengthT(Seq(2, 3), 1 + 0) // = lengthT(Seq(2, 3), 1)
\end_layout

\begin_layout Plain Layout

  = lengthT(Seq(3), 1 + 1) // = lengthT(Seq(3), 2)
\end_layout

\begin_layout Plain Layout

  = lengthT(Seq(), 1 + 2) // = lengthT(Seq(), 3)
\end_layout

\begin_layout Plain Layout

  = 3
\end_layout

\end_inset

The sub-expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 + 2
\end_layout

\end_inset

 are computed each time 
\emph on
before
\emph default
 each recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

.
 Because of that, sub-expressions do not grow within the stack memory.
 This is the main benefit of tail recursion.
\end_layout

\begin_layout Standard
How did we rewrite the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

 to obtain the tail-recursive code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

? An important difference between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 is the additional argument, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

res
\end_layout

\end_inset

, called the 
\series bold
accumulator argument
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
accumulator argument
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
recursion!accumulator argument
\end_layout

\end_inset

.
 This argument is equal to an intermediate result of the computation.
 The next intermediate result (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 + res
\end_layout

\end_inset

) is computed and passed on to the next recursive call via the accumulator
 argument.
 In the base case of the recursion, the function now returns the accumulated
 result, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

res
\end_layout

\end_inset

, rather than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, because at that time the computation is finished.
\end_layout

\begin_layout Standard
Rewriting code by adding an accumulator argument to achieve tail recursion
 is called the 
\series bold
accumulator technique
\series default
 or the 
\begin_inset Quotes eld
\end_inset

accumulator trick
\begin_inset Quotes erd
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
accumulator trick
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
recursion!accumulator trick
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One consequence of using the accumulator trick is that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 now always needs a value for the accumulator argument.
 However, our goal is to implement a function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length(s)
\end_layout

\end_inset

 with just one argument, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s:Seq[Int]
\end_layout

\end_inset

.
 We can define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length(s) = lengthT(s, ???)
\end_layout

\end_inset

 if we supply an initial accumulator value.
 The correct initial value for the accumulator is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, since in the base case (an empty sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

) we need to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
So, a tail-recursive implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 requires us to define 
\emph on
two
\emph default
 functions: the tail-recursive 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 and an 
\begin_inset Quotes eld
\end_inset

adapter
\begin_inset Quotes erd
\end_inset

 function that will set the initial value of the accumulator argument.
 To emphasize that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 is a helper function, one could define it 
\emph on
inside
\emph default
 the adapter function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def length[A](s: Seq[A]): Int = {
\end_layout

\begin_layout Plain Layout

  @tailrec def lengthT(s: Seq[A], res: Int): Int = {
\end_layout

\begin_layout Plain Layout

    if (s == Seq()) res
\end_layout

\begin_layout Plain Layout

    else lengthT(s.tail, 1 + res)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  lengthT(s, 0)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

With this code, users will not be able to call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 directly, since it is only visible within the body of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Standard
Another possibility in Scala is to use a 
\series bold
default value
\begin_inset Index idx
status open

\begin_layout Plain Layout
default value
\end_layout

\end_inset


\series default
 for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

res
\end_layout

\end_inset

 argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def length[A](s: Seq[A], res: Int = 0): Int = 
\end_layout

\begin_layout Plain Layout

  if (s == Seq()) res
\end_layout

\begin_layout Plain Layout

  else length(s.tail, 1 + res)
\end_layout

\end_inset

In Scala, giving a default value for a function argument is the same as
 defining 
\emph on
two
\emph default
 functions: one with that argument and one without.
 For example, the syntax
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int, y: Boolean = false): Int = ...
 // Function body.
\end_layout

\end_inset

is equivalent to defining two functions (with the same name),
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int, y: Boolean) = ...
 // Function body.
\end_layout

\begin_layout Plain Layout

def f(x: Int): Int = f(Int, false)
\end_layout

\end_inset

Using a default argument value, we can define the tail-recursive helper
 function and the adapter function at once, making the code shorter.
\end_layout

\begin_layout Standard
The accumulator trick works in a large number of cases, but it may be far
 from obvious how to introduce the accumulator argument, what its initial
 value must be, and how to define the induction step for the accumulator.
 In the example with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 function, the accumulator trick works because of the following mathematical
 property of the expression being computed:
\begin_inset Formula 
\[
1+\left(1+\left(1+\left(...+1\right)\right)\right)=\left(\left(\left(1+1\right)+1\right)+...\right)+1\quad.
\]

\end_inset

This property is called the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
associativity law!of addition
\end_layout

\end_inset

associativity law
\series default
 of addition.
 Due to this law, the computation can be rearranged so that additions associate
 to the left.
 In code, it means that intermediate expressions are computed immediately
 before making the recursive calls; this avoids the growth of the intermediate
 expressions.
 
\end_layout

\begin_layout Standard
Usually, the accumulator trick works because some associativity law is present.
 In that case, we are able to rearrange the order of recursive calls so
 that these calls always occur outside all other sub-expressions, â€“ that
 is, in tail positions.
 However, not all computations obey a suitable associativity law.
 Even if a code rearrangement exists, it may not be immediately obvious
 how to find it.
\end_layout

\begin_layout Standard
As an example, consider a tail-recursive re-implementation of the function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 from the previous subsection, where the recursive call is within a sub-expressi
on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt(xs) * 10 + x
\end_layout

\end_inset

.
 To transform the code into a tail-recursive form, we need to rearrange
 the main computation,
\begin_inset Formula 
\[
r=d_{n-1}+10*\left(d_{n-2}+10*\left(d_{n-3}+10*\left(...d_{0}\right)\right)\right)\quad,
\]

\end_inset

so that the operations group to the left.
 We can do this by rewriting 
\begin_inset Formula $r$
\end_inset

 as
\begin_inset Formula 
\[
r=\left(\left(d_{0}*10+d_{1}\right)*10+...\right)*10+d_{n-1}\quad.
\]

\end_inset

It follows that the digit sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 must be split into the 
\emph on
leftmost
\emph default
 digit and the rest, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s = s.head ++ s.tail
\end_layout

\end_inset

.
 So, a tail-recursive implementation of the above formula is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def fromDigits(s: Seq[Int], res: Int = 0): Int =
\end_layout

\begin_layout Plain Layout

  // `res` is the accumulator.
\end_layout

\begin_layout Plain Layout

  if (s == Seq()) res
\end_layout

\begin_layout Plain Layout

  else fromDigits(s.tail, 10 * res + s.head)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Despite a certain similarity between this code and the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 from the previous subsection, the implementation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromDigits
\end_layout

\end_inset

 cannot be directly derived from the inductive definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

.
 One needs a separate proof that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromDigits(s, 0)
\end_layout

\end_inset

 computes the same result as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt(s)
\end_layout

\end_inset

.
 The proof follows from the following property.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-fromdigitsT-equals-fromdigits"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-fromdigitsT-equals-fromdigits"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs: Seq[Int]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r: Int
\end_layout

\end_inset

, we have
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fromDigits(xs, r) = digitsToInt(xs) + r * math.pow(10, s.length)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We prove this by induction.
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
It is quicker to write this proof in a mathematical notation instead of
 the Scala code syntax.
\end_layout

\end_inset

Let us use a short notation for sequences, 
\begin_inset Formula $\left[1,2,3\right]$
\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(1, 2, 3)
\end_layout

\end_inset

, and temporarily write 
\begin_inset Formula $d(s)$
\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt(s)
\end_layout

\end_inset

 and 
\begin_inset Formula $f(s,r)$
\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromDigitsT(s, r)
\end_layout

\end_inset

.
 Then an inductive definition of 
\begin_inset Formula $f(s,r)$
\end_inset

 is
\begin_inset Formula 
\begin{equation}
f([],r)=r\quad,\quad\quad f([x]\negmedspace+\negthickspace+s,r)=f(s,10*r+x)\quad.\label{eq:stmt-fromdigitsT-expand-f}
\end{equation}

\end_inset

Denoting by 
\begin_inset Formula $\left|s\right|$
\end_inset

 the length of a sequence 
\begin_inset Formula $s$
\end_inset

, we reformulate Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-fromdigitsT-equals-fromdigits"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as
\begin_inset Formula 
\begin{equation}
f(s,r)=d(s)+r*10^{\left|s\right|}\quad,\label{eq:stmt-fromdigitsT-reformulated}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We prove Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-fromdigitsT-reformulated"
plural "false"
caps "false"
noprefix "false"

\end_inset

) by induction.
 To prove the base case 
\begin_inset Formula $s=\left[\right]$
\end_inset

, we have 
\begin_inset Formula $f(\left[\right],r)=r$
\end_inset

 and 
\begin_inset Formula $d(\left[\right])+r*10^{0}=r$
\end_inset

 since 
\begin_inset Formula $d(\left[\right])=0$
\end_inset

 and 
\begin_inset Formula $\left|s\right|=0$
\end_inset

.
 The resulting equality 
\begin_inset Formula $r=r$
\end_inset

 proves the base case.
 
\end_layout

\begin_layout Standard
To prove the inductive step, we assume that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-fromdigitsT-reformulated"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for a given sequence 
\begin_inset Formula $s$
\end_inset

; then we need to prove that
\begin_inset Formula 
\begin{equation}
f([x]\negmedspace+\negthickspace+s,r)=d([x]\negmedspace+\negthickspace+s)+r*10^{\left|s\right|+1}\quad.\label{eq:stmt-need-to-prove-step}
\end{equation}

\end_inset

To prove this, we transform the left-hand side and the right-hand side separatel
y, hoping that we will obtain the same expression.
 The left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-need-to-prove-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & f([x]\negmedspace+\negthickspace+s,r)\\
\text{use Eq.~(\ref{eq:stmt-fromdigitsT-expand-f})}:\quad & =f(s,10*r+x)\\
\text{use Eq.~(\ref{eq:stmt-fromdigitsT-reformulated})}:\quad & =d(s)+\left(10*r+x\right)*10^{\left|s\right|}\quad.
\end{align*}

\end_inset

The right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-need-to-prove-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

) contains 
\begin_inset Formula $d([x]\negmedspace+\negthickspace+s)$
\end_inset

, which we somehow need to simplify.
 Assuming that 
\begin_inset Formula $d(s)$
\end_inset

 correctly calculates a number from its digits, we can use the basic property
 of decimal notation, which is that a digit 
\begin_inset Formula $x$
\end_inset

 in front of 
\begin_inset Formula $n$
\end_inset

 other digits has the value 
\begin_inset Formula $x*10^{n}$
\end_inset

.
 This property can be formulated as
\begin_inset Formula 
\begin{equation}
d([x]\negmedspace+\negthickspace+s)=x*10^{\left|s\right|}+d(s)\quad.\label{stmt-from-digits-property}
\end{equation}

\end_inset

So, the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-need-to-prove-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be rewritten as
\begin_inset Formula 
\begin{align*}
 & d([x]\negmedspace+\negthickspace+s)+r*10^{\left|s\right|+1}\\
\text{use Eq.~(\ref{stmt-from-digits-property})}:\quad & =x*10^{\left|s\right|}+d(s)+r*10^{\left|s\right|+1}\\
\text{factor out }10^{\left|s\right|}:\quad & =d(s)+\left(10*r+x\right)*10^{\left|s\right|}\quad.
\end{align*}

\end_inset

Now we have transformed both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-need-to-prove-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to the same expression.
\end_layout

\begin_layout Standard
We have not yet proved that the function 
\begin_inset Formula $d$
\end_inset

 satisfies the property in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "stmt-from-digits-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The proof uses induction and begins by writing the code of 
\begin_inset Formula $d$
\end_inset

 in a short notation,
\begin_inset Formula 
\begin{equation}
d(\left[\right])=0\quad,\quad\quad d(s\negmedspace+\negthickspace+[y])=d(s)*10+y\quad.\label{eq:stmt-fromdigits-code-of-d}
\end{equation}

\end_inset

The base case is Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "stmt-from-digits-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $s=[]$
\end_inset

.
 It is proved by
\begin_inset Formula 
\[
x=d([]\negmedspace+\negthickspace+[x])=d([x]\negmedspace+\negthickspace+[])=x*10^{0}+d(\left[\right])=x\quad.
\]

\end_inset

The induction step assumes Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "stmt-from-digits-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for a given 
\begin_inset Formula $x$
\end_inset

 and a given sequence 
\begin_inset Formula $s$
\end_inset

, and needs to prove that for any 
\begin_inset Formula $y$
\end_inset

, the same property holds with 
\begin_inset Formula $s\negmedspace+\negthickspace+[y]$
\end_inset

 instead of 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula 
\begin{equation}
d([x]\negmedspace+\negthickspace+s\negmedspace+\negthickspace+[y])=x*10^{\left|s\right|+1}+d(s\negmedspace+\negthickspace+[y])\quad.\label{eq:stmt-from-digits-induction-step}
\end{equation}

\end_inset

The left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-from-digits-induction-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is transformed into its right-hand side like this:
\begin_inset Formula 
\begin{align*}
 & d([x]\negmedspace+\negthickspace+s\negmedspace+\negthickspace+[y])\\
\text{use Eq.~(\ref{eq:stmt-fromdigits-code-of-d})}:\quad & =d([x]\negmedspace+\negthickspace+s)*10+y\\
\text{use Eq.~(\ref{stmt-from-digits-property})}:\quad & =\left(x*10^{\left|s\right|}+d(s)\right)*10+y\\
\text{expand parentheses}:\quad & =x*10^{\left|s\right|+1}+d(s)*10+y\\
\text{use Eq.~(\ref{eq:stmt-fromdigits-code-of-d})}:\quad & =x*10^{\left|s\right|+1}+d(s\negmedspace+\negthickspace+[y])\quad.
\end{align*}

\end_inset

This demonstrates Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-from-digits-induction-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and so concludes the proof.
\end_layout

\begin_layout Subsection
Implementing generic aggregation (
\family typewriter
foldLeft
\family default
)
\begin_inset CommandInset label
LatexCommand label
name "subsec:implementing-generic-aggregation-foldleft"

\end_inset


\end_layout

\begin_layout Standard
An 
\series bold
aggregation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
aggregation
\end_layout

\end_inset

 converts a sequence of values into a single value.
 In general, the type of the result value may be different from the type
 of elements in the sequence.
 To describe this general situation, we introduce type parameters, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, so that the input sequence is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 and the aggregated value is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Then an inductive definition of any aggregation function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Seq[A] => B
\end_layout

\end_inset

 looks like this:
\end_layout

\begin_layout Itemize
(Base case.) For an empty sequence, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(Seq()) = b0
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b0:B
\end_layout

\end_inset

 is a given value.
\end_layout

\begin_layout Itemize
(Induction step.) Assuming that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(xs) = b
\end_layout

\end_inset

 is already computed, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(xs ++ Seq(x)) = g(x, b)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 is a given function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g:(A, B) => B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Then the code implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is written using recursion:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B](s: Seq[A]): B =
\end_layout

\begin_layout Plain Layout

  if (s == Seq()) b0
\end_layout

\begin_layout Plain Layout

  else g(s.last, f(s.take(s.length - 1)))
\end_layout

\end_inset

We can now refactor this code into a generic utility function, by making
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b0
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 into parameters.
 A possible implementation is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B](s: Seq[A], b: B, g: (A, B) => B): B =
\end_layout

\begin_layout Plain Layout

  if (s == Seq()) b
\end_layout

\begin_layout Plain Layout

  else g(s.last, f(s.take(s.length - 1), b, g)
\end_layout

\end_inset

However, this implementation is not tail-recursive.
 Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to a sequence of, say, three elements, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x, y, z)
\end_layout

\end_inset

, will create an intermediate expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(z, g(y, g(x, b)))
\end_layout

\end_inset

.
 This expression will grow with the length of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

, which is not acceptable.
 To rearrange the computation into a tail-recursive form, we need to start
 the base case at the innermost call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(x, b)
\end_layout

\end_inset

, then compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(y, g(x, b))
\end_layout

\end_inset

 and continue.
 In other words, we need to traverse the sequence starting from its 
\emph on
leftmost
\emph default
 element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, rather than starting from the right.
 So, instead of splitting the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.last ++ s.take(s.length - 1)
\end_layout

\end_inset

 as we did in the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

, we need to split 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.head ++ s.tail
\end_layout

\end_inset

.
 Let us also exchange the order of the arguments of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

, in order to be more consistent with the way this code is implemented in
 the Scala library.
 The resulting code is now tail-recursive:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def leftFold[A, B](s: Seq[A], b: B, g: (B, A) => B): B =
\end_layout

\begin_layout Plain Layout

  if (s == Seq()) b
\end_layout

\begin_layout Plain Layout

  else leftFold(s.tail, g(b, s.head), g)
\end_layout

\end_inset

This function is called a 
\begin_inset Quotes eld
\end_inset

left fold
\begin_inset Quotes erd
\end_inset

 because it aggregates (or 
\begin_inset Quotes eld
\end_inset

folds
\begin_inset Quotes erd
\end_inset

) the sequence starting from the leftmost element.
\end_layout

\begin_layout Standard
In this way, we have defined a general method of computing any inductively
 defined aggregation function on a sequence.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 implements the logic of aggregation
\begin_inset Index idx
status open

\begin_layout Plain Layout
aggregation
\end_layout

\end_inset

 defined via mathematical induction.
 Using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

, we can write concise implementations of methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

, and of many other similar aggregation methods.
 The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 already contains all the code necessary to set up the base case and the
 induction step.
 The programmer just needs to specify the expressions for the initial value
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

 and for the updater function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
As a first example, let us use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 for implementing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sum(s: Seq[Int]): Int = leftFold(s, 0, { (x, y) => x + y })
\end_layout

\end_inset

To understand in detail how 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 works, let us trace the evaluation of this function when applied to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(1, 2, 3)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sum(Seq(1, 2, 3)) = leftFold(Seq(1, 2, 3), 0, g)
\end_layout

\begin_layout Plain Layout

  // Here, g = { (x, y) => x + y }, so g(x, y) = x + y
\end_layout

\begin_layout Plain Layout

  = leftFold(Seq(2, 3), g(0, 1), g) // g (0, 1) = 1
\end_layout

\begin_layout Plain Layout

  = leftFold(Seq(2, 3), 1, g) // now expand the code of leftFold
\end_layout

\begin_layout Plain Layout

  = leftFold(Seq(3), g(1, 2), g) // g(1, 2) = 3; expand the code
\end_layout

\begin_layout Plain Layout

  = leftFold(Seq(), g(3, 3), g) // g(3, 3) = 6; expand the code
\end_layout

\begin_layout Plain Layout

  = 6
\end_layout

\end_inset

The second argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 is the accumulator argument.
 The initial value of the accumulator is specified when first calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

.
 At each iteration, the new accumulator value is computed by calling the
 updater function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

, which uses the previous accumulator value and the value of the next sequence
 element.
\end_layout

\begin_layout Standard
To visualize the process of evaluation, it is convenient to write a table
 showing the sequence elements and the accumulator values as they are updated:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Current element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Old accumulator value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
New accumulator value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

6
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
In general, the type of the accumulator value can be different from the
 type of the sequence elements.
 An example is an implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def count[A](s: Seq[A], p: A => Boolean): Int =
\end_layout

\begin_layout Plain Layout

  leftFold(s, 0, { (x, y) => x + (if (p(y)) 1 else 0) })
\end_layout

\end_inset

The accumulator is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, while the sequence elements can have an arbitrary type, parameterized
 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 The aggregation function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 works in the same way for all types of accumulators and all types of sequence
 elements.
\end_layout

\begin_layout Standard
In Scala's standard library, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 method has a different type signature and, in particular, requires its
 arguments to be in separate argument groups.
 For comparison, the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 using our 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 function is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sum(s: Seq[Int]): Int = leftFold(s, 0, { (x, y) => x + y })
\end_layout

\end_inset

With the Scala library's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 method, the code is written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sum(s: Seq[Int]): Int = s.foldLeft(0){ (x, y) => x + y }
\end_layout

\end_inset

This syntax makes it more convenient to write nameless functions as arguments,
 since the updater argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 is separated from other arguments by curly braces.
 We will use the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 method from now on; the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 function was implemented only as an illustration.
\end_layout

\begin_layout Standard
The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 is available in the Scala standard library for all collections, including
 dictionaries and sets.
 It is safe to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

, in the sense that no stack overflows will occur even for very large sequences.
\end_layout

\begin_layout Standard
The Scala library contains several other methods similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldRight
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.reduce
\end_layout

\end_inset

.
 (However, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldRight
\end_layout

\end_inset

 is not tail-recursive!)
\end_layout

\begin_layout Subsection
Solved examples: using 
\family typewriter
foldLeft
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is important to gain experience using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 method.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-1-max-foldleft"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-1-max-foldleft"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 for implementing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 function for integer sequences.
 Return the special value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int.MinValue
\end_layout

\end_inset

 for empty sequences.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
Write an inductive formulation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 function:
\end_layout

\begin_layout Itemize
(Base case.) For an empty sequence, return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int.MinValue
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
(Inductive step.) If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 is already computed on a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max(xs) = b
\end_layout

\end_inset

, the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 on a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs ++ Seq(x)
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

math.max(b,x)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Now we can write the code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def max(s: Seq[Int]): Int = 
\end_layout

\begin_layout Plain Layout

  s.foldLeft(Int.MinValue){ (b, x) => math.max(b, x) }
\end_layout

\end_inset

If we are sure that the function will never be called on empty sequences,
 we can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 in a simpler way by using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.reduce
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def max(s: Seq[Int]): Int = s.reduce { (x, y) => math.max(x, y) }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-2-count-foldleft"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-2-count-foldleft"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 method on sequences of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
Using the inductive definition of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 as shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Inductive-definitions-of-aggregation-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we can write the code as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def count[A](s: Seq[A], p: A => Boolean): Int =
\end_layout

\begin_layout Plain Layout

  s.foldLeft(0){ (b, x) => b + (if (p(x)) 1 else 0) }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-3-digitstoint-foldleft"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-3-digitstoint-foldleft"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
The inductive definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 is directly translated into code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsToInt(d: Seq[Int]): Int = d.foldLeft(0){ (n, x) => n * 10 + x }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-3-digitstoint-foldleft-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-3-digitstoint-foldleft-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given non-empty sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs: Seq[Double]
\end_layout

\end_inset

, compute the minimum, the maximum, and the mean as a tuple 
\begin_inset Formula $\left(x_{\min},x_{\max},x_{\text{mean}}\right)$
\end_inset

.
 The sequence should be traversed only once, i.e.
\begin_inset space ~
\end_inset

we may call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.foldLeft
\end_layout

\end_inset

 only once.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
Without the requirement of using a single traversal, we would write
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(xs.min, xs.max, xs.sum / xs.length)
\end_layout

\end_inset

However, this code traverses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 at least three times, since each of the aggregations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.min
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.max
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.sum
\end_layout

\end_inset

 iterates over 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
 We need to combine the four inductive definitions of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

min
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 into a single inductive definition of some function.
 What is the type of that function's return value? We need to accumulate
 intermediate values of 
\emph on
all four
\emph default
 numbers (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

min
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

) in a tuple.
 So the required type of the accumulator is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double, Double, Double)
\end_layout

\end_inset

.
 To avoid repeating a very long type expression, we can define a type alias
\begin_inset Index idx
status open

\begin_layout Plain Layout
type alias
\end_layout

\end_inset

 for it, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D4
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> type D4 = (Double, Double, Double, Double)
\end_layout

\begin_layout Plain Layout

defined type alias D4 
\end_layout

\end_inset

The updater function must update each of the four numbers according to the
 definitions of their inductive steps:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def update(p: D4, x: Double): D4 = p match {
\end_layout

\begin_layout Plain Layout

  case (min, max, sum, length) =>
\end_layout

\begin_layout Plain Layout

   (math.min(x, min), math.max(x, max), x + sum, length + 1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Now we can write the code of the required function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(xs: Seq[Double]): (Double, Double, Double) = {
\end_layout

\begin_layout Plain Layout

  val init: D4 = (Double.PositiveInfinity, Double.NegativeInfinity, 0, 0)
\end_layout

\begin_layout Plain Layout

  val (min, max, sum, length) = xs.foldLeft(init)(update)
\end_layout

\begin_layout Plain Layout

  (min, max, sum/length)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f(Seq(1.0, 1.5, 2.0, 2.5, 3.0))
\end_layout

\begin_layout Plain Layout

res0: (Double, Double, Double) = (1.0,3.0,2.0)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-4-digitstodouble-foldleft"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-4-digitstodouble-foldleft"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToDouble
\end_layout

\end_inset

 using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

.
 The argument is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Char]
\end_layout

\end_inset

.
 For example,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

digitsToDouble(Seq('3', '4', '.', '2', '5')) = 34.25
\end_layout

\end_inset

Assume that all characters are either digits or the dot character (so, negative
 numbers are not supported).
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
The evaluation of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 on a sequence of digits will visit the sequence from left to right.
 The updating function should work the same as in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 until a dot character is found.
 After that, we need to change the updating function.
 So, we need to remember whether a dot character has been seen.
 The only way for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 to 
\begin_inset Quotes eld
\end_inset

remember
\begin_inset Quotes erd
\end_inset

 any data is to hold that data in the accumulator value.
 We can choose the type of the accumulator according to our needs.
 So, for this task we can choose the accumulator to be a 
\emph on
tuple
\emph default
 that contains, for instance, the floating-point result constructed so far
 and a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 flag showing whether we have already seen the dot character.
\end_layout

\begin_layout Standard
To visualize what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToDouble
\end_layout

\end_inset

 must do, let us consider how the evaluation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToDouble(Seq('3', '4', '.', '2', '5'))
\end_layout

\end_inset

 should go.
 We can write a table showing the intermediate result at each iteration.
 This will hopefully help us figure out what the accumulator and the updater
 function 
\begin_inset Formula $g(...)$
\end_inset

 must be:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Current digit 
\begin_inset Formula $c$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Previous result 
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
New result 
\begin_inset Formula $n'=g(n,c)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'3'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $3.0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'4'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $3.0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $34.0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'.'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $34.0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $34.0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'2'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $34.0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $34.2$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'5'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $34.2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $34.25$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Until the dot character is found, the updater function multiplies the previous
 result by 
\begin_inset Formula $10$
\end_inset

 and adds the current digit.
 After the dot character, the updater function must add to the previous
 result the current digit divided by a factor that represents increasing
 powers of 
\begin_inset Formula $10$
\end_inset

.
 In other words, the update computation 
\begin_inset Formula $n'=g(n,c)$
\end_inset

 must be defined by these formulas:
\end_layout

\begin_layout Itemize
Before the dot character: 
\begin_inset Formula $g(n,c)=n*10+c$
\end_inset

.
\end_layout

\begin_layout Itemize
After the dot character: 
\begin_inset Formula $g(n,c)=n+\frac{c}{f}$
\end_inset

, where 
\begin_inset Formula $f$
\end_inset

 is 
\begin_inset Formula $10$
\end_inset

, 
\begin_inset Formula $100$
\end_inset

, 
\begin_inset Formula $1000$
\end_inset

, etc., for each subsequent digit.
\end_layout

\begin_layout Standard
The updater function 
\begin_inset Formula $g$
\end_inset

 has only two arguments: the current digit and the previous accumulator
 value.
 So, the changing factor 
\begin_inset Formula $f$
\end_inset

 must be 
\emph on
part
\emph default
 
\emph on
of
\emph default
 the accumulator value, and must be multiplied by 
\begin_inset Formula $10$
\end_inset

 at each digit after the dot.
 If the factor 
\begin_inset Formula $f$
\end_inset

 is not a part of the accumulator value, the function 
\begin_inset Formula $g$
\end_inset

 will not have enough information for computing the next accumulator value
 correctly.
 So, the updater computation must be 
\begin_inset Formula $n'=g(n,c,f)$
\end_inset

, not 
\begin_inset Formula $n'=g(n,c)$
\end_inset

.
\end_layout

\begin_layout Standard
For this reason, we choose the accumulator type as a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Boolean, Double)
\end_layout

\end_inset

 where the first number is the result 
\begin_inset Formula $n$
\end_inset

 computed so far, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 flag indicates whether the dot was already seen, and the third number is
 
\begin_inset Formula $f$
\end_inset

, that is, the power of 
\begin_inset Formula $10$
\end_inset

 by which the current digit will be divided if the dot was already seen.
 Initially, the accumulator tuple will be equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(0.0, false, 10.0)
\end_layout

\end_inset

.
 Then the updater function is implemented like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def update(acc: (Double, Boolean, Double), c: Char): (Double, Boolean, Double)
 =
\end_layout

\begin_layout Plain Layout

acc match { case (n, flag, factor) =>
\end_layout

\begin_layout Plain Layout

  if (c == '.') (n, true, factor) // Set flag to `true` if dot character.
\end_layout

\begin_layout Plain Layout

  else {
\end_layout

\begin_layout Plain Layout

    val digit = c - '0'
\end_layout

\begin_layout Plain Layout

    if (flag) // This digit is after the dot.
 Update `factor`.
\end_layout

\begin_layout Plain Layout

      (n + digit/factor, flag, factor * 10)
\end_layout

\begin_layout Plain Layout

    else // This digit is before the dot.
\end_layout

\begin_layout Plain Layout

      (n * 10 + digit, flag, factor)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Now we can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToDouble
\end_layout

\end_inset

 as follows,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsToDouble(d: Seq[Char]): Double = {
\end_layout

\begin_layout Plain Layout

  val initAccumulator = (0.0, false, 10.0)
\end_layout

\begin_layout Plain Layout

  val (n, _, _) = d.foldLeft(initAccumulator)(update)
\end_layout

\begin_layout Plain Layout

  n
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsToDouble(Seq('3', '4', '.', '2', '5'))
\end_layout

\begin_layout Plain Layout

res0: Double = 34.25
\end_layout

\end_inset

The result of calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

d.foldLeft
\end_layout

\end_inset

 is a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(n, flag, factor)
\end_layout

\end_inset

, in which only the first part, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

, is needed.
 In Scala's pattern matching expressions, the underscore symbol is used
 to denote the pattern variables whose values are not needed in the subsequent
 code.
 We could extract the first part using the accessor method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

._1
\end_layout

\end_inset

, but the code is more readable if we show all parts of the tuple as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(n, _, _)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-foldleft-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-foldleft-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method for sequences by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

.
 The input sequence should be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

, and the output sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[B]
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are type parameters.
 Here are the required type signature of the function and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: Seq[A])(f: A => B): Seq[B] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> map(List(1, 2, 3)){ x => x * 10 }
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(10, 20, 30)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
The required code should build a new sequence by applying the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to each element.
 How can we build a new sequence using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

? The evaluation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 consists of iterating over the input sequence and accumulating some result
 value, which is updated at each iteration.
 Since the result of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 is always equal to the last computed accumulator value, it follows that
 the new sequence should 
\emph on
be
\emph default
 the accumulator value.
 So, we need to update the accumulator by appending the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is the current element of the input sequence.
 We can append elements to sequences using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

:+
\end_layout

\end_inset

 operation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: Seq[A])(f: A => B): Seq[B] =
\end_layout

\begin_layout Plain Layout

  xs.foldLeft(Seq[B]()){ (acc, x) => acc :+ f(x) }
\end_layout

\end_inset

The operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

acc :+ f(x)
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

acc ++ Seq(f(x))
\end_layout

\end_inset

 but is shorter to write.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-foldleft-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-foldleft-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toPairs
\end_layout

\end_inset

 that converts a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 to a sequence of pairs, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(A, A)]
\end_layout

\end_inset

, by putting together each pair of adjacent elements.
 If the initial sequence has an odd number of elements, a given default
 value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is used:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toPairs[A](xs: Seq[A], default: A): Seq[(A, A)] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toPairs(Seq(1, 2, 3, 4, 5, 6), -1)
\end_layout

\begin_layout Plain Layout

res0: Seq[(Int, Int)] = List((1,2), (3,4), (5,6))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toPairs(Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

), 
\begin_inset Quotes eld
\end_inset

<nothing>
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res1: Seq[(String, String)] = List((a,b), (c,<nothing>)) 
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
We need to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 to accumulate a sequence of pairs.
 However, we iterate over elements of the input sequence one by one.
 So, a new pair can be added only once every two iterations.
 The accumulator needs to hold the information about the current iteration
 being even or odd.
 For odd-numbered iterations, the accumulator also needs to store the previous
 element that is still waiting for its pair.
 Therefore, we choose the type of the accumulator to be a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq[(A, A)], Seq(A))
\end_layout

\end_inset

.
 The first sequence is the intermediate result, and the second sequence
 is the 
\begin_inset Quotes eld
\end_inset

remainder
\begin_inset Quotes erd
\end_inset

: it holds the previous element for odd-numbered iterations and is empty
 for even-numbered iterations.
 Initially, the accumulator should be empty.
 A trace of the accumulator updates is shown in this table:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Current element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Previous accumulator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Next accumulator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq(), Seq())
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq(), Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq(), Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq((
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

b
\begin_inset Quotes erd
\end_inset

)), Seq())
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq((
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

b
\begin_inset Quotes erd
\end_inset

)), Seq())
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq((
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

b
\begin_inset Quotes erd
\end_inset

)), Seq(
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Now it becomes clear how to implement the updater function.
 The code calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 and then performs some post-processing to make sure we create the last
 pair in case the last iteration is odd-numbered, i.e.
\begin_inset space ~
\end_inset

when the 
\begin_inset Quotes eld
\end_inset

remainder
\begin_inset Quotes erd
\end_inset

 is not empty after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 is finished.
 In this implementation, we use pattern matching to decide whether a sequence
 is empty:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toPairs[A](xs: Seq[A], default: A): Seq[(A, A)] = {
\end_layout

\begin_layout Plain Layout

  type Acc = (Seq[(A, A)], Seq[A]) // Type alias, for brevity.
\end_layout

\begin_layout Plain Layout

  def init: Acc = (Seq(), Seq())
\end_layout

\begin_layout Plain Layout

  def updater(acc: Acc, x: A): Acc = acc match {
\end_layout

\begin_layout Plain Layout

    case (result, Seq()) => (result, Seq(x))
\end_layout

\begin_layout Plain Layout

    case (result, Seq(prev)) => (result ++ Seq((prev, x)), Seq())
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  val (result, remainder) = xs.foldLeft(init)(updater)
\end_layout

\begin_layout Plain Layout

  // May need to append the last element to the result.
\end_layout

\begin_layout Plain Layout

  remainder match {
\end_layout

\begin_layout Plain Layout

    case Seq() => result
\end_layout

\begin_layout Plain Layout

    case Seq(x) => result ++ Seq((x, default))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code shows examples of partial functions that are applied safely.
 One of these partial functions is used in the expression
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

remainder match {
\end_layout

\begin_layout Plain Layout

  case Seq() => ...
\end_layout

\begin_layout Plain Layout

  case Seq(a) => ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code works when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remainder
\end_layout

\end_inset

 is empty or has length 
\begin_inset Formula $1$
\end_inset

, but fails for longer sequences.
 So it is safe to apply the partial function as long as it is used on sequences
 of length at most 
\begin_inset Formula $1$
\end_inset

, which is indeed the case for the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toPairs
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Exercises: Using 
\family typewriter
foldLeft
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromPairs
\end_layout

\end_inset

 that performs the inverse transformation to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toPairs
\end_layout

\end_inset

 function defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-foldleft-7"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fromPairs[A](xs: Seq[(A, A)]): Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fromPairs(Seq((1, 2), (3, 4)))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(1, 2, 3, 4)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: This can be done with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 or with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method for sequences by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flatten[A](xxs: Seq[Seq[A]]): Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> flatten(Seq(Seq(1, 2, 3), Seq(), Seq(4)))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(1, 2, 3, 4)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 to implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 method for sequences.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def zipWithIndex[A](xs: Seq[A]): Seq[(A, Int)] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> zipWithIndex(Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

d
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

res0: Seq[String] = List((a, 0), (b, 1), (c, 2), (d, 3))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 to implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filterMap
\end_layout

\end_inset

 that combines 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 for sequences.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filterMap[A, B](xs: Seq[A])(pred: A => Boolean)(f: A => B): Seq[B] =
 ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> filterMap(Seq(1, 2, 3, 4)) { x => x > 2 } { x => x * 10 }
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(30, 40)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Split a sequence into subsequences (
\begin_inset Quotes eld
\end_inset

batches
\begin_inset Quotes erd
\end_inset

) of length not larger than a given maximum length 
\begin_inset Formula $n$
\end_inset

.
 The required type signature and a sample test are:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def batching[A](xs: Seq[A], size: Int): Seq[Seq[A]] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> batching(Seq("a", "b", "c", "d"), 2)
\end_layout

\begin_layout Plain Layout

res0: Seq[Seq[String]] = List(List(a, b), List(c, d))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> batching(Seq(1, 2, 3, 4, 5, 6, 7), 3)
\end_layout

\begin_layout Plain Layout

res1: Seq[Seq[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7))
\end_layout

\end_inset


\begin_inset Note Comment
status open

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def batching[A](xs: Seq[A], size: Int): Seq[Seq[A]] = {  
\end_layout

\begin_layout Plain Layout

  type Acc = (Seq[Seq[A]], Seq[A], Int)
\end_layout

\begin_layout Plain Layout

  val init: Acc = ((Seq(), Seq(), 0))
\end_layout

\begin_layout Plain Layout

  val (result, rem, _) = xs.foldLeft(init){ case ((seq, rem, len), x) =>
\end_layout

\begin_layout Plain Layout

    val newLen = len + 1
\end_layout

\begin_layout Plain Layout

    if (newLen > size) (seq ++ Seq(rem), Seq(x), 1)
\end_layout

\begin_layout Plain Layout

    else (seq, rem ++ Seq(x), newLen)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  result ++ Seq(rem)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-5-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-5-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Split a sequence into batches by 
\begin_inset Quotes eld
\end_inset

weight
\begin_inset Quotes erd
\end_inset

 computed via a given function.
 The total weight of items in any batch should not be larger than a given
 maximum weight.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def byWeight[A](xs: Seq[A], maxW: Double)(w: A => Double): Seq[Seq[A]] =
 ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> byWeight((1 to 10).toList, 5.75){ x => math.sqrt(x) }
\end_layout

\begin_layout Plain Layout

res0: Seq[Seq[Int]] = List(List(1, 2, 3), List(4, 5), List(6, 7), List(8),
 List(9), List(10))
\end_layout

\end_inset


\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def weightBatching[A](xs: Seq[A], maxW: Double)(w: A => Double): Seq[Seq[A]]
 = {  
\end_layout

\begin_layout Plain Layout

  type Acc = (Seq[Seq[A]], Seq[A], Double)
\end_layout

\begin_layout Plain Layout

  val init: Acc = ((Seq(), Seq(), 0.0))
\end_layout

\begin_layout Plain Layout

  val (result, rem, _) = xs.foldLeft(init) { case ((seq, rem, weight), x)
 =>
\end_layout

\begin_layout Plain Layout

    val wx = w(x)
\end_layout

\begin_layout Plain Layout

    if (wx > maxW) (seq ++ Seq(rem, Seq(x)), Seq(), 0.0)
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      val newWeight = weight + wx
\end_layout

\begin_layout Plain Layout

      if (newWeight > maxW) (seq ++ Seq(rem), Seq(x), wx)
\end_layout

\begin_layout Plain Layout

      else (seq, rem ++ Seq(x), newWeight)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  result ++ Seq(rem)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-6"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 to implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

groupBy
\end_layout

\end_inset

 function.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def groupBy[A, K](xs: Seq[A])(by: A => K): Map[K, Seq[A]] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> groupBy(Seq(1, 2, 3, 4, 5)){ x => x % 2 }
\end_layout

\begin_layout Plain Layout

res0: Map[Int, Seq[Int]] = Map(1 -> List(1, 3, 5), 0 -> List(2, 4))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hints: 
\end_layout

\begin_layout Standard
The accumulator should be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[K, Seq[A]]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
To work with dictionaries, you will need to use the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.getOrElse
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.updated
\end_layout

\end_inset

.
 The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.getOrElse
\end_layout

\end_inset

 fetches a value from a dictionary by key, and returns the given default
 value if the dictionary does not contain that key:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 -> 1, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 -> 2).getOrElse(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 300)
\end_layout

\begin_layout Plain Layout

res0: Int = 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Map("a" -> 1, "b" -> 2).getOrElse("c", 300)
\end_layout

\begin_layout Plain Layout

res1: Int = 300
\end_layout

\end_inset

The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.updated
\end_layout

\end_inset

 produces a new dictionary that contains a new value for the given key,
 whether or not that key already exists in the dictionary:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 -> 1, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 -> 2).updated(
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

, 300) // Key is new.
\end_layout

\begin_layout Plain Layout

res0: Map[String,Int] = Map(a -> 1, b -> 2, c -> 300)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Map("a" -> 1, "b" -> 2).updated("a", 400) // Key already exists.
\end_layout

\begin_layout Plain Layout

res1: Map[String,Int] = Map(a -> 400, b -> 2) 
\end_layout

\end_inset


\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def groupBy[A, K](xs: Seq[A])(by: A => K): Map[K, Seq[A]] = {  
\end_layout

\begin_layout Plain Layout

  val init: Map[K, Seq[A]] = Map()
\end_layout

\begin_layout Plain Layout

  xs.foldLeft(init) { (res, x) =>
\end_layout

\begin_layout Plain Layout

    val key = by(x)
\end_layout

\begin_layout Plain Layout

    val seq = res.getOrElse(key, Seq()) ++ Seq(x)
\end_layout

\begin_layout Plain Layout

    res.updated(key, seq)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Converting a single value into a sequence
\begin_inset CommandInset label
LatexCommand label
name "sec:ch2Converting-a-single"

\end_inset


\end_layout

\begin_layout Standard
An aggregation converts or 
\begin_inset Quotes eld
\end_inset

folds
\begin_inset Quotes erd
\end_inset

 a sequence into a single value; the opposite operation (
\begin_inset Quotes eld
\end_inset

unfolding
\begin_inset Quotes erd
\end_inset

) converts a single value into a sequence.
 An example of this task is to compute the sequence of decimal digits for
 a given integer:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsOf(x: Int): Seq[Int] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsOf(2405)
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(2, 4, 0, 5)
\end_layout

\end_inset

We cannot implement this function using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

, because these methods may be applied only if we 
\emph on
already have
\emph default
 a sequence.
 A new sequence can be created, e.g., via the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n)
\end_layout

\end_inset

, but we do not know in advance how long the required sequence must be.
 The length of the required sequence is determined by a condition that we
 cannot easily evaluate in advance.
\end_layout

\begin_layout Standard
A general 
\begin_inset Quotes eld
\end_inset

unfolding
\begin_inset Quotes erd
\end_inset

 operation requires us to build a sequence whose length is not determined
 in advance.
 This kind of sequence is called an 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
stream
\end_layout

\end_inset

stream
\series default
.
 A stream is a sequence whose elements are computed only when necessary
 (unlike sequences such as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 or an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

, whose elements are all computed in advance and stored).
 The unfolding operation will keep computing the next element; this creates
 a stream.
 We can then apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.takeWhile
\end_layout

\end_inset

 to the stream, in order to stop it when a certain condition holds.
 Finally, if required, the truncated stream may be converted to a list or
 to another type of sequence.
 In this way, we can generate a sequence of initially unknown length according
 to the given requirements.
\end_layout

\begin_layout Standard
A general stream-producing function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 is available in the Scala library.
 This function has two arguments, the initial value and a function that
 computes the next value from the previous one:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Stream.iterate(2){ x => x + 10 }
\end_layout

\begin_layout Plain Layout

res0: Stream[Int] = Stream(2, ?)
\end_layout

\end_inset

The stream is ready to start computing the next elements of the sequence
 (so far, only the first element, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset

, has been computed).
 In order to see the next elements, we need to stop the stream at a finite
 size and then convert the result to a list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Stream.iterate(2){ x => x + 10 }.take(6).toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(2, 12, 22, 32, 42, 52)
\end_layout

\end_inset

If we try to evaluate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toList
\end_layout

\end_inset

 on a stream without first limiting its size via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.take
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.takeWhile
\end_layout

\end_inset

, the program will keep producing more and more elements of the stream,
 until it runs out of memory and crashes.
\end_layout

\begin_layout Standard
Streams are similar to sequences, and methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 are also defined for streams.
 For instance, we can use the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.drop
\end_layout

\end_inset

 that skips a given number of initial elements:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(10, 20, 30, 40, 50).drop(3)
\end_layout

\begin_layout Plain Layout

res2: Seq[Int] = List(40, 50)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Stream.iterate(2){ x => x + 10 }.drop(3)
\end_layout

\begin_layout Plain Layout

res3: Stream[Int] = Stream(32, ?)
\end_layout

\end_inset

This example shows that in order to evaluate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.drop(3)
\end_layout

\end_inset

, the stream had to compute its elements up to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

32
\end_layout

\end_inset

 (but the subsequent elements are still not computed).
\end_layout

\begin_layout Standard
To figure out the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsOf
\end_layout

\end_inset

, we first write this function as a mathematical formula.
 To compute the sequence of digits for, say, 
\begin_inset Formula $n=2405$
\end_inset

, we need to divide 
\begin_inset Formula $n$
\end_inset

 repeatedly by 
\begin_inset Formula $10$
\end_inset

, getting a sequence 
\begin_inset Formula $n_{k}$
\end_inset

 of intermediate numbers (
\begin_inset Formula $n_{0}=2405$
\end_inset

, 
\begin_inset Formula $n_{1}=240$
\end_inset

, ...) and the corresponding sequence of last digits, 
\begin_inset Formula $n_{k}\text{ mod }10$
\end_inset

 (in this example: 
\begin_inset Formula $5$
\end_inset

, 
\begin_inset Formula $0$
\end_inset

, ...).
 The sequence 
\begin_inset Formula $n_{k}$
\end_inset

 is defined using mathematical induction:
\end_layout

\begin_layout Itemize
Base case: 
\begin_inset Formula $n_{0}=n$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the given initial integer.
\end_layout

\begin_layout Itemize
Inductive step: 
\begin_inset Formula $n_{k+1}=\left\lfloor \frac{n_{k}}{10}\right\rfloor \ \text{for}\ k=1,2,...$
\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\left\lfloor \frac{n_{k}}{10}\right\rfloor $
\end_inset

 is the mathematical notation for the integer division by 
\begin_inset Formula $10$
\end_inset

.
 
\end_layout

\begin_layout Standard
Let us trace the evaluation of the sequence 
\begin_inset Formula $n_{k}$
\end_inset

 for 
\begin_inset Formula $n=2405$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $3$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $5$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $6$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{k}=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2405$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $240$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $24$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{k}\text{ mod }10=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $5$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The numbers 
\begin_inset Formula $n_{k}$
\end_inset

 will remain all zeros after 
\begin_inset Formula $k=4$
\end_inset

.
 It is clear that the useful part of the sequence is before it becomes all
 zeros.
 In this example, the sequence 
\begin_inset Formula $n_{k}$
\end_inset

 needs to be stopped at 
\begin_inset Formula $k=4$
\end_inset

.
 The sequence of digits then becomes 
\begin_inset Formula $\left[5,0,4,2\right]$
\end_inset

, and we need to reverse it to obtain 
\begin_inset Formula $\left[2,4,0,5\right]$
\end_inset

.
 For reversing a sequence, the Scala library has the standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.reverse
\end_layout

\end_inset

.
 So the code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsOf(n: Int): Seq[Int] =
\end_layout

\begin_layout Plain Layout

  if (n == 0) Seq(0) else { // n == 0 is a special case.
\end_layout

\begin_layout Plain Layout

    Stream.iterate(n) { nk => nk / 10 }
\end_layout

\begin_layout Plain Layout

      .takeWhile { nk => nk != 0 }
\end_layout

\begin_layout Plain Layout

      .map { nk => nk % 10 }
\end_layout

\begin_layout Plain Layout

      .toList.reverse
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

By writing nameless functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ nk => nk % 10 }
\end_layout

\end_inset

 in a shorter syntax such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(_ % 10)
\end_layout

\end_inset

, we can shorten the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsOf
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsOf(n: Int): Seq[Int] =
\end_layout

\begin_layout Plain Layout

  if (n == 0) Seq(0) else { // n == 0 is a special case.
\end_layout

\begin_layout Plain Layout

    Stream.iterate(n)(_ / 10)
\end_layout

\begin_layout Plain Layout

      .takeWhile(_ != 0)
\end_layout

\begin_layout Plain Layout

      .map(_ % 10)
\end_layout

\begin_layout Plain Layout

      .toList.reverse
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The type signature of the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 can be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def iterate[A](init: A)(next: A => A): Stream[A]
\end_layout

\end_inset

This shows how 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 constructs a sequence defined by mathematical induction.
 The base case is the first value, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

, and the inductive step is a function, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next
\end_layout

\end_inset

, that computes the next element from the previous one.
 It is a flexible way of generating sequences whose length is not determined
 in advance.
\end_layout

\begin_layout Section
Transforming a sequence into another sequence
\end_layout

\begin_layout Standard
We have seen methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

 that transform sequences into sequences.
 However, these methods cannot express a general transformation where the
 elements of the new sequence are defined by induction, depending on previous
 elements.
 An example of a task of this kind is to compute the partial sums of a given
 sequence 
\begin_inset Formula $x_{i}$
\end_inset

: 
\begin_inset Formula 
\[
b_{k}=\sum_{i=0}^{k-1}x_{i}\quad.
\]

\end_inset

This formula defines 
\begin_inset Formula $b_{0}=0$
\end_inset

, 
\begin_inset Formula $b_{1}=x_{0}$
\end_inset

, 
\begin_inset Formula $b_{2}=x_{0}+x_{1}$
\end_inset

, 
\begin_inset Formula $b_{3}=x_{0}+x_{1}+x_{2}$
\end_inset

, etc.
 A definition via mathematical induction may be written like this,
\end_layout

\begin_layout Itemize
(Base case.) 
\begin_inset Formula $b_{0}=0$
\end_inset

.
\end_layout

\begin_layout Itemize
(Induction step.) Given 
\begin_inset Formula $b_{k}$
\end_inset

, we define 
\begin_inset Formula $b_{k+1}=b_{k}+x_{k}$
\end_inset

 for 
\begin_inset Formula $k=0,1,2,...$
\end_inset


\end_layout

\begin_layout Standard
The Scala library method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.scanLeft
\end_layout

\end_inset

 implements a general sequence-to-sequence transformation defined in this
 way.
 The code implementing the partial sums is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def partialSums(xs: Seq[Int]): Seq[Int] = xs.scanLeft(0){ (x, y) => x + y
 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> partialSums(Seq(1, 2, 3, 4))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(0, 1, 3, 6, 10)
\end_layout

\end_inset

The first argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.scanLeft
\end_layout

\end_inset

 is the base case, and the second argument is an updater function describing
 the induction step.
 In general, the type of elements of the second sequence is different from
 that of the first sequence.
 The updater function takes an element of the first sequence and a previous
 element of the second sequence, and returns the next element of the second
 sequence.
 Note that the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.scanLeft
\end_layout

\end_inset

 is one element longer than the original sequence, because the base case
 provides an initial value.
\end_layout

\begin_layout Standard
Until now, we have seen that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 is sufficient to re-implement almost every method that work on sequences,
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

.
 The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.scanLeft
\end_layout

\end_inset

 can be also implemented via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

.
 In the implementation, the accumulator contains the previous element of
 the second sequence together with a growing fragment of that sequence,
 which is updated as we iterate over the first sequence.
 The code (shown here only as illustration) is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def scanLeft[A, B](xs: Seq[A])(b0: B)(next: (B, A) => B): Seq[B] = {
\end_layout

\begin_layout Plain Layout

  val init: (B, Seq[B]) = (b0, Seq(b0))
\end_layout

\begin_layout Plain Layout

  val (_, result) = xs.foldLeft(init){ case ((b, seq), x) =>
\end_layout

\begin_layout Plain Layout

    val newB = next(b, x)
\end_layout

\begin_layout Plain Layout

    (newB, seq ++ Seq(newB))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To define the (nameless) updater function for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

, we used the Scala feature that makes it easier to define functions with
 several arguments containing tuples.
 In our case, the updater function in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 has two arguments: the first is a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(B, Seq[B])
\end_layout

\end_inset

, the second is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 The pattern matching expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case ((b, seq), x) => ...
 }
\end_layout

\end_inset

 appears to match against a nested tuple
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples!nested
\end_layout

\end_inset

.
 In reality, this expression matches the two arguments of the updater function
 and, at the same time, destructures the tuple argument as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(b, seq)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
We have seen a broad overview of translating mathematical induction into
 Scala code.
 What problems can we solve now?
\end_layout

\begin_layout Itemize
Compute mathematical expressions involving arbitrary recursion.
\end_layout

\begin_layout Itemize
Use the accumulator trick to enforce tail recursion.
\end_layout

\begin_layout Itemize
Use arbitrary inductive (i.e.
\begin_inset space \space{}
\end_inset

recursive) formulas to:
\end_layout

\begin_deeper
\begin_layout Itemize
convert sequences to single values (
\begin_inset Quotes eld
\end_inset

aggregation
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Itemize
create new sequences from single values;
\end_layout

\begin_layout Itemize
transform existing sequences into new sequences.
\end_layout

\end_deeper
\begin_layout Standard
This table summarizes the Scala methods implementing these tasks:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Definition via mathematical induction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Scala code example
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f(\left[\right])=b~;~~f(s\negmedspace+\negthickspace+[x])=g(f(s),x)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(xs) = xs.foldLeft(b)(g)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{0}=b~;~~x_{k+1}=g(x_{k})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs = Stream.iterate(b)(g)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{0}=b~;~~y_{k+1}=g(y_{k},x_{k})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ys = xs.scanLeft(b)(g)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Using these methods, any iterative calculation is implemented by translating
 mathematical induction directly into code.
 In the functional programming paradigm, the programmer does not need to
 write any loops or check any array indices.
 Instead, the programmer reasons about sequences as mathematical values:
 
\begin_inset Quotes eld
\end_inset

Starting from this value, we get that sequence, then transform it into this
 other sequence,
\begin_inset Quotes erd
\end_inset

 etc.
 This is a powerful way of working with sequences, dictionaries, and sets.
 Many kinds of programming errors (such as an incorrect array index) are
 avoided from the outset, and the code is shorter and easier to read than
 conventional code written using loops.
\end_layout

\begin_layout Paragraph*
What tasks are not possible with these tools?
\end_layout

\begin_layout Standard
We cannot implement a non-tail-recursive function without stack overflow
 (i.e.
\begin_inset space ~
\end_inset

without unlimited growth of intermediate expressions).
 The accumulator trick does not always work! In some cases, it is impossible
 to implement tail recursion in a given recursive computation.
 An example of such a computation is the 
\begin_inset Quotes eld
\end_inset

merge-sort
\begin_inset Quotes erd
\end_inset

 algorithm where the function body must contain two recursive calls within
 a single expression.
 (It is impossible to rewrite 
\emph on
two
\emph default
 recursive calls as one!) 
\end_layout

\begin_layout Standard
What if our recursive code cannot be transformed into tail-recursive code
 via the accumulator trick, but the depth of the recursion is so large that
 stack overflows are possible? We must then use more advanced tricks (for
 instance, the 
\begin_inset Quotes eld
\end_inset

continuation-passing
\begin_inset Index idx
status open

\begin_layout Plain Layout
continuation-passing
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

trampolines
\begin_inset Index idx
status open

\begin_layout Plain Layout
trampolines
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) that convert non-tail-recursive code into iterative code without stack
 overflows.
 These tricks are beyond the scope of this chapter.
\end_layout

\begin_layout Subsection
Solved examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute the smallest 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $f(f(f(...f(1)...)\geq1000$
\end_inset

, where the function 
\begin_inset Formula $f$
\end_inset

 is applied 
\begin_inset Formula $n$
\end_inset

 times.
 Write this as a function taking 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $1$
\end_inset

, and 
\begin_inset Formula $1000$
\end_inset

 as arguments.
 Test with 
\begin_inset Formula $f(x)=2x+1$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
We define a stream of values 
\begin_inset Formula $\left[1,f(1),f(f(1)),...\right]$
\end_inset

 and use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.takeWhile
\end_layout

\end_inset

 to stop the stream when the given condition holds.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.length
\end_layout

\end_inset

 method then gives the length of the resulting sequence: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Stream.iterate(1)(x => 2*x+1).takeWhile(x => x < 1000).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 3, 7, 15, 31, 63, 127, 255, 511)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Stream.iterate(1)(x => 2*x+1).takeWhile(x => x < 1000).length
\end_layout

\begin_layout Plain Layout

res1: Int = 9
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 For a given stream of integers, compute the stream of the largest values
 seen so far.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Compute the stream of 
\begin_inset Formula $k$
\end_inset

 largest values seen so far (
\begin_inset Formula $k$
\end_inset

 is a given integer parameter).
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
We cannot use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

 or sort the entire stream, since the length of the stream is not known
 in advance.
 So we need to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.scanLeft
\end_layout

\end_inset

, which will build the output stream one element at a time.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Maintain the largest value seen so far in the accumulator of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.scanLeft
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def maxSoFar(xs: Stream[Int]): Stream[Int] =
\end_layout

\begin_layout Plain Layout

  xs.scanLeft(xs.head){ case (max, x) => math.max(max, x) }
\end_layout

\begin_layout Plain Layout

    .drop(1)
\end_layout

\end_inset

We use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.drop(1)
\end_layout

\end_inset

 to remove the initial value, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.head
\end_layout

\end_inset

, because it is not useful for our result but is necessary for the definition
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.scanLeft
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To test this function, let us define a stream whose values go up and down:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = Stream.iterate(0)(x => 1 - 2*x)
\end_layout

\begin_layout Plain Layout

s: Stream[Int] = Stream(0, ?)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s.take(10).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(0, 1, -1, 3, -5, 11, -21, 43, -85, 171)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maxSoFar(s).take(10).toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(0, 1, 1, 3, 3, 11, 11, 43, 43, 171)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We again use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.scanLeft
\end_layout

\end_inset

, where now the accumulator needs to keep the largest 
\begin_inset Formula $k$
\end_inset

 values seen so far.
 There are two ways of maintaining this accumulator: First, to have a sequence
 of 
\begin_inset Formula $k$
\end_inset

 values that we sort and truncate each time.
 Second, to use a specialized data structure such as a priority queue that
 automatically keeps values sorted and its length bounded.
 For the purposes of this tutorial, let us avoid using specialized data
 structures:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def maxKSoFar(xs: Stream[Int], k: Int): Stream[Seq[Int]] = {
\end_layout

\begin_layout Plain Layout

  // The initial value of the accumulator is an empty Seq() of type Seq[Int].
\end_layout

\begin_layout Plain Layout

  xs.scanLeft(Seq[Int]()) { case (seq, x) =>
\end_layout

\begin_layout Plain Layout

  // Sort in the descending order, and take the first k values.
\end_layout

\begin_layout Plain Layout

    (seq :+ x).sorted.reverse.take(k)
\end_layout

\begin_layout Plain Layout

  }.drop(1) // Skip the useless first value.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maxKSoFar(s, 3).take(10).toList
\end_layout

\begin_layout Plain Layout

res2: List[Seq[Int]] = List(List(0), List(1, 0), List(1, 0, -1), List(3,
 1, 0), List(3, 1, 0), List(11, 3, 1), List(11, 3, 1), List(43, 11, 3),
 List(43, 11, 3), List(171, 43, 11)) 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find the last element of a non-empty sequence.
 (Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.reduce
\end_layout

\end_inset

.)
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
This function is available in the Scala library as the standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.last
\end_layout

\end_inset

 on sequences.
 Here we need to re-implement it using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.reduce
\end_layout

\end_inset

.
 Begin by writing an inductive definition:
\end_layout

\begin_layout Itemize
(Base case.) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

last(Seq(x)) = x
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
(Inductive step.) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

last(Seq(x) ++ xs) = last(xs)
\end_layout

\end_inset

 assuming 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 is non-empty.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.reduce
\end_layout

\end_inset

 method implements an inductive aggregation similarly to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

, except that for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.reduce
\end_layout

\end_inset

 the base case is fixed â€“ it always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 for a 1-element sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x)
\end_layout

\end_inset

.
 This is exactly what we need here, so the inductive definition is directly
 translated into code, with the updater function 
\begin_inset Formula $g(x,y)=y$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def last[A](xs: Seq[A]): A = xs.reduce { case (x, y) => y }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-binary-search-seq-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-binary-search-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Using tail recursion, implement the binary search algorithm in a given
 sorted sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs: Seq[Int]
\end_layout

\end_inset

 as a function returning the index of the requested number 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 (assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 contains the number 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def binSearch(xs: Seq[Int], goal: Int): Int = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> binSearch(Seq(1, 3, 5, 7), 5)
\end_layout

\begin_layout Plain Layout

res0: Int = 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Re-implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

binSearch
\end_layout

\end_inset

 using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 instead of explicit recursion.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The well-known binary search algorithm splits the array into two halves
 and may continue the search recursively in one of the halves.
 We need to write the solution as a tail-recursive function with an additional
 accumulator argument.
 So we expect that the code should look like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def binSearch(xs: Seq[Int], goal: Int, acc: _ = ???): Int = {
\end_layout

\begin_layout Plain Layout

  if (???are we done???) acc
\end_layout

\begin_layout Plain Layout

  else {
\end_layout

\begin_layout Plain Layout

    // Determine which half of the sequence contains `goal`.
\end_layout

\begin_layout Plain Layout

    // Then update the accumulator accordingly.
\end_layout

\begin_layout Plain Layout

    val newAcc = ???
\end_layout

\begin_layout Plain Layout

    binSearch(xs, goal, newAcc) // Tail-recursive call.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It remains to determine the type and the initial value of the accumulator,
 as well as the code for updating it.
\end_layout

\begin_layout Standard
The information required for the recursive call is the remaining segment
 of the sequence where the target number is present.
 This segment is defined by two indices 
\begin_inset Formula $i$
\end_inset

, 
\begin_inset Formula $j$
\end_inset

 representing the left and the right bounds of the sub-sequence, such that
 the target element is 
\begin_inset Formula $x_{n}$
\end_inset

 with 
\begin_inset Formula $x_{i}\leq x_{n}<x_{j-1}$
\end_inset

.
 It follows that the accumulator should be a pair of two integers 
\begin_inset Formula $\left(i,j\right)$
\end_inset

.
 The initial value of the accumulator is the pair 
\begin_inset Formula $\left(0,N\right)$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is the length of the entire sequence.
 The search is finished when 
\begin_inset Formula $i+1=j$
\end_inset

.
 We can now write the corresponding code, where for convenience we introduce
 
\emph on
two
\emph default
 accumulator values:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def binSearch(xs: Seq[Int], goal: Int)(left: Int = 0,
\end_layout

\begin_layout Plain Layout

                       right: Int = xs.length): Int = {
\end_layout

\begin_layout Plain Layout

  // Check whether `goal` is at one of the boundaries.
\end_layout

\begin_layout Plain Layout

  if (right - left <= 1 || xs(left) == goal) left
\end_layout

\begin_layout Plain Layout

  else {
\end_layout

\begin_layout Plain Layout

    val middle = (left + right) / 2
\end_layout

\begin_layout Plain Layout

    // Determine which half of the array contains `target`.
\end_layout

\begin_layout Plain Layout

    // Update the accumulator accordingly.
\end_layout

\begin_layout Plain Layout

    val (newLeft, newRight) =
\end_layout

\begin_layout Plain Layout

      if (goal < xs(middle)) (left, middle)
\end_layout

\begin_layout Plain Layout

      else (middle, right)
\end_layout

\begin_layout Plain Layout

    binSearch(xs, goal)(newLeft, newRight) // Tail-recursive call.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> binSearch(0 to 10, 3)() // Default accumulator values.
\end_layout

\begin_layout Plain Layout

res0: Int = 3
\end_layout

\end_inset

Here we used a feature of Scala that allows us to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.length
\end_layout

\end_inset

 as a default value for the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

right
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

binSearch
\end_layout

\end_inset

.
 This is possible only because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

right
\end_layout

\end_inset

 is in a different 
\series bold
argument group
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
argument group
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
 In Scala, values in an argument group may depend on arguments given in
 a 
\emph on
previous
\emph default
 argument group.
 However, the code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def binSearch(xs: Seq[Int], goal: Int, left: Int = 0, right: Int = xs.length)
\end_layout

\end_inset

will generate an error: the arguments in the same argument group cannot
 depend on each other.
 (The error will say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

not found: value xs
\end_layout

\end_inset

.)
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We can visualize the binary search as a procedure that generates a sequence
 of progressively tighter bounds for the location of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

goal
\end_layout

\end_inset

.
 The initial bounds are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(0, xs.length)
\end_layout

\end_inset

, and the final bounds are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k, k+1)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

.
 We can generate the sequence of bounds using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 and stop the sequence when the bounds become sufficiently tight.
 To make the use of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.takeWhile
\end_layout

\end_inset

 more convenient, we add an extra sequence element where the bounds 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k, k)
\end_layout

\end_inset

 are equal.
 The code becomes
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def binSearch(xs: Seq[Int], goal: Int): Int = {
\end_layout

\begin_layout Plain Layout

  type Acc = (Int, Int)
\end_layout

\begin_layout Plain Layout

  val init: Acc = (0, xs.length)
\end_layout

\begin_layout Plain Layout

  val updater: Acc => Acc = { case (left, right) =>
\end_layout

\begin_layout Plain Layout

    if (right - left <= 1) (left, left) // Extra element.
\end_layout

\begin_layout Plain Layout

    else if (xs(left) == goal) (left, left + 1)
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      val middle = (left + right) / 2
\end_layout

\begin_layout Plain Layout

      // Determine which half of the array contains `target`.
\end_layout

\begin_layout Plain Layout

      // Update the accumulator accordingly.
\end_layout

\begin_layout Plain Layout

      if (goal < xs(middle)) (left, middle)
\end_layout

\begin_layout Plain Layout

      else (middle, right)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Stream.iterate(init)(updater)
\end_layout

\begin_layout Plain Layout

    .takeWhile{ case (left, right) => right > left }
\end_layout

\begin_layout Plain Layout

    .last._1 // Take the `left` boundary from the last element.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code is clearer because recursion is delegated to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

, and we only need to write the 
\begin_inset Quotes eld
\end_inset

business logic
\begin_inset Quotes erd
\end_inset

 (i.e.
\begin_inset space ~
\end_inset

the base case and the inductive step) of our function.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2sumdigitsExample-seq-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2sumdigitsExample-seq-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given positive 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n:Int
\end_layout

\end_inset

, compute the sequence 
\begin_inset Formula $\left[s_{0},s_{1},s_{2},...\right]$
\end_inset

 defined by 
\begin_inset Formula $s_{0}=SD(n)$
\end_inset

 and 
\begin_inset Formula $s_{k}=SD(s_{k-1})$
\end_inset

 for 
\begin_inset Formula $k>0$
\end_inset

, where 
\begin_inset Formula $SD(x)$
\end_inset

 is the sum of the decimal digits of the integer 
\begin_inset Formula $x$
\end_inset

, e.g.
 
\begin_inset Formula $SD(123)=6$
\end_inset

.
 Stop the sequence 
\begin_inset Formula $s_{i}$
\end_inset

 when the numbers begin repeating.
 For example, 
\begin_inset Formula $SD(99)=18$
\end_inset

, 
\begin_inset Formula $SD(18)=9$
\end_inset

, 
\begin_inset Formula $SD(9)=9$
\end_inset

.
 So, for 
\begin_inset Formula $n=99$
\end_inset

, the sequence 
\begin_inset Formula $s_{i}$
\end_inset

 must be computed as 
\begin_inset Formula $\left[99,18,9\right]$
\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

; compute the decimal digits in the reverse order since the sum will be
 the same.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
We need to implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sdSeq
\end_layout

\end_inset

 having the type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sdSeq(n: Int): Seq[Int]
\end_layout

\end_inset

First we need to implement 
\begin_inset Formula $SD(x)$
\end_inset

.
 The sum of digits is obtained by almost the same code as in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ch2Converting-a-single"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def SD(n: Int): Int = if (n == 0) 0 else
\end_layout

\begin_layout Plain Layout

  Stream.iterate(n)(_ / 10).takeWhile(_ != 0).map(_ % 10).sum
\end_layout

\end_inset

Now we can try evaluating 
\begin_inset Formula $SD$
\end_inset

 on some numbers to see its behavior:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 15).toList.map(SD)
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6)
\end_layout

\end_inset

It is clear that 
\begin_inset Formula $SD(n)<n$
\end_inset

 as long as 
\begin_inset Formula $n\geq10$
\end_inset

.
 So the sequence elements 
\begin_inset Formula $s_{i}$
\end_inset

 will not repeat until they become smaller than 
\begin_inset Formula $10$
\end_inset

, and then they will always repeat.
 This seems to be an easy way of stopping the sequence.
 Let us try that:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Stream.iterate(99)(SD).takeWhile(x => x >= 10).toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(99, 18)
\end_layout

\end_inset

We are missing the last element of the sequence, 
\begin_inset Formula $SD(18)=9$
\end_inset

, because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.takeWhile
\end_layout

\end_inset

 stops the sequence too early.
 In order to obtain the correct sequence, we need to compute one more element.
 To fix this, we can generate a stream of 
\emph on
pairs
\emph default
:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Stream.iterate((0, 99)){ case (prev, x) => (x, SD(x)) }.
\end_layout

\begin_layout Plain Layout

  takeWhile{ case (prev, x) => prev >= 10 || x >= 10 }.toList
\end_layout

\begin_layout Plain Layout

res2: List[(Int, Int)] = List((0,99), (99,18), (18,9))
\end_layout

\end_inset

This looks right; it remains to remove the first parts of the tuples:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sdSeq(n: Int): Seq[Int] =
\end_layout

\begin_layout Plain Layout

  Stream.iterate((0, n)){ case (prev, x) => (x, SD(x)) } // Stream[(Int,
 Int)]
\end_layout

\begin_layout Plain Layout

    .takeWhile{ case (prev, x) => prev >= 10 || x >= 10 } // Stream[(Int,
 Int)]
\end_layout

\begin_layout Plain Layout

    .map(_._2) // Stream[Int]
\end_layout

\begin_layout Plain Layout

    .toList // List[Int]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> sdSeq(99)
\end_layout

\begin_layout Plain Layout

res3: Seq[Int] = List(99, 18, 9)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given stream 
\begin_inset Formula $\left[s_{0},s_{1},s_{2},...\right]$
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream[T]
\end_layout

\end_inset

, compute the 
\begin_inset Quotes eld
\end_inset

half-speed
\begin_inset Quotes erd
\end_inset

 stream 
\begin_inset Formula $h=\left[s_{0},s_{0},s_{1},s_{1},s_{2},s_{2},...\right]$
\end_inset

.
 (The half-speed sequence 
\begin_inset Formula $h$
\end_inset

 can be defined by the formula 
\begin_inset Formula $s_{k}=h_{2k}=h_{2k+1}$
\end_inset

.)
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
We use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 to replace each element 
\begin_inset Formula $s_{i}$
\end_inset

 by a sequence containing two copies of 
\begin_inset Formula $s_{i}$
\end_inset

.
 Let us try this on a sample sequence:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1,2,3).map( x => Seq(x, x))
\end_layout

\begin_layout Plain Layout

res0: Seq[Seq[Int]] = List(List(1, 1), List(2, 2), List(3, 3))
\end_layout

\end_inset

The result is almost what we need, except we need to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 the nested list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1,2,3).map( x => Seq(x, x)).flatten
\end_layout

\begin_layout Plain Layout

res1: Seq[Seq[Int]] = List(1, 1, 2, 2, 3, 3)
\end_layout

\end_inset

The composition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatten
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

, so the final code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def halfSpeed[T](str: Stream[T]): Stream[T] = str.flatMap(x => Seq(x, x))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> halfSpeed(Seq(1,2,3).toStream)
\end_layout

\begin_layout Plain Layout

res2: Stream[Int] = Stream(1, ?)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> halfSpeed(Seq(1,2,3).toStream).toList
\end_layout

\begin_layout Plain Layout

res3: List[Int] = List(1, 1, 2, 2, 3, 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Stop a given stream 
\begin_inset Formula $\left[s_{0},s_{1},s_{2},...\right]$
\end_inset

 at a place 
\begin_inset Formula $k$
\end_inset

 where the sequence repeats itself; that is, an element 
\begin_inset Formula $s_{k}$
\end_inset

 equals some earlier element 
\begin_inset Formula $s_{i}$
\end_inset

 with 
\begin_inset Formula $i<k$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
The trick is to create a half-speed sequence 
\begin_inset Formula $h_{i}$
\end_inset

 out of 
\begin_inset Formula $s_{i}$
\end_inset

 and then find an index 
\begin_inset Formula $k>0$
\end_inset

 such that 
\begin_inset Formula $h_{k}=s_{k}$
\end_inset

.
 (The condition 
\begin_inset Formula $k>0$
\end_inset

 is needed because we will always have 
\begin_inset Formula $h_{0}=s_{0}$
\end_inset

.) If we find such an index 
\begin_inset Formula $k$
\end_inset

, it would mean that either 
\begin_inset Formula $s_{k}=s_{k/2}$
\end_inset

 or 
\begin_inset Formula $s_{k}=s_{\left(k-1\right)/2}$
\end_inset

; in either case, we will have found an element 
\begin_inset Formula $s_{k}$
\end_inset

 that equals an earlier element.
 
\end_layout

\begin_layout Standard
As an example, take 
\begin_inset Formula $s=\left[1,3,5,7,9,3,5,7,9,...\right]$
\end_inset

 and compute the half-speed sequence 
\begin_inset Formula $h=\left[1,1,3,3,5,5,7,7,9,9,3,3,...\right]$
\end_inset

.
 Looking for an index 
\begin_inset Formula $k>0$
\end_inset

 such that 
\begin_inset Formula $h_{k}=s_{k}$
\end_inset

, we find that 
\begin_inset Formula $s_{7}=h_{7}=7$
\end_inset

.
 This is indeed an element of 
\begin_inset Formula $s_{i}$
\end_inset

 that repeats an earlier element (although 
\begin_inset Formula $s_{7}$
\end_inset

 is not the first such repetition).
\end_layout

\begin_layout Standard
There are in principle two ways of finding an index 
\begin_inset Formula $k>0$
\end_inset

 such that 
\begin_inset Formula $h_{k}=s_{k}$
\end_inset

: First, to iterate over a list of indices 
\begin_inset Formula $k=1,2,...$
\end_inset

 and evaluate the condition 
\begin_inset Formula $h_{k}=s_{k}$
\end_inset

 as a function of 
\begin_inset Formula $k$
\end_inset

.
 Second, to build a sequence of pairs 
\begin_inset Formula $\left(h_{i},s_{i}\right)$
\end_inset

 and use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.takeWhile
\end_layout

\end_inset

 to stop at the required index.
 In the present case, we cannot use the first way because we do not have
 a fixed set of indices to iterate over.
 Also, the condition 
\begin_inset Formula $h_{k}=s_{k}$
\end_inset

 cannot be directly evaluated as a function of 
\begin_inset Formula $k$
\end_inset

 because 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $h$
\end_inset

 are streams that compute elements on demand, not lists whose elements are
 computed in advance and ready to be used.
 
\end_layout

\begin_layout Standard
So the code must iterate over a stream of pairs 
\begin_inset Formula $\left(h_{i},s_{i}\right)$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def stopRepeats[T](str: Stream[T]): Stream[T] = {
\end_layout

\begin_layout Plain Layout

  val halfSpeed = str.flatMap(x => Seq(x, x))
\end_layout

\begin_layout Plain Layout

  val result = halfSpeed.zip(str) // Stream[(T, T)]
\end_layout

\begin_layout Plain Layout

  .drop(1) // Enforce the condition k > 0.
\end_layout

\begin_layout Plain Layout

  .takeWhile { case (h, s) => h != s } // Stream[(T, T)]
\end_layout

\begin_layout Plain Layout

  .map(_._2) // Stream[T]
\end_layout

\begin_layout Plain Layout

  str.head +: result // Prepend the first element that was dropped.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> stopRepeats(Seq(1, 3, 5, 7, 9, 3, 5, 7, 9).toStream).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 3, 5, 7, 9, 3, 5)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Reverse each word in a string, but keep the order of words:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def revWords(s: String): String = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> revWords(
\begin_inset Quotes eld
\end_inset

A quick brown fox
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res0: String = A kciuq nworb xof
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
The standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.split
\end_layout

\end_inset

 converts a string into an array of words:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> "pa re ci vo mu".split(" ")
\end_layout

\begin_layout Plain Layout

res0: Array[String] = Array(pa, re, ci, vo, mu)
\end_layout

\end_inset

Each word is reversed with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.reverse
\end_layout

\end_inset

; the resulting array is concatenated into a string with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.mkString
\end_layout

\end_inset

.
 So the code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def revWords(s: String): String = s.split(
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

).map(_.reverse).mkString(
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Remove adjacent repeated characters from a string:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def noDups(s: String): String = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> noDups(
\begin_inset Quotes eld
\end_inset

abbcdeeeeefddgggggh
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res0: String = abcdefdgh
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
A string is automatically converted into a sequence of characters when we
 use methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.zip
\end_layout

\end_inset

 on it.
 So, we can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.zip(s.tail)
\end_layout

\end_inset

 to get a sequence of pairs 
\begin_inset Formula $\left(s_{k},s_{k+1}\right)$
\end_inset

 where 
\begin_inset Formula $c_{k}$
\end_inset

 is the 
\begin_inset Formula $k$
\end_inset

-th character of the string 
\begin_inset Formula $s$
\end_inset

.
 Now we can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 to remove the elements 
\begin_inset Formula $s_{k}$
\end_inset

 for which 
\begin_inset Formula $s_{k+1}=s_{k}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = "abbcd"
\end_layout

\begin_layout Plain Layout

s: String = abbcd
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s.zip(s.tail).filter { case (sk, skPlus1) => sk != skPlus1 }
\end_layout

\begin_layout Plain Layout

res0: IndexedSeq[(Char, Char)] = Vector((a,b), (b,c), (c,d))
\end_layout

\end_inset

It remains to convert this sequence of pairs into the string 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

abcd
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

.
 One way of doing this is to project the sequence of pairs onto the second
 parts of the pairs,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> res0.map(_._2).mkString
\end_layout

\begin_layout Plain Layout

res1: String = bcd
\end_layout

\end_inset

We just need to add the first character, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'a'
\end_layout

\end_inset

.
 The resulting code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def noDups(s: String): String = if (s == 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

) 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

 else {
\end_layout

\begin_layout Plain Layout

  val pairs = s.zip(s.tail).filter { case (x, y) => x != y }
\end_layout

\begin_layout Plain Layout

  pairs.head._1 +: pairs.map(_._2).mkString
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+:
\end_layout

\end_inset

 prepends an element to a sequence, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x +: xs
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x) ++ xs
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Count the occurrences of each distinct word in a string:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countWords(s: String): Map[String, Int] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> countWords(
\begin_inset Quotes eld
\end_inset

a quick a quick a fox
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res0: Map[String, Int] = Map(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 -> 3, 
\begin_inset Quotes eld
\end_inset

quick
\begin_inset Quotes erd
\end_inset

 -> 2, 
\begin_inset Quotes eld
\end_inset

fox
\begin_inset Quotes erd
\end_inset

 -> 1)
\end_layout

\end_inset


\series bold
(b)
\series default
 Count the occurrences of each distinct element in a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 We split the string into an array of words via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.split(
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

)
\end_layout

\end_inset

, and apply a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 to that array, since the computation is a kind of aggregation over the
 array of words.
 The accumulator of the aggregation will be the dictionary of word counts
 for all the words seen so far:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countWords(s: String): Map[String, Int] = {
\end_layout

\begin_layout Plain Layout

  val init: Map[String, Int] = Map()
\end_layout

\begin_layout Plain Layout

  s.split(
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

).foldLeft(init) { (dict, word) =>
\end_layout

\begin_layout Plain Layout

    val newCount = dict.getOrElse(word, 0) + 1
\end_layout

\begin_layout Plain Layout

    dict.updated(word, newCount)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\series bold
(b)
\series default
 The main code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

countWords
\end_layout

\end_inset

 does not depend on the fact that words are of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 It will work in the same way for any other type of keys for the dictionary.
 So we keep the same code and define the type signature of the function
 to contain a type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countValues[A](xs: Seq[A]): Map[A, Int] =
\end_layout

\begin_layout Plain Layout

  xs.foldLeft(Map[A, Int]()) { (dict, word) =>
\end_layout

\begin_layout Plain Layout

    val newCount = dict.getOrElse(word, 0) + 1
\end_layout

\begin_layout Plain Layout

    dict.updated(word, newCount)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> countValues(Seq(100, 100, 200, 100, 200, 200, 100))
\end_layout

\begin_layout Plain Layout

res0: Map[Int,Int] = Map(100 -> 4, 200 -> 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-10-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-10-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

, find the longest subsequence that does not contain any adjacent duplicate
 values.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def longestNoDups[A](xs: Seq[A]): Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> longestNoDups(Seq(1, 2, 2, 5, 4, 4, 4, 8, 2, 3, 3))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(4, 8, 2, 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
This is a dynamic programming problem.
 Many such problems are solved with a single 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

.
 The accumulator represents the current 
\begin_inset Quotes eld
\end_inset

state
\begin_inset Quotes erd
\end_inset

 of the dynamic programming solution, and the 
\begin_inset Quotes eld
\end_inset

state
\begin_inset Quotes erd
\end_inset

 is updated with each new element of the input sequence.
\end_layout

\begin_layout Standard
To obtain the solution, we first need to determine the type of the accumulator
 value, or the 
\begin_inset Quotes eld
\end_inset

state
\begin_inset Quotes erd
\end_inset

.
 The task is to find the longest subsequence without adjacent duplicates.
 So the accumulator should represent the longest subsequence found so far,
 as well as any required extra information about other subsequences that
 might grow as we iterate over the elements of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
 What is this extra information in our case? 
\end_layout

\begin_layout Standard
Imagine that we wanted to build set of 
\emph on
all
\emph default
 subsequences without adjacent duplicates.
 In the example where the input sequence is 
\begin_inset Formula $\left[1,2,2,5,4,4,4,8,2,3,3\right]$
\end_inset

, this set of subsequences should be 
\begin_inset Formula $\left\{ \left[1,2\right],\left[2,5,4\right],\left[4,8,2,3\right]\right\} $
\end_inset

.
 We can build this set incrementally in the accumulator value of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

.
 To visualize how this set would be built, consider the partial result after
 seeing the first 
\begin_inset Formula $8$
\end_inset

 elements of the input sequence, 
\begin_inset Formula $\left[1,2,2,5,4,4,4,8\right]$
\end_inset

.
 The partial set of non-repeating subsequences is 
\begin_inset Formula $\left\{ \left[1,2\right],\left[2,5,4\right],\left[4,8\right]\right\} $
\end_inset

.
 As we add another element, 
\begin_inset Formula $2$
\end_inset

, we update the partial set to 
\begin_inset Formula $\left\{ \left[1,2\right],\left[2,5,4\right],\left[4,8,2\right]\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
It is now clear that the subsequence 
\begin_inset Formula $\left[1,2\right]$
\end_inset

 has no chance of being the longest subsequence, since 
\begin_inset Formula $\left[2,5,4\right]$
\end_inset

 is already longer.
 However, we do not yet know whether 
\begin_inset Formula $\left[2,5,4\right]$
\end_inset

 or 
\begin_inset Formula $\left[4,8,2\right]$
\end_inset

 is the winner, because the subsequence 
\begin_inset Formula $\left[4,8,2\right]$
\end_inset

 could still grow and become the longest one (and it does become 
\begin_inset Formula $\left[4,8,2,3\right]$
\end_inset

 later).
 At this point, we need to keep both of these two subsequences in the accumulato
r, but we may already discard 
\begin_inset Formula $\left[1,2\right]$
\end_inset

.
\end_layout

\begin_layout Standard
We have deduced that the accumulator needs to keep only 
\emph on
two
\emph default
 sequences: the first sequence is already terminated and will not grow,
 the second sequence ends with the current element and may yet grow.
 The initial value of the accumulator is empty.
 The first subsequence is discarded when it becomes shorter than the second.
 The code can be written now:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def longestNoDups[A](xs: Seq[A]): Seq[A] = {
\end_layout

\begin_layout Plain Layout

  val init: (Seq[A], Seq[A]) = (Seq(), Seq())
\end_layout

\begin_layout Plain Layout

  val (first, last) = xs.foldLeft(init) { case ((first, current), x) =>
\end_layout

\begin_layout Plain Layout

    // If `current` is empty, `x` cannot be repeated.
\end_layout

\begin_layout Plain Layout

    val xWasRepeated = current != Seq() && current.last == x
\end_layout

\begin_layout Plain Layout

    val firstIsLongerThanCurrent = first.length > current.length
\end_layout

\begin_layout Plain Layout

    // Compute the new pair `(first, current)`.
\end_layout

\begin_layout Plain Layout

    // Keep `first` only if it is longer; otherwise replace it by `current`.
\end_layout

\begin_layout Plain Layout

    val newFirst = if (firstIsLongerThanCurrent) first else current
\end_layout

\begin_layout Plain Layout

    // Append `x` to `current` if `x` is not repeated.
\end_layout

\begin_layout Plain Layout

    val newCurrent = if (xWasRepeated) Seq(x) else current :+ x
\end_layout

\begin_layout Plain Layout

    (newFirst, newCurrent)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  // Return the longer of the two subsequences; prefer `first`.
\end_layout

\begin_layout Plain Layout

  if (first.length >= last.length) first else last
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exercises
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute the sum of squared digits of a given integer; e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

dsq(123) = 14
\end_layout

\end_inset

 (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2sumdigitsExample-seq-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Generalize the solution to take an arbitrary function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f : Int => Int
\end_layout

\end_inset

 as a parameter, instead of the squaring operation.
 The type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsMapSum(x: Int)(f: Int => Int): Int = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsMap(123){ x => x * x }
\end_layout

\begin_layout Plain Layout

res0: Int = 14
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsMap(123){ x => x * x * x }
\end_layout

\begin_layout Plain Layout

res1: Int = 36
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute the 
\series bold
Collatz sequence
\begin_inset Index idx
status open

\begin_layout Plain Layout
Collatz sequence
\end_layout

\end_inset


\series default
 
\begin_inset Formula $c_{i}$
\end_inset

 as a stream defined by
\begin_inset Formula 
\[
c_{0}=n\quad;\quad\quad c_{k+1}=\begin{cases}
\frac{c_{k}}{2} & \text{if }c_{k}\text{ is even,}\\
3c_{k}+1 & \text{if }c_{k}\text{ is odd.}
\end{cases}
\]

\end_inset

Stop the stream when it reaches 
\begin_inset Formula $1$
\end_inset

 (
\begin_inset CommandInset href
LatexCommand href
name "as one would expect"
target "https://en.wikipedia.org/wiki/Collatz_conjecture"
literal "false"

\end_inset

 it will).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given integer 
\begin_inset Formula $n$
\end_inset

, compute the sum of cubed digits, then the sum of cubed digits of the result,
 etc.; stop the resulting sequence when it repeats itself, and so determine
 whether it ever reaches 
\begin_inset Formula $1$
\end_inset

.
 (Use Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cubes(n: Int): Stream[Int] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cubes(123).take(10).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(123, 36, 243, 99, 1458, 702, 351, 153, 153, 153)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cubes(2).take(10).toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(2, 8, 512, 134, 92, 737, 713, 371, 371, 371)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cubes(4).take(10).toList
\end_layout

\begin_layout Plain Layout

res2: List[Int] = List(4, 64, 280, 520, 133, 55, 250, 133, 55, 250)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def cubesReach1(n: Int): Boolean = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cubesReach1(10)
\end_layout

\begin_layout Plain Layout

res3: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cubesReach1(4)
\end_layout

\begin_layout Plain Layout

res4: Boolean = false
\end_layout

\end_inset


\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsOf(n: Int): Seq[Int] = Stream.iterate(n)(_ / 10).takeWhile(_ !=
 0).map(_ % 10).toList
\end_layout

\begin_layout Plain Layout

def cubeDigits(n: Int): Int = digitsOf(n).map(x => x*x*x).sum
\end_layout

\begin_layout Plain Layout

def cubes(n: Int): Stream[Int] = Stream.iterate(n)(cubeDigits)
\end_layout

\begin_layout Plain Layout

def stopRepeats[T](str: Stream[T]): Stream[T] = {
\end_layout

\begin_layout Plain Layout

  val halfSpeed = str.flatMap(x => Seq(x, x))
\end_layout

\begin_layout Plain Layout

  val result = halfSpeed.zip(str).drop(1).takeWhile{ case (h, s) => h != s
 }.map(_._2)
\end_layout

\begin_layout Plain Layout

  if (result.isEmpty) str.take(1) else str
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def cubesReach1(n: Int): Boolean = stopRepeats(cubes(n)).contains(1)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set[Int]
\end_layout

\end_inset

, compute the set of all sets of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set(x, y, z)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prod3(a: Set[Int], b: Set[Int], c: Set[Int]): Set[Set[Int]] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> prod3(Set(1,2), Set(3), Set(4,5))
\end_layout

\begin_layout Plain Layout

res0: Set[Set[Int]] = Set(Set(1,3,4), Set(1,3,5), Set(2,3,4), Set(2,3,5))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prod3(a: Set[Int], b: Set[Int], c: Set[Int]): Set[Set[Int]] =     a.flatMap(x
 => b.flatMap(y => c.map(z => Set(x, y, z))))
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Same task as in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a set of sets, i.e.
\begin_inset space ~
\end_inset

given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set[Set[Int]]
\end_layout

\end_inset

 instead of just three sets 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prodSet(si: Set[Set[Int]]): Set[Set[Int]] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> prodSet(Set(Set(1,2), Set(3), Set(4,5), Set(6)))
\end_layout

\begin_layout Plain Layout

res0: Set[Set[Int]] = Set(Set(1,3,4,6),Set(1,3,5,6),Set(2,3,4,6),Set(2,3,5,6))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prodSet(sets: Set[Set[Int]]): Set[Set[Int]] =     sets.foldLeft(Set[Set[Int]]
(Set())) {
\end_layout

\begin_layout Plain Layout

      // Combine each of results so far with each element in current set
\end_layout

\begin_layout Plain Layout

      case (accumSet: Set[Set[Int]], currSet: Set[Int]) =>
\end_layout

\begin_layout Plain Layout

        for {
\end_layout

\begin_layout Plain Layout

          s <- accumSet
\end_layout

\begin_layout Plain Layout

          i <- currSet
\end_layout

\begin_layout Plain Layout

        } yield s + i
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
In a sorted array 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs:Array[Int]
\end_layout

\end_inset

 where no values are repeated, find all pairs of values whose sum equals
 a given number 
\begin_inset Formula $n$
\end_inset

.
 Use tail recursion.
 A possible type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pairs(goal: Int, xs: Array[Int]): Set[(Int, Int)] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> pairs(10, Array(1, 2, 3, 4, 5, 6, 7, 8))()
\end_layout

\begin_layout Plain Layout

res0: Set[(Int, Int)] = Set((2,8), (3,7), (4,6), (5,5))
\end_layout

\end_inset


\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def pairs(goal: Int, xs: Array[Int])(res: Set[(Int, Int)] = Set(),
 left: Int = 0, right: Int = xs.length): Set[(Int, Int)] = if (left == right)
 res else {
\end_layout

\begin_layout Plain Layout

  val sum = xs(left) + xs(right - 1)
\end_layout

\begin_layout Plain Layout

  val (newLeft, newRight, newRes) = if (sum == goal) (left + 1, right, res
 + ((xs(left), xs(right - 1)))) else if (sum < goal) (left + 1, right, res)
 else (left, right - 1, res)
\end_layout

\begin_layout Plain Layout

  pairs(goal, xs)(newRes, newLeft, newRight)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Reverse a sentence's word order, but keep the words unchanged:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def revSentence(s: String): String = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> revSentence(
\begin_inset Quotes eld
\end_inset

A quick brown fox
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res0: String = 
\begin_inset Quotes eld
\end_inset

fox brown quick A
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2revdigits-Exercise-seq-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2revdigits-Exercise-seq-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Reverse an integer's digits (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2sumdigitsExample-seq-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as shown:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def revDigits(n: Int): Int = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> revDigits(12345)
\end_layout

\begin_layout Plain Layout

res0: Int = 54321
\end_layout

\end_inset

A 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
palindrome number
\end_layout

\end_inset

palindrome number
\series default
 is an integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 such that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

revDigits(n) == n
\end_layout

\end_inset

.
 Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Boolean
\end_layout

\end_inset

 that checks whether a given positive integer is a palindrome.
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsOf(n: Int): Seq[Int] = Stream.iterate(n)(_ / 10).takeWhile(_ !=
 0).map(_ % 10).toList
\end_layout

\begin_layout Plain Layout

def revDigits(n: Int): Int = digitsOf(n).foldLeft(0){case (acc, d) => acc*10+d
 }
\end_layout

\begin_layout Plain Layout

def isPalindrome(n: Int): Boolean = revDigits(n) == n
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Starting from a given integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

, compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

revDigits(n) + n
\end_layout

\end_inset

; the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

revDigits
\end_layout

\end_inset

 was defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2revdigits-Exercise-seq-7"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Check whether the result is a palindrome integer.
 If it is not, repeat the same operation until a palindrome number is found,
 and return that number.
 The required type signature and a test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def findPalindrome(n: Int): Int = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> findPalindrome(123)
\end_layout

\begin_layout Plain Layout

res0: Int = 444
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> findPalindrome(83951)
\end_layout

\begin_layout Plain Layout

res1: Int = 869363968
\end_layout

\end_inset


\begin_inset Note Comment
status open

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def findPalindrome(n: Int): Int = Stream.iterate(n){x => x + revDigits(x)}.filter(
isPalindrome).take(1).toList.head
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-8-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-8-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 For a given integer interval 
\begin_inset Formula $\left[n_{1},n_{2}\right]$
\end_inset

, find the largest integer 
\begin_inset Formula $k\in\left[n_{1},n_{2}\right]$
\end_inset

 such that the decimal representation of 
\begin_inset Formula $k$
\end_inset

 does 
\emph on
not
\emph default
 contain any of the digits 
\begin_inset Formula $3$
\end_inset

, 
\begin_inset Formula $5$
\end_inset

, or 
\begin_inset Formula $7$
\end_inset

.
 
\series bold
(b)
\series default
 For a given integer interval 
\begin_inset Formula $\left[n_{1},n_{2}\right]$
\end_inset

, find the integer 
\begin_inset Formula $k\in\left[n_{1},n_{2}\right]$
\end_inset

 with the largest sum of decimal digits.
 
\series bold
(c)
\series default
 A positive integer 
\begin_inset Formula $n$
\end_inset

 is called a 
\series bold
perfect number
\begin_inset Index idx
status open

\begin_layout Plain Layout
perfect number
\end_layout

\end_inset


\series default
 if it is equal to the sum of its divisors (other integers 
\begin_inset Formula $k$
\end_inset

 such that 
\begin_inset Formula $k<n$
\end_inset

 and 
\begin_inset Formula $n/k$
\end_inset

 is an integer).
 For example, 
\begin_inset Formula $6$
\end_inset

 is a perfect number because its divisors are 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, and 
\begin_inset Formula $3$
\end_inset

, and 
\begin_inset Formula $1+2+3=6$
\end_inset

, while 
\begin_inset Formula $8$
\end_inset

 is not a perfect number because its divisors are 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, and 
\begin_inset Formula $4$
\end_inset

, and 
\begin_inset Formula $1+2+4=7\neq8$
\end_inset

.
 Write a function that determines whether a given number 
\begin_inset Formula $n$
\end_inset

 is perfect.
 Determine all perfect numbers up to one million.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Remove adjacent repeated elements from a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 when they are repeated more than 
\begin_inset Formula $k$
\end_inset

 times.
 Repetitions up to 
\begin_inset Formula $k$
\end_inset

 times should remain unchanged.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def removeDups[A](s: Seq[A], k: Int): Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> removeDups(Seq(1, 1, 1, 1, 5, 2, 2, 5, 5, 5, 5, 5, 1), 3)
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(1, 1, 1, 5, 2, 2, 5, 5, 5, 1)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-11"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-11"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Remove repeated elements (whether adjacent or not) from a sequence of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

.
 (This re-implements the standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.distinct
\end_layout

\end_inset

.)
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 For a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

, remove all elements that are repeated (whether adjacent or not) more than
 
\begin_inset Formula $k$
\end_inset

 times:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def removeK[A](k: Int, xs: Seq[A]): Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> removeK(2, Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

res0: Seq[String] = List(a, b, a, b, c)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-10"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
For a given sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs:Seq[Double]
\end_layout

\end_inset

, find a subsequence that has the largest sum of values.
 The sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 is not sorted, and its values may be positive or negative.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def maxsub(xs: Seq[Double]): Seq[Double] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maxsub(Seq(1.0, -1.5, 2.0, 3.0, -0.5, 2.0, 1.0, -10.0, 2.0))
\end_layout

\begin_layout Plain Layout

res0: Seq[Double] = List(2.0, 3.0, -0.5, 2.0, 1.0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use dynamic programming and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.foldLeft
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-12"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-12"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Find all common integers between two sorted sequences:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def commonInt(xs: Seq[Int], ys: Seq[Int]): Seq[Int] = ??? // Use tail recursion.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> commonInt(Seq(1, 3, 5, 7), Seq(2, 3, 4, 6, 7, 8))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(3, 7)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Subsection
Total and partial functions
\end_layout

\begin_layout Standard
In Scala, functions can be total or partial.
 A 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
total function
\end_layout

\end_inset

total
\series default
 function will always compute a result value, while a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
partial function
\end_layout

\end_inset

partial
\series default
 function may fail to compute its result for certain values of its arguments.
\end_layout

\begin_layout Standard
A simple example of a partial function in Scala is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

 method: it only works for non-empty sequences.
 Trying to evaluate it on an empty sequence generates an error called an
 
\begin_inset Quotes eld
\end_inset

exception
\begin_inset Index idx
status open

\begin_layout Plain Layout
exception
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset listings
lstparams "mathescape=false"
inline false
status open

\begin_layout Plain Layout

scala> Seq(1).tail
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List()
\end_layout

\begin_layout Plain Layout

scala> res0.max
\end_layout

\begin_layout Plain Layout

java.lang.UnsupportedOperationException: empty.max
\end_layout

\begin_layout Plain Layout

  at scala.collection.TraversableOnce$class.max(TraversableOnce.scala:229)
\end_layout

\begin_layout Plain Layout

  at scala.collection.AbstractTraversable.max(Traversable.scala:104)
\end_layout

\begin_layout Plain Layout

  ...
 32 elided 
\end_layout

\end_inset

This kind of error may crash the entire program at run time.
 Unlike the type errors
\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

 we saw before, which occur at compilation time (i.e.
\begin_inset space ~
\end_inset

before the program can start), 
\series bold
run-time errors
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
run-time error
\end_layout

\end_inset

 occur while the program is running, and only when some partial function
 happens to get an incorrect input.
 The incorrect input may occur at any point after the program started running,
 which may crash the entire program in the middle of a long computation.
\end_layout

\begin_layout Standard
So, it seems clear that we should write code that does not generate such
 errors.
 For instance, it is safe to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

 to a sequence if we know that it is non-empty.
\end_layout

\begin_layout Standard
Sometimes, a function that uses pattern matching turns out to be a partial
 function because its pattern matching code fails on certain input data.
 
\end_layout

\begin_layout Standard
If a pattern matching expression fails, the code will throw an exception
 and stop running.
 In functional programming, we usually want to avoid this situation because
 it makes it much harder to reason about program correctness.
 In most cases, programs can be written to avoid the possibility of match
 errors.
 An example of an unsafe pattern matching expression is
\begin_inset listings
lstparams "mathescape=false"
inline false
status open

\begin_layout Plain Layout

def h(p: (Int, Int)): Int = p match { case (x, 0) => x }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> h( (1,0) )
\end_layout

\begin_layout Plain Layout

res0: Int = 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> h( (1,2) )
\end_layout

\begin_layout Plain Layout

 scala.MatchError: (1,2) (of class scala.Tuple2$mcII$sp)
\end_layout

\begin_layout Plain Layout

  at .h(<console>:12)
\end_layout

\begin_layout Plain Layout

  ...
 32 elided 
\end_layout

\end_inset

Here the pattern contains a pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and a constant 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
 This pattern only matches tuples whose second part is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
 If the second argument is nonzero, a match error occurs and the program
 crashes.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 is a partial function.
\end_layout

\begin_layout Standard
Pattern matching failures never happen if we match a tuple of correct size
 with a pattern such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y, z)
\end_layout

\end_inset

, because pattern variables will always match whatever values the tuple
 has.
 So, pattern matching with a pattern such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y, z)
\end_layout

\end_inset

 is 
\series bold
infallible
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern matching!infallible
\end_layout

\end_inset

 (never fails at run time) when applied to a tuple with 
\begin_inset Formula $3$
\end_inset

 elements.
\end_layout

\begin_layout Standard
Another way in which pattern matching can be made infallible is by including
 a pattern that matches everything:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

p match {
\end_layout

\begin_layout Plain Layout

  case (x, 0) => ...
 // This only matches some tuples.
\end_layout

\begin_layout Plain Layout

  case _ => ...
 // This matches everything.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

If the first pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, 0)
\end_layout

\end_inset

 fails to match the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

, the second pattern will be tried (and will always succeed).
 When a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 expression has several 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 patterns, the patterns are tried in the order they are written.
 So, a match expression can be made infallible by adding a 
\begin_inset Quotes eld
\end_inset

match-all
\begin_inset Quotes erd
\end_inset

 underscore pattern.
\end_layout

\begin_layout Subsection
Scope and shadowing of pattern matching variables
\begin_inset CommandInset label
LatexCommand label
name "subsec:Scope-and-shadowing-variables"

\end_inset


\end_layout

\begin_layout Standard
Pattern matching introduces 
\series bold
locally scoped
\begin_inset Index idx
status open

\begin_layout Plain Layout
local scope
\end_layout

\end_inset


\series default
 variables â€“ that is, variables defined only on the right-hand side of the
 pattern match expression.
 As an example, consider this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: (Int, Int)): Int = x match { case (x, y) => x + y }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f( (2,4) )
\end_layout

\begin_layout Plain Layout

res0: Int = 6
\end_layout

\end_inset

The argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of a tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int,Int)
\end_layout

\end_inset

, but there is also a pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 in the case expression.
 The pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 matches the first part of the tuple and has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 Because variables are locally scoped, the pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is only defined within the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x + y
\end_layout

\end_inset

.
 The argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:(Int,Int)
\end_layout

\end_inset

 is a completely different variable whose value has a different type.
\end_layout

\begin_layout Standard
The code works correctly but is confusing to read because of the name clash
 between the two quite different variables, both named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 Another negative consequence of the name clash is that the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:(Int,Int)
\end_layout

\end_inset

 
\emph on
is invisible
\emph default
 within the case expression: if we write 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 in that expression, we will get the pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:Int
\end_layout

\end_inset

.
 One says that the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:(Int,Int)
\end_layout

\end_inset

 has been 
\begin_inset Index idx
status open

\begin_layout Plain Layout
shadowed name
\end_layout

\end_inset


\series bold
shadowed
\series default
 by the pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The problem is easy to correct: we can give the pattern variable some other
 name.
 Since the pattern variable is locally scoped, it can be renamed within
 its scope without having to change any other code.
 A completely equivalent code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: (Int, Int)): Int = x match { case (a, b) => a + b }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f( (2,4) )
\end_layout

\begin_layout Plain Layout

res0: Int = 6
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Lazy values and sequences: Iterators and streams
\begin_inset CommandInset label
LatexCommand label
name "subsec:Lazy-values-iterators-and-streams"

\end_inset


\end_layout

\begin_layout Standard
We have used streams to create sequences whose length is not known in advance.
 An example is a stream containing a sequence of increasing positive integers:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p = Stream.iterate(1)(_ + 1)
\end_layout

\begin_layout Plain Layout

p: Stream[Int] = Stream(1, ?)
\end_layout

\end_inset

At this point, we have not defined a stopping condition for this stream.
 In some sense, streams are 
\begin_inset Quotes eld
\end_inset

infinite
\begin_inset Quotes erd
\end_inset

 sequences, although in practice a stream is always finite because computers
 cannot run infinitely long.
 Also, computers cannot store infinitely many values in memory.
 
\end_layout

\begin_layout Standard
To be more precise, streams are 
\begin_inset Quotes eld
\end_inset

not fully computed
\begin_inset Quotes erd
\end_inset

 rather than 
\begin_inset Quotes eld
\end_inset

infinite
\begin_inset Quotes erd
\end_inset

.
 The main difference between arrays and streams is that a stream's elements
 are computed on demand and not initially available (except perhaps for
 the first element), while an array's elements are all computed in advance
 and are available immediately.
 Generally, there are four possible ways a value could be available:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Availability
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Explanation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Example Scala code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

eager
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computed in advance
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val x = f(123)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

lazy
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computed upon first request
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lazy val y = f(123)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computed each time it is requested
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def z = f(123)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

never
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cannot be computed due to errors
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val (x, y) = 
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
A 
\series bold
lazy value
\begin_inset Index idx
status open

\begin_layout Plain Layout
lazy value
\end_layout

\end_inset


\series default
 (declared as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lazy val
\end_layout

\end_inset

 in Scala) is computed only when used in some other expression.
 Once computed, a lazy value stays in memory and will not be re-computed.
\end_layout

\begin_layout Standard
An 
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset

 value is re-computed every time it is used.
 In Scala, this is the behavior of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 declaration.
\end_layout

\begin_layout Standard
Most collection types in Scala (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map
\end_layout

\end_inset

) are 
\series bold
eager
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
eager collection
\end_layout

\end_inset

: all the elements inside these collections are already evaluated.
 A stream can be seen as a 
\series bold
lazy
\begin_inset Index idx
status open

\begin_layout Plain Layout
lazy collection
\end_layout

\end_inset


\series default
 
\series bold
collection
\series default
.
 Values in a stream are computed only when first needed; after that, they
 remain in memory and will not be computed again:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val str = Stream.iterate(1)(_ + 1)
\end_layout

\begin_layout Plain Layout

str: Stream[Int] = Stream(1, ?)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.take(10).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str
\end_layout

\begin_layout Plain Layout

res1: Stream[Int] = Stream(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ?)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In many cases, it is not necessary to keep previous values of a sequence
 in memory.
 For example, consider the computation
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1L to 1000000000L).sum
\end_layout

\begin_layout Plain Layout

res0: Long = 500000000500000000
\end_layout

\end_inset

We do not actually need to keep a billion numbers in memory if we only want
 to compute their sum.
 Indeed, the computation just shown does 
\emph on
not
\emph default
 keep all the numbers in memory.
 The same computation fails if we use a list or a stream:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1L to 1000000000L).toStream.sum
\end_layout

\begin_layout Plain Layout

java.lang.OutOfMemoryError: GC overhead limit exceeded
\end_layout

\end_inset

The code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1L to 1000000000L).sum
\end_layout

\end_inset

 works because the operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n)
\end_layout

\end_inset

 produces a sequence whose elements are computed whenever needed but do
 not remain in memory.
 This can be seen as a sequence with the 
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset

 availability of elements.
 Sequences of this sort are called 
\series bold
iterators
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
iterator
\end_layout

\end_inset

.
 Here are some examples:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> 1 to 5
\end_layout

\begin_layout Plain Layout

res0: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> 1 until 5
\end_layout

\begin_layout Plain Layout

res1: scala.collection.immutable.Range = Range(1, 2, 3, 4)
\end_layout

\end_inset

The types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Range
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Range.Inclusive
\end_layout

\end_inset

 are defined in the Scala standard library and are iterators.
 They behave as collections and support the usual methods (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, etc.), but they do not store previously computed values in memory.
\end_layout

\begin_layout Paragraph
The 
\family typewriter
.view
\family default
 method
\end_layout

\begin_layout Standard
Eager collections such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 can be converted to iterators by using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.view
\end_layout

\end_inset

 method.
 This is necessary when intermediate collections consume too much memory
 when fully evaluated.
 For example, consider the computation of Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example7"
plural "false"
caps "false"
noprefix "false"

\end_inset

 where we used 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 to replace each element of an initial sequence by three new numbers before
 computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

 of the resulting collection.
 If instead of three new numbers we wanted to compute 
\emph on
three
\emph default
 
\emph on
million
\emph default
 new numbers each time, the intermediate collection created by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 would require too much memory, and the computation would crash:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).flatMap(x => 1 to 3000000).max
\end_layout

\begin_layout Plain Layout

java.lang.OutOfMemoryError: GC overhead limit exceeded
\end_layout

\end_inset

Even though the range expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to 10)
\end_layout

\end_inset

 produces an iterator, a subsequent 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap
\end_layout

\end_inset

 operation creates an intermediate collection that is too large for our
 computer's memory.
 We can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.view
\end_layout

\end_inset

 to avoid this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).view.flatMap(x => 1 to 3000000).max
\end_layout

\begin_layout Plain Layout

res0: Int = 3000000
\end_layout

\end_inset

The choice between using streams and using iterators is dictated by the
 memory considerations.
 Except for that, streams and iterators behave similarly to other sequences.
 We may write programs in the map/reduce style, applying the standard methods
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, etc., to streams and iterators.
 Mathematical reasoning about sequences is the same, whether they are eager,
 lazy, or on-call.
\end_layout

\begin_layout Paragraph
The broken 
\family typewriter
Iterator
\family default
 class
\end_layout

\begin_layout Standard
The Scala library contains a class called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

, which has methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator.iterate
\end_layout

\end_inset

 and other methods similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

.
 However, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 actually not an 
\begin_inset Quotes eld
\end_inset

iterator
\begin_inset Quotes erd
\end_inset

 in the sense I explained.
 It cannot be treated as a 
\emph on
value
\emph default
 in the mathematical sense
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala's Iterator is broken
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val iter = (1 until 10).toIterator
\end_layout

\begin_layout Plain Layout

iter: Iterator[Int] = non-empty iterator
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> iter.toList // Look at the elements of `iter`.
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> iter.toList // Look at these elements again...??
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> iter
\end_layout

\begin_layout Plain Layout

res2: Iterator[Int] = empty iterator
\end_layout

\end_inset

Evaluating the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iter.toList
\end_layout

\end_inset

 two times produces a 
\emph on
different
\emph default
 result the second time! Also, we see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iter
\end_layout

\end_inset

 became 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 after the first use.
\end_layout

\begin_layout Standard
This situation is impossible in mathematics: if 
\begin_inset Formula $x$
\end_inset

 is some value, such as 
\begin_inset Formula $100$
\end_inset

, and 
\begin_inset Formula $f$
\end_inset

 is some function, such as 
\begin_inset Formula $f(x)=\sqrt{x}$
\end_inset

, then 
\begin_inset Formula $f(x)$
\end_inset

 will be the same, 
\begin_inset Formula $f(100)=\sqrt{100}=10$
\end_inset

, no matter how many times we compute 
\begin_inset Formula $f(x)$
\end_inset

.
 For instance, we can compute 
\begin_inset Formula $f(x)+f(x)=20$
\end_inset

 and obtain the correct result.
 The number 
\begin_inset Formula $x=100$
\end_inset

 does not 
\begin_inset Quotes eld
\end_inset

become empty
\begin_inset Quotes erd
\end_inset

 after the first use; its value remains the same.
 This behavior is called the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
value semantics
\end_layout

\end_inset

value semantics
\series default
 of numbers.
 One says that integers 
\begin_inset Quotes eld
\end_inset

are values
\begin_inset Quotes erd
\end_inset

 in the mathematical sense.
 Alternatively, one says that numbers are 
\series bold
immutable
\begin_inset Index idx
status open

\begin_layout Plain Layout
immutable value
\end_layout

\end_inset

,
\series default
 i.e.
\begin_inset space ~
\end_inset

cannot be changed.
 (What would it mean to 
\begin_inset Quotes eld
\end_inset

modify
\begin_inset Quotes erd
\end_inset

 the number 
\begin_inset Formula $10$
\end_inset

?)
\end_layout

\begin_layout Standard
In programming, a type has value semantics if any computation applied to
 it always gives the same result.
 Usually, this means that the type contains immutable data.
 We can see that Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Range
\end_layout

\end_inset

 has value semantics and is immutable:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x = 1 until 10
\end_layout

\begin_layout Plain Layout

x: scala.collection.immutable.Range = Range(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x.toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x.toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9) 
\end_layout

\end_inset

Collections such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

 are immutable.
 Some elements of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

 may not be evaluated yet, but this does not affect its value semantics:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val str = (1 until 10).toStream
\end_layout

\begin_layout Plain Layout

str: scala.collection.immutable.Stream[Int] = Stream(1, ?)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9) 
\end_layout

\end_inset

Iterators produced by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.view
\end_layout

\end_inset

 also have value semantics:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val v = (1 until 10).view
\end_layout

\begin_layout Plain Layout

v: scala.collection.SeqView[Int,IndexedSeq[Int]] = SeqView(...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> v.toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> v.toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Due to the lack of value semantics, programs written using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 cannot use the tools of mathematical reasoning.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala's Iterator is broken
\end_layout

\end_inset

This makes it easy to write wrong code that looks correct! 
\end_layout

\begin_layout Standard
To illustrate the problem, let us re-implement Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-7"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by keeping the same code but using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def stopRepeatsBad[T](iter: Iterator[T]): Iterator[T] = {
\end_layout

\begin_layout Plain Layout

  val halfSpeed = iter.flatMap(x => Seq(x, x))
\end_layout

\begin_layout Plain Layout

  halfSpeed.zip(iter) // Do not prepend the first element.
 It won't help.
\end_layout

\begin_layout Plain Layout

  .drop(1)
\end_layout

\begin_layout Plain Layout

  .takeWhile { case (h, s) => h != s }
\end_layout

\begin_layout Plain Layout

  .map(_._2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> stopRepeatsBad(Seq(1, 3, 5, 7, 9, 3, 5, 7, 9).toIterator).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(5, 9, 3, 7, 9)
\end_layout

\end_inset

The result 
\begin_inset Formula $\left[5,9,3,7,9\right]$
\end_inset

 is incorrect, but not in an obvious way: the sequence 
\emph on
was
\emph default
 stopped at a repetition, as we expected, but some of the elements of the
 given sequence are missing (while other elements are present).
 It is difficult to debug a program when it produces numbers that are 
\emph on
partially
\emph default
 correct! 
\end_layout

\begin_layout Standard
The error in this code occurs in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

halfSpeed.zip(iter)
\end_layout

\end_inset

 due to the fact that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

halfSpeed
\end_layout

\end_inset

 was itself defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iter
\end_layout

\end_inset

.
 The result is that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iter
\end_layout

\end_inset

 is 
\emph on
used twice
\emph default
 in this code, which leads to errors because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iter
\end_layout

\end_inset

 is not immutable and does not behave as a value.
 Creating an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 and using it twice in the same expression can even fail with an exception:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = (1 until 10).toIterator
\end_layout

\begin_layout Plain Layout

s: Iterator[Int] = non-empty iterator
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val t = s.zip(s).toList
\end_layout

\begin_layout Plain Layout

java.util.NoSuchElementException: next on empty iterator
\end_layout

\end_inset

It is surprising and counter-intuitive that a variable cannot be used twice!
 We expect code such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.zip(s)
\end_layout

\end_inset

 to work correctly even though the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 is used twice.
 When we read the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.zip(s)
\end_layout

\end_inset

, we imagine a given sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 being 
\begin_inset Quotes eld
\end_inset

zipped
\begin_inset Quotes erd
\end_inset

 with itself.
 So we reason that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.zip(s)
\end_layout

\end_inset

 should produce a sequence of pairs.
 But Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 is not immutable, which breaks the usual ways of mathematical reasoning
 about code.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala's Iterator is broken
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 can be converted to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

 using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toStream
\end_layout

\end_inset

 method.
 This restores the value semantics, since streams are values:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val iter = (1 until 10).toIterator
\end_layout

\begin_layout Plain Layout

iter: Iterator[Int] = non-empty iterator
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val str = iter.toStream
\end_layout

\begin_layout Plain Layout

str: Stream[Int] = Stream(1, ?)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.zip(str).toList
\end_layout

\begin_layout Plain Layout

res2: List[(Int, Int)] = List((1,1), (2,2), (3,3), (4,4), (5,5), (6,6),
 (7,7), (8,8), (9,9)) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

, we can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.view
\end_layout

\end_inset

 when lazy or on-call collections are required.
 
\end_layout

\end_body
\end_document
