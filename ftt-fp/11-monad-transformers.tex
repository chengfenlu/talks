\batchmode
\makeatletter
\def\input@path{{/Users/sergei.winitzki/Code/talks/ftt-fp/}}
\makeatother
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amstext}
\usepackage{wasysym}
\usepackage[all]{xy}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
% this default might be overridden by plain title style
\newcommand\makebeamertitle{\frame{\maketitle}}%
% (ERT) argument for the TOC
\AtBeginDocument{%
  \let\origtableofcontents=\tableofcontents
  \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
  \def\gobbletableofcontents#1{\origtableofcontents}
}
\newenvironment{lyxcode}
  {\par\begin{list}{}{
    \setlength{\rightmargin}{\leftmargin}
    \setlength{\listparindent}{0pt}% needed for AMS classes
    \raggedright
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \normalfont\ttfamily}%
   \def\{{\char`\{}
   \def\}{\char`\}}
   \def\textasciitilde{\char`\~}
   \item[]}
  {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 11: Monad transformers]{Chapter 11:
Computations in a functor context III}
\subtitle{Monad transformers}
\author{Sergei Winitzki}
\date{2019-01-05}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\newcommand{\bef}{\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-3.3pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Computations within a functor context: Combining monads}

Programs often need to combine monadic effects
\begin{itemize}
\item ``Effect'' $\equiv$ what else happens in {\footnotesize{}$A\Rightarrow M^{B}$}
besides computing $B$ from $A$
\item Examples of effects for some standard monads:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}Option}} -- computation will
have no result or a single result
\item \texttt{\textcolor{blue}{\footnotesize{}List}} -- computation will
have zero, one, or multiple results
\item \texttt{\textcolor{blue}{\footnotesize{}Either}} -- computation may
fail to obtain its result, reports error
\item \texttt{\textcolor{blue}{\footnotesize{}Reader}} -- computation needs
to read an external context value
\item \texttt{\textcolor{blue}{\footnotesize{}Writer}} -- some value will
be appended to a (monoidal) accumulator
\item \texttt{\textcolor{blue}{\footnotesize{}Future}} -- computation will
be scheduled to run later
\end{itemize}
\item How to combine several effects in the same functor block (\texttt{\textcolor{blue}{\footnotesize{}for}}/\texttt{\textcolor{blue}{\footnotesize{}yield}})?
\end{itemize}
{\footnotesize{}\vspace{-0.35cm}}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{darkgray}{\footnotesize{}//~This~is~not~valid~Scala!}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~result~=~for~\{~i~$\leftarrow$~1~to~n}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~j~$\leftarrow$~Future~\{~q(i)~\}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~k~$\leftarrow$~maybeError(j)~:~Try{[}Int{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~yield~f(k)}{\footnotesize\par}

\textcolor{darkgray}{\footnotesize{}//~What~should~be~the~type~of~result??}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}~ ~ ~}}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}~~}\textcolor{darkgray}{\footnotesize{}//~This~is~not~valid~Scala!}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}(1~to~n).flatMap~\{~i~$\Rightarrow$}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~Future(q(i)).flatMap~\{~j~$\Rightarrow$}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~maybeError(j).map~\{~k~$\Rightarrow$}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~~f(k)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~~~~\}\}\}}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
}}{\footnotesize\par}
\begin{itemize}
\item The code will work if we ``unify'' all effects in a new, larger
monad
\item Need to compute the type of new monad that contains all given effects
\end{itemize}
\end{frame}

\begin{frame}{Combining monadic effects I. Trial and error}

There are several ways of combining two monads into a new monad:
\begin{itemize}
\item If $M_{1}^{A}$ and $M_{2}^{A}$ are monads then $M_{1}^{A}\times M_{2}^{A}$
is also a monad
\begin{itemize}
\item But $M_{1}^{A}\times M_{2}^{A}$ describes two separate values with
two separate effects
\end{itemize}
\item If $M_{1}^{A}$ and $M_{2}^{A}$ are monads then $M_{1}^{A}+M_{2}^{A}$
is usually not a monad
\begin{itemize}
\item If it worked, it would be a choice between two different values /
effects
\end{itemize}
\item If $M_{1}^{A}$ and $M_{2}^{A}$ are monads then one of $M_{1}^{M_{2}^{A}}$
or $M_{2}^{M_{1}^{A}}$ is often a monad
\item Examples and counterexamples for functor composition:
\begin{itemize}
\item Combine $Z\Rightarrow A$ and $\text{List}^{A}$ as $Z\Rightarrow\text{List}^{A}$
\item Combine \texttt{\textcolor{blue}{\footnotesize{}Future{[}A{]}}} and
\texttt{\textcolor{blue}{\footnotesize{}Option{[}A{]}}} as \texttt{\textcolor{blue}{\footnotesize{}Future{[}Option{[}A{]}{]}}} 
\item But \texttt{\textcolor{blue}{\footnotesize{}Either{[}Z, Future{[}A{]}{]}}}
and \texttt{\textcolor{blue}{\footnotesize{}Option{[}Z $\Rightarrow$
A{]}}} are not monads
\item Neither \texttt{\textcolor{blue}{\footnotesize{}Future{[}State{[}A{]}{]}}}
nor \texttt{\textcolor{blue}{\footnotesize{}State{[}Future{[}A{]}{]}}}
are monads
\end{itemize}
\item The order of effects matters when composition works both ways: 
\begin{itemize}
\item Combine \texttt{\textcolor{blue}{\footnotesize{}Either}} ($M_{1}^{A}=Z+A$)
and \texttt{\textcolor{blue}{\footnotesize{}Writer}} ($M_{2}^{A}=W\times A$) 
\begin{itemize}
\item as $Z+W\times A$ -- either compute result and write a message, or
all fails
\item as $\left(Z+A\right)\times W$ -- message is always written, but
computation may fail
\end{itemize}
\end{itemize}
\item Find a general way of defining a new monad with combined effects
\item Derive properties required for the new monad
\end{itemize}
\end{frame}

\begin{frame}{Combining monadic effects II. Lifting into a larger monad}

{\footnotesize{}\vspace{-0.15cm}}If a ``big monad'' \texttt{\textcolor{blue}{\footnotesize{}BigM{[}A{]}}}
\emph{somehow} combines all the needed effects:

{\footnotesize{}\vspace{-0.15cm}\hspace{-0.35cm}}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~This~could~be~valid~Scala...}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~result:~BigM{[}Int{]}~=~for~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~i~$\leftarrow$~lift$_{1}$(1~to~n)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~j~$\leftarrow$~lift$_{2}$(Future\{~q(i)~\})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~k~$\leftarrow$~lift$_{3}$(maybeError(j))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~yield~f(k)}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{} }}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}~}\textrm{\textcolor{darkgray}{\footnotesize{}//~If~we~define~the~various}}{\footnotesize\par}

\textrm{\textcolor{darkgray}{\footnotesize{}~//~required~``lifting''~functions:}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~lift$_{1}${[}A{]}:~Seq{[}A{]}~$\Rightarrow$~BigM{[}A{]}~=~???}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~lift$_{2}${[}A{]}:~Future{[}A{]}~$\Rightarrow$~BigM{[}A{]}~=~???}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~lift$_{3}${[}A{]}:~Try{[}A{]}~$\Rightarrow$~BigM{[}A{]}~=~???~~~}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
}}{\footnotesize\par}
\begin{itemize}
\item Example 1: combining as \texttt{\textcolor{blue}{\footnotesize{}BigM{[}A{]}
= Future{[}Option{[}A{]}{]}}} with liftings:
\end{itemize}
\begin{lyxcode}
{\footnotesize{}\vspace{-0.4cm}}\textcolor{blue}{\footnotesize{}def~lift$_{1}${[}A{]}:~Option{[}A{]}~$\Rightarrow$~Future{[}Option{[}A{]}{]}~=~Future.successful(\_)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~lift$_{2}${[}A{]}:~Future{[}A{]}~$\Rightarrow$~Future{[}Option{[}A{]}{]}~=~\_.map(x~$\Rightarrow$~Some(x))}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.15cm}}Example 2: combining as \texttt{\textcolor{blue}{\footnotesize{}BigM{[}A{]}
= List{[}Try{[}A{]}{]}}} with liftings:
\end{itemize}
\begin{lyxcode}
{\footnotesize{}\vspace{-0.05cm}}\textcolor{blue}{\footnotesize{}def~lift$_{1}${[}A{]}:~Try{[}A{]}~$\Rightarrow$~List{[}Try{[}A{]}{]}~=~x~$\Rightarrow$~List(x)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~lift$_{2}${[}A{]}:~List{[}A{]}~$\Rightarrow$~List{[}Try{[}A{]}{]}~=~\_.map(x~$\Rightarrow$~Success(x))}{\footnotesize\par}
\end{lyxcode}
{\footnotesize{}\vspace{-0.1cm}}Remains to be understood:
\begin{itemize}
\item Finding suitable laws for the liftings; checking that the laws hold
\item Building a ``big monad'' out of ``smaller'' ones, with lawful
liftings
\begin{itemize}
\item Is this always possible? Unique? Are there alternative solutions?
\end{itemize}
\item Ways of reducing the complexity of code; make liftings automatic
\end{itemize}
\end{frame}

\begin{frame}{Laws for monad liftings I. Identity laws}

Whatever identities we expect to hold for monadic programs must continue
to hold after lifting \texttt{\textcolor{blue}{\footnotesize{}M$_{1}$}}
or \texttt{\textcolor{blue}{\footnotesize{}M$_{2}$}} values into
the ``big monad'' \texttt{\textcolor{blue}{\footnotesize{}BigM}} 
\begin{itemize}
\item We assume that \texttt{\textcolor{blue}{\footnotesize{}M$_{1}$}},
\texttt{\textcolor{blue}{\footnotesize{}M$_{2}$}}, and \texttt{\textcolor{blue}{\footnotesize{}BigM}}
already satisfy all the monad laws
\end{itemize}
Consider the various functor block constructions containing the liftings:
\begin{itemize}
\item Left identity law after \texttt{\textcolor{blue}{\footnotesize{}lift$_{1}$}} 
\end{itemize}
{\footnotesize{}\vspace{-0.3cm}\hspace{-0.0cm}}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.54\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~Anywhere~inside~a~for/yield:}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}i~$\leftarrow$~lift$_{1}$(M$_{1}$.pure(x))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}j~$\leftarrow$~bigM(i)~}\textrm{\textcolor{darkgray}{\footnotesize{}//~Any~BigM~value.}}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}~ }}%
\begin{minipage}[t]{0.54\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~Must~be~equivalent~to...}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}i~=~x}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}j~$\leftarrow$~bigM(x)}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\smallskip{}
lift$_{1}$(M$_{1}$.pure(x)).flatMap(b) = b(x)}} --- in terms of
Kleisli composition $\left(\diamond\right)$:
\begin{center}
{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}$\left(\text{pure}_{M_{1}}\bef\text{lift}_{1}\right)^{:X\Rightarrow\text{BigM}^{X}}\diamond b^{:X\Rightarrow\text{BigM}^{Y}}=b$\hspace*{\fill}with
$f^{:X\Rightarrow M^{Y}}\diamond g^{:Y\Rightarrow M^{Z}}\equiv x\Rightarrow f(x).\text{flatMap}(g)$}{\footnotesize\par}
\par\end{center}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}}Right identity law
after \texttt{\textcolor{blue}{\footnotesize{}lift$_{1}$}} 
\end{itemize}
{\footnotesize{}\vspace{-0.3cm}\hspace{-0.0cm}}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.54\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~Anywhere~inside~a~for/yield:}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}x~$\leftarrow$~bigM~}\textrm{\textcolor{darkgray}{\footnotesize{}//~Any~BigM~value.}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}i~$\leftarrow$~lift$_{1}$(M$_{1}$.pure(x))}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}~ }}%
\begin{minipage}[t]{0.54\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~Must~be~equivalent~to...}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}x~$\leftarrow$~bigM}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}i~=~x}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
b.flatMap(M$_{1}$.pure andThen lift$_{1}$) = b}} --- in terms of
Kleisli composition:
\begin{center}
{\footnotesize{}\vspace{-0.1cm}\hspace{-0.0cm}$b^{:X\Rightarrow\text{BigM}^{Y}}\diamond\left(\text{pure}_{M_{1}}\bef\text{lift}_{1}\right)^{:Y\Rightarrow\text{BigM}^{Y}}=b$}{\footnotesize\par}
\par\end{center}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.15cm}\hspace{-0.0cm}}The same identity
laws must hold for \texttt{\textcolor{blue}{\footnotesize{}M$_{2}$}}
and \texttt{\textcolor{blue}{\footnotesize{}lift$_{2}$}} as well
\end{itemize}
\end{frame}

\begin{frame}{Laws for monad liftings II. Simplifying the laws}

{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}}$\big(\text{pure}_{M_{1}}\bef\text{lift}_{1}\big)$
is a unit for the Kleisli composition $\diamond$ in the monad \texttt{\textcolor{blue}{\footnotesize{}BigM}} 
\begin{itemize}
\item But the monad \texttt{\textcolor{blue}{\footnotesize{}BigM}} already
has a unit element, namely $\text{pure}_{\text{BigM}}$
\item The two-sided unit element is always unique: $\text{u}=\text{u}\diamond\text{u}^{\prime}=\text{u}^{\prime}$
\item So the two identity laws for $\big(\text{pure}_{M_{1}}\bef\text{lift}_{1}\big)$
can be reduced to one law:{\footnotesize{}\vspace{-0.1cm}\hspace{-0.0cm}
\[
\text{pure}_{M_{1}}\bef\text{lift}_{1}=\text{pure}_{\text{BigM}}
\]
}{\footnotesize\par}
\end{itemize}
{\footnotesize{}\vspace{-0.15cm}\hspace{-0.0cm}}Refactoring a portion
of a monadic program under \texttt{\textcolor{blue}{\footnotesize{}lift$_{1}$}}
gives another law:

{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.58\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~Anywhere~inside~a~for/yield,~this...}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}i~$\leftarrow$~lift$_{1}$(p)~}\textrm{\textcolor{darkgray}{\footnotesize{}//~Any~M$_{1}$~value.}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}j~$\leftarrow$~lift$_{1}$(q(i))~}\textrm{\textcolor{darkgray}{\footnotesize{}//~Any~M$_{1}$~value.}}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}~ }}%
\begin{minipage}[t]{0.5\columnwidth}%
\begin{lyxcode}
\textrm{\textcolor{darkgray}{\footnotesize{}//~must~be~equivalent~to...}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}pq~=~p.flatMap(q)~}\textrm{\textcolor{darkgray}{\footnotesize{}//~In~M$_{1}$.}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}j~$\leftarrow$~lift$_{1}$(pq)}\textrm{\textcolor{darkgray}{\footnotesize{}~~//~Now~lift~it.}}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
lift$_{1}$(p).flatMap(q andThen lift$_{1}$) = lift$_{1}$(p flatMap
q)}}{\footnotesize\par}
\begin{itemize}
\item Rewritten equivalently through $\text{flm}_{M}:\left(A\Rightarrow M^{B}\right)\Rightarrow M^{A}\Rightarrow M^{B}$
as
\end{itemize}
\begin{center}
{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}$\text{lift}_{1}\bef\text{flm}_{\text{BigM}}\left(q\bef\text{lift}_{1}\right)=\text{flm}_{M_{1}}q\bef\text{lift}_{1}$
-- both sides are functions $M_{1}^{A}\Rightarrow\text{BigM}^{B}$}{\footnotesize\par}
\par\end{center}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.3cm}\hspace{-0.0cm}}Rewritten equivalently
through $\text{ftn}_{M}:M^{M^{A}}\Rightarrow M^{A}$ as
\end{itemize}
\begin{center}
{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}$\text{lift}_{1}\bef\text{fmap}_{\text{BigM}}\text{lift}_{1}\bef\text{ftn}_{\text{BigM}}=\text{ftn}_{M_{1}}\bef\text{lift}_{1}$
-- both sides are functions $M_{1}^{M_{1}^{A}}\Rightarrow\text{BigM}^{A}$}{\footnotesize\par}
\par\end{center}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.3cm}\hspace{-0.0cm}}Rewritten equivalently
in terms of Kleisli composition $\diamond_{M}$ as
\end{itemize}
\begin{center}
{\footnotesize{}\vspace{-0.2cm}\hspace{-0.0cm}$\big(b^{:X\Rightarrow M_{1}^{Y}}\bef\text{lift}_{1}\big)\diamond_{\text{BigM}}\big(c^{:Y\Rightarrow M_{1}^{Z}}\bef\text{lift}_{1}\big)=\left(b\diamond_{M_{1}}c\right)\bef\text{lift}_{1}$}{\footnotesize\par}
\par\end{center}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.3cm}\hspace{-0.0cm}}Liftings $\text{lift}_{1}$
and $\text{lift}_{2}$ must obey an identity law and a composition
law
\begin{itemize}
\item The laws say that the liftings \textbf{commute with} the monads' operations
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Laws for monad liftings III. The naturality law}

Show that $\text{lift}_{1}:M_{1}^{A}\Rightarrow\text{BigM}^{A}$ is
a natural transformation 
\begin{itemize}
\item It maps $\text{pure}_{M_{1}}$ to $\text{pure}_{\text{BigM}}$ and
$\text{flm}_{M_{1}}$ to $\text{flm}_{\text{BigM}}$
\begin{itemize}
\item $\text{lift}_{1}$ is a \textbf{monadic morphism} between monads $M_{1}^{\bullet}$
and $\text{BigM}^{\bullet}$
\end{itemize}
\end{itemize}
The (functor) naturality law: for any $f:X\Rightarrow Y$, 
\[
\text{lift}_{1}\bef\text{fmap}_{\text{BigM}}f=\text{fmap}_{M_{1}}f\bef\text{lift}_{1}
\]
{\footnotesize{}\vspace{-0.5cm}
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}M_{1}^{X}\ar[d]\sb(0.45){\text{fmap}_{M_{1}}\,f^{:X\Rightarrow Y}}\ar[r]\sp(0.45){\ \text{lift}_{1}} & \text{BigM}^{X}\ar[d]\sp(0.45){\text{fmap}_{\text{BigM}}\,f^{:X\Rightarrow Y}}\\
M_{1}^{Y}\ar[r]\sp(0.45){\text{lift}_{1}} & \text{BigM}^{Y}
}
\]
}Derivation of the naturality law:
\begin{itemize}
\item Express $\text{fmap}$ as $\text{fmap}_{M}f=\text{flm}_{M}\left(f\bef\text{pure}_{M}\right)$
for both monads
\item Given $f^{:X\Rightarrow Y}$, use the law {\footnotesize{}$\text{flm}_{M_{1}}q\bef\text{lift}_{1}=\text{lift}_{1}\bef\text{flm}_{\text{BigM}}\left(q\bef\text{lift}_{1}\right)$}
to compute {\footnotesize{}$\text{flm}_{M_{1}}\left(f\bef\text{pure}_{M_{1}}\right)\bef\text{lift}_{1}=\text{lift}_{1}\bef\text{flm}\left(f\bef\text{pure}_{M_{1}}\bef\text{lift}_{1}\right)=\text{lift}_{1}\bef\text{flm}\left(f\bef\text{pure}_{\text{BigM}}\right)=\text{lift}_{1}\bef\text{fmap}_{\text{BigM}}f$}{\footnotesize\par}
\end{itemize}
A monadic morphism is always also a natural transformation of the
functors
\end{frame}

\begin{frame}{Monad transformers I: Motivation}

\begin{itemize}
\item {\footnotesize{}\vspace{-0.2cm}}Combine $Z\Rightarrow A$ and $1+A$:
only $Z\Rightarrow1+A$ works, not $1+\left(Z\Rightarrow A\right)$
\begin{itemize}
\item It is not possible to combine monads via a natural bifunctor $B^{M_{1},M_{2}}$
\item It is not possible to combine arbitrary monads as $M_{1}^{M_{2}^{\bullet}}$
or $M_{2}^{M_{1}^{\bullet}}$
\begin{itemize}
\item Example: state monad $\text{St}_{S}^{A}\equiv S\Rightarrow A\times S$
does not compose
\end{itemize}
\end{itemize}
\item The trick: for a fixed \textbf{base }monad $L^{\bullet}$, let $M^{\bullet}$
(\textbf{foreign }monad) vary
\item Call the desired result the ``$L$'s monad transformer'', $T_{L}^{M,\bullet}$
\begin{itemize}
\item In Scala: \texttt{\textcolor{blue}{\footnotesize{}LT{[}M{[}\_{]}:~Monad,
A{]}}} -- e.g. \texttt{\textcolor{blue}{\footnotesize{}ReaderT}},
\texttt{\textcolor{blue}{\footnotesize{}StateT}}, etc.
\end{itemize}
\item $T_{L}^{M,\bullet}$ is generic in $M$ but not in $L$
\begin{itemize}
\item No general formula for monad transformers seems to exist
\item For each base monad $L$, a different construction is needed
\item Some monads $L$ do not seem to have a transformer!
\end{itemize}
\item To combine 3 or more monads, compose the transformers: $T_{L_{1}}^{T_{L_{2}}^{M,\bullet}}$
\begin{itemize}
\item Example in Scala: \texttt{\textcolor{blue}{\footnotesize{}StateT{[}S,
ListT{[}Reader{[}R, ?{]}, ?{]}, A{]}}} 
\end{itemize}
\item This is called a \textbf{monad stack} -- but may not be \emph{functor
composition}
\begin{itemize}
\item because e.g.~\texttt{\textcolor{blue}{\footnotesize{}State{[}S, List{[}Reader{[}R,
A{]}{]}{]}}} is not a monad
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Monad transformers II: The requirements}

{\footnotesize{}\vspace{-0.1cm}}A \textbf{monad transformer} for
a \textbf{base} monad $L^{\bullet}$ is a type constructor $T_{L}^{M,\bullet}$
parameterized by a monad $M^{\bullet}$, such that for all monads
$M^{\bullet}$
\begin{itemize}
\item $T_{L}^{M,\bullet}$ is a monad (the monad $M$ \textbf{transformed
with} $T_{L}$)
\item ``Lifting'' -- a monadic morphism $\text{lift}_{L}^{M}:M^{A}\leadsto T_{L}^{M,A}$,
natural in $M^{\bullet}$
\item ``Base lifting'' -- a monadic morphism $\text{blift}:L^{A}\leadsto T_{L}^{M,A}$
\begin{itemize}
\item The ``base lifting'' could not possibly be natural in $L^{\bullet}$
\end{itemize}
\item Transformed identity monad ($\text{Id}$) must be $L$, i.e.~$T_{L}^{\text{Id},\bullet}\cong L^{\bullet}$
\item $T_{L}^{M,\bullet}$ is \textbf{monadically natural} in $M^{\bullet}$
(but not in $L^{\bullet}$)
\begin{itemize}
\item $T_{L}^{M,\bullet}$ is natural w.r.t.~a monadic functor $M^{\bullet}$
as a type parameter
\item For any monad $N^{\bullet}$ and a monadic morphism $f:M^{\bullet}\leadsto N^{\bullet}$
we need to have a monadic morphism $T_{L}^{M,\bullet}\leadsto T_{L}^{N,\bullet}$
for the transformed monads
\begin{itemize}
\item If we implement $T_{L}^{M,\bullet}$ only via $M$'s monad methods,
naturality will hold 
\end{itemize}
\item Cf.~\texttt{\textcolor{blue}{\footnotesize{}traverse}}{\small{}$:L^{A}\Rightarrow\left(A\Rightarrow F^{B}\right)\Rightarrow F^{L^{B}}$
-- natural w.r.t.~applicative $F^{\bullet}$}{\small\par}
\item This is needed for lifting a ``runner'' $M^{A}\leadsto A$ to $T_{L}^{M,\bullet}\leadsto T_{L}^{\text{Id},\bullet}=L^{\bullet}$
\end{itemize}
\item ``Base runner'': lifts $L^{A}\leadsto A$ into a monadic morphism
$T_{L}^{M,\bullet}\leadsto M^{\bullet}$
\end{itemize}
\end{frame}

\begin{frame}{Monad transformers III: First examples}

{\footnotesize{}\vspace{-0.2cm}}Recall these monad constructions:
\begin{itemize}
\item If $M^{A}$ is a monad then $R\Rightarrow M^{A}$ is also a monad
(for a fixed type $R$)
\item If $M^{A}$ is a monad then $M^{Z+A\times W}$ is also a monad (for
fixed $W,$ $Z$)
\end{itemize}
This gives the monad transformers for base monads \texttt{\textcolor{blue}{\footnotesize{}Reader}},
\texttt{\textcolor{blue}{\footnotesize{}Writer}}, \texttt{\textcolor{blue}{\footnotesize{}Either}}:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}type~ReaderT{[}R,~M{[}\_{]},~A{]}~=~R~$\Rightarrow$~M{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}type~EitherT{[}Z,~M{[}\_{]},~A{]}~=~M{[}Either{[}Z,~A{]}{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}type~WriterT{[}W,~M{[}\_{]},~A{]}~=~M{[}(W,~A){]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.2cm}}\texttt{\textcolor{blue}{\footnotesize{}ReaderT}}
wraps the foreign monad from the outside
\item \texttt{\textcolor{blue}{\footnotesize{}EitherT}} and \texttt{\textcolor{blue}{\footnotesize{}WriterT}}
require the foreign monad to wrap \emph{them} outside
\end{itemize}
Remaining questions:
\begin{itemize}
\item What are transformers for other standard monads (\texttt{\textcolor{blue}{\footnotesize{}List}},
\texttt{\textcolor{blue}{\footnotesize{}State}}, \texttt{\textcolor{blue}{\footnotesize{}Cont}})?
\begin{itemize}
\item These monads do not compose (neither ``inside'' nor ``outside''
works)
\end{itemize}
\item How to derive a monad transformer for an arbitrary given monad?
\begin{itemize}
\item For monads obtained via known monad constructions?
\item For monads constructed via other monad transformers?
\item Is it always possible? (Probably not.)
\end{itemize}
\item For a given monad, is the corresponding monad transformer unique?
\item How to avoid the boilerplate around \texttt{\textcolor{blue}{\footnotesize{}lift}}?
(\texttt{\textcolor{blue}{\footnotesize{}mtl}}-style transformers)
\end{itemize}
\end{frame}

\begin{frame}{Monad transformers IV: The zoology of monads}

Need to select the correct monad transformer construction, per monad:
\begin{itemize}
\item ``Composed-inside'', base monad is inside foreign monad: $T_{L}^{M,A}=M^{L^{A}}$
\begin{itemize}
\item Examples: \texttt{\textcolor{blue}{\footnotesize{}OptionT}}, \texttt{\textcolor{blue}{\footnotesize{}WriterT}},
\texttt{\textcolor{blue}{\footnotesize{}EitherT}} 
\end{itemize}
\item ``Composed-outside'', base monad is outside: $T_{L}^{M,A}=L^{M^{A}}$
\begin{itemize}
\item Examples: \texttt{\textcolor{blue}{\footnotesize{}ReaderT}}; \texttt{\textcolor{blue}{\footnotesize{}SearchT}}
for search monad \texttt{\textcolor{blue}{\footnotesize{}S{[}A{]}
= (A $\Rightarrow$ Z) $\Rightarrow$ A}} 
\item More generally: all rigid monads have ``outside'' transformers
\begin{itemize}
\item Definition: a \textbf{rigid monad} has the method \texttt{\textcolor{blue}{\footnotesize{}fuseIn}}$:\left(A\Rightarrow R^{B}\right)\Rightarrow R^{A\Rightarrow B}$
\end{itemize}
\end{itemize}
\item ``Recursive'': interleaves the base monad and the foreign monad
\begin{itemize}
\item Examples: \texttt{\textcolor{blue}{\footnotesize{}ListT}}, \texttt{\textcolor{blue}{\footnotesize{}NonEmptyListT}},
\texttt{\textcolor{blue}{\footnotesize{}FreeMonadT}} 
\end{itemize}
\item ``Irregular'': none of the above constructions work
\begin{itemize}
\item Examples: \texttt{\textcolor{blue}{\footnotesize{}StateT}}, \texttt{\textcolor{blue}{\footnotesize{}ContT}},
``codensity monads'' (no full transformers)
\end{itemize}
\item Examples of monads for which no transformers are available??
\item Monad constructions: defining a transformer for new monads
\begin{itemize}
\item Product monads $L_{1}^{A}\times L_{2}^{A}$ -- ``product transformer''
$T_{L_{1}}^{M,A}\times T_{L_{2}}^{M,A}$
\item Consumer choice monads $H^{A}\Rightarrow A$ -- ``composed-outside''
transformer
\item Free pointed monads $A+L^{A}$ -- transformer $M^{A+T_{L}^{M,A}}$
\item ``Selectors'' $\left(A\Rightarrow P^{Q}\right)\Rightarrow P^{A}$
-- transformer $\big(M^{A}\Rightarrow T_{P}^{M,Q}\big)\Rightarrow T_{P}^{M,A}$
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Rigid monads, their laws and structure I}

\begin{itemize}
\item A \textbf{rigid monad} $R^{\bullet}$ has the method \texttt{\textcolor{blue}{\footnotesize{}fuseIn}}$:\left(A\Rightarrow R^{B}\right)\Rightarrow R^{A\Rightarrow B}$
\begin{itemize}
\item Examples: $R^{A}\equiv A\times A$ and $R^{A}\equiv Z\Rightarrow A$
are rigid; $R^{A}\equiv1+A$ is not
\item Compare with \texttt{\textcolor{blue}{\footnotesize{}fuseOut}}$:R^{A\Rightarrow B}\Rightarrow A\Rightarrow R^{B}$,
which exists for any functor
\item Implementation: $\text{fo}\,h^{:R^{A\Rightarrow B}}=x^{:A}\Rightarrow\left(f^{:A\Rightarrow B}\Rightarrow f\,x\right)^{\uparrow R}h$
\end{itemize}
\item Laws: the \texttt{\textcolor{blue}{\footnotesize{}fuseIn}} method
(\texttt{\textcolor{blue}{\footnotesize{}$\text{fi}$}}) must be ``compatible
with the monad''
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}$\text{fi}$}} must be a lawful
lifting from $A\Rightarrow R^{B}$ to $R^{A\Rightarrow B}$
\end{itemize}
\item That is, a functor from Kleisli category to Applicative category
\begin{itemize}
\item identity law: $\text{fi}\left(\text{pure}_{R}\right)=\text{pure}_{R}\left(\text{id}\right)$
\item composition law: $\text{fi}\left(f\diamond_{R}g\right)=\left(p\times q\Rightarrow p\bef q\right)^{\uparrow R}\left(\text{fi}\,f\bowtie\text{fi}\,g\right)${\footnotesize{}\vspace{-0.3cm}}{\small{}
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{1.5pc}A\Rightarrow R^{B}\ar[d]\sp(0.4){\text{fi}} & \times\quad\quad B\Rightarrow R^{C}~\ar[d]\sp(0.4){\text{fi}}\ar[rr]\sb(0.5){\text{use }\diamond_{R}} &  & A\Rightarrow R^{C}\ar[d]\sp(0.4){\text{fi}}\\
R^{A\Rightarrow B} & \times\quad\quad R^{B\Rightarrow C}\quad~\ar[r]\sb(0.5){\text{use }\bowtie} & R^{\left(A\Rightarrow B\right)\times\left(B\Rightarrow C\right)}\ar[r]\sb(0.6){~\text{fmap}\left(\bef\right)} & R^{A\Rightarrow C}
}
\]
}{\small\par}
\item {\footnotesize{}\vspace{-0.3cm}}{\small{}Alternative formulation:
$\text{flm}=\text{fi}\bef\text{pa}$ where $\text{pa}:R^{A\Rightarrow B}\Rightarrow R^{A}\Rightarrow R^{B}$}{\small\par}
\item Then $\text{fi}\bef\text{fo}=\text{id}$. Proof: $\text{fo}\,x\,a=\text{pa}\,x\,\left(\text{pure}\,a\right)$;
set $x^{:R^{A\Rightarrow B}}=\text{fi}\,h^{:A\Rightarrow R^{B}}$
and get $\text{fo}\,x\,a=\text{pa}\,\left(\text{fi}\,h\right)\left(\text{pure}\,a\right)=\text{flm}\,h\left(\text{pure}\,a\right)=h\,a$,
so $\text{fo}\left(\text{fi}\,h\right)=h$ 
\end{itemize}
\item Rigid monads $R^{\bullet}$ have ``composed-outside'' transformers,
$T_{R}^{M,A}\equiv R^{M^{A}}$
\end{itemize}
\end{frame}

\begin{frame}{Rigid monads, their laws and structure II}

Examples and constructions of rigid and non-rigid monads:
\begin{itemize}
\item Rigid: $R^{A}\equiv A$, $R^{A}\equiv Z\Rightarrow A$, $R^{A}\equiv H^{A}\Rightarrow A$
($H^{\bullet}$ is a contrafunctor)
\item Not rigid: $R^{A}\equiv1$, $R^{A}\equiv W\times A$, $R^{A}\equiv E+A$,
$\text{List}^{A}$, $\text{Cont}^{A}$, $\text{State}^{A}$
\item The composition of rigid monads is rigid: $R_{1}^{R_{2}^{A}}$
\item The product of rigid monads is rigid: $R_{1}^{A}\times R_{2}^{A}$
\item The selector monad $S^{A}\equiv\left(A\Rightarrow R^{Q}\right)\Rightarrow R^{A}$
is rigid if $R^{A}$ is rigid
\item Any rigid functor is pointed: $A\Rightarrow R^{A}$
\end{itemize}
Use cases for rigid monads:
\begin{itemize}
\item For a rigid monad $R^{\bullet}$ and any monad $M^{\bullet}$, have
``$R$-valued \texttt{\textcolor{blue}{\footnotesize{}flatMap}}'':
$M^{A}\times\big(A\Rightarrow R^{M^{B}}\big)\Rightarrow R^{M^{B}}$
-- handles multiple $M^{\bullet}$ effects at once
\item For a rigid monad $R^{\bullet}$, can implement a general refactoring
function, \texttt{\textcolor{blue}{\footnotesize{}monadify}}$:\left(\left(A\Rightarrow B\right)\Rightarrow C\right)\Rightarrow\left(A\Rightarrow R^{B}\right)\Rightarrow R^{C}$
-- uptake monadic API
\end{itemize}
\end{frame}

\begin{frame}{Invalid attempts to create a general monad transformer}

General recipes for combining two functors $L^{\bullet}$ and $M^{\bullet}$
all fail
\begin{itemize}
\item ``Fake'' transformers: $T_{L}^{M,A}\equiv L^{A}$; or $T_{L}^{M,A}\equiv M^{A}$;
or just $T_{L}^{M,A}\equiv1$
\begin{itemize}
\item no \texttt{\textcolor{blue}{\footnotesize{}lift}} and/or no base runner
and/or $T_{L}^{\text{Id},A}\not\equiv L^{A}$
\end{itemize}
\item Functor composition: $L^{M^{\bullet}}$, $M^{L^{\bullet}}$ -- not
a monad for some $L^{\bullet}$, $M^{\bullet}$
\item Making a monad out of functor composition:
\begin{itemize}
\item free monad over $L^{M^{\bullet}}$, $\text{Free}^{L^{M}}$ -- \texttt{\textcolor{blue}{\footnotesize{}lift}}
violates lifting laws
\item free monad over $L^{\bullet}+M^{\bullet}$, $\text{Free}^{L^{\bullet}+M^{\bullet}}$
-- \texttt{\textcolor{blue}{\footnotesize{}lift}} violates lifting
laws
\begin{itemize}
\item However, laws will hold after interpreting the free monad!
\end{itemize}
\item codensity monad over $L^{M^{\bullet}}$: $F^{A}\equiv\forall B.\,\big(A\Rightarrow L^{M^{B}}\big)\Rightarrow L^{M^{B}}$
-- no \texttt{\textcolor{blue}{\footnotesize{}lift}} 
\end{itemize}
\item Codensity-$L$ transformer: $\text{Cod}_{L}^{M,A}\equiv\forall B.\left(A\Rightarrow L^{B}\right)\Rightarrow L^{M^{B}}$
-- no \texttt{\textcolor{blue}{\footnotesize{}lift}} 
\begin{itemize}
\item uses the continuation transformer on $M^{A}\cong\forall B.\left(A\Rightarrow B\right)\Rightarrow M^{B}$
\end{itemize}
\item Codensity composition: row M^{B}$
\end{itemize}
\item Codensity composition: $F^{A}\equiv\forall B.\left(M^{A}\Rightarrow L^{B}\right)\Rightarrow L^{B}$
-- not a monad
\begin{itemize}
\item Counterexample: $M^{A}\equiv R\Rightarrow A$ and $L^{A}\equiv S\Rightarrow A$
\end{itemize}
\item ``Monoidal'' convolution: {\small{}$\left(L\star M\right)^{A}\equiv\exists P\exists Q.\left(P\times Q\Rightarrow A\right)\times L^{P}\times M^{Q}$}{\small\par}
\begin{itemize}
\item combines $L^{A}\cong\exists P.L^{P}\times\left(P\Rightarrow A\right)$
with $M^{A}\cong\exists Q.M^{Q}\times\left(Q\Rightarrow A\right)$ 
\item $L\star M$ is not a monad for some $L^{\bullet}$, $M^{\bullet}$
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Exercises}
\begin{enumerate}
\item {\small{}Show that the method }\texttt{\textcolor{blue}{\footnotesize{}pure}}{\small{}$:A\Rightarrow M^{A}$
is a monadic morphism between monads $\text{Id}^{A}\equiv A$ and
$M^{A}$. Show that $1\Rightarrow1+A$ is not a monadic morphism.}{\small\par}
\item {\small{}Show that $M_{1}^{A}+M_{2}^{A}$ is }\emph{\small{}not}{\small{}
a monad when $M_{1}^{A}\equiv1+A$ and $M_{2}^{A}\equiv Z\Rightarrow A$.}{\small\par}
\item {\small{}Derive the composition law for }\texttt{\textcolor{blue}{\small{}lift}}{\small{}
written using $\text{ftn}$ as $\text{lift}_{1}\bef\text{fmap}_{\text{BigM}}\text{lift}_{1}\bef\text{ftn}_{\text{BigM}}=\text{ftn}_{M_{1}}\bef\text{lift}_{1}$
from the $\text{flm}$-based law $\text{lift}_{1}\bef\text{flm}_{\text{BigM}}\left(q\bef\text{lift}_{1}\right)=\text{flm}_{M_{1}}q\bef\text{lift}_{1}$.
Draw type diagrams for both laws.}{\small\par}
\end{enumerate}
\end{frame}

\end{document}
