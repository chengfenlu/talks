#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.0pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2cm
\topmargin 1.1cm
\rightmargin 2cm
\bottommargin 1.75cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Success,Failure,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Essay: Software engineers and software artisans
\end_layout

\begin_layout Standard
Let us look at the differences between the kind of activities we ordinarily
 call engineering, as opposed to artisanship or craftsmanship.
 It will then become apparent that today's computer programmers are better
 understood as 
\begin_inset Quotes eld
\end_inset

software artisans
\begin_inset Quotes erd
\end_inset

 rather than software engineers.
\end_layout

\begin_layout Section
Engineering disciplines 
\end_layout

\begin_layout Standard
Consider what kinds of process a mechanical engineer, a chemical engineer,
 or an electrical engineer follows in their work, and what kind of studies
 they require for proficiency in their work.
\end_layout

\begin_layout Standard
A mechanical engineer 
\begin_inset CommandInset href
LatexCommand href
name "studies"
target "https://www.colorado.edu/mechanical/undergraduate-students/curriculum"
literal "false"

\end_inset

 calculus, linear algebra, differential geometry, and several areas of physics
 such as theoretical mechanics, thermodynamics, and elasticity theory, and
 then uses calculations to guide the design of a bridge, say.
 A chemical engineer 
\begin_inset CommandInset href
LatexCommand href
name "studies"
target "https://www.colorado.edu/engineering/sample-undergraduate-curriculum-chemical"
literal "false"

\end_inset

 chemistry, thermodynamics, calculus, linear algebra, differential equations,
 some areas of physics such as thermodynamics and kinetic theory, and uses
 calculations to guide the design of a chemical process, say.
 An electrical engineer 
\begin_inset CommandInset href
LatexCommand href
name "studies"
target "https://seas.yale.edu/departments/electrical-engineering/undergraduate-study/undergraduate-curriculum-information"
literal "false"

\end_inset

 advanced calculus, linear algebra, as well as several areas of physics
 such as electrodynamics and quantum physics, and uses calculations to guide
 the design of an antenna or a microchip.
\end_layout

\begin_layout Standard
The pattern here is that an engineer uses mathematics and natural sciences
 in order to design new devices.
 Mathematical calculations and scientific reasoning are required 
\emph on
before
\emph default
 drawing a design, let alone building a real device or machine.
\end_layout

\begin_layout Standard
Some of the studies required for engineers include arcane abstract concepts
 such as a 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "rank-4 elasticity tensor"
target "https://serc.carleton.edu/NAGTWorkshops/mineralogy/mineral_physics/tensors.html"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 (used in calculations of elasticity of materials), 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Lagrangian with non-holonomic constraints"
target "https://arxiv.org/abs/math/0008147"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 (used in robotics), the 
\begin_inset Quotes eld
\end_inset

Gibbs free energy
\begin_inset Quotes erd
\end_inset

 (for 
\begin_inset CommandInset href
LatexCommand href
name "chemical reactor design"
target "https://www.amazon.com/Introduction-Chemical-Engineering-Kinetics-Reactor/dp/1118368258"
literal "false"

\end_inset

), or the 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Fourier transform of the delta function"
target "https://www.youtube.com/watch?v=KAbqISZ6SHQ"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "inverse Z-transform"
target "https://ocw.mit.edu/resources/res-6-008-digital-signal-processing-spring-2011/video-lectures/lecture-6-the-inverse-z-transform/"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 (for digital signal processing).
\end_layout

\begin_layout Standard
To be sure, a significant part of what engineers do is not covered by any
 theory: the 
\emph on
know-how
\emph default
, the informal reasoning, the traditional knowledge passed on from expert
 to novice,  –  all those skills that are hard to formalize.
 Nevertheless, engineering is crucially based on natural science and mathematics
 for some of its decision-making about new designs.
\end_layout

\begin_layout Section
Artisanship: Trades and crafts 
\end_layout

\begin_layout Standard
Now consider what kinds of things shoemakers, plumbers, or home painters
 do, and what they have to learn in order to become proficient in their
 profession.
\end_layout

\begin_layout Standard
A novice shoemaker, for example, would begin by 
\begin_inset CommandInset href
LatexCommand href
name "copying some drawings"
target "https://youtu.be/cY5MY0czMAk?t=141"
literal "false"

\end_inset

 and then cutting leather in a home workshop.
 Apprenticeships proceed via learning by doing while listening to comments
 and instructions from an expert.
 After a few years of apprenticeship (for example, a 
\begin_inset CommandInset href
LatexCommand href
name "painter apprenticeship in California"
target "http://www.calapprenticeship.org/programs/painter_apprenticeship.php"
literal "false"

\end_inset

 can be as short as 2 years), a new specialist is ready to start productive
 work.
 
\end_layout

\begin_layout Standard
All these trades operate entirely from tradition and practical experience.
 The trades do not require any academic study because there is no formal
 theory from which to proceed.
 To be sure, there is 
\emph on
a lot
\emph default
 to learn in the crafts, and it takes a large amount of effort to become
 a good artisan in any profession.
 But there are no rank-4 tensors to calculate, nor any differential equations
 to solve; no Fourier transforms to apply to delta functions, and no Lagrangians
 to check for non-holonomic constraints.
\end_layout

\begin_layout Standard
Artisans do not study any formal science or mathematics because their profession
s do not make use of any 
\emph on
formal computation
\emph default
 for guiding their designs or processes.
\end_layout

\begin_layout Section
Programmers today are artisans, not engineers 
\end_layout

\begin_layout Standard
Now I will argue that programmers are 
\emph on
not engineers
\emph default
 in the sense we normally see the engineering professions.
\end_layout

\begin_layout Subsection
No requirement of formal study 
\end_layout

\begin_layout Standard
According to this recent Stack Overflow survey, 
\begin_inset CommandInset href
LatexCommand href
name "about half of the programmers do not have a degree in Computer Science"
target "https://thenextweb.com/insider/2016/04/23/dont-need-go-college-anymore-programmer/"
literal "false"

\end_inset

.
 I am one myself; my degrees are in physics, and I have never formally studied
 computer science.
 I took no academic courses in algorithms, data structures, computer networks,
 compilers, programming languages, or any other topics ordinarily included
 in the academic study of 
\begin_inset Quotes eld
\end_inset

computer science
\begin_inset Quotes erd
\end_inset

.
 None of the courses I took at university or at graduate school were geared
 towards programming.
 I am a completely self-taught software developer.
\end_layout

\begin_layout Standard
There is a large number of successful programmers who 
\emph on
never
\emph default
 studied at a college, or perhaps never studied formally in any sense.
 They acquired all their knowledge and skills through self-study and practical
 work.
 
\begin_inset CommandInset href
LatexCommand href
name "Robert C. Martin"
target "https://en.wikipedia.org/wiki/Robert_C._Martin"
literal "false"

\end_inset

 is one such prominent example; an outspoken guru in the arts of programming
 who has seen it all, he routinely 
\begin_inset CommandInset href
LatexCommand href
name "refers to programmers as artisans"
target "https://blog.cleancoder.com/uncle-bob/2013/02/01/The-Humble-Craftsman.html"
literal "false"

\end_inset

 and uses the appropriate imagery: novices, trade and craft, the 
\begin_inset Quotes eld
\end_inset

honor of the guild
\begin_inset Quotes erd
\end_inset

, etc.
 He compares programmers to plumbers, electricians, lawyers, and surgeons,
 but not to mathematicians, physicists, or engineers of any kind.
 According to 
\begin_inset CommandInset href
LatexCommand href
name "one of his blog posts"
target "https://blog.cleancoder.com/uncle-bob/2013/11/25/Novices-Coda.html"
literal "false"

\end_inset

, he started working at age 17 as a self-taught programmer, and then went
 on to more jobs in the software industry; he never mentions going to college.
 It is clear that R.
\begin_inset space ~
\end_inset

C.
\begin_inset space ~
\end_inset

Martin 
\emph on
is
\emph default
 an expert craftsman, and that he did not need academic study to master
 his craft.
\end_layout

\begin_layout Standard
Here is 
\begin_inset CommandInset href
LatexCommand href
name "another opinion"
target "https://www.quora.com/Can-you-become-a-software-engineer-without-actually-going-to-university-college-How"
literal "false"

\end_inset

 (emphasis is theirs):
\end_layout

\begin_layout Quotation
Software Engineering is unique among the STEM careers in that it absolutely
 does 
\emph on
not
\emph default
 require a college degree to be successful.
 It most certainly does not require licensing or certification.
 
\emph on
It requires experience
\emph default
.
\end_layout

\begin_layout Standard
This is a description that fits a career in crafts – but certainly not a
 career, say, in electrical engineering.
\end_layout

\begin_layout Standard
The high demand for software developers gave rise to 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "developer boot camps"
target "https://cvbj.biz/2018/03/15/demand-software-developers-continues-soar-heres-cheapest-free-way-start-tech-career/"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 – vocational schools that prepare new programmers very quickly, with no
 formal theory or mathematics involved, through purely practical training.
 These vocational schools 
\begin_inset CommandInset href
LatexCommand href
name "are successful"
target "https://www.fullstackacademy.com/blog/why-are-some-coding-bootcamps-job-placement-rates-so-high"
literal "false"

\end_inset

 in job placement.
 But it is unimaginable that a 6-month crash course or even a 2-year vocational
 school could prepare an engineer to work successfully on designing, say,
 
\begin_inset CommandInset href
LatexCommand href
name "quantum computers"
target "https://www.dwavesys.com/quantum-computing"
literal "false"

\end_inset

, without ever having studied quantum physics or calculus.
\end_layout

\begin_layout Subsection
No mathematical formalism guides software development
\end_layout

\begin_layout Standard
Most books on software engineering contain no formulas or equations, no
 mathematical derivations of any results, and no precise definitions of
 the various technical terms they are using (such as 
\begin_inset Quotes eld
\end_inset

object-oriented
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

software architecture
\begin_inset Quotes erd
\end_inset

).
 Some books on software engineering even have no program code in them –
 just words and illustrative diagrams.
 These books talk about how programmers should approach their job, how to
 organize the work flow and the code architecture, in vague and general
 terms: 
\begin_inset Quotes eld
\end_inset

code is about detail
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

you must never abandon the big picture
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

you should avoid tight coupling in your modules
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a class must serve a single responsibility
\begin_inset Quotes erd
\end_inset

, and so on.
 Practitioners such as R.
\begin_inset space \space{}
\end_inset

C.
\begin_inset space \space{}
\end_inset

Martin never studied any formalisms and do not think in terms of formalisms;
 instead they think in 
\begin_inset CommandInset href
LatexCommand href
name "vaguely formulated, heuristic “principles”"
target "https://blog.cleancoder.com/uncle-bob/2016/03/19/GivingUpOnTDD.html"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
In contrast, every textbook on mechanical engineering or electrical engineering
 has a significant amount of mathematics in it.
 The design of a microwave antenna 
\begin_inset CommandInset href
LatexCommand href
name "is guided"
target "https://www.youtube.com/watch?v=46SbGxS73dY"
literal "false"

\end_inset

 not by the principle of 
\begin_inset Quotes eld
\end_inset

serving a single responsibility
\begin_inset Quotes erd
\end_inset

 but by calculations of wave propagation, based on theoretical electrodynamics.
\end_layout

\begin_layout Standard
Donald Knuth's classic textbook is called 
\begin_inset Quotes eld
\end_inset


\emph on
The Art of Programming
\emph default

\begin_inset Quotes erd
\end_inset

.
 It is full of tips and tricks about how to program; but it does not provide
 any formal theory that could guide programmers while actually 
\emph on
writing
\emph default
 programs.
 There is nothing in that book that would be similar to the way mathematical
 formalism guides designs in electrical or mechanical engineering.
 If Knuth's books were based on such formalism, they would have looked quite
 differently: some theory would be first explained and then applied to help
 us write code.
\end_layout

\begin_layout Standard
Knuth's books provide many algorithms, including mathematical ones.
 But algorithms are similar to patented inventions: They can be used immediately
 without further study.
 Understanding an algorithm is not similar to understanding a mathematical
 theory.
 Knowing one algorithm does not make it easier to develop another algorithm
 in an unrelated domain.
 In comparison, knowing how to solve differential equations will be applicable
 to thousands of different areas of science and engineering.
\end_layout

\begin_layout Standard
A book exists with the title 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Science of Programming"
target "https://www.amazon.com/Science-Programming-Monographs-Computer/dp/0387964800"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

, but the title is misleading.
 The author does not propose a science, similar to physics, at the foundation
 of the process of designing programs, similarly to how calculations in
 quantum physics predict the properties of a quantum device.
 The book claims to give precise methods that guide programmers in writing
 code, but the scope of proposed methods is narrow: the design of simple
 algorithms for iterative manipulation of data.
 The procedure suggested in that book is far from a formal mathematical
 
\emph on
derivation
\emph default
 of programs from specification.
 (
\begin_inset CommandInset href
LatexCommand href
name "A book with that title"
target "https://www.amazon.com/Program-Derivation-Development-Specifications-International/dp/0201416247"
literal "false"

\end_inset

 also exists, and similarly disappoints.) Programmers today are mostly oblivious
 to these books and do not use the methods explained there.
\end_layout

\begin_layout Standard
Standard computer science courses today do not teach a true 
\emph on
engineering
\emph default
 aproach to software construction.
 They do teach analysis of programs using formal mathematical methods; the
 main such methods are 
\begin_inset CommandInset href
LatexCommand href
name "complexity analysis"
target "https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html"
literal "false"

\end_inset

 (the 
\begin_inset Quotes eld
\end_inset

big-
\begin_inset Formula $O$
\end_inset

 notation
\begin_inset Quotes erd
\end_inset

), and 
\begin_inset CommandInset href
LatexCommand href
name "formal verification"
target "https://en.wikipedia.org/wiki/Formal_verification"
literal "false"

\end_inset

.
 But programs are analyzed only 
\emph on
after
\emph default
 they are complete.
 Theory does not guide the actual 
\emph on
process
\emph default
 of writing code, does not suggest good ways of organizing the code (e.g.
\begin_inset space ~
\end_inset

choosing which classes or functions or modules should be defined), and does
 not tell programmers which data structures or APIs would be best to implement.
 Programmers make these design decisions purely on the basis of experience
 and intuition, trial-and-error, copy-paste, and guesswork.
 
\end_layout

\begin_layout Standard
The theory of program analysis and verification is analogous to writing
 a mathematical equation for the surface of a shoe made by a fashion designer.
 True, the 
\begin_inset Quotes eld
\end_inset

shoe surface equations
\begin_inset Quotes erd
\end_inset

 are mathematically unambiguous and can be 
\begin_inset Quotes eld
\end_inset

analyzed
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

verified
\begin_inset Quotes erd
\end_inset

; but the equations are written after the fact and do not guide the fashion
 designers in actually making shoes.
 It is understandable that fashion designers do not study the mathematical
 theory of surfaces.
\end_layout

\begin_layout Subsection
Programmers avoid academic terminology 
\end_layout

\begin_layout Standard
Programmers appear to be taken aback by terminology such as 
\begin_inset Quotes eld
\end_inset

functor
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

monad
\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

lambda-functions
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Quotation
\begin_inset CommandInset href
LatexCommand href
name "Those fancy words"
target "https://www.cakesolutions.net/teamblogs/those-fancy-words-monads-functors-nonsense"
literal "false"

\end_inset

 used by functional programmers purists really annoy me.
 Monads, functors...
 Nonsense!!! 
\end_layout

\begin_layout Standard
In my experience, only a tiny minority of software engineers actually complain
 about this; the vast majority remain unaware of 
\begin_inset Quotes eld
\end_inset

functors
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

monads
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
However, chemical engineers do not wince at 
\begin_inset Quotes eld
\end_inset

phase diagram
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Gibbs free energy
\begin_inset Quotes erd
\end_inset

, and apparently accept the need for studying differential equations.
 Electrical engineers do not complain that the word 
\begin_inset Quotes eld
\end_inset

Fourier
\begin_inset Quotes erd
\end_inset

 is foreign and difficult to spell, or that 
\begin_inset Quotes eld
\end_inset

delta-function
\begin_inset Quotes erd
\end_inset

 is such a weird thing to say.
 Mechanical engineers take it for granted that they need to calculate with
 
\begin_inset Quotes eld
\end_inset

tensors
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Lagrangians
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

non-holonomic constraints
\begin_inset Quotes erd
\end_inset

.
 Actually, it seems that the arcane terminology is the least of their difficulti
es! Their textbooks are full of complicated equations and long, difficult
 derivations.
\end_layout

\begin_layout Standard
Similarly, software engineers would not complain about the word 
\begin_inset Quotes eld
\end_inset

functor
\begin_inset Quotes erd
\end_inset

, or about having to study the derivation of the algebraic laws for 
\begin_inset Quotes eld
\end_inset

monads,
\begin_inset Quotes erd
\end_inset

 – if they were actually 
\emph on
engineers
\emph default
.
 True software engineers' textbooks would be full of equations and derivations,
 which would be used to perform calculations required 
\emph on
before
\emph default
 starting to write code.
\end_layout

\begin_layout Section
Towards software engineering 
\end_layout

\begin_layout Standard
It is now clear that we do not presently have true software engineering.
 The people employed under that job title are actually artisans.
 They work using artisanal methods, and their culture and processes are
 that of a crafts guild.
\end_layout

\begin_layout Standard
One could point out that numerical simulations required for physics or the
 matrix calculations required for machine learning are 
\begin_inset Quotes eld
\end_inset

mathematical
\begin_inset Quotes erd
\end_inset

.
 True, these programming 
\emph on
tasks
\emph default
 are mathematical in nature and require formal theory to be 
\emph on
formulated
\emph default
.
 However, mathematical 
\emph on
subject matter
\emph default
 (aerospace control, physics or astronomy experiments, mathematical statistics,
 etc.) does not automatically make the 
\emph on
process of programming
\emph default
 into engineering.
 Data scientists, aerospace engineers, and natural scientists all write
 code nowadays – and they are all working as artisans when they write code.
\end_layout

\begin_layout Standard
True software engineering would be achieved if we had theory that guides
 and informs our process of creating programs, – not theory that describes
 or analyzes programs after they are somehow written.
\end_layout

\begin_layout Standard
We expect that software engineers' textbooks should be full of equations.
 What theory should those equations represent?
\end_layout

\begin_layout Standard
I believe this theory already exists, and I call it 
\series bold
functional type theory
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
functional type theory
\end_layout

\end_inset

.
 It is the algebraic foundation of the modern practice of functional programming
, as implemented in languages such as OCaml, Haskell, and Scala.
 This theory is a blend of type theory, category theory, and logical proof
 theory.
 It has been in development since late 1990s and is still being actively
 worked on by a community of academic computer scientists and advanced software
 practitioners.
\end_layout

\begin_layout Standard
To appreciate that functional programming, unlike any other programming
 paradigm, 
\emph on
has a theory that guides coding
\emph default
, we can look at some recent software engineering conferences such as 
\begin_inset CommandInset href
LatexCommand href
name "Scala By the Bay"
target "http://2015.scala.bythebay.io/"
literal "false"

\end_inset

 or 
\begin_inset CommandInset href
LatexCommand href
name "BayHac"
target "http://bayhac.org/"
literal "false"

\end_inset

, or at the numerous FP-related online tutorials and blogs.
 We cannot fail to notice that much time is devoted not to showing code
 but to a peculiar kind of mathematical reasoning.
 Rather than focusing on one or another API or algorithm, as it is often
 the case with other software engineering blogs or presentations, an FP
 speaker describes a 
\emph on
mathematical structure
\emph default
 – such as the 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "applicative functor"
target "http://www.youtube.com/watch?v=bmIxIslimVY"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 or the 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "free monad"
target "http://www.youtube.com/watch?v=U0lK0hnbc4U"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 – and illustrates its use for practical coding.
\end_layout

\begin_layout Standard
These people are not graduate students showing off their theoretical research;
 they are practitioners, software engineers who use FP on their jobs.
 It is just the nature of FP that certain mathematical tools – coming from
 formal logic and category theory – are now directly applicable to practical
 programming tasks.
\end_layout

\begin_layout Standard
These mathematical tools are not mere tricks for a specific programming
 language; they apply equally to all FP languages.
 Before starting to write code, the programmer can jot down certain calculations
 in a mathematical notation (see Fig.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "ftt-example"

\end_inset

).
 The results of those calculations will help design the code fragment the
 programmer is about to write.
 This activity is quite similar to that of an engineer who first performs
 some mathematical calculations and only then embarks on a real-life design
 project.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ftt-example.jpg
	width 75text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example calculation in functional type theory.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "ftt-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A recent example of the hand-in-hand development of the functional type
 theory and its applications is seen in the 
\begin_inset Quotes eld
\end_inset

free applicative functor
\begin_inset Quotes erd
\end_inset

 construction.
 It was first described in a 
\begin_inset CommandInset href
LatexCommand href
name "2014 paper"
target "https://arxiv.org/pdf/1403.0749.pdf"
literal "false"

\end_inset

; a couple of years later, a combined free applicative / free monad data
 type was designed and its implementation proposed 
\begin_inset CommandInset href
LatexCommand href
name "in Scala"
target "https://github.com/typelevel/cats/issues/983"
literal "false"

\end_inset

 as well as 
\begin_inset CommandInset href
LatexCommand href
name "in Haskell"
target "https://elvishjerricco.github.io/2016/04/08/applicative-effects-in-free-monads.html"
literal "false"

\end_inset

.
 This technique allows programmers to work with declarative side-effect
 computations where some parts are sequential but other parts can be computed
 in parallel, and to achieve the parallelism 
\emph on
automatically
\emph default
 while maintaining the composability of the resulting programs.
 The new technique has distinct advantages over using monad transformers,
 which was the previous method of composing declarative side-effects.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

free applicative / free monad
\begin_inset Quotes erd
\end_inset

 combination was designed and implemented by true software engineers.
 They first wrote down the types and derived the necessary algebraic properties;
 the obtained results directly guided them about how to proceed writing
 the library API.
\end_layout

\begin_layout Standard
Another example of a development in functional type theory is the  
\begin_inset Quotes eld
\end_inset

tagless final
\begin_inset Quotes erd
\end_inset

 encoding of data types, 
\begin_inset CommandInset href
LatexCommand href
name "first described in 2009"
target "http://okmij.org/ftp/tagless-final/index.html"
literal "false"

\end_inset

.
 This technique, developed from category theory and type theory motivations,
 has several advantages over the free monad technique and can improve upon
 it in a number of cases – just as the free monad itself was designed to
 cure certain 
\begin_inset CommandInset href
LatexCommand href
name "problems with monad transformers"
target "http://blog.ezyang.com/2013/09/if-youre-using-lift-youre-doing-it-wrong-probably/"
literal "false"

\end_inset

.
 The new technique is also not a trick in a specific programming language;
 rather, it is a theoretical development that is available to programmers
 in any language (
\begin_inset CommandInset href
LatexCommand href
name "even in Java"
target "https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/"
literal "false"

\end_inset

).
\end_layout

\begin_layout Standard
This example shows that we may need several more years of work before the
 practical aspects of using 
\begin_inset Quotes eld
\end_inset

functional type theory
\begin_inset Quotes erd
\end_inset

 are sufficiently well understood by the FP community.
 The theory is in active development, and its design patterns – as well
 as the exact scope of the requisite theoretical material – are still being
 figured out.
 If 
\begin_inset CommandInset href
LatexCommand href
name "the 40-year gap hypothesis"
target "https://www.linkedin.com/pulse/40-year-gap-what-has-academic-computer-science-ever-done-winitzki/"
literal "false"

\end_inset

 holds, we should expect functional type theory (perhaps under a different
 name) to become mainstream by 2030.
 This book is a step towards a clear designation of the scope of that theory.
\end_layout

\begin_layout Section
Does software need engineers, or are artisans good enough? 
\end_layout

\begin_layout Standard
The demand for programmers is growing.
 
\begin_inset Quotes eld
\end_inset

Software developer
\begin_inset Quotes erd
\end_inset

 was 
\begin_inset CommandInset href
LatexCommand href
name "#1 best job"
target "https://money.usnews.com/money/careers/articles/how-us-news-ranks-the-best-jobs"
literal "false"

\end_inset

 in the US in 2018.
 But is there a demand for engineers, or just for artisans?
\end_layout

\begin_layout Standard
We 
\begin_inset CommandInset href
LatexCommand href
name "do not seem to be able"
target "https://www.mendix.com/blog/5-stats-illustrating-the-developer-shortage-facing-enterprise-organizations/"
literal "false"

\end_inset

 to train enough software artisans.
 Therefore, it is probably impossible to train as many software engineers
 in the true sense of the word.
 Modern courses in Computer Science do not actually train engineers in that
 sense; at best, they train academics who act as software artisans when
 writing code.
 The few existing true software 
\emph on
engineers
\emph default
 are all self-taught.
 Recalling the situation in construction business, with a few architects
 and hundreds of construction workers, we might also conclude that, perhaps,
 only a few software engineers are required per hundred software artisans.
\end_layout

\begin_layout Standard
What is the price of 
\emph on
not
\emph default
 having engineers, of replacing them with artisans?
\end_layout

\begin_layout Standard
Software practitioners have long bemoaned the mysterious difficulty of software
 development.
 Code 
\begin_inset Quotes eld
\end_inset

becomes rotten with time
\begin_inset Quotes erd
\end_inset

, programs grow in size 
\begin_inset Quotes eld
\end_inset

out of control
\begin_inset Quotes erd
\end_inset

, and operating systems have been notorious for ever-appearing 
\begin_inset CommandInset href
LatexCommand href
name "security flaws"
target "https://www.techrepublic.com/article/a-malicious-usb-stick-could-crash-your-windows-pc-even-if-its-locked/"
literal "false"

\end_inset

 despite many thousands of programmers and testers employed.
 I think this shows we are overestimating the artisanal creative capacity
 of the human brain.
\end_layout

\begin_layout Standard
It is precisely in designing very large and robust software systems that
 we would benefit from true engineering.
 Consider that humanity has been using chemical reactions and building bridges
 by trial, error, and adherence to tradition, long before mechanical or
 chemical engineering disciplines were developed and founded upon rigorous
 theory.
 Once the theory became available, humanity proceeded to create unimaginably
 more complicated and powerful structures and devices than ever before.
\end_layout

\begin_layout Standard
For building large and reliable software, such as new mobile or embedded
 operating systems or distributed peer-to-peer trust architectures, we will
 most likely need the qualitative increase in productivity and reliability
 that can only come from transforming artisanal programming into a proper
 engineering discipline.
 Functional type theory and functional programming are first steps in that
 direction.
\end_layout

\begin_layout Chapter
Essay: Towards functional data engineering with Scala
\end_layout

\begin_layout Standard
Data engineering is among 
\begin_inset CommandInset href
LatexCommand href
name "the most in-demand"
target "https://www.forbes.com/sites/louiscolumbus/2017/05/13/ibm-predicts-demand-for-data-scientists-will-soar-28-by-2020/"
literal "false"

\end_inset

 novel occupations in the IT world today.
 Data engineers create software pipelines that process large volumes of
 data efficiently.
 Why did the Scala programming language 
\begin_inset CommandInset href
LatexCommand href
name "emerge as a premier tool"
target "https://www.slideshare.net/noootsab/scala-the-unpredicted-lingua-franca-for-data-science"
literal "false"

\end_inset

 for crafting the foundational data engineering technologies such as Spark
 or Akka? Why is 
\begin_inset CommandInset href
LatexCommand href
name "Scala in such demand"
target "https://techcrunch.com/2016/06/14/scala-is-the-new-golden-child/"
literal "false"

\end_inset

 within the world of big data software?
\end_layout

\begin_layout Standard
There are reasons to believe that the choice of Scala was quite far from
 pure happenstance.
\end_layout

\begin_layout Section
Data is math
\end_layout

\begin_layout Standard
Humanity has been working with data at least since 
\begin_inset CommandInset href
LatexCommand href
name "Babylonian tax tables"
target "https://www.nytimes.com/2017/08/29/science/trigonometry-babylonian-tablet.html?mcubz=0"
literal "false"

\end_inset

 and the 
\begin_inset CommandInset href
LatexCommand href
name "ancient Chinese number books"
target "http://quatr.us/china/science/chinamath.htm"
literal "false"

\end_inset

.
 Mathematics summarizes several millennia's worth of data processing experience
 into a few tenets:
\end_layout

\begin_layout Itemize
Data is 
\emph on
immutable
\emph default
, because facts are immutable.
 
\end_layout

\begin_layout Itemize
Each 
\emph on
type
\emph default
 of values – population count, land area, distances, prices, dates, times,
 – needs to be handled separately; e.g.
\begin_inset space \space{}
\end_inset

it is meaningless to add a distance to a population count.
\end_layout

\begin_layout Itemize
Data processing is to be codified by 
\emph on
mathematical formulas
\emph default
.
 
\end_layout

\begin_layout Standard
Violating these tenets produces nonsense (see Fig.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "nonsense-math"

\end_inset

).
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename type-error.jpg
	width 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A nonsensical calculation arises when mixing incompatible data types.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "nonsense-math"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The power of the basic principles of mathematics extends over all epochs
 and all cultures; they are the same in Rio de Janeiro, in Kuala-Lumpur,
 and even in Pyongyang (see Fig.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "code-without-bugs"

\end_inset

).
\end_layout

\begin_layout Section
Functional programming is math
\end_layout

\begin_layout Standard
The functional programming paradigm is based on similar principles: values
 are immutable, data processing is coded through formula-like expressions,
 and each type of data is required to match correctly during the computations.
 A flexible system of data types helps programmers automatically prevent
 many kind of coding errors.
 In addition, modern programming languages such as Scala and Haskell have
 a set of features adapted to building powerful abstractions and domain-specific
 languages.
 This power of abstraction is not accidental.
 Since mathematics is the ultimate art of building abstractions, math-based
 functional programming languages capitalize on the advantage of several
 millennia of mathematical experience.
\end_layout

\begin_layout Standard
A prominent example of how mathematics informs the design of programming
 languages is the connection between 
\begin_inset CommandInset href
LatexCommand href
name "constructive logic"
target "https://en.wikipedia.org/wiki/Intuitionistic_logic"
literal "false"

\end_inset

 and the programming language's type system, called the 
\begin_inset CommandInset href
LatexCommand href
name "Curry-Howard (CH) correspondence"
target "https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence"
literal "false"

\end_inset

.
 The main idea of the CH correspondence
\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence
\end_layout

\end_inset

 is to think of programs as mathematical formulas that compute a value of
 a certain type 
\begin_inset Formula $A$
\end_inset

.
 The CH correspondence is between programs and logical propositions.
 To any program that computes a value of type 
\begin_inset Formula $A$
\end_inset

, there corresponds a proposition stating that 
\begin_inset Quotes eld
\end_inset

a value of type 
\begin_inset Formula $A$
\end_inset

 can be computed
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
This may sound rather theoretical so far.
 To see the real value of the CH correspondence, recall that formal logic
 has operations 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
and
\series default
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
or
\series default
\emph default

\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
implies
\series default
\emph default

\begin_inset Quotes erd
\end_inset

.
 For any two propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, we can construct the propositions 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
and
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
or
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
implies
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 These three logical operations are foundational; without one of them, the
 logic is 
\emph on
incomplete
\emph default
 (you cannot derive some theorems).
\end_layout

\begin_layout Standard
A programming language 
\series bold
obeys the CH correspondence
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence
\end_layout

\end_inset

 to the logic if for any two types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, the language also contains composite types corresponding to the logical
 formulas 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
or
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
and
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
implies
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 In Scala, these composite types are 
\family typewriter
Either[A,B]
\family default
, the tuple 
\family typewriter
(A,B)
\family default
, and the function type, 
\family typewriter
A
\begin_inset Formula $\Rightarrow$
\end_inset

B
\family default
.
 All modern functional languages such as OCaml, Haskell, Scala, F#, Swift,
 Elm, and PureScript support these three type constructions and thus are
 faithful to the CH correspondence.
 Having a 
\emph on
complete
\emph default
 logic in a language's type system enables 
\begin_inset CommandInset href
LatexCommand href
name "declarative domain-driven code design"
target "https://fsharpforfunandprofit.com/ddd/"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
It is interesting to note that most older programming languages (C/C++,
 Java, JavaScript, Python) do not support some of these composite types.
 In other words, these programming languages have type systems based on
 an incomplete logic.
 As a result, users of these languages have to implement burdensome workarounds
 that make for error-prone code.
 Failure to follow mathematical principles has real costs.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename no-bugs.jpg
	width 75text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The Pyongyang method of error-free programming.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "code-without-bugs"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
The power of abstraction
\end_layout

\begin_layout Standard
Data engineering at scale poses problems of such complexity that many software
 companies adopt functional programming languages as their main implementation
 tool.
 Netflix, LinkedIn, Twitter started using Scala early on and were able to
 reap the benefits of the powerful abstractions Scala affords, such as asynchron
ous streams and parallelized functional collections.
 In this way, Scala enabled these businesses to engineer and scale up their
 massively concurrent computations.
 What exactly makes Scala suitable for big data processing?
\end_layout

\begin_layout Standard
The only way to manage massively concurrent code is to use sufficiently
 high-level abstractions that make application code declarative.
 The two most important such abstractions are the 
\begin_inset Quotes eld
\end_inset

resilient distributed dataset
\begin_inset Quotes erd
\end_inset

 (RDD) of Apache Spark and the 
\begin_inset Quotes eld
\end_inset

reactive stream
\begin_inset Quotes erd
\end_inset

 used in systems such as Kafka, Apache Storm, Akka Streams, and Apache Flink.
 While these abstractions are certainly implementable in Java or Python,
 true declarative and type-safe usage is possible only in a programming
 language with a sufficiently sophisticated functional type system.
 Among the currently available mature functional languages, only Scala and
 Haskell would be technically adequate for that task, due to their support
 for typeclasses and higher-order generic collections.
\end_layout

\begin_layout Standard
It remains to see why Scala became the 
\emph on
lingua franca
\emph default
 of big data and not, say, Haskell.
\end_layout

\begin_layout Section
Scala is Java on math 
\end_layout

\begin_layout Standard
The recently invented general-purpose functional programming languages can
 be grouped into 
\begin_inset Quotes eld
\end_inset

industrial
\begin_inset Quotes erd
\end_inset

 (F#, Scala, Swift) and 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 (OCaml, Haskell).
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 languages are clean-room implementations of well-researched mathematical
 principles of programming language design (the CH correspondence being
 one such principle).
 These languages are unencumbered by requirements of compatibility with
 any existing platform or libraries.
 Because of this, the 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 languages are perfect playgrounds for taking various mathematical ideas
 to their logical conclusion.
 At the same time, software practitioners struggle to adopt these languages
 due to a steep learning curve, a lack of enterprise-grade libraries and
 tool support, and immature package management.
\end_layout

\begin_layout Standard
The languages from the 
\begin_inset Quotes eld
\end_inset

industrial
\begin_inset Quotes erd
\end_inset

 group are based on existing and mature software ecosystems: F# on .NET,
 Scala on JVM, and Swift on Apple's MacOS/iOS platform.
 One of the important design requirements for these languages is 100% binary
 compatibility with their 
\begin_inset Quotes eld
\end_inset

parent
\begin_inset Quotes erd
\end_inset

 platforms and languages (F# with C#, Scala with Java, and Swift with Objective-
C).
 Because of this, developers can immediately take advantage of the existing
 tooling, package management, and industry-strength libraries, while slowly
 ramping up the idiomatic usage of new language features.
 However, the same compatibility requirements necessitated certain limitations
 in the languages, making their design less than fully satisfactory from
 the functional programming viewpoint.
\end_layout

\begin_layout Standard
It is now easy to see why the adoption rate of the 
\begin_inset Quotes eld
\end_inset

industrial
\begin_inset Quotes erd
\end_inset

 group of languages is 
\begin_inset CommandInset href
LatexCommand href
name "much higher"
target "https://www.tiobe.com/tiobe-index/"
literal "false"

\end_inset

 than that of the 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 languages.
 The transition to the functional paradigm is also made smoother for software
 developers because F#, Scala, and Swift seamlessly support the familiar
 object-oriented programming paradigm.
 At the same time, these new languages still have logically complete type
 systems, which gives developers an important benefit of type-safe domain
 modeling.
\end_layout

\begin_layout Standard
Nevertheless, the type systems of these languages are not equally powerful.
 For instance, F# and Swift are similar to OCaml in many ways but omit OCaml's
 parameterized modules and some other features.
 Of all mentioned languages, only Scala and Haskell directly support typeclasses
 and higher-order generics, which are necessary for expressing abstractions
 such as automatically parallelized data sets or asynchronous data streams.
\end_layout

\begin_layout Standard
To see the impact of these advanced features of Scala and Haskell, consider
 LINQ, a domain-specific language for database queries on .NET, implemented
 in C# and F# through a special built-in syntax supported by Microsoft's
 compilers.
 Analogous functionality is provided in Scala as a 
\emph on
library
\emph default
, without need to modify the Scala compiler, by several open-source projects
 such as Slick, Squeryl, or Quill.
 Similar libraries exist for Haskell – but are impossible to implement in
 languages with less powerful type systems.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
The decisive advantages of Scala over other contenders (such as OCaml, Haskell,
 F#, or Swift) are
\end_layout

\begin_layout Enumerate
functional collections in the standard library;
\end_layout

\begin_layout Enumerate
a highly sophisticated type system, with support for typeclasses and higher-orde
r generics; 
\end_layout

\begin_layout Enumerate
seamless compatibility with a mature software ecosystem (JVM).
 
\end_layout

\begin_layout Standard
Based on this assessment, we may be confident in Scala's great future as
 a main implementation language for big data engineering.
 
\end_layout

\begin_layout Chapter
\begin_inset Quotes eld
\end_inset

Applied functional type theory
\begin_inset Quotes erd
\end_inset

: A proposal
\end_layout

\begin_layout Standard
What exactly is the extent of 
\begin_inset Quotes eld
\end_inset

theory
\begin_inset Quotes erd
\end_inset

 that a practicing functional programmer should know in order to be effective
 at writing code in the functional paradigm? In my view, this question is
 not yet resolved.
 In this book, I present a coherent body of theoretical knowledge that I
 believe fits the description of 
\begin_inset Quotes eld
\end_inset

practicable functional programming theory
\begin_inset Quotes erd
\end_inset

.
 This body of knowledge is, or should be, understood as a branch of computer
 science, and I propose to call it
\series bold
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
applied functional type theory
\end_layout

\end_inset

applied functional type theory
\series default
 (AFTT).
 This is the area of theoretical computer science that should serve the
 needs of functional programmers working as software engineers.
\end_layout

\begin_layout Standard
It is for these practitioners (I am one myself), rather than for academic
 researchers, that I set out to examine the functional programming inventions
 over the last 30 years, – such as the 
\begin_inset CommandInset href
LatexCommand href
name "“functional pearls” papers"
target "https://wiki.haskell.org/Research_papers/Functional_pearls"
literal "false"

\end_inset

 – and to determine the scope of theoretical material that has demonstrated
 its pragmatic usefulness and thus belongs to AFTT, as opposed to material
 that is purely academic and may be tentatively omitted.
 This book is a first step towards formulating AFTT.
\end_layout

\begin_layout Standard
In this book, I show code in Scala because I am familiar with that language.
 However, most of this material will work equally well in Haskell, OCaml,
 and other FP languages.
 This is so because the science of functional programming, which I call
 AFTT, is not a set of tricks specific to Scala or Haskell.
 An advanced user of any other functional programming language will have
 to face the same questions and struggle with the same practical issues.
\end_layout

\begin_layout Section
AFTT is not covered by computer science curricula
\end_layout

\begin_layout Standard
Traditional courses of theoretical computer science (algorithms and data
 structures, complexity theory, distributed systems, databases, network
 systems, compilers, operating systems) are largely not relevant to AFTT.
\end_layout

\begin_layout Standard
Here is an example: To an academic computer scientist, the 
\begin_inset Quotes eld
\end_inset

science behind Haskell
\begin_inset Quotes erd
\end_inset

 is the theory of lambda-calculus, the type-theoretic 
\begin_inset Quotes eld
\end_inset

System 
\begin_inset Formula $F\omega$
\end_inset


\begin_inset Quotes erd
\end_inset

, and formal semantics.
 These theories guided the design of the Haskell language and define rigorously
 what a Haskell program 
\begin_inset Quotes eld
\end_inset

means
\begin_inset Quotes erd
\end_inset

 in a mathematical sense.
 Academic computer science courses teach these theories, although typically
 only at the graduate level.
 
\end_layout

\begin_layout Standard
However, a practicing Haskell or Scala programmer is not concerned with
 designing Haskell or Scala, or with proving any theoretical properties
 of those languages.
 A practicing programmer is mainly concerned with 
\emph on
using
\emph default
 a chosen programming language to 
\emph on
write code
\emph default
.
 
\end_layout

\begin_layout Standard
Neither the theory of lambda-calculus, nor proofs of type-theoretical properties
 of 
\begin_inset Quotes eld
\end_inset

System 
\begin_inset Formula $F\omega$
\end_inset


\begin_inset Quotes erd
\end_inset

, nor theories of formal semantics will actually help a programmer to write
 code.
 So all these theories are not within the scope of AFTT.
 Functional programming does not require graduate-level theoretical studies.
\end_layout

\begin_layout Standard
As an example of theoretical material that 
\emph on
is
\emph default
 within the scope of AFTT, consider the equational laws imposed on applicative
 functors (see Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:8-Applicative-functors,-contrafunc"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout
applicative functors
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
It is essential for a practicing functional programmer to be able to recognize
 and use applicative functors.
 An applicative functor is a data structure specifying declaratively a set
 of operations that run independently of each other.
 Programs can then easily combine these operations, for example, in order
 to execute them in parallel, or to refactor the program for better maintainabil
ity.
\end_layout

\begin_layout Standard
To use this functionality, the programmer must begin by checking whether
 a given data structure satisfies the laws of applicative functors.
 In a given application, a data structure may be dictated in part by the
 business logic rather than by a programmer's choice.
 The programmer first writes down the type of that data structure and the
 code implementing the required methods, and then checks that the laws hold.
 The data structure may need to be adjusted in order to fit the definition
 of an applicative functor or its laws.
\end_layout

\begin_layout Standard
This work is done using pen and paper, in a mathematical notation.
 Once the applicative laws are verified, the programmer proceeds to write
 code using that data structure.
\end_layout

\begin_layout Standard
Because of the mathematical proofs, it is assured that the data structure
 satisfies the known properties of applicative functors, no matter how the
 rest of the program is written.
 So, for example, it is assured that the relevant effects can be automatically
 parallelized and will still work correctly.
 In this way, AFTT directly guides the programmer and helps to write correct
 code.
\end_layout

\begin_layout Standard
Applicative functors were discovered by practitioners who were using Haskell
 for writing code, in applications such as parser combinators, compilers,
 and domain-specific languages for parallel computations.
 However, applicative functors are not a feature of Haskell: they are the
 same in Scala, OCaml, or any other functional programming language.
 And yet, no standard computer science textbook defines applicative functors,
 motivates their laws, explores their structure on basic examples, or shows
 data structures that are 
\emph on
not
\emph default
 applicative functors and explains why.
 (Books on category theory and type theory also do not mention applicative
 functors.)
\begin_inset Index idx
status open

\begin_layout Plain Layout
applicative functors
\end_layout

\end_inset


\end_layout

\begin_layout Section
AFTT is not category theory, type theory, or formal logic
\end_layout

\begin_layout Standard
So far it appears that AFTT includes a selection of certain areas of category
 theory, formal logic, and type theory.
 However, software engineers would not derive much benefit from following
 traditional academic courses in these subjects, because their presentation
 is too abstract and at the same time lacks specific results necessary for
 practical programming.
 In other words, the traditional academic courses answer questions that
 academic computer scientists have, not questions that software engineers
 have.
\end_layout

\begin_layout Standard
There exist several books intended as presentations of category theory 
\begin_inset Quotes eld
\end_inset

for computer scientists
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

for programmers
\begin_inset Quotes erd
\end_inset

.
 However, these books do not explain certain concepts relevant to programming,
 such as applicative or traversable functors.
 Instead, these books contain purely theoretical topics such as limits,
 adjunctions, or toposes, – concepts that have no applications in practical
 functional programming today.
\end_layout

\begin_layout Standard
Typical questions in academic books are: 
\begin_inset Quotes eld
\end_inset

Is 
\begin_inset Formula $X$
\end_inset

 an introduction rule or an elimination rule
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Does the property 
\begin_inset Formula $Y$
\end_inset

 hold in non-small categories, or only in the category of sets
\begin_inset Quotes erd
\end_inset

.
 Typical questions a Scala programmer might have are: 
\begin_inset Quotes eld
\end_inset

Can we compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Z, R => A]
\end_layout

\end_inset

 from a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R => Either[Z, A]
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Is the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A] = Option[(A, A, A)]
\end_layout

\end_inset

 a monad or only an applicative functor
\begin_inset Quotes erd
\end_inset

.
 The proper scope of AFTT includes answering the last two questions, but
 
\emph on
not
\emph default
 the first two.
\end_layout

\begin_layout Standard
A software engineer hoping to understand the foundations of functional programmi
ng will not find the concepts of filterable, applicative, or traversable
 functors in any books on category theory, including books intended for
 programmers.
 And yet, these concepts are necessary to obtain a mathematically correct
 implementation of such foundationally important operations as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 – operations that functional programmers often use in their code.
\end_layout

\begin_layout Standard
To compensate for the lack of AFTT textbooks, programmers have written many
 online tutorials for each other, trying to explain the theoretical concepts
 necessary for practical work.
 There are the infamous 
\begin_inset Quotes eld
\end_inset

monad tutorials
\begin_inset Quotes erd
\end_inset

, but also tutorials about applicative functors, traversable functors, free
 monads, and so on.
 These tutorials tend to be hands-on (
\begin_inset Quotes eld
\end_inset

run this code now and see what happens
\begin_inset Quotes erd
\end_inset

) and narrow in scope, limited to one or two specific questions and specific
 applications.
 Such tutorials usually do not present sufficient mathematical insights
 to help programmers develop the necessary mathematical intuition.
\end_layout

\begin_layout Standard
For example, 
\begin_inset Quotes eld
\end_inset

free monads
\begin_inset Quotes erd
\end_inset

 became popular in the Scala community around 2015.
 Many talks about free monads were presented at Scala engineering conferences,
 each giving their own slightly different implementation but never formulating
 rigorously the required properties for a piece of code to be a valid implementa
tion of the free monad.
\end_layout

\begin_layout Standard
Without knowledge of mathematical principles behind free monads, a programmer
 cannot make sure that a given implementation is correct.
 However, books on category theory present free monads in a way that is
 unsuitable for programming applications: a free monad is just an adjoint
 functor to a forgetful functor into the category of sets.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

What's your problem?
\begin_inset Quotes erd
\end_inset

 as the joke would go.
\end_layout

\end_inset

 This definition is too abstract and, for instance, cannot be used to check
 whether a given implementation of the free monad in Scala is correct.
\end_layout

\begin_layout Standard
Perhaps the best selection of AFTT tutorial material can be found in the
 
\begin_inset CommandInset href
LatexCommand href
name "Haskell Wikibooks"
target "https://en.wikibooks.org/wiki/Haskell"
literal "false"

\end_inset

.
 However, those tutorials are incomplete and limited to explaining the use
 of Haskell.
 Many of them are suitable neither as a first introduction nor as a reference
 on AFTT.
 Also, the Haskell Wikibooks tutorials rarely show any proofs or derivations
 of equational laws.
\end_layout

\begin_layout Standard
Apart from referring to some notions from category theory, AFTT also uses
 some concepts from type theory and formal logic.
 However, existing textbooks on type theory and formal logic focus on domain
 theory and proof theory – which is a lot of information that practicing
 programmers will have difficulty assimilating and yet will have no chance
 of ever applying in their daily work.
 At the same time, these books never mention practical techniques used in
 many functional programming libraries today, such as quantified types,
 types parameterized by type constructors, or partial type-level functions
 (known as 
\begin_inset Quotes eld
\end_inset

typeclasses
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
Type theory and formal logic can, in principle, help the programmer with
 certain practical tasks, such as:
\end_layout

\begin_layout Itemize
deciding whether two data structures are equivalent as types, and implementing
 the isomorphism transformation; for example, the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, Either[B, C])
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, B), (A, C)]
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
detecting whether a definition of a recursive type is 
\begin_inset Quotes eld
\end_inset

reasonable
\begin_inset Quotes erd
\end_inset

, i.e.
\begin_inset space ~
\end_inset

does not lead to a useless infinite recursion; an example of a useless recursive
 type definition in Scala is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Bad(x: Bad)
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
deriving an implementation of a function from its type signature and required
 laws; for example, deriving the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad from the type signature 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flatMap[Z, A, B](r: Z => A)(f: A => Z => B): Z => B
\end_layout

\end_inset

 and verifying that the monad laws hold
\end_layout

\begin_layout Itemize
deciding whether a generic pure function with a given signature can be implement
ed; for example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A, B]: (A => B) => A
\end_layout

\end_inset

 cannot be implemented but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def g[A, B]: A => (B => A)
\end_layout

\end_inset

 can be implemented 
\end_layout

\begin_layout Standard
I mention these practical tasks as examples because they are actual real-world-c
oding applications of domain theory and the Curry-Howard correspondence
 theory.
 However, existing books on type theory and logic do not give practical
 recipes for resolving these questions.
\end_layout

\begin_layout Standard
On the other hand, books such as 
\begin_inset CommandInset href
LatexCommand href
name "“Scala with Cats”"
target "https://underscore.io/books/scala-with-cats/"
literal "false"

\end_inset

 and 
\begin_inset CommandInset href
LatexCommand href
name "“Functional programming, simplified”"
target "https://alvinalexander.com/scala/functional-programming-simplified-book"
literal "false"

\end_inset

 are focused on explaining the practical aspects of programming and do not
 adequately treat the equational laws that the mathematical structures require
 (such as the laws for applicative or monadic functors).
\end_layout

\begin_layout Standard
The only existing Scala-based AFTT textbook aiming at the proper scope is
 the 
\begin_inset CommandInset href
LatexCommand href
name "Bjarnason-Chiusano book"
target "https://www.manning.com/books/functional-programming-in-scala"
literal "false"

\end_inset

, which balances practical considerations with theoretical developments
 such as equational laws.
 This book is written at about the same level but goes deeper into the mathemati
cal foundations and at the same time gives a wider range of examples.
\end_layout

\begin_layout Standard
This book is an attempt to delineate the proper scope of AFTT and to develop
 a rigorous yet clear and approachable presentation of the chosen material.
 
\end_layout

\end_body
\end_document
