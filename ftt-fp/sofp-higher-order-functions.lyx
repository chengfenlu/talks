#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% Better formatting of tables.
%\usepackage{booktabs}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.0pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.
\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt,utf8
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7in
\paperheight 9in
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Success,Failure,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The formal logic of types II.
 Higher-order functions
\begin_inset CommandInset label
LatexCommand label
name "chap:Higher-order-functions"

\end_inset

 
\end_layout

\begin_layout Section
Functions that return functions
\end_layout

\begin_layout Subsection
Motivation and a first example
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset

Consider the task of preparing a logger function that prints messages but
 adds a fixed prefix to each message.
 
\end_layout

\begin_layout Standard
A simple logger function can be viewed as a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => Unit
\end_layout

\end_inset

, such as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val logger: String => Unit = { message => println(s
\begin_inset Quotes erd
\end_inset

INFO: $message
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> logger("hello world")
\end_layout

\begin_layout Plain Layout

INFO: hello world
\end_layout

\end_inset

This function prints any given message with the logging prefix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Note that the standard library function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

println(...)
\end_layout

\end_inset

 always returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 value after printing its arguments.
 As we already know, there is only a single value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, and that value is denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 To verify, run this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x = println(123)
\end_layout

\begin_layout Plain Layout

123
\end_layout

\begin_layout Plain Layout

x: Unit = ()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The task is to make the logging prefix configurable.
 A simple solution is to implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 that takes a prefix as an argument and returns a new logger with that prefix
 fixed.
 It is important to note that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 will return a new value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => Unit
\end_layout

\end_inset

, i.e.
\begin_inset space ~
\end_inset

a new 
\emph on
function
\emph default
:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def logWith(prefix: String): (String => Unit) = {
\end_layout

\begin_layout Plain Layout

    message => println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 consists of a single expression, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{message => println(...)}
\end_layout

\end_inset

, which is a nameless function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => Unit
\end_layout

\end_inset

.
 This expression is what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(...)
\end_layout

\end_inset

 will compute and return as its value.
\end_layout

\begin_layout Standard
We can now use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 to create a few logger functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val info = logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

info: String => Unit = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val warn = logWith(
\begin_inset Quotes eld
\end_inset

WARN
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

warn: String => Unit = <function1>
\end_layout

\end_inset

The logger functions are then used as normal functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> info(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

INFO: hello
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> warn(
\begin_inset Quotes eld
\end_inset

goodbye
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

WARN: goodbye
\end_layout

\end_inset

The newly created logger functions can be now given as arguments to other
 code that need a logging function.
\end_layout

\begin_layout Standard
It is important that the prefix is 
\begin_inset Quotes eld
\end_inset

baked into
\begin_inset Quotes erd
\end_inset

 the functions created by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

.
 A logger such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warn
\end_layout

\end_inset

 will always print messages with the prefix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

WARN
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

, and the prefix cannot be changed any more.
 The value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prefix
\end_layout

\end_inset

 is treated as a local value in the scope of the function returned by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

.
 For instance, the body of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warn
\end_layout

\end_inset

 is equivalent to
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ val prefix = 
\begin_inset Quotes eld
\end_inset

WARN
\begin_inset Quotes erd
\end_inset

; (message => s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\end_inset

So, whenever a new function is created using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(prefix)
\end_layout

\end_inset

, the (immutable) value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prefix
\end_layout

\end_inset

 is stored within the body of the newly created function.
 This is a general feature of nameless functions created in a scope that
 contains other local values: the function body keeps a copy of all the
 local values it uses.
 One sometimes says that the function body 
\begin_inset Quotes eld
\end_inset

closes over
\begin_inset Quotes erd
\end_inset

 the local values; for this reason, nameless functions are sometimes also
 called 
\begin_inset Quotes eld
\end_inset


\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
closure
\end_layout

\end_inset

closure
\series default
s
\begin_inset Quotes erd
\end_inset

.
 It would be perhaps clearer to say that nameless functions 
\begin_inset Quotes eld
\end_inset

capture
\begin_inset Quotes erd
\end_inset

 local values.
\end_layout

\begin_layout Standard
As another example of the capture of local values, consider this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: Int => Int = {
\end_layout

\begin_layout Plain Layout

  val p = 10
\end_layout

\begin_layout Plain Layout

  val q = 20
\end_layout

\begin_layout Plain Layout

  x => p + q * x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The body of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{x => 10 + 20 * x}
\end_layout

\end_inset

 because the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p = 10
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q = 20
\end_layout

\end_inset

 were captured.
\end_layout

\begin_layout Subsection
Curried and uncurried functions
\end_layout

\begin_layout Standard
If we reason mathematically about the code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val info = logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

info(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

we should expect that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

info
\end_layout

\end_inset

 is 
\emph on
the same value
\emph default
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

, and so the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

info(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 should have the same effect as the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith("INFO")("hello")
\end_layout

\end_inset

.
 This is indeed so:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> logWith("INFO")("hello")
\end_layout

\begin_layout Plain Layout

INFO: hello
\end_layout

\end_inset

The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith("INFO")("hello")
\end_layout

\end_inset

 suggests that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 is being applied to 
\emph on
two
\emph default
 arguments.
 And yet we have defined 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 as a function with a single argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 This works only because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 returns a function that accepts an additional argument.
\end_layout

\begin_layout Standard
A function that can be applied to more than one argument in this way is
 called a 
\series bold

\begin_inset CommandInset href
LatexCommand href
name "curried"
target "https://en.wikipedia.org/wiki/Currying"
literal "false"

\end_inset


\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
curried function
\end_layout

\end_inset

 function.
 A curried function can be applied to one argument at a time.
\end_layout

\begin_layout Standard
A function that must be applied to all arguments at once, such as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prefixLog(prefix: String, message: String): Unit =
\end_layout

\begin_layout Plain Layout

  println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

is called an 
\series bold
uncurried
\begin_inset Index idx
status open

\begin_layout Plain Layout
uncurried function
\end_layout

\end_inset


\series default
 function.
\end_layout

\begin_layout Standard
The type of the curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => (String => Unit)
\end_layout

\end_inset

.
 Scala adopts the syntax convention that the function arrow 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 associates to the 
\emph on
right
\emph default
.
 So the parentheses in the type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => (String => Unit)
\end_layout

\end_inset

 are not necessary; the function's type can be written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => String => Unit
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => String => Unit
\end_layout

\end_inset

 is 
\emph on
different
\emph default
 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String => String) => Unit
\end_layout

\end_inset

, which is a type signature of a function returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 and taking a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => String
\end_layout

\end_inset

 as its argument.
 When an argument's type is a function type, it must be enclosed in parentheses.
\end_layout

\begin_layout Standard
In general, a curried function takes an argument and returns another function
 that again takes an argument and returns another function, and so on, until
 finally a non-function type is returned.
 So, the type of a curried function looks like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => ...
 => R => S
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, ..., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R
\end_layout

\end_inset

 can be viewed as 
\begin_inset Quotes eld
\end_inset


\series bold
curried arguments
\begin_inset Index idx
status open

\begin_layout Plain Layout
curried arguments
\end_layout

\end_inset


\series default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 as the 
\begin_inset Quotes eld
\end_inset

final
\begin_inset Quotes erd
\end_inset

 result type.
 
\end_layout

\begin_layout Standard
For most people, it takes time to get used to reading this kind of syntax.
 In the type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => D
\end_layout

\end_inset

, the first three types are curried arguments and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

 is the final result type.
\end_layout

\begin_layout Standard
In Scala, functions defined with multiple argument groups (enclosed in multiple
 pairs of parentheses) are curried functions.
 We have seen examples of curried functions before:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
\end_layout

\begin_layout Plain Layout

def fmap[A, B](f: A => B)(xs: Option[A]): Option[B]
\end_layout

\begin_layout Plain Layout

def foldLeft[A, R](xs: Seq[A])(init: R)(update: (R, A) => R): R
\end_layout

\end_inset

The type signatures of these functions can be also written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: Seq[A] => (A => B) => Seq[B]
\end_layout

\begin_layout Plain Layout

def fmap[A, B]: (A => B) => Option[A] => Option[B]
\end_layout

\begin_layout Plain Layout

def foldLeft[A, R]: Seq[A] => R => ((R, A) => R) => R
\end_layout

\end_inset

These examples show the need to use parentheses whenever a curried argument
 is itself a function, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => B)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 can be defined in three equivalent ways:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def logWith1(prefix: String)(message: String): Unit =
\end_layout

\begin_layout Plain Layout

  println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

def logWith2(prefix: String): String => Unit =
\end_layout

\begin_layout Plain Layout

  message => println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

def logWith3: String => String => Unit =
\end_layout

\begin_layout Plain Layout

  prefix => message => println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

Nameless functions in Scala may be enclosed in parentheses or curly braces,
 but parentheses are unnecessary for very simple expressions.
\end_layout

\begin_layout Standard
The last line in the above code shows that the arrow 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 within the code of nameless functions associates to the 
\emph on
right
\emph default
: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => expr
\end_layout

\end_inset

 means 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => { y => expr } }
\end_layout

\end_inset

, a nameless function taking an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returning a nameless function that takes an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 and returns an expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

.
 This syntax convention is useful for two reasons.
 First, the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => z
\end_layout

\end_inset

 visually corresponds to the curried function's type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C
\end_layout

\end_inset

 where the same syntax convention is used.
 Second, the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => y) => z
\end_layout

\end_inset

 could not be valid for a nameless function because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => y)
\end_layout

\end_inset

 is not a valid pattern expression for the function's argument; it is impossible
 to define a pattern that matches arbitrary 
\emph on
functions
\emph default
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Although the code syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => y) => z
\end_layout

\end_inset

 is invalid, a type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => B) => C
\end_layout

\end_inset

 is valid.
 A nameless function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => B) => C
\end_layout

\end_inset

 is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f => expr(f)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 is its argument and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr(f)
\end_layout

\end_inset

 its body.
 So 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => (y => z)
\end_layout

\end_inset

 is the only possible way of inserting parenthesis into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => z
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Equivalence of curried and uncurried functions
\end_layout

\begin_layout Standard
We defined the curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 in order to be able to create logger functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

info
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warn
\end_layout

\end_inset

.
 However, some curried functions, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, are almost always applied to all possible arguments.
 A curried function applied to all its possible arguments is equivalent
 to an uncurried function that takes all those arguments at once.
 Let us look at this equivalence in more detail.
\end_layout

\begin_layout Standard
A simple example of a curried function is one with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset

.
 This is a function that takes an integer and returns a 
\emph on
function
\emph default
 that again takes an integer and then returns an integer.
 An example of defining such a function is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f0(x: Int): Int => Int = { y => x - y }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function takes an integer argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returns the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y => x - y
\end_layout

\end_inset

, which is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
 The definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f0
\end_layout

\end_inset

 can be also written equivalently as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f1: Int => Int => Int = { x => y => x - y }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us compare the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 with a function that takes its two arguments at once.
 Such a function will have a different type signature, for instance
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2(x: Int, y: Int): Int = x - y
\end_layout

\end_inset

has type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int) => Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The syntax for calling the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is different:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f1(20)(4)
\end_layout

\begin_layout Plain Layout

res0: Int = 16
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f2(20, 4)
\end_layout

\begin_layout Plain Layout

res1: Int = 16
\end_layout

\end_inset

The main difference between the usage of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 must be applied 
\emph on
at once
\emph default
 to both arguments, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1(20)
\end_layout

\end_inset

 can be evaluated separately, – that is, applied only to its first argument,
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

.
 The result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1(20)
\end_layout

\end_inset

 is a function that can be later applied to another argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val r1 = f1(20)
\end_layout

\begin_layout Plain Layout

r1: Int => Int = <function1> 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> r1(4)
\end_layout

\begin_layout Plain Layout

res2: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Applying a curried function to some but not all of possible arguments is
 called a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
partial application
\end_layout

\end_inset

partial application
\series default
.
 Applying a curried function to all possible arguments is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
saturated application
\end_layout

\end_inset


\series bold
saturated
\series default
 application.
\end_layout

\begin_layout Standard
If we need to apply an uncurried function to some of its arguments but leave
 other arguments unspecified, we can use the Scala syntax with the underscore
 (
\begin_inset Formula $\_$
\end_inset

) symbol:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val r2: Int => Int = f2(20, _)
\end_layout

\begin_layout Plain Layout

r2: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> r2(4)
\end_layout

\begin_layout Plain Layout

res3: Int = 16
\end_layout

\end_inset

This code creates a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r2
\end_layout

\end_inset

 by partially applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 to the first argument but not to the second.
 The type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

 is necessary in Scala.
 Other than that, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r2
\end_layout

\end_inset

 is the same function as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r1
\end_layout

\end_inset

 defined above (i.e.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r2
\end_layout

\end_inset

 returns the same values for the same arguments as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r1
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Another equivalent syntax for a partial application is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val r3: Int => Int = { x => f2(20, x) }
\end_layout

\begin_layout Plain Layout

r3: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> r3(4)
\end_layout

\begin_layout Plain Layout

res4: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see that a curried function, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, is better adapted for partial application than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, because the syntax is shorter.
 However, the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are 
\series bold
computationally equivalent
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
computational equivalence
\end_layout

\end_inset

 in the sense that given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 we can reconstruct 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 and vice versa:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2new(x: Int, y: Int): Int = f1(x)(y)
\end_layout

\begin_layout Plain Layout

def f1new: Int => Int => Int = { x => y => f2(x, y) }
\end_layout

\end_inset

It is clear that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1new
\end_layout

\end_inset

 computes the same results as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, and that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2new
\end_layout

\end_inset

 computes the same results as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

.
 The computational equivalence of the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is not 
\emph on
equality
\emph default
  –  these functions are 
\emph on
different
\emph default
; but one of them can be easily reconstructed from the other if necessary.
 
\end_layout

\begin_layout Standard
More generally, a curried function may have a type signature of the form
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => ...
 => R => S
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, ..., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 are some types.
 A function with this type signature is computationally equivalent to an
 uncurried
\begin_inset Index idx
status open

\begin_layout Plain Layout
uncurried function
\end_layout

\end_inset

 function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B,C,...,R) => S
\end_layout

\end_inset

.
 The uncurried function takes all arguments at once, while the curried function
 takes one argument at a time.
 Other than that, these two functions compute the same results given the
 same arguments.
\end_layout

\begin_layout Standard
We have seen how a curried function can be converted to an equivalent uncurried
 one, and vice versa.
 The Scala library defines the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curried
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

uncurried
\end_layout

\end_inset

 that convert between these computationally equivalent forms of functions.
 Here convert the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and back:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val f1c = (f2 _).curried
\end_layout

\begin_layout Plain Layout

f1c: Int => (Int => Int) = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val f2u = Function.uncurried(f1c)
\end_layout

\begin_layout Plain Layout

f2u: (Int, Int) => Int = <function2> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f2 _)
\end_layout

\end_inset

 is used in Scala to convert methods to function values.
 Recall that Scala has two ways of defining a function: one as a method
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala method
\end_layout

\end_inset

 (defined using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

), another as a function value
\begin_inset Index idx
status open

\begin_layout Plain Layout
function value
\end_layout

\end_inset

 (defined using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.curried
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.uncurried
\end_layout

\end_inset

 are easy to implement in Scala code, as we will see in the solved examples.
\end_layout

\begin_layout Section
Functions with fully parametric type signatures
\end_layout

\begin_layout Standard
We have seen that some functions are declared with type parameters, so that
 certain arguments can have an arbitrary type.
 Examples of such functions are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 methods with type signatures
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
\end_layout

\begin_layout Plain Layout

def filter[A](xs: Seq[A])(p: A => Boolean): Seq[A]
\end_layout

\end_inset

It saves time for the programmer to implement a single function with type
 parameters instead of a number of functions with the same function bodies
 but applied to specific types.
 
\end_layout

\begin_layout Standard
In the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 as just shown, some types are parameters while others are specific types,
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

.
 It is sometimes possible to replace 
\emph on
all
\emph default
 types in the type signature of a function by type parameters.
\end_layout

\begin_layout Standard
A function is 
\series bold
fully parametric
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric function
\end_layout

\end_inset


\series default
 if all its arguments have types described by type parameters, and the code
 of the function always works with type parameters rather than with fixed
 types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 In other words, fully parametric functions do not have any specific types,
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, in their type signature or in their body.
 When a fully parametric function is applied to an argument of a specific
 type, the function does not use any information about that type.
 
\end_layout

\begin_layout Standard
What kind of functions are fully parametric? To build an intuition, compare
 these two functions having the same type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cos_sin(p: (Double, Double)): (Double, Double) = p match {
\end_layout

\begin_layout Plain Layout

  case (a, b) =>
\end_layout

\begin_layout Plain Layout

    val r = math.sqrt(a * a + b * b)
\end_layout

\begin_layout Plain Layout

    (a / r, b / r) // Return cos and sin of the angle.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def swap(p: (Double, Double)): (Double, Double) = p match {
\end_layout

\begin_layout Plain Layout

  case (a, b) => (b, a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can introduce type parameters into the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 to make it fully parametric, with no changes in the code of the function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def swap[A, B](p: (A, B)): (B, A) = p match {
\end_layout

\begin_layout Plain Layout

  case (a, b) => (b, a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We are able to generalize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 to a fully parametric function because swapping two parts of a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 is an operation that works in the same way for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
In comparison, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 performs a computation that is specific to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, and its arguments cannot be generalized to arbitrary types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 The angle computation in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 makes no sense for other types.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 cannot be generalized to a fully parametric function.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 operation for pairs is already defined in the Scala library:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1, 
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

).swap
\end_layout

\begin_layout Plain Layout

res0: (String, Int) = (abc,1)
\end_layout

\end_inset

For tuples with three and more elements, we may define various swapping
 functions, e.g.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def swap12[A,B,C]: ((A, B, C)) => (B, A, C) = {
\end_layout

\begin_layout Plain Layout

  case (a, b, c) => (b, a, c)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The Scala syntax requires the double parentheses around tuple types of arguments
 but not around the tuple type of a function's result.
 So, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 may be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cos_sin: ((Double, Double)) => (Double, Double)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Examples of fully parametric functions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Examples-of-fully-parametric"

\end_inset


\end_layout

\begin_layout Standard
Further examples of fully parametric functions are the identity function,
 the constant function, the function composition methods, and the curry
 / uncurry transformations.
 The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity function
\end_layout

\end_inset

identity function (already defined in the Scala library as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity
\end_layout

\end_inset

) is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def id[T]: T => T = (t => t)
\end_layout

\end_inset

The constant function
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant function
\end_layout

\end_inset

 (available in the Scala library as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Function.const
\end_layout

\end_inset

) takes an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 and returns a new function that always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def const[C, X](c: C): X => C = { _ => c }
\end_layout

\end_inset

The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(_ => c)
\end_layout

\end_inset

 is used to emphasize that the function ignores its argument.
 
\end_layout

\begin_layout Standard
The Scala library defines two different function composition methods, called
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

andThen
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compose
\end_layout

\end_inset

.
 The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

andThen
\end_layout

\end_inset

 performs the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
forward composition
\end_layout

\end_inset

forward composition
\series default
 of two functions: the result is a new function, written in Scala as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f andThen g
\end_layout

\end_inset

.
 That function first applies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to the argument 
\begin_inset Quotes eld
\end_inset

and then
\begin_inset Quotes erd
\end_inset

 applies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 to the result.
 Mathematically, this operation is denoted by 
\begin_inset Formula $\bef$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

before
\begin_inset Quotes erd
\end_inset

) and can be defined as
\begin_inset Formula 
\begin{equation}
f\bef g\triangleq\left(x\Rightarrow g(f(x))\right)\quad.\label{eq:def-of-forward-composition}
\end{equation}

\end_inset

The symbol 
\begin_inset Formula $\triangleq$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

is defined as
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In Scala, the forward composition may be written as a fully parametric function,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def andThen[X, Y, Z](f: X => Y)(g: Y => Z): X => Z = { x => g(f(x)) }
\end_layout

\end_inset

The type signature of this curried function is could be written as 
\begin_inset Formula 
\[
\text{andThen}:\left(X\Rightarrow Y\right)\Rightarrow\left(Y\Rightarrow Z\right)\Rightarrow X\Rightarrow Z\quad.
\]

\end_inset

This type signature shows how the types of the functions must match for
 the composition to be defined.
\end_layout

\begin_layout Standard
The 
\series bold
backward composition
\begin_inset Index idx
status open

\begin_layout Plain Layout
backward composition
\end_layout

\end_inset


\series default
 of two functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 works in the opposite order: first 
\begin_inset Formula $g$
\end_inset

 is applied and then 
\begin_inset Formula $f$
\end_inset

 is applied to the result.
 Using the mathematical symbol 
\begin_inset Formula $\circ$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

after
\begin_inset Quotes erd
\end_inset

) for this operation, we can write
\begin_inset Formula 
\begin{equation}
f\circ g\triangleq\left(x\Rightarrow f(g(x))\right)\quad.\label{eq:def-of-backward-composition}
\end{equation}

\end_inset

In Scala, the backward composition is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compose
\end_layout

\end_inset

 and used as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f compose g
\end_layout

\end_inset

.
 This method may be redefined as a fully parametric function
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def compose[X, Y, Z](f: Y => X)(g: Z => Y): Z => X = { z => f(g(z)) }
\end_layout

\end_inset

The type signature of this curried function is
\begin_inset Formula 
\[
\text{compose}:\left(Y\Rightarrow X\right)\Rightarrow\left(Z\Rightarrow Y\right)\Rightarrow Z\Rightarrow X\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We have already seen the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curried
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

uncurried
\end_layout

\end_inset

 defined by the Scala library.
 As an illustration, let us write a transformation from curried to uncurried
 functions in our own Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def uncurry[A, B, R](f: A => B => R): ((A, B)) => R = {
\end_layout

\begin_layout Plain Layout

  case (a, b) => f(a)(b) // Compute a value of type R.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We conclude from these examples that fully parametric functions perform
 operations that are so general that they work in the same way for all types
 of arguments.
 Some arguments of fully parametric functions may have complicated types
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => R
\end_layout

\end_inset

, which are type expressions made up from type parameters alone.
 Fully parametric functions do not perform any operations with specific
 types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The property of being fully parametric is also called 
\series bold
parametricity
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
parametricity
\end_layout

\end_inset

 for short.
\end_layout

\begin_layout Subsection
Laws of function composition
\begin_inset CommandInset label
LatexCommand label
name "subsec:Laws-of-function-composition"

\end_inset


\end_layout

\begin_layout Standard
Function composition has three important properties or 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

 that follow naturally from the definitions.
 These laws are:
\end_layout

\begin_layout Itemize
the identity laws: the composition of any function 
\begin_inset Formula $f$
\end_inset

 with the identity function will give again the function 
\begin_inset Formula $f$
\end_inset

;
\end_layout

\begin_layout Itemize
the associativity law: the consecutive composition of three functions 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $h$
\end_inset

 does not depend on the order in which the pairs are composed.
\end_layout

\begin_layout Standard
Let us write these laws rigorously as mathematical equations and prove them.
 For brevity, we will denote the identity function by 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{id}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The composition of the identity function with an arbitrary function 
\begin_inset Formula $f$
\end_inset

 can be 
\begin_inset Formula $\text{id}\bef f$
\end_inset

 with the identity function to the left of 
\begin_inset Formula $f$
\end_inset

, or 
\begin_inset Formula $f\bef\text{id}$
\end_inset

 with the identity function to the right of 
\begin_inset Formula $f$
\end_inset

.
 In both cases, the result must be equal to the function 
\begin_inset Formula $f$
\end_inset

.
 So we actually have 
\emph on
two
\emph default
 laws:
\begin_inset Formula 
\begin{align*}
\text{left identity law of composition}:\quad & \text{id}\bef f=f\quad,\\
\text{right identity law of composition}:\quad & f\bef\text{id}=f\quad.
\end{align*}

\end_inset

To show that these laws always hold, we need to show that both sides of
 the laws, which are functions, give the same result when applied to an
 arbitrary value 
\begin_inset Formula $x$
\end_inset

.
 To see this, let us first clarify how the type parameters must be set for
 the laws to have consistent types.
\end_layout

\begin_layout Standard
The laws must hold for an arbitrary function 
\begin_inset Formula $f$
\end_inset

.
 So we may assume that 
\begin_inset Formula $f$
\end_inset

 has the type signature 
\begin_inset Formula $A\Rightarrow B$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are arbitrary type parameters.
 Consider the left identity law.
 The function 
\begin_inset Formula $\left(\text{id}\bef f\right)$
\end_inset

 is, by definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-forward-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), a function that takes an argument 
\begin_inset Formula $x$
\end_inset

, applies 
\begin_inset Formula $\text{id}$
\end_inset

 to that 
\begin_inset Formula $x$
\end_inset

, and then applies 
\begin_inset Formula $f$
\end_inset

 to the result: 
\begin_inset Formula 
\[
\text{id}\bef f=\left(x\Rightarrow f(\text{id}(x))\right)\quad.
\]

\end_inset

If 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

, its argument must be of type 
\begin_inset Formula $A$
\end_inset

, or else the types do not match.
 Therefore, the identity function must have type 
\begin_inset Formula $A\Rightarrow A$
\end_inset

, and the argument 
\begin_inset Formula $x$
\end_inset

 must have type 
\begin_inset Formula $A$
\end_inset

.
 With these choices of the type parameters, the function 
\begin_inset Formula $\left(x\Rightarrow f(\text{id}(x))\right)$
\end_inset

 will have type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

, as it must since the right-hand side of the law is 
\begin_inset Formula $f$
\end_inset

.
 We add type annotations to the code as superscripts,
\begin_inset Formula 
\[
\text{id}^{A}\bef f^{:A\Rightarrow B}=\left(x^{:A}\Rightarrow f(\text{id}(x))\right)^{:A\Rightarrow B}\quad.
\]

\end_inset

In the Scala syntax, this formula may be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

id[A] andThen (f: A => B) == { x: A => f(id(x)) }: A => B
\end_layout

\end_inset

It is quicker to write the short mathematical notation than code in the
 Scala syntax.
 
\end_layout

\begin_layout Standard
We write 
\begin_inset Formula $\text{id}^{A}$
\end_inset

 to denote the type parameter 
\begin_inset Formula $A$
\end_inset

 in the identity function 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id[A]
\end_layout

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
; equivalently (but more verbosely) we may write 
\begin_inset Formula $\text{id}^{:A\Rightarrow A}$
\end_inset

.
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\text{id}(x)=x$
\end_inset

 by definition of the identity function, we find that 
\begin_inset Formula 
\[
\text{id}\bef f=\left(x\Rightarrow f\left(\text{id}\left(x\right)\right)\right)=\left(x\Rightarrow f\left(x\right)\right)=f\quad,
\]

\end_inset

since the expression 
\begin_inset Formula $x\Rightarrow f\left(x\right)$
\end_inset

 is a function that takes an argument 
\begin_inset Formula $x$
\end_inset

 and applies 
\begin_inset Formula $f$
\end_inset

 to that argument; i.e.
\begin_inset space ~
\end_inset


\begin_inset Formula $x\Rightarrow f\left(x\right)$
\end_inset

 is the same function as 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
Now consider the right identity law:
\begin_inset Formula 
\[
f\bef\text{id}=\left(x\Rightarrow\text{id}\left(f\left(x\right)\right)\right)\quad.
\]

\end_inset

To make the types match, assume that 
\begin_inset Formula $f:A\Rightarrow B$
\end_inset

.
 Then 
\begin_inset Formula $x$
\end_inset

 must have type 
\begin_inset Formula $A$
\end_inset

, and the identity function must have the type 
\begin_inset Formula $B\Rightarrow B$
\end_inset

.
 The result of 
\begin_inset Formula $\text{id}\left(f\left(x\right)\right)$
\end_inset

 will be also of type 
\begin_inset Formula $B$
\end_inset

.
 With these choices of type parameters, all types match:
\begin_inset Formula 
\[
f^{:A\Rightarrow B}\bef\text{id}^{B}=\left(x^{:A}\Rightarrow\text{id}(f(x))\right)^{:A\Rightarrow B}\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{id}(f(x))=f(x)$
\end_inset

, we find that 
\begin_inset Formula 
\[
f\bef\text{id}=\left(x\Rightarrow f\left(x\right)\right)=f\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
In this way, we have demonstrated that both identity laws hold.
 
\end_layout

\begin_layout Standard
The associativity law is written like this:
\begin_inset Formula 
\begin{equation}
\left(f\bef g\right)\bef h=f\bef\left(g\bef h\right)\quad.\label{eq:associativity-of-function-composition}
\end{equation}

\end_inset

Let us first check whether the types match.
 The types of the functions 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, and 
\begin_inset Formula $h$
\end_inset

 must be such that all the function compositions exist.
 If 
\begin_inset Formula $f:A\Rightarrow B$
\end_inset

 for some type parameters 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, then the argument of 
\begin_inset Formula $g$
\end_inset

 must be of type 
\begin_inset Formula $B$
\end_inset

; so we can choose 
\begin_inset Formula $g:B\Rightarrow C$
\end_inset

, where 
\begin_inset Formula $C$
\end_inset

 is another type parameter.
 The composition 
\begin_inset Formula $f\bef g$
\end_inset

 has type 
\begin_inset Formula $A\Rightarrow C$
\end_inset

, so 
\begin_inset Formula $h$
\end_inset

 must be of type 
\begin_inset Formula $C\Rightarrow D$
\end_inset

 for some type 
\begin_inset Formula $D$
\end_inset

.
 Assuming the types as 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

, 
\begin_inset Formula $g^{:B\Rightarrow C}$
\end_inset

, and 
\begin_inset Formula $h^{:C\Rightarrow D}$
\end_inset

, we find that the types in all the compositions 
\begin_inset Formula $f\bef g$
\end_inset

, 
\begin_inset Formula $g\bef h$
\end_inset

, 
\begin_inset Formula $\left(f\bef g\right)\bef h$
\end_inset

, and 
\begin_inset Formula $f\bef\left(g\bef h\right)$
\end_inset

 match.
 We can write the associativity law with type annotations as
\begin_inset Formula 
\begin{equation}
(f^{:A\Rightarrow B}\bef g^{:B\Rightarrow C})\bef h^{:C\Rightarrow D}=f^{:A\Rightarrow B}\bef(g^{:B\Rightarrow C}\bef h^{:C\Rightarrow D})\quad.\label{eq:assoc-law-for-composition-with-types}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Having checked the types, we are ready to prove the associativity law.
 We note that both sides of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are functions of type 
\begin_inset Formula $A\Rightarrow D$
\end_inset

.
 To prove that two functions are equal means to prove that they always return
 the same results when applied to the same argument.
 So we need to apply both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to an arbitrary value 
\begin_inset Formula $x^{:A}$
\end_inset

.
 Using the definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-forward-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of the forward composition, 
\begin_inset Formula 
\[
\left(f\bef g\right)(x)=g(f(x))\quad,
\]

\end_inset

we find
\begin_inset Formula 
\begin{align*}
\left(\left(f\bef g\right)\bef h\right)(x) & =h\left(\left(f\bef g\right)(x)\right)=h(g(f(x)))\quad,\\
\left(f\bef\left(g\bef h\right)\right)(x) & =\left(g\bef h\right)(f(x))=h(g(f(x)))\quad.
\end{align*}

\end_inset

Both sides of the law are now equal when applied to an arbitrary value 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Standard
Because of the associativity law, we do not need parentheses in the expression
 
\begin_inset Formula $f\bef g\bef h$
\end_inset

, since the result is the same with 
\begin_inset Formula $\left(f\bef g\right)\bef h$
\end_inset

 and with 
\begin_inset Formula $f\bef\left(g\bef h\right)$
\end_inset

.
\end_layout

\begin_layout Standard
In the proof, we have not written out the types since we already checked
 that the types match.
 This allows us to write shorter proofs.
\end_layout

\begin_layout Paragraph
Proofs in the backward notation
\end_layout

\begin_layout Standard
This book uses the 
\series bold
forward notation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
forward notation
\end_layout

\end_inset

 
\begin_inset Formula $f\bef g$
\end_inset

 for writing function compositions, rather than the backward notation 
\begin_inset Formula $g\circ f$
\end_inset

.
 However, all equations can be automatically converted from one notation
 to the other by reversing the order of function compositions, since
\begin_inset Formula 
\[
f\bef g=g\circ f
\]

\end_inset

for any functions 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\Rightarrow C}$
\end_inset

.
 Let us see how to prove the composition laws in the backward notation.
 We will just need to reverse the order of function compositions in the
 proofs above.
\end_layout

\begin_layout Standard
The left identity and right identity laws are
\begin_inset Formula 
\[
f\circ\text{id}=f\quad\quad,\quad\text{id}\circ f=f\quad.
\]

\end_inset

To match the types, we need to choose the type parameters as
\begin_inset Formula 
\[
f^{:A\Rightarrow B}\circ\text{id}^{:A\Rightarrow A}=f^{:A\Rightarrow B}\quad\quad,\quad\text{id}^{B\Rightarrow B}\circ f^{:A\Rightarrow B}=f^{:A\Rightarrow B}\quad.
\]

\end_inset

We can apply both sides of the laws to an arbitrary value 
\begin_inset Formula $x^{:A}$
\end_inset

.
 For the left identity law, we find from definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-backward-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that
\begin_inset Formula 
\[
f\circ\text{id}=\left(x\Rightarrow f(\text{id}(x))\right)=\left(x\Rightarrow f(x)\right)=f\quad.
\]

\end_inset

Similarly for the right identity law,
\begin_inset Formula 
\[
\text{id}\circ f=\left(x\Rightarrow\text{id}\left(f\left(x\right)\right)\right)=\left(x\Rightarrow f\left(x\right)\right)=f\quad.
\]

\end_inset

The associativity law,
\begin_inset Formula 
\[
h\circ\left(g\circ f\right)=\left(h\circ g\right)\circ f\quad,
\]

\end_inset

is proved by applying both sides to an arbitrary value 
\begin_inset Formula $x$
\end_inset

 of a suitable type:
\begin_inset Formula 
\begin{align*}
\left(h\circ\left(g\circ f\right)\right)(x) & =h(\left(g\circ f\right)(x))=h\left(g\left(f\left(x\right)\right)\right)\quad,\\
\left(\left(h\circ g\right)\circ f\right)(x) & =\left(h\circ g\right)(f(x))=h(g(f(x)))\quad.
\end{align*}

\end_inset

The types are checked by assuming that 
\begin_inset Formula $f$
\end_inset

 has the type 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

.
 The types in 
\begin_inset Formula $g\circ f$
\end_inset

 match only when 
\begin_inset Formula $g^{:B\Rightarrow C}$
\end_inset

, and then 
\begin_inset Formula $g\circ f$
\end_inset

 is of type 
\begin_inset Formula $A\Rightarrow C$
\end_inset

.
 The type of 
\begin_inset Formula $h$
\end_inset

 must be 
\begin_inset Formula $h^{:C\Rightarrow D}$
\end_inset

 for the types in 
\begin_inset Formula $h\circ\left(g\circ f\right)$
\end_inset

 to match.
 We can write the associativity law with type annotations as
\begin_inset Formula 
\begin{equation}
h^{:C\Rightarrow D}\circ(g^{:B\Rightarrow C}\circ f^{A\Rightarrow B})=(h^{:C\Rightarrow D}\circ g^{:B\Rightarrow C})\circ f^{:A\Rightarrow B}\quad.\label{eq:assoc-law-for-composition-with-types-backward}
\end{equation}

\end_inset

Because of the associativity law, we do not need parentheses in the expression
 
\begin_inset Formula $h\circ g\circ f$
\end_inset

.
 
\end_layout

\begin_layout Standard
The length of calculations is the same in the forward and the backward notation.
 One difference is that types are less visually clear in function compositions:
 it is easier to check types in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:assoc-law-for-composition-with-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

) than in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:assoc-law-for-composition-with-types-backward"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection
Example of a function that violates parametricity 
\end_layout

\begin_layout Standard
Fully parametric functions should not make any decisions based on the actual
 types of its parameters.
 As an example of an 
\emph on
incorrect
\emph default
 implementation of a fully parametric function, consider the following 
\begin_inset Quotes eld
\end_inset

fake identity
\begin_inset Quotes erd
\end_inset

 function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fakeId[A]: A => A = { // Special code for `A` = `Int`:
\end_layout

\begin_layout Plain Layout

  case x: Int => (x - 1).asInstanceOf[A]
\end_layout

\begin_layout Plain Layout

  case x => x // The usual code for all other types `A`.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This function's type signature is the same as that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[A]
\end_layout

\end_inset

, and its behavior is the same for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 except for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fakeId("abc")
\end_layout

\begin_layout Plain Layout

res0: String = abc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fakeId(true)
\end_layout

\begin_layout Plain Layout

res1: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fakeId(0)
\end_layout

\begin_layout Plain Layout

res2: Int = -1
\end_layout

\end_inset

While Scala allows us to write this kind of code, the resulting function
 does not appear to be useful; in any case, it is not a fully parametric
 function.
\end_layout

\begin_layout Standard
The identity laws of composition will not hold if we use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fakeId[A]
\end_layout

\end_inset

 instead of the correct function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id[A]
\end_layout

\end_inset

.
 For example, consider the composition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fakeId
\end_layout

\end_inset

 with a simple function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1
\end_layout

\end_inset

 defined by
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f_1: Int => Int = { x => x + 1 }
\end_layout

\end_inset

The composition (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1 andThen fakeId
\end_layout

\end_inset

) will have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, Scala will automatically set the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

 in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fakeId[A]
\end_layout

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def f_2 = f_1 andThen fakeId
\end_layout

\begin_layout Plain Layout

f_2: Int => Int
\end_layout

\end_inset

The identity law says that 
\begin_inset Formula $f_{2}=f_{1}\bef\text{id}=f_{1}$
\end_inset

.
 But we can check that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_2
\end_layout

\end_inset

 are not the same:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f_1(0)
\end_layout

\begin_layout Plain Layout

res3: Int = 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f_2(0)
\end_layout

\begin_layout Plain Layout

res3: Int = 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is important that we are able to detect a violation of parametricity
 by checking whether some equation holds, without need to examine the code
 of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fakeId
\end_layout

\end_inset

.
 In this book, we will always formulate any desired properties of functions
 through equations and laws, and provide proofs.
\end_layout

\begin_layout Section
Symbolic calculations with nameless functions
\end_layout

\begin_layout Subsection
Deriving a function's type from its code
\end_layout

\begin_layout Standard
Checking that the types match is an important part of the functional programming
 paradigm – both in the practice of writing code, and in theoretical derivations
 of general properties for various functions.
 For instance, in the derivations of the composition laws (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Laws-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we were able to deduce the possible type parameters for 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, and 
\begin_inset Formula $h$
\end_inset

 in the expression 
\begin_inset Formula $f\bef g\bef h$
\end_inset

.
 This worked because the composition function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

andThen
\end_layout

\end_inset

 (denoted 
\begin_inset Formula $\bef$
\end_inset

) is fully parametric.
 Given a fully parametric function, it is often possible to derive the most
 general type signature that matches the body of the function.
 The same method will also work for generalizing a given function to a fully
 parametric form.
\end_layout

\begin_layout Standard
Let us look at some examples of doing this.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

 were defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-fully-parametric"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 What is the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

 and what is its possible type? Determine the most general type parameters
 in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to treat the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

 as values, since our goal is to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

.
 Writing the code of these functions in a short notation, we get
\begin_inset Formula 
\begin{align*}
\text{const}^{C,X} & =c^{:C}\Rightarrow\_^{:X}\Rightarrow c\quad,\\
\text{id}^{A} & =a^{:A}\Rightarrow a\quad.
\end{align*}

\end_inset

Begin by reasoning about the types.
 The types will match in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

 only if the argument of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 has the same type as the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

.
 Since 
\begin_inset Formula $\text{const}^{C,X}$
\end_inset

 is a curried function, we need to look at its 
\emph on
first
\emph default
 curried argument, which is of type 
\begin_inset Formula $C$
\end_inset

.
 The type of 
\begin_inset Formula $\text{id}$
\end_inset

 is 
\begin_inset Formula $A\Rightarrow A$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is an arbitrary type so far.
 So, the type parameter 
\begin_inset Formula $C$
\end_inset

 in 
\begin_inset Formula $\text{const}^{C,X}$
\end_inset

 must be equal to 
\begin_inset Formula $A\Rightarrow A$
\end_inset

.
 The type parameter 
\begin_inset Formula $X$
\end_inset

 in 
\begin_inset Formula $\text{const}^{C,X}$
\end_inset

 is not constrained, so we keep it as 
\begin_inset Formula $X$
\end_inset

.
 The result of applying 
\begin_inset Formula $\text{const}$
\end_inset

 to 
\begin_inset Formula $\text{id}$
\end_inset

 is of type 
\begin_inset Formula $X\Rightarrow C=X\Rightarrow\left(A\Rightarrow A\right)$
\end_inset

.
 In this way, we find that the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{const}^{A\Rightarrow A,X}(\text{id}^{A}):X\Rightarrow A\Rightarrow A\quad.
\]

\end_inset

The types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $X$
\end_inset

 can be arbitrary.
 The type 
\begin_inset Formula $X\Rightarrow A\Rightarrow A$
\end_inset

 is the most general type for the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

 because we have not made any assumptions on the types other than requiring
 that all functions are always applied to arguments of the correct types.
\end_layout

\begin_layout Standard
To compute the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

, it remains to substitute the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

.
 Since we already checked the types, we do not need to write type annotations
 any more:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\text{const}}\left(\text{id}\right)\\
\text{definition of const}:\quad & =(c\Rightarrow x\Rightarrow\gunderline c)\left(\text{id}\right)\\
\text{substitute }c=\text{id}:\quad & =(x\Rightarrow\gunderline{\text{id}})\\
\text{definition of }\text{id}:\quad & =\left(x\Rightarrow a\Rightarrow a\right)\quad.
\end{align*}

\end_inset

This is a function that takes an argument 
\begin_inset Formula $x^{:X}$
\end_inset

 and returns the identity function 
\begin_inset Formula $a^{:A}\Rightarrow a$
\end_inset

.
 It is clear that the argument 
\begin_inset Formula $x$
\end_inset

 is ignored by this function, so we can rewrite it equivalently as
\begin_inset Formula 
\[
\text{const}(\text{id})=(\_^{:X}\Rightarrow a^{:A}\Rightarrow a)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 that takes a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Int => Int
\end_layout

\end_inset

 as its argument and returns a function that applies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 twice.
 For example, if the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f = { x => x + 3 }
\end_layout

\end_inset

, the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(f)
\end_layout

\end_inset

 should be equal to the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x + 6
\end_layout

\end_inset

.
 After implementing the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

, generalize it to a fully parametric function.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
According to the requirements, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 must return a new function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
 So the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice(f: Int => Int): Int => Int = ???
\end_layout

\end_inset

Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(f)
\end_layout

\end_inset

 must be a new function with an integer argument, we begin to write the
 body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice(f: Int => Int): Int => Int = { (x: Int) => ??? }
\end_layout

\end_inset

The new function must apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 twice to its argument, that is, it must return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(f(x))
\end_layout

\end_inset

.
 We can finish the implementation now:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice(f: Int => Int): Int => Int = { x => f(f(x)) }
\end_layout

\end_inset

The type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x: Int)
\end_layout

\end_inset

 can be omitted.
 To test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val g = twice(x => x + 3)
\end_layout

\begin_layout Plain Layout

g: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> g(10)
\end_layout

\begin_layout Plain Layout

res0: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example illustrates how a function can return a new function.
 We just write a nameless function in the function body.
\end_layout

\begin_layout Standard
To generalize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 to a fully parametric function means to replace the type signature by a
 parameterized type while keeping the function body unchanged,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice[A, B, ...](f: ...): ...
 = { x => f(f(x)) }
\end_layout

\end_inset

 To determine the type signature and the possible type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, ..., we need to determine the most general type that matches the function
 body.
 The function body is the expression 
\begin_inset Formula $x\Rightarrow f(f(x))$
\end_inset

.
 Assume that 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset

; for types to match in the sub-expression 
\begin_inset Formula $f(x)$
\end_inset

, we need 
\begin_inset Formula $f$
\end_inset

 to have type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 for some type 
\begin_inset Formula $B$
\end_inset

.
 The sub-expression 
\begin_inset Formula $f(x)$
\end_inset

 will then have type 
\begin_inset Formula $B$
\end_inset

.
 For types to match in 
\begin_inset Formula $f(f(x))$
\end_inset

, the argument of 
\begin_inset Formula $f$
\end_inset

 must have type 
\begin_inset Formula $B$
\end_inset

; but we already assumed 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

.
 This is consistent only if 
\begin_inset Formula $A=B$
\end_inset

.
 In this way, 
\begin_inset Formula $x^{:A}$
\end_inset

 implies 
\begin_inset Formula $f^{:A\Rightarrow A}$
\end_inset

, and the expression 
\begin_inset Formula $x\Rightarrow f(f(x))$
\end_inset

 has type 
\begin_inset Formula $A\Rightarrow A$
\end_inset

.
 We can now write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice[A](f: A => A): A => A = { x => f(f(x)) }
\end_layout

\end_inset

This fully parametric function has only one independent type parameter,
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 A mathematical notation for this function can be written as
\begin_inset Formula 
\[
\text{twice}^{A}=f^{:A\Rightarrow A}\Rightarrow x^{:A}\Rightarrow f(f(x))\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The procedure of deriving the most general type for a given expression is
 called 
\series bold
type inference
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type inference
\end_layout

\end_inset

.
 The type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => A) => A => A
\end_layout

\end_inset

 has been 
\series bold
infer
\series default
red from the expression 
\begin_inset Formula $f\Rightarrow x\Rightarrow f(f(x))$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 What is the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

, and what computation does it perform? Test your answer on the expression
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice[Int])(x => x+3)(10)
\end_layout

\end_inset

.
 What are the type parameters in that expression?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by figuring out the required type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

.
 We introduce unknown type parameters as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[A](twice[B])
\end_layout

\end_inset

.
 The types will match if the argument type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[A]
\end_layout

\end_inset

, which is 
\begin_inset Formula $A\Rightarrow A$
\end_inset

, matches the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[B]
\end_layout

\end_inset

, which is 
\begin_inset Formula $\left(B\Rightarrow B\right)\Rightarrow B\Rightarrow B$
\end_inset

.
 Since the symbol 
\begin_inset Formula $\Rightarrow$
\end_inset

 groups to the right, we have 
\begin_inset Formula 
\[
\left(B\Rightarrow B\right)\Rightarrow B\Rightarrow B=\left(B\Rightarrow B\right)\Rightarrow\left(B\Rightarrow B\right)\quad.
\]

\end_inset

This can match with 
\begin_inset Formula $A\Rightarrow A$
\end_inset

 if we set 
\begin_inset Formula $A=\left(B\Rightarrow B\right)$
\end_inset

.
 So the most general type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

 is
\begin_inset Formula 
\begin{equation}
\text{twice}^{A\Rightarrow A}(\text{twice}^{A}):\left(A\Rightarrow A\right)\Rightarrow A\Rightarrow A\quad.\label{eq:hof-twice-example-solved3}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
After determining the type parameters that match, we may omit types from
 code derivations.
\end_layout

\begin_layout Standard
Since we are using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 as an argument in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

, we need to write the entire code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 as a single value,
\begin_inset Formula 
\[
\text{twice}=f\Rightarrow x\Rightarrow f(f(x))\quad.
\]

\end_inset

 Substituting this into the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

, we find
\begin_inset Formula 
\begin{align*}
 & \text{twice}(\text{twice})\\
\text{definition of twice}:\quad & =(f\Rightarrow x\Rightarrow f(f(x)))(\text{twice})\quad.\\
\text{substitute }f=\text{twice}:\quad & =x\Rightarrow\text{twice}(\text{twice}(x))\\
 & =x\Rightarrow\left(f\Rightarrow x\Rightarrow f(f(x))\right)\left(\left(f\Rightarrow x\Rightarrow f(f(x))\right)(x)\right)\quad.
\end{align*}

\end_inset

The last expression is hard to work with: it is confusing that the argument
 names 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $x$
\end_inset

 are repeated.
 The calculation will be made clearer if we give the arguments new names
 and eliminate name shadowing
\begin_inset Index idx
status open

\begin_layout Plain Layout
name shadowing
\end_layout

\end_inset

.
 To avoid errors, we will rename arguments in one scope at a time:
\begin_inset Formula 
\begin{align*}
 & x\Rightarrow\text{twice}(\text{twice}(x))\\
\text{rename }x\text{ to }z:\quad & =z\Rightarrow\text{twice}(\text{twice}(z))\\
\text{definition of twice}:\quad & =z\Rightarrow\left(f\Rightarrow x\Rightarrow f(f(x))\right)\left(\text{twice}(z)\right)\\
\text{rename }f,x\text{ to }g,y:\quad & =z\Rightarrow(g\Rightarrow y\Rightarrow\gunderline g(\gunderline g(y)))\left(\text{twice}(z)\right)\\
\text{apply, }g=\text{twice}(z):\quad & =z\Rightarrow y\Rightarrow\gunderline{\left(\text{twice}(z)\right)}\left(\text{twice}(z)(y)\right)\\
\text{have }\text{twice}(z)=\left(x\Rightarrow z(z(x))\right):\quad & =z\Rightarrow y\Rightarrow\left(x\Rightarrow z(z(x))\right)(\gunderline{\text{twice}(z)(y)})\\
\text{apply, }x=\text{twice}(z)(y)=z(z(y)):\quad & =z\Rightarrow y\Rightarrow z(z(z(z(y))))\quad.
\end{align*}

\end_inset

We find that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

 is a function that applies its (function-typed) argument 
\emph on
four
\emph default
 times.
\end_layout

\begin_layout Standard
The type parameters can be written out as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[Int => Int](twice[Int])
\end_layout

\end_inset

, as we find from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:hof-twice-example-solved3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $A=\text{Int}$
\end_inset

.
 To test, we need to write at least one type parameter in the code, or else
 Scala cannot infer the types correctly:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> twice(twice[Int])(x => x + 3)(100) // _ + 3 + 3 + 3 + 3
\end_layout

\begin_layout Plain Layout

res0: Int = 112
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> twice[Int => Int](twice)(x => x + 3)(100)
\end_layout

\begin_layout Plain Layout

res1: Int = 112
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Fill in the type signature for the fully parametric function
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[...]:...
 = { f => f(2) }
\end_layout

\end_inset

Can the types possibly match in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(p)
\end_layout

\end_inset

?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
In the nameless function 
\begin_inset Formula $f\Rightarrow f(2)$
\end_inset

, the argument 
\begin_inset Formula $f$
\end_inset

 has to be itself a function, otherwise the expression 
\begin_inset Formula $f(2)$
\end_inset

 would make no sense.
 The sub-expression 
\begin_inset Formula $f(2)$
\end_inset

 will have correct types only if the argument of 
\begin_inset Formula $f$
\end_inset

 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 Therefore, the type signature of 
\begin_inset Formula $f$
\end_inset

 must be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => A
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is the (so far unknown) type of the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(2)
\end_layout

\end_inset

.
 The nameless function 
\begin_inset Formula $f\Rightarrow f(2)$
\end_inset

 has the argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => A
\end_layout

\end_inset

 and the result of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, so the type of 
\begin_inset Formula $p$
\end_inset

 must be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => A) => A
\end_layout

\end_inset

.
 With this type assignment, all types match; so the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 remains undetermined, and must appear as a type parameter of the function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 The code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[A]: (Int => A) => A = { f => f(2) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To answer the question about the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(p)
\end_layout

\end_inset

, we begin by writing that expression with explicit type parameters as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[A](p[B])
\end_layout

\end_inset

, where the type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are initially unknown.
 Then we try to choose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 so that the types match in that expression.
 Does the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[B]
\end_layout

\end_inset

, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => B) => B
\end_layout

\end_inset

, match the type of the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[A]
\end_layout

\end_inset

, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => A
\end_layout

\end_inset

, with some choice of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

? A function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P => Q
\end_layout

\end_inset

 matches 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X => Y
\end_layout

\end_inset

 only if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = X
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q = Y
\end_layout

\end_inset

.
 So 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => B) => B
\end_layout

\end_inset

 can match 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => A
\end_layout

\end_inset

 only if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => B
\end_layout

\end_inset

 matches 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 and if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B = A
\end_layout

\end_inset

.
 But it is impossible for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => B
\end_layout

\end_inset

 to match 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, no matter how we choose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
We conclude that types cannot be chosen consistently in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[A](p[B])
\end_layout

\end_inset

.
 One also says that the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(p)
\end_layout

\end_inset

 is 
\series bold
not well-typed
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
well-typed expression
\end_layout

\end_inset

, or does not 
\series bold
typecheck
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type checking
\end_layout

\end_inset

.
 Such expressions contain a type error and are rejected by the Scala compiler.
\end_layout

\begin_layout Standard
For any given code expression containing variables and functions, one can
 always find the most general type that makes all functions match their
 arguments, unless the expression does not typecheck.
 Algorithms such as the Damas-Hindley-Milner algorithm
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Algorithm_W"
target "https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Algorithm_W"
literal "false"

\end_inset


\end_layout

\end_inset

 will perform type inference (or determine that there is a type error) for
 a large class of expressions that may contain functions, tuples, and disjunctiv
e types.
 
\end_layout

\begin_layout Subsection
Calculations with curried functions
\end_layout

\begin_layout Standard
In mathematics, functions are evaluated by substituting their argument values
 into their body.
 Nameless functions are evaluated in the same way.
 For example, applying the nameless function 
\begin_inset Formula $x\Rightarrow x+10$
\end_inset

 to an integer 
\begin_inset Formula $2$
\end_inset

, we substitute 
\begin_inset Formula $2$
\end_inset

 instead of 
\begin_inset Formula $x$
\end_inset

 in “
\begin_inset Formula $x+10$
\end_inset

” and get “
\begin_inset Formula $2+10$
\end_inset

”, which we then evaluate to 
\begin_inset Formula $12$
\end_inset

.
 The computation is written like this, 
\begin_inset Formula 
\[
(x\Rightarrow x+10)(2)=2+10=12\quad.
\]

\end_inset

To run this computation in Scala, we need to add a type annotation: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((x: Int) => x + 10)(2)
\end_layout

\begin_layout Plain Layout

res0: Int = 12 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Curried function applications such as 
\begin_inset Formula $f(x)(y)$
\end_inset

 are rarely used in mathematics , so we need to gain some experience working
 with them.
\end_layout

\begin_layout Standard
Let us consider a curried nameless function being applied to arguments,
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => y => x - y)(20)(4)
\end_layout

\end_inset

, and compute the result of this function application.
 Begin with the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

; applying a nameless function of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => ...)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

 means to substitute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = 20
\end_layout

\end_inset

 into the body of the function.
 After that substitution, we obtain the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y => 20 - y
\end_layout

\end_inset

, which is again a nameless function.
 Applying that function to the remaining argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(4)
\end_layout

\end_inset

 means substituting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = 4
\end_layout

\end_inset

 into the body of that function.
 This yields the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20 - 4
\end_layout

\end_inset

.
 We can compute that and get the result, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

16
\end_layout

\end_inset

.
 Check the result with Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((x: Int) => (y: Int) => x - y)(20)(4)
\end_layout

\begin_layout Plain Layout

res1: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Applying a curried function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => z => expr(x,y,z)
\end_layout

\end_inset

 to three curried arguments 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

30
\end_layout

\end_inset

 means to substitute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = 10
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = 20
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z = 30
\end_layout

\end_inset

 into the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

.
 In this way, we can easily apply a curried function to any number of curried
 arguments.
\end_layout

\begin_layout Standard
This calculation is helped by the convention that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(g)(h)
\end_layout

\end_inset

 means first applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 and then applying the result to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

.
 In other words, function application associates to the 
\emph on
left
\emph default
: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(g)(h) = (f(g))(h)
\end_layout

\end_inset

.
 It would be confusing if function application associated to the right and
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(g)(h)
\end_layout

\end_inset

 meant first applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 and then applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to the result.
 If 
\emph on
that
\emph default
 were the syntax convention, we would not be able to reason so easily about
 applying a curried function to the arguments.
\end_layout

\begin_layout Standard
We see that the right associativity for the function arrow 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 is well adapted to the left associativity for function applications.
 All functional languages adopt these syntactic conventions.
\end_layout

\begin_layout Standard
To perform the calculations faster, we will write code in a short mathematical
 notation rather than in the Scala syntax.
 We will write type annotations with a colon in the 
\emph on
superscript
\emph default
, for example: 
\begin_inset Formula $x^{:\text{Int}}\Rightarrow x+10$
\end_inset

 instead of the Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((x:Int) => x + 10)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The symbolic evaluation of the Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((x:Int) => (y:Int) => x - y)(20)(4)
\end_layout

\end_inset

 can be written as the following derivation,
\begin_inset Formula 
\begin{eqnarray*}
 &  & (\gunderline{x^{:\text{Int}}\Rightarrow}\,y^{:\text{Int}}\Rightarrow\gunderline x-y)\left(20\right)\left(4\right)\\
\text{substitute }x=20:\quad & = & (\gunderline{y^{:\text{Int}}\Rightarrow}\,20-\gunderline y)\left(4\right)\\
\text{substitute }y=4:\quad & = & 20-4=16\quad.
\end{eqnarray*}

\end_inset

We use the green underline to show the part of the expression that is being
 rewritten in the next step.
\end_layout

\begin_layout Standard
Here we have been performing calculations step by step, substituting an
 argument into a function at each step.
 A Scala program is evaluated in a similar way at run time.
\end_layout

\begin_layout Standard
Nameless functions are 
\emph on
values
\emph default
 and so can be used as part of larger expressions, just as any other values.
 For instance, nameless functions can be arguments of other functions (nameless
 or not).
 Here is an example of applying a nameless function 
\begin_inset Formula $f\Rightarrow f(2)$
\end_inset

 to a nameless function 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (f\Rightarrow\gunderline f(2))\left(x\Rightarrow x+4\right)\\
\text{substitute }f=\left(x\Rightarrow x+4\right):\quad & =(x\Rightarrow\gunderline x+4)(2)\\
\text{substitute }x=2:\quad & =2+4=6\quad.
\end{align*}

\end_inset

In the nameless function 
\begin_inset Formula $f\Rightarrow f(2)$
\end_inset

, the argument 
\begin_inset Formula $f$
\end_inset

 has to be itself a function, otherwise the expression 
\begin_inset Formula $f(2)$
\end_inset

 would make no sense.
 The argument 
\begin_inset Formula $x$
\end_inset

 of 
\begin_inset Formula $f(x)$
\end_inset

 must be an integer, or else we would not be able to compute 
\begin_inset Formula $x+4$
\end_inset

.
 The result of computing 
\begin_inset Formula $f(2)$
\end_inset

 is 
\begin_inset Formula $4$
\end_inset

, and integer.
 We conclude that in this example, 
\begin_inset Formula $f$
\end_inset

 must have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, or else the types will not match.
 To verify this result in Scala, we need to specify the type annotation
 for 
\begin_inset Formula $f$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((f: Int => Int) => f(2))(x => x + 4)
\end_layout

\begin_layout Plain Layout

res2: Int = 6  
\end_layout

\end_inset

The type annotations are not necessary for 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

 since the Scala compiler already knows the type of 
\begin_inset Formula $f$
\end_inset

 and can infer that 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

 must have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To summarize the standard syntax conventions for curried nameless functions:
\end_layout

\begin_layout Itemize
Function expressions group everything to the right:
\begin_inset Newline newline
\end_inset

so 
\begin_inset Formula $x\Rightarrow y\Rightarrow z\Rightarrow e$
\end_inset

 means 
\begin_inset Formula $x\Rightarrow\left(y\Rightarrow\left(z\Rightarrow e\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Function applications group everything to the left:
\begin_inset Newline newline
\end_inset

so 
\begin_inset Formula $f(x)(y)(z)$
\end_inset

 means 
\begin_inset Formula $\big((f(x))(y)\big)(z)$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Function applications group stronger than infix operations:
\begin_inset Newline newline
\end_inset

so 
\begin_inset Formula $x+f(y)$
\end_inset

 means 
\begin_inset Formula $x+(f(y))$
\end_inset

, as in mathematics.
\end_layout

\begin_layout Standard
Here are some more examples of performing function applications symbolically.
 Types are omitted for brevity, since every non-function value is of type
 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset


\family default
 in these examples.
\begin_inset Formula 
\begin{align*}
\left(x\Rightarrow x*2\right)(10) & =10*2=20\quad.\\
\left(p\Rightarrow z\Rightarrow z*p\right)\left(t\right) & =(z\Rightarrow z*t)\quad.\\
\left(p\Rightarrow z\Rightarrow z*p\right)(t)(4) & =(z\Rightarrow z*t)(4)=4*t\quad.
\end{align*}

\end_inset

Some results of these computation are integer values such as 
\begin_inset Formula $20$
\end_inset

; in other cases, results are nameless functions such as 
\begin_inset Formula $z\Rightarrow z*t$
\end_inset

.
 Verify this in Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((x:Int) => x*2)(10)
\end_layout

\begin_layout Plain Layout

res3: Int = 20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> ((p:Int) => (z:Int) => z*p)(10)
\end_layout

\begin_layout Plain Layout

res4: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> ((p:Int) => (z:Int) => z*p)(10)(4)
\end_layout

\begin_layout Plain Layout

res5: Int = 40 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the following examples, some arguments are themselves functions:
\begin_inset Formula 
\begin{align}
 & (\gunderline f\Rightarrow p\Rightarrow f(p))\left(g\Rightarrow g(2)\right)\nonumber \\
\text{substitute }f=\left(g\Rightarrow g(2)\right):\quad & =p\Rightarrow(g\Rightarrow\gunderline g(2))\,(p)\nonumber \\
\text{substitute }g=p:\quad & =p\Rightarrow p(2)\quad.\label{eq:higher-order-functions-derivation1}
\end{align}

\end_inset

The result of this expression is a function 
\begin_inset Formula $p\Rightarrow p(2)$
\end_inset

 that will apply 
\emph on
its
\emph default
 argument to the value 
\begin_inset Formula $2$
\end_inset

.
 In other words, this function expects that its argument 
\begin_inset Formula $p$
\end_inset

 has the type of a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
 A suitable argument is a function 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

, and we can apply the previous expression to that function:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\left(f\Rightarrow p\Rightarrow f(p)\right)\left(g\Rightarrow g(2)\right)}\left(x\Rightarrow x+4\right)\\
\text{use Eq.~(\ref{eq:higher-order-functions-derivation1})}:\quad & =(p\Rightarrow\gunderline p(2))\left(x\Rightarrow x+4\right)\\
\text{substitute }p=\left(x\Rightarrow x+4\right):\quad & =(x\Rightarrow\gunderline x+4)\left(2\right)\\
\text{substitute }x=2:\quad & =2+4=6\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify this calculation in Scala, we need to add appropriate type annotations
 for 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

.
 The reasoning bout types goes like this: We know that the function 
\begin_inset Formula $f\Rightarrow p\Rightarrow f(p)$
\end_inset

 is being applied to the arguments 
\begin_inset Formula $g\Rightarrow g(2)$
\end_inset

 and 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

.
 The variable 
\begin_inset Formula $g$
\end_inset

 in 
\begin_inset Formula $g\Rightarrow g(2)$
\end_inset

 must be a function with argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

; let us assume that 
\begin_inset Formula $g$
\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => A
\end_layout

\end_inset

 with a type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 that we do not yet know.
 It follows that the function 
\begin_inset Formula $g\Rightarrow g(2)$
\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => A) => A
\end_layout

\end_inset

.
 This must also be the type of the argument 
\begin_inset Formula $f$
\end_inset

 in 
\begin_inset Formula $f\Rightarrow p\Rightarrow f(p)$
\end_inset

.
 
\end_layout

\begin_layout Standard
The variable 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

 must be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, or else we cannot add 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $4$
\end_inset

.
 So, the type of the expression 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, and so must be the type of the argument 
\begin_inset Formula $p$
\end_inset

 in 
\begin_inset Formula $f\Rightarrow p\Rightarrow f(p)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Finally, we need to make sure that the types match in the function 
\begin_inset Formula $f\Rightarrow p\Rightarrow f(p)$
\end_inset

.
 The types match in 
\begin_inset Formula $f(p)$
\end_inset

 if the type of 
\begin_inset Formula $f$
\end_inset

's argument is the same as the type of 
\begin_inset Formula $p$
\end_inset

.
 Since 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => A) => A
\end_layout

\end_inset

, its argument has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => A
\end_layout

\end_inset

.
 This will be the same as the type of 
\begin_inset Formula $p$
\end_inset

, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, only if we set 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

.
 So, the actual type of 
\begin_inset Formula $f$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => Int) => Int
\end_layout

\end_inset

.
 We know enough to write the Scala code now:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((f: (Int => Int) => Int) => p => f(p))(g => g(2))(x => x + 4)
\end_layout

\begin_layout Plain Layout

res6: Int = 6
\end_layout

\end_inset

Type annotations for 
\begin_inset Formula $p$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, and 
\begin_inset Formula $x$
\end_inset

 are not necessary because Scala can derive their types unambiguously from
 the given type of 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer the most general type for the fully parametric function
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[...]: ...
 = { f => g => g(f) }
\end_layout

\end_inset

What types are inferred for the expressions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
In the sub-expression 
\begin_inset Formula $f\Rightarrow g\Rightarrow g(f)$
\end_inset

, the curried argument 
\begin_inset Formula $g$
\end_inset

 must itself be a function, because it is being applied to 
\begin_inset Formula $f$
\end_inset

 as 
\begin_inset Formula $g(f)$
\end_inset

.
 So we can assign types as 
\begin_inset Formula $f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f)$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are some type parameters.
 Since there are no other constraints on the types, the parameters 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 remain arbitrary and need to be added to the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To match types in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

, we first assume arbitrary type parameters and write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[A,B](q[C,D])
\end_layout

\end_inset

.
 The type of the first curried argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[A, B]
\end_layout

\end_inset

, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, must match the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[C, D]
\end_layout

\end_inset

, so we must set
\begin_inset Formula 
\[
A=\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\quad.
\]

\end_inset

The type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

 becomes
\begin_inset Formula 
\begin{align*}
q^{A,B}(q^{C,D}) & :\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad,\\
\text{where } & A\triangleq\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We use this result to infer the most general type for the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

.
 We may denote 
\begin_inset Formula $r\triangleq q(q)$
\end_inset

 for brevity; then, as we already know, 
\begin_inset Formula $r$
\end_inset

 has type 
\begin_inset Formula $\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B$
\end_inset

.
 To infer types in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(r)
\end_layout

\end_inset

, we introduce new type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

E, F
\end_layout

\end_inset

 and write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[E, F](r)
\end_layout

\end_inset

.
 The type of the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[E, F]
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

E
\end_layout

\end_inset

, and this must be the same as the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

.
 This gives the constraint
\begin_inset Formula 
\[
E=\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad.
\]

\end_inset

Other than that, the type parameters are arbitrary.
 The type of the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

 is 
\begin_inset Formula $\left(E\Rightarrow F\right)\Rightarrow F$
\end_inset

.
 We conclude that the most general type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

 is
\begin_inset Formula 
\begin{align*}
q^{E,F}(q^{A,B}(q^{C,D})) & :\left(\left(\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\right)\Rightarrow F\right)\Rightarrow F\quad,\\
\text{where } & A\triangleq\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\\
\text{and } & E=\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad.
\end{align*}

\end_inset

It is clear that we will be able to find matching types for expressions
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q(q)))
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q(q(q))))
\end_layout

\end_inset

, and so on.
\end_layout

\begin_layout Standard
To test our results in Scala, we write the type signatures (renaming the
 type parameters for clarity to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def qq[A, B, C]: ((A => (A => B) => B) => C) => C = q(q)
\end_layout

\begin_layout Plain Layout

qq: [A, B, C]=> ((A => ((A => B) => B)) => C) => C
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> def qqq[A, B, C, D]: ((((A => (A => B) => B) => C) => C) => D) =>
 D =
\end_layout

\begin_layout Plain Layout

     |  q(q(q))
\end_layout

\begin_layout Plain Layout

qqq: [A, B, C, D]=> ((((A => ((A => B) => B)) => C) => C) => D) => D
\end_layout

\end_inset

We did not need to give any type parameters within the expressions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

 because the full type signature was declared at the beginning of each of
 these expressions.
 Since the Scala compiler did not print any error messages, we are assured
 that the types match correctly.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-curried"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-curried"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer types in the code expression
\begin_inset Formula 
\[
\left(f\Rightarrow g\Rightarrow g(f)\right)\left(f\Rightarrow g\Rightarrow g(f)\right)\left(f\Rightarrow f(10)\right)\quad,
\]

\end_inset

and simplify the code as much as possible.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The given expression is a curried function 
\begin_inset Formula $f\Rightarrow g\Rightarrow g(f)$
\end_inset

 applied to two curried arguments.
 The plan is to consider each of these sub-expressions in turn, assigning
 types for them using type parameters, and then to figure out how to set
 the type parameters so that all types match.
\end_layout

\begin_layout Standard
Begin by renaming the shadowed variables 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

, so that no names are repeated:
\begin_inset Formula 
\begin{equation}
\left(f\Rightarrow g\Rightarrow g(f)\right)\left(x\Rightarrow y\Rightarrow y(x)\right)\left(h\Rightarrow h(10)\right)\quad.\label{eq:example-hof-curried-function-solved1}
\end{equation}

\end_inset

 As we have seen in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the sub-expression 
\begin_inset Formula $f\Rightarrow g\Rightarrow g(f)$
\end_inset

 is typed as 
\begin_inset Formula $f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f)$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are some type parameters.
 The sub-expression 
\begin_inset Formula $x\Rightarrow y\Rightarrow y(x)$
\end_inset

 is the same function as 
\begin_inset Formula $f\Rightarrow g\Rightarrow g(f)$
\end_inset

 after renaming of the arguments (
\begin_inset Formula $x$
\end_inset

 instead of 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 instead of 
\begin_inset Formula $g$
\end_inset

).
 Renaming a function's arguments does not change that function.
 So the types in 
\begin_inset Formula $x\Rightarrow y\Rightarrow y(x)$
\end_inset

 can be written as 
\begin_inset Formula $x^{:C}\Rightarrow y^{:C\Rightarrow D}\Rightarrow y(x)$
\end_inset

.
 We need to introduce new type parameters 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

 because these types may be different from 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 The types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

 are so far unknown.
\end_layout

\begin_layout Standard
Finally, the variable 
\begin_inset Formula $h$
\end_inset

 in the sub-expression 
\begin_inset Formula $h\Rightarrow h(10)$
\end_inset

 must have type 
\begin_inset Formula $\text{Int}\Rightarrow E$
\end_inset

, where 
\begin_inset Formula $E$
\end_inset

 is another type parameter.
 So, the sub-expression 
\begin_inset Formula $h\Rightarrow h(10)$
\end_inset

 is a function of type 
\begin_inset Formula $\left(\text{Int}\Rightarrow E\right)\Rightarrow E$
\end_inset

.
\end_layout

\begin_layout Standard
The types must match in the entire expression
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{equation}
(f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f))(x^{:C}\Rightarrow y^{:C\Rightarrow D}\Rightarrow y(x))(h^{:\text{Int}\Rightarrow E}\Rightarrow h(10)\quad.\label{eq:example-hof-curried-function-solved2}
\end{equation}

\end_inset

It follows that 
\begin_inset Formula $f$
\end_inset

 must have the same type as 
\begin_inset Formula $x\Rightarrow y\Rightarrow y(x)$
\end_inset

, and 
\begin_inset Formula $g$
\end_inset

 must have the same type as 
\begin_inset Formula $h\Rightarrow h(10)$
\end_inset

.
 The type of 
\begin_inset Formula $g$
\end_inset

, which we know as 
\begin_inset Formula $A\Rightarrow B$
\end_inset

, will match the type of 
\begin_inset Formula $h\Rightarrow h(10)$
\end_inset

, which we know as 
\begin_inset Formula $\left(\text{Int}\Rightarrow E\right)\Rightarrow E$
\end_inset

, only if 
\begin_inset Formula $A=\text{Int}\Rightarrow E$
\end_inset

 and 
\begin_inset Formula $B=E$
\end_inset

.
 It follows that 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $\text{Int}\Rightarrow E$
\end_inset

.
 At the same time, the type of 
\begin_inset Formula $f$
\end_inset

 must match the type of 
\begin_inset Formula $x\Rightarrow y\Rightarrow y(x)$
\end_inset

, which is 
\begin_inset Formula $C\Rightarrow(C\Rightarrow D)\Rightarrow D$
\end_inset

.
 This can work only if 
\begin_inset Formula $C=\text{Int}$
\end_inset

 and 
\begin_inset Formula $E=(C\Rightarrow D)\Rightarrow D$
\end_inset

.
\end_layout

\begin_layout Standard
In this way, we have found all the relationships between the type parameters
 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $E$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The type 
\begin_inset Formula $D$
\end_inset

 remains undetermined (i.e.
\begin_inset space ~
\end_inset

arbitrary), while 
\begin_inset Formula 
\begin{align}
A & =\text{Int}\Rightarrow\left(\text{Int}\Rightarrow D\right)\Rightarrow D\quad,\label{eq:example-hof-curried-solved3}\\
B & =E=\left(\text{Int}\Rightarrow D\right)\Rightarrow D\quad,\label{eq:example-hof-curried-solved4}\\
C & =\text{Int}\quad.\nonumber 
\end{align}

\end_inset

The entire expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is a saturated application of a curried function, and thus has the same
 type as the 
\begin_inset Quotes eld
\end_inset

final
\begin_inset Quotes erd
\end_inset

 result expression 
\begin_inset Formula $g(f)$
\end_inset

, which has type 
\begin_inset Formula $B$
\end_inset

.
 So, the entire expression has type 
\begin_inset Formula $\left(\text{Int}\Rightarrow D\right)\Rightarrow D$
\end_inset

.
\end_layout

\begin_layout Standard
Having established that types match, we can now omit the type annotations
 and rewrite the code expression as
\begin_inset Formula 
\begin{align*}
 & (f\Rightarrow g\Rightarrow\gunderline g(\gunderline f))\left(x\Rightarrow y\Rightarrow y(x)\right)\left(h\Rightarrow h(10)\right)\\
\text{substitute }f,g:\quad & =(h\Rightarrow\gunderline h(10))\left(x\Rightarrow y\Rightarrow y(x)\right)\\
\text{substitute }h:\quad & =(x\Rightarrow y\Rightarrow y(\gunderline x))(10)\\
\text{substitute }x:\quad & =y\Rightarrow y(10)\quad.
\end{align*}

\end_inset

The type of this expression is 
\begin_inset Formula $\left(\text{Int}\Rightarrow D\right)\Rightarrow D$
\end_inset

 for an arbitrary type 
\begin_inset Formula $D$
\end_inset

.
 Since the argument 
\begin_inset Formula $y$
\end_inset

 is an arbitrary function, we cannot simplify 
\begin_inset Formula $y(10)$
\end_inset

.
 We find that 
\begin_inset Formula 
\[
y^{:\text{Int}\Rightarrow D}\Rightarrow y(10)
\]

\end_inset

is the final simplified form of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
To test this in Scala, we first define the function 
\begin_inset Formula $f\Rightarrow g\Rightarrow g(f)$
\end_inset

 as in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end_layout

\end_inset

We also define the function 
\begin_inset Formula $h\Rightarrow h(10)$
\end_inset

 with a general type 
\begin_inset Formula $\left(\text{Int}\Rightarrow E\right)\Rightarrow E$
\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def r[E]: (Int => E) => E = { h => h(10) }
\end_layout

\end_inset

To help Scala evaluate Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to set the type parameters for the first 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 function as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[A, B]
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are given by Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-solved3"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-solved4"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def s[D] = q[Int => (Int => D) => D, (Int => D) => D](q)(r)
\end_layout

\begin_layout Plain Layout

s: [D]=> (Int => D) => D
\end_layout

\end_inset

To verify that the function 
\begin_inset Formula $s^{D}$
\end_inset

 equals 
\begin_inset Formula $y^{:\text{Int}\Rightarrow D}\Rightarrow y(10)$
\end_inset

, we apply 
\begin_inset Formula $s^{D}$
\end_inset

 to some functions of type 
\begin_inset Formula $\text{Int}\Rightarrow D$
\end_inset

, say, for 
\begin_inset Formula $D=\text{Boolean}$
\end_inset

 and 
\begin_inset Formula $D=\text{Int}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> s(_ > 0) // Evaluate 10 > 0.
\end_layout

\begin_layout Plain Layout

res6: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s(_ + 20) // Evaluate 10 + 20.
\end_layout

\begin_layout Plain Layout

res7: Int = 30
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Apply the function 
\begin_inset Formula $\left(x\Rightarrow\_\Rightarrow x\right)$
\end_inset

 to the value 
\begin_inset Formula $\left(z\Rightarrow z(q)\right)$
\end_inset

 where 
\begin_inset Formula $q$
\end_inset

 is a given value of type 
\begin_inset Formula $Q$
\end_inset

.
 Infer types in the resulting expression.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer types in the following expressions:
\begin_inset Formula 
\begin{align*}
\text{(a):}\quad & p\Rightarrow q\Rightarrow p(t\Rightarrow t(q))\quad,\\
\text{(b):}\quad & p\Rightarrow q\Rightarrow q(x\Rightarrow x(p(q)))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the following expressions are not well-typed:
\begin_inset Formula 
\begin{align*}
\text{(a):}\quad & p\Rightarrow p(q\Rightarrow q(p))\quad,\\
\text{(b):}\quad & p\Rightarrow q\Rightarrow q(x\Rightarrow p(q(x)))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer types and simplify the following code expressions:
\begin_inset Formula 
\begin{align*}
\text{(a):}\quad & q\Rightarrow\left(x\Rightarrow y\Rightarrow z\Rightarrow x(z)(y(z))\right)\left(a\Rightarrow a\right)\left(b\Rightarrow b(q)\right)\quad,\\
\text{(b):}\quad & \left(f\Rightarrow g\Rightarrow h\Rightarrow f(g(h))\right)(x\Rightarrow x)\quad,\\
\text{(c):}\quad & \left(x\Rightarrow y\Rightarrow x(y)\right)\left(x\Rightarrow y\Rightarrow x\right)\quad,\\
\text{(d):}\quad & \left(x\Rightarrow y\Rightarrow x(y)\right)\left(x\Rightarrow y\Rightarrow y\right)\quad,\\
\text{(e):}\quad & x\Rightarrow\left(f\Rightarrow y\Rightarrow f(y)(x)\right)\left(z\Rightarrow\_\Rightarrow z\right)\quad,\\
\text{(f):}\quad & z\Rightarrow\left(x\Rightarrow y\Rightarrow x\right)\left(x\Rightarrow x(z)\right)(y\Rightarrow y(z))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
infer the type from the code that you write so you write some code do specify
 some types like this and then clearly this is a string since you're doing
 two strings so if you if you do control shift P it knows is that to strain
 in the function it turns the string so compose has type parameters the
 Scala compiler will find the values of these type parameters that fit in
 this case so for example this function obviously you're returning a boolean
 here because this expression is a boolean expression so this first argument
 has type integer - boolean this is inferred from the code that you wrote
 you don't have to say explicitly that this is integer - boolean you just
 say this is integer then it knows this must be boolean so it infers that
 this expression is integer to boolean and the compose function has the
 first argument text Y therefore X the type parameter the capital X must
 be equal to the type integer as a type variable capital X and the capital
 y must be equal to the type boolean similarly the second argument of compose
 is this expression and it has type of a function from boolean to string
 which follows from the code so the skeleton Pilar then looks at your definition
 of the function compose and finds that G has typed Y to Z so obviously
 the type variable y must be equal to the type boolean and the type variable
 Z must be equal to the type string in the previous argument Y was also
 equal to boolean so that fits Y is the same one as this it has value blue
 in Z has value string X has value int if any of these types did not match
 like for example the first argument gave you from integer to integer and
 a second from boolean to strengthen this y must be integer but this y must
 be boolean that does not match this woman this must be the value of the
 type variable the compiler will then give you an error in this way the
 compiler in first the type that this is integer to string and so f if you
 do control shift P it tells you it's integer to string another function
 in IntelliJ is option enter which says add type annotation it automatically
 inserts the type annotation that it inferred from your code this is also
 a very useful function to check that the compiler understands your code
 in the same way as you think your code is supposed to be working in terms
 of types so this will give you a check that the function f has the type
 you think it should help but you don't once you check that maybe you don't
 need to write this type a Scala compiler does not infer every type it in
 first most but not all types in many cases you have to specify some types
 for example type of argument in a function often needs to be specified
 alternatively you could specify type arguments of the compose function
 let me show you how that works let's call as f f1 now I'm going to delete
 the type annotation here and now once I delete them things become red because
 it doesn't know that X is integer you see compose has a fully parametric
 type so the first function is X 2y it has no clue that X you think must
 be integer but if I write here I can with this syntax I can say it's integer
 so I I have to specify these three arguments integer boolean string once
 I do that the Scala compiler will check that everything I wrote here fits
 what I just said so what I said is that compose in this line is called
 with type arguments int boolean string so F must be in two boolean and
 then this fits X is in let me do ctrl shift key so now Scala knows that
 this X is integer this Y is boolean so it knows that once it knows that
 I can write it in the shorter format which I showed you in a previous tutorial
 this format of the functions typically if you have a function that looks
 like X going to X something you just replace this by underscore this is
 a special syntax that Scala provides to write functions in a shorter way
 and now since all types are specified you don't need to specify in the
 don't need to write type annotations in this long format so this is a shorter
 format and then F 1 of 23 should equal false F 1 of 22 and equal true let's
 run this test and see that it passes and let it compiles of course even
 though we don't see in your head there might be errors but the Scala compiler
 will catch everything is great good so let's look at our first worked example
 I define the functions constant Eid as in the previous slide what is coin
 stop it and what is the type of that value cost of it so how do we find
 out well this looks like an idle question but it's a useful exercise so
 let's reason about constant it constant it are defined here so what would
 be cost of it const has the first argument of type C so when we say Const
 of it it means that C is the type of it now the type of it is T two T is
 a function it means that C must be equal to the function T two T let's
 write this as a comment constant get so C Const has two type parameters
 and it has one type to another so let's try to put these parameters in
 so it can have any parameter T constant must have the trend or C of X so
 the first argument C must be equal to the type of Eid of T which is C 2
 T so C must be T 2 T 2 good then when we apply constitu its first argument
 of type C it returns a function of type X to see where X is anything so
 it means that the result of applying constant to its argument is something
 of type X 2 C now C we know is T 2 T so the result is this I don't write
 parentheses because by convention these parentheses are unnecessary on
 the right side of the error so this is the type of Const of it it has still
 two unknown type parameters X and T and the type is X 2 T 2 T so that is
 our reasoning let me go to the actual code that I prepared so Const of
 it so that let me put the comment here and let's see what happens if we
 just start writing I will delete this let's see what happens if we write
 code like this Const of it what would be the type of this so let me press
 option enter and add the type and notation it's a very curious type it
 inferred any - nothing - nothing so it looks like X 2 T 2 T except it didn't
 introduce type parameters so Scala does not infer the most general type
 which we inferred well scholars compiler is limited in this way its type
 inference is limited so this is certainly not going to work nothing isn't
 very useless type in this case we actually don't need one test type but
 that's what Scala in first because it has no information now the second
 attempt we made I made was this I put a type parameter here and then I
 say it has that parameter here so what the result of this is any Tootsie
 Tootsie so it instead of it did not infer type tramp your ex like I said
 Scala cannot really do this it will infer nothing or any it cannot infer
 that there is a type parameter okay so that is a little better any is really
 any type it's a type that fits anything is also not very useful it doesn't
 check any any correct types so that's not great let's try this so you see
 we had this idea that this works when C is T - t let's put explicitly name
 this - T so this is what we wrote okay so let's see if this makes intelligent
 infer the type es so let me rename this to X and then we have exactly what
 I have here in the comment so another way of achieving the same result
 is that I write the type here and then I don't write any type parameters
 on the right hand side that works too so here what happens is that I specify
 the type and IntelliJ or Scala compiler rather will fit the types so it
 knows this is T 2 T this is C 2 X 2 C and C will be equal to T 2 T so until
 now I've only looked at types I don't actually talk about didn't talk talk
 about what this value does this constant it well it's a function it takes
 an argument of any type and returns this which is the identity function
 let's check that it works actually so let me say C equals example 0 1 B
 of let's say some number okay so something is wrong here yes so I define
 this method twice let's go see okay now the result of calling this function
 which is constant of it on the number is a function which has no type nothing
 to nothing so I need to specify type parameters here so let me say this
 is int and this is moving then C will have type boolean tubulin so in this
 way I get an identity function of type boolean to boolean now this is more
 flexible I can define a function which is of type C you know where I I
 say this is of type T and then I can have a function of type t - t right
 so this is an identity so I can say for example C of ABC that should be
 call ABC let me run this test so now C is identity function now this identity
 function is fully parametric because I put all the types in here so green
 to run the test I press control-shift are by the way very useful thing
 you are in in a test code then you just press control shift or it only
 runs one test all right so these are the types and this is the value it's
 an identity function of some arbitrary type second example define a function
 twice that takes the function f as its argument returns a new function
 it applies F twice for example twice of this must return a new function
 which is equivalent to that is equivalent to adding six so adding three
 twice so let's implement this function here is the implementation basically
 what we remove the type now it's red so the function twice takes a function
 f as an argument and function f has some type which type should it have
 what's reason about this so this is a solution let's find out how we reason
 about the problem to derive the solution so let me write this as a comment
 I want to do a a function twice must take some F as an argument so let's
 say this is a 2b and it must return some C so what does it do what is this
 C well we return required to return the function okay so that's this function
 should be applying F twice to some argument so f of f of X now what is
 X well obviously X must be the argument so we need to return this code
 so this code seems to be clear we need to return a function that takes
 X and applies F twice 2x so what remains is to determine the types here
 right now I just said ABC because I don't know yet what they are the code
 is already fixed this is what we want now what is the type of X well it
 can be any type so let's say that the type of X is deep for example well
 then we need to apply F to X and F has type A to B the only way that can
 work is when X has type a then f of X will have type B okay so D actually
 needs to be a now the result is that f of X has type B now we apply F to
 that but F means type a has argument this can only work when a is the same
 as B all right now F of a is a so the result of this whole thing must be
 a so C is not actually a different type it's also a alright so now we need
 an a as a parameter just one parameter in this way we derived the code
 and actually oh actually this is a to AML today sorry about that because
 we are returning a function right now you see there are two ways of defining
 this they are different only by syntax one is that we say define twice
 and then we specify argument in parenthesis then we specify the return
 type and when we write the code second way is just different syntax is
 to say this is a kind of a value of this type so the first argument this
 type which is the same as this it takes this argument and returns this
 and here we could write parentheses again like that but this is not necessary
 by the syntax convention the first pair of parentheses is required it is
 necessary okay and what is the value of twice V it is a function that takes
 this so it takes F of this type and return the function that takes X of
 type T and returns this so these are two I I not identical but equivalent
 ways of defining this function which one is more convenient well the first
 one is less code to read plus code to write and however the second one
 emphasizes the value nature of functions so sometimes for clarity you would
 do this but most of the time you undo this because it's shorter and also
 easier to read as a function its argument its value and its code that takes
 argument and so on and you could even declare this function with the syntax
 with two pairs of parenthesis so let me show you how that works so I declare
 the first argument I declare the second argument which is of type T in
 the second pair of parenthesis so this is this X which was here which must
 be of type T so I declare it here and then the result is of type T and
 then I type this as the code now let's call it twice zero so the tests
 don't stop working now all of these three definitions declare exactly the
 same function which has effectively two pairs of arguments at first sorry
 two sets of arguments the first set is this the second set is that so in
 Scala you can have functions that have any number of sets of arguments
 in this case each set has just one argument so now notice this is not the
 same as twice f T goes to T X T that's not the same that function is not
 returning a function it just returns a value and it has two arguments you
 cannot call this function with one argument at a time with this syntax
 with two sets of arguments you can call as function with the first set
 of argument and get a function back this is the curried syntax this is
 not curried so this is not what we want if we wanted a function that returns
 a function the only way to do that is to use this syntax or this syntax
 or list syntax Scala gives you all these possibilities most people would
 prefer this because this is the smallest code to write but I just wanted
 to make it clear this is the same these all three are the same thing and
 this is not the same all right so let me delete that and now let's test
 so let's call twice on this function right so we apply this function twice
 to ten we get 16 let's see how we can specify types while Scala Allah requires
 you to specify types somewhere so you can specify it here it will then
 infer that the type arguments T on twice must be int or you can specify
 the type argument T on twice it will then infer that this X must be int
 if you don't do that things won't compile because it won't you know that
 T must be int both are the same so another way of writing it is to write
 both arguments at once so twice of this applied to 10 same answer is 16
 now I'm just testing twice V which I put over there let me just doing this
 it's unnecessary to define it twice just to see that it gives you the same
 results 16 another syntax for the same as this remember in Scala when you
 have a function that looks like X goes to X something then you can replace
 this entire thing next to X by underscore so that is just making it shorter
 like this is a function that adds 3 to its arguments so this underscore
 means argument this is just fancy syntax a lot of people like it um so
 here the tests basically show you all the different ways in which you can
 write the same thing here's another interesting syntax that scholar gives
 you again it's exactly the same thing it's twice V or applying which is
 syntactic they are a variant of twice applied to the same argument the
 function that takes X and goes to X plus 3 however now I put early braces
 around this function which is possible acceptable and note I don't need
 parentheses around the type anymore now this is a syntactic convenience
 in Scala in most cases you want parentheses round round parentheses for
 very simple functions and you want curly braces for complicated functions
 functions in a curly brace can be multi-line they can introduce new web
 new names like vowels you can do new depths you can do whatever you want
 you cannot do this if you write that in ordinary round parentheses that
 just won't work you are not allowed to have multi-line expressions with
 vowels and deaths inside this kind of parentheses Scala sandbox requires
 you in this case the right curly brace once you write the curly brace we
 can't have multi-line code with all kinds of stuff in it so we can here
 you can define new things whatever you want it can be very complicated
 so for this reason the Scala convention is that if your function is complicated
 use curly braces if your function is extremely simple use round parentheses
 let me undo all this and show you so this is a very simple function that
 adds 3 to the argument for such things Scala provides a short syntax and
 this syntax is equivalent but normally used for complicated functions alright
 so much about cindex so Scala gives you all these syntactic possibilities
 no matter how you define if and the syntax works I just have all these
 tests that check that this all combinations of syntax always worked in
 other programming languages there are fewer versions of syntax in Scala
 der quite a lot don't think that I don't think this is a drawback you can
 choose the one you like most the most important thing however is the type
 that always needs to be given when you have functions with fully parametric
 types Scala don't doesn't usually know what X is in an anonymous function
 expression such as this the next question is to derive what twice of twice
 is what does it do well it's a function right twice returns a function
 so when you call twice on something that returns a function so what does
 that function do so if we reason about this twice applies its argument
 two times to something so twice of twice will apply twice two times to
 something so it will be like twice of twice of something now twice of something
 is that something applied two times so twice of twice of something means
 that itself applied to x so now I'm getting already confused so let's write
 it down actually so these are the various definitions of twice twice but
 before we start writing code let's reason about what it should be so mathematic
ally twice of twice is a action that should be applied to some F so what
 is that first we compute this so twice of something is going to be applying
 this two times to that so this is the same as twice of twice all right
 now twice of F is a function so this entire thing needs to be applied to
 some X so this is equal to twice of X going to F of f of X now this twice
 is going to apply this function two times to some argument in other words
 this is some argument let's say X and it's going to be applying this function
 two times to this argument so this is F of F of F of f of X so that applies
 the function f for x to the argument well maybe sense so these are the
 tests if you apply this twice twice to a function like that it it applies
 this four times so it adds 12 and so the result of adding to a 12 to 10
 is 22 now the interesting thing is to apply it three times I leave that
 to you as an exercise apply twice of twice of twice so I'm going to leave
 that and let's concentrate now on types so we figured out what this function
 does it just applies four times how to write it well if we just write twice
 of twice things don't work the way we don't we see that as it doesn't work
 if we do ctrl shift P that's the type it inferred and that's no good it's
 nothing nothing nothing nothing so that's no good that's no good now that's
 better so the type why is that type what is that so let's reason about
 the type so twice has the type which we derived over there the easiest
 way of thinking about the type of a function is to write it like this as
 a kind of a value with parameter with no explicit arguments and just as
 a value but of this type so this is the type of twice now if I want to
 apply it twice to itself what does it mean well this is that argument so
 the first argument is actually t - t and in here it's again the same type
 so this cannot be the same T in here and in here because the first argument
 of twice is T - t and twice is this so the first realization is that these
 two instances of twice cannot have the same type parameter let's call this
 type parameter a let's call this type parameter B or or what's called as
 T just to make it a little easier all right so twice T is is of this type
 now what is a what can it be well the first argument of twice a is of type
 so let me repeat this comment and say what is twice a twice a has this
 type if it's a function whose first argument is this the second argument
 is that so the first argument of twice a is this so it has this type I
 remind you by convention this is how we interpret this syntax with these
 parentheses so clearly this can be a to a only when a is actually T to
 T and then a to a is this alright so now we figured out that the type parameter
 a here must be actually t to t okay so what is the result of : twice with
 argument twice well we put this in here so this is twice of a right so
 we put this argument here the result is this type so it's a to a a is this
 so it's again that so a to a is equal to this now I'm this is not Scala
 code in their comments that I wrote while I was thinking about the type
 of this expression in Scala code you don't write this you cannot do that
 so you can write that but you cannot write what I need so these are just
 my notes for myself [Music] so now intelligent agrees there are two ways
 to make or even three ways to make IntelliJ in further types if I just
 write this IntelliJ doesn't infer the type if I write this it doesn't improve
 the type which I verify here because this example doesn't compile this
 example doesn't compile so three ways that it works in terms of syntax
 first well obviously we have to specify a type somewhere first we specify
 this parameter so we specify a remember this was our a a second is we specified
 T the third is we specified the entire thing on the left now maybe this
 is the best way because it serves at the same time as documentation and
 as code if somebody reads this code later it will be very helpful if they
 don't have to go through this consideration again this is a calculation
 really what we just did here is a calculation and I would say it's very
 nice that we determine things by calculation in our programs we're not
 guessing anything but once this calculation is done it is nice to document
 its results so that other people don't have to repeat this calculation
 again so however all these three things define exactly the same function
 which I verify here in the tests calling this function again requires you
 since this function is fully generic it doesn't have any non generic parameters
 non parametric types generic and parametric is synonymous it's I prefer
 to say parametric but in some programming languages people use the word
 generic in terms of generic type nice parametric type or type parameters
 so when you use this function you supply anonymous function as the argument
 Scala needs to know the type of that function either that type is inferred
 because you specify this where the type is inferred because you specify
 this you can specify both that's not an error it's just not necessary so
 that's how it works so now we found out the type of twice twice let's go
 on the next example is that we need to take a function with two arguments
 fix the value of the first argument and return the function of the remaining
 one argument we define this operation as a function with fully parametric
 types and here is what we were supposed to do so we are supposed to have
 a function first Arg with three type parameters the first argument is a
 function from two arguments of types x and y to a z value x z a second
 argument of the function is a value of type x and the result must be a
 function from Y to Z so we fix the value of the first argument of this
 F we call F on the x0 and the supplied Y so that results in a new function
 that takes Y as an argument and returns Z so that is the most general type
 that we could imagine for this kind of function the code for this function
 is extremely simple just for readability sometimes I like to put the code
 of the function on the next line and also sometimes I like to put this
 into curly brackets in the curly braces you saw that it's written or readable
 this is the code of the function and this is the type of this return value
 but it's just syntax it's exactly the same thing if the function is very
 simple like this function for example it's okay to have it in all in one
 line all right so this is it this is the reason this is the solution so
 how do we reason about this problem how do we derive this solution so let
 me see if I didn't know how to write this what would I do well I would
 write the first part so we're supposed to have two arguments first is a
 function of some type x and y sub two arguments function and this is a
 general type of any function so that has two arguments then the general
 type is XY going to Z I remind you this is not a to problem XY Scala has
 a distinction if I wanted the tuple of XY I would have done this and that
 means that the function f takes a single argument that is a tuple of F
 of two parts having types x and y but in my problem statement i was not
 supposed to do that i was supposed to define a first arc whose argument
 is a function of two organs so that's a general type and then the value
 x0 has type X and I'm then I'll return what you can I return well there
 is not much I can return really all the types are fully parametric so I
 cannot return Y for example because I don't have any values of type Y I
 could return X but that's not what I mean required to do and require to
 call F put in X 0 in it so I don't know what that is but I need to call
 f of X 0 and y and Y should be an argument of this new function so what
 is the type of Y well obviously it must have type capital y there's no
 by the way so this must be a capital y going to Z because F returns Z so
 in this way I'm forced to have this as a return type and then I need to
 introduce X Y Z as type variable since I'm using them here so in this way
 I derive first well the code of the function is kind of clear from the
 problem statement but then I derived the most general type signature for
 this function a fully parameterised function type it does not have any
 specific types like integers or emporia string or anything all types are
 parameters alright so that is how I reason about this solution and then
 I just check that this works so for example I have a function try one that
 prints this and then I fix the argument of the first argument the integer
 argument of try 1 to be 123 and then the result is that so that works and
 also this syntax works so I can call first Arg with two sets of arguments
 the first set of arguments having two arguments the second set of arguments
 having a single argument so now but by now I hope you can understand how
 this works and how the syntax works alternative way of writing this function
 would be to have a value like let's just call it first Arg 1 to make things
 don't break a value like syntax where this doesn't have parameters but
 it equals an expression which is a function so f okay so first I say the
 type which is why point to Z and X so this is the first set of arguments
 when I have a second set of arguments which is just Y and then Z and then
 I say it's f going to Y going to I'm sorry F comma X zero going to Y going
 to type of X near Y alright so this is an alternative syntax for exactly
 the same function it has two sets of arguments which means that here's
 the first set of arguments arrow second set of arguments arrow result type
 this is a typical thing for curried functions with multiple arrows and
 then the first set of arguments actually has two arguments of these types
 the first type is less the second type is this this is a bit harder to
 read than that so I would not prefer to write things this way but this
 is equivalent so it's important that you understand why this is equivalent
 and how this works I can exactly the same syntax can be used for the second
 function let's run this test to make sure this runs so this is a solution
 of this example let me just wait until tests finish component and then
 we'll go on moment the next example is we need to implement a function
 that applies given function f repeatedly to an initial value x0 until a
 given condition function returns true so a hint is that this would be a
 signature so we'll have parameter X type parameter X and then three arguments
 a function from X to X initial value of type X and the condition from X
 to boolean now notice we have this boolean so this is not a fully parametric
 function it has a specific logic which is tied to this boolean type so
 that's fine boolean is a very special type and that's probably okay so
 this function is still widely usable for many different types X how would
 we implement this function so there are two ways of implementing it if
 you have gone through the previous tutorial we have seen how that works
 the first way is using iterator which is a library function second is to
 write explicit recursion let me go through the iterator first I use the
 iterated function which is a standard library parameterize by type X which
 is given to me here and iterate has two sets of arguments it's a curried
 function the first argument is start which is of type T which I called
 X here you see X is a type variable so this is like an argument or a function
 as well so the type argument so these are value arguments and this is a
 type argument and like in any function argument I can rename this to anything
 I want I can rename this to T I can reveal this to LA I can rename this
 to anything so by convention these are single capital letters but it doesn't
 have to be this way so iterate is the first argument which is start second
 argument is a function from T to T so we have exactly the same arguments
 here so I give X 0 and f as the arguments so what does iterate do it creates
 an iterator that takes X 0 as the first value and then applies f repeatedly
 getting the next value and again getting the next value and so on that's
 exactly what we want however this will generate an infinite iterators will
 never stop so what we need is to stop when this condition is true so we
 filter which means we skip all the elements in the iterator sequence for
 which the condition is not true after the filter I still have an iterator
 of T but now all elements in this iterator sequence are such that the condition
 returns true we actually only need the first one so let's take one element
 the result of this is still an iterator you see to see that I press command
 and I hover my mouse over this symbol and then I see what type it would
 definition it has an type in everything so after this I have a still an
 iterator of T with just one element in it so now I can convert this to
 sequence the result of that would be sequence of T having just one element
 now I take a head of this sequence which is just one value it's safe to
 take head because well either this condition is never true or it's true
 sometimes if it's true sometimes we'll get that value this sequence will
 be non-empty and head can be done on an on two secrets if this condition
 is never true and this iterator will iterate forever the filter will be
 never true so this entire thing will never return we cannot do very much
 about this while we could in principle first specify some max number of
 elements take that so we could do this to be safe take 1 million elements
 and but that would is not what we were told to do in the problem setting
 so in some real situation we should think about limiting the number of
 iterations of course let's just forget about this for now ok so this is
 a reasonably simple implementation the second implementation uses tail
 recursion so that is a direct translation of mathematical induction which
 is if the condition is true already on the initial element that's the base
 case of the induction and then we return that initial element otherwise
 we apply one function f1 x and a function f to x0 and call the same function
 again so we do the inductive step the the value is the same procedure applied
 to the next value after the initial value now this is a little more difficult
 to reason about perhaps than this and also what if I wanted to limit the
 number of iterations then I have to complicate this code significantly
 so tail recursion is not very nice to maintain its or rather not Taylor
 just recursion at all recursive functions generally take more work to write
 and more work to maintain that is to to make the curve to make changes
 if you want to do other things or make things different I'll do things
 differently it's more difficult to make changes to recursive function then
 it is - this kind of code which is on the surface it's not recursive was
 just calling library functions and working directly on a sequence so iterator
 produces a sequence and we just call functions on a sequence - nothing
 is recursive here recursion is hidden somewhere in the library and it's
 safe so it's very easy to change this code to do whatever we want so I
 would prefer this implementation in production code it's easier to maintain
 how do I test this well I test this using the procedure to compute approximate
 square roots with the saturation so this is known from numerical methods
 i iterate a square root sequence so given X and if given Y which is an
 approximation to the square root then this formula gives a better approximation
 to the square root of x and I iterate that with initial value equal to
 1/2 of X just randomly kind of chosen as Peralta strongly not equal to
 x over 2 min most cases but anyway that's okay as an initial guess and
 then the condition the condition is that Y times y minus x is less than
 the given precision so I need to specify the precision just write it like
 this with all s spaced out how do I test this so I say precision is 10
 to the minus 8 and then let's compute square root of 25 that should be
 equal to 5 plus - precision so this is test library that gives me their
 syntax and this test passes final - worked examples are to infer types
 in a function so this is something we have done when we were reasoning
 about twice and let's just do this a little more to get practice to understand
 how types work in functions alright so what is this let's reason about
 this I already wrote of course the solution before but let's pretend we
 don't see that so how do we reason about it so here's what we need right
 this code is given what is the type of this value well obviously it's a
 function what is the type of the argument of this function well this is
 some kind of a so f has type a and then the code of the function the expression
 is f of 2 well that can only work if F is itself a function and this function
 has an argument that is an integer so a must be actually int going to some
 B that's the only way that this could make any sense all right now what
 is the result of applying F to 2 the result is of type D so this will return
 B so what is the type of this entire expression it's a function that takes
 F this and returns this which is of type B so so it returns B and it takes
 this does it type okay so it's let me write it a little more formatted
 so this is the actual type now it has an unknown type B which is not fixed
 by the code it could be any type so therefore we need this B as a type
 parameter here this is how we derive the type now I wrote this solution
 exactly the same code except I used T instead of B so as we know this is
 a type variable so it can be renamed and we know in mathematics our function
 arguments can be renamed type arguments are the kind of function arguments
 as well although there are different different sort so it's the same if
 we write B or T or any other letter so in this way we infer the missing
 types so let's find out if this works so how do we test well we need to
 supply a function of type into T so I'd say T is boolean so let's supply
 this function which is defined as this again this is a function I used
 before which checks that X is even X going to this expression which is
 true only when X is even so then P of F should equal true because 2 is
 even so the function P applies def to a fixed argument which is 2 fixed
 value which is 2 so then P of F is true because F in our example is checking
 whether its argument is even another question here is whether P of P works
 and I have a test here that says it does not compile so why does P of P
 not compile let's reason about the type of P of P so P of P let's write
 out the type arguments well it could be different type arguments correct
 we don't know that so it could be different type arguments since they're
 not written in this expression could we find any type arguments a and B
 that would make this expression well typed let's reason about this let's
 replace the expression P of B with its type just for our own notes this
 is not going to be Scala code it's going to be our reasoning which is some
 mathematical like notation so we replace this with the type so the type
 of P of B is this int going to be going to be and P of a is int going to
 a going to a so this type is a function which is applied to this type now
 the only way this can work is when the type of the argument of this function
 is the same as the type of the expression that we are applying it to so
 can it be that int int going to a is the same as int going to be to be
 so the left hand side is something going to something a function type mapping
 into a lab the right hand side is again against something going to something
 so the only way this can work is if a is the same as be yeah but now it
 doesn't worry because int is not the same type as int going to 84 no possible
 type a we could have int equal to this because this is a function type
 and this is not a function type so there are no more type variables there
 is nothing we can do to make this match so for this reason there are no
 possibilities to find types or type parameters in this expression so that
 the types match the compiler finds this and gives us an error so if I write
 something like this I will have read type mismatch cannot resolve reference
 be with such signature so it tries to find values of type parameters that
 would match but it can't and so it gives me read right away now this read
 is different from the read I would get if I emitted type parameters somewhere
 because actually this can never work whatever type parameters you put in
 it just will never match because what we just saw well we just saw int
 cannot be equal to int to me so that's why it will not compile the final
 worked example is this inferred types in this code and ask questions about
 key of Q and Q of Q of Q so this is kind of a puzzle a bit so let's go
 through this just as an illustration of type directed reason so Q is given
 as sowhat's again start reasoning q is given as f going to G going to G
 of F f going to G going to G of F so this is the code that we are given
 we should be able to put types on it so let me put this into braces and
 let's put types so f is some type a maybe G is of some type B I don't know
 what types so right now I just put some arbitrary type various type of
 variables okay now G of F is in the code so it means G must be a function
 such that its first argument is of type a so this B must be of type a going
 to some C so let's call let's put it more explicitly it's not helping to
 so okay so we assumed F is of type a therefore G must be of type a to something
 so let's call that something C without loss of generality the result is
 of type C therefore so this whole thing is F type a going to a to C going
 to C so the first argument is a the second is well it's a curried function
 so it's the syntax with something arrow something arrow something where
 the parentheses around the last pair are assumed so I'm not going to write
 down but these parentheses are assumed and therefore the type of Q must
 be this and that's the most general type I have not assumed anything about
 any type so for example G is a function it must be a function because it's
 applied to F but the result of genius any types it could be any complicated
 type could be itself a function I don't care so Q must have two type parameters
 a and C therefore and that is the solution so this is exactly what I wrote
 here except I used letters F and T instead of a and C and I have two versions
 of syntax first is when I specify the types on the right hand side the
 second if I specify the types on the left hand side other than that it's
 exactly the same thing so Scala would not work if I don't specify types
 it cannot infer type parameters so I have to specify type parameters and
 I have to specify either this or this if I specify this it will infer the
 right type if I specify that it will infer types of F and type on G I prefer
 the second form because it shows what type this value is so this computation
 doesn't have to be repeated by people who will look at this code later
 and actually I would even prefer q1 let's say which has two sets of our
 means one is f-type F 1 and G of type F going to T and that's of type T
 so I would actually prefer to write code like this because that is easier
 to read I clearly show there two groups of arguments two sets of arguments
 we are not actually mathematical sets leader sequences of arguments as
 arguments are ordering here so first and second and I clearly separate
 languages easier to read the types are given the result type in women and
 the code is shortened so I don't have this longer expression which is somewhat
 more difficult to read and I don't have this expression however it's nice
 to understand that this is actually the function value unworthiness all
 right so when I use this skill I need to specify type parameters fmt otherwise
 it doesn't know what to do and that means don't work well as we have seen
 before so let me just emphasize two things first these three syntactic
 forms define exactly equivalent code there's no difference between the
 code except the syntax second thing I'd like to emphasize is that this
 function exists once in the code and it can be used many times specifying
 different type parameters so I could use it in this place in the code with
 these type parameters at another place in the code with different type
 parameters I don't have to repeat the definition of this function and it's
 not duplicate it's called with different types so really type parameters
 are like arguments where you call function call this function many times
 of different audience you can call this function many tests also with different
 type turnovers and different arguments here I show different ways of using
 it so a has the type insta boolean - boolean and then I use it on a function
 which is into the boolean I get boolean now if I don't specify types then
 this doesn't work I have to specify types here it works because I specified
 that this is returning boolean so it could get both type parameters so
 you see sometimes you have to specify types at other times if you give
 both arguments at once then this is fine you don't have to specify type
 it's never an error to specify type parameters just makes your code longer
 so it knows this is an int because this is an int and then that is a boolean
 so it knows this is a boy so in this case you didn't have to specify this
 in here but you could and if you do the error message would probably be
 easier to understand so I put here for example 10.0 type mismatch expected
 int actual double but why does it expect int it's because of this int that
 I wrote if I didn't write this this error wouldn't be noticed so it's never
 a mistake to write types it's safer it guards against mistakes in the code
 earlier but it's just more typing so it's not always necessary alright
 now what is Q of Q well that's an interesting same Q of Q and you see things
 are getting very long very easy but I will not go through a key of P of
 Q perhaps because it's very similar so let us go through Q of Q so that's
 reason about it so what is Q of Q well first of all we need to put type
 parameters Q has to type parameters a and B and this is C only right because
 the two instances of Q could have completely different type parameters
 the Scala compiler will try to find combinations of type parameters that
 work together it may fail or it may succeed let's see if this succeeds
 just as I did before I'm going to replace this expression with its type
 just for the purposes of reasoning so what is the type the easiest way
 to see the type is to look at this syntax so this is the type F T is f
 f - t t so so this is going to be C going to see me going through D and
 this is I'm just going to copy this in here and replace CMD with mV so
 now I'm going to try to fit the types together this function has the first
 argument which is of type a and it's applied to this expression of this
 type so the only way this can work if a equals this that's already something
 but once that is so once a is equal to this then there is no more constraint
 so this argument has been substituted it has the right type B is an is
 not fixed so B can be anything so actually we have three arbitrate type
 parameters now B CMD now I can rename them but I have three type parameter
 so Q Q which is Q of Q has this type which is applying Q to this expression
 and the result is this type now a is equal to that so I thought it I'm
 dating just recently didn't it so let me copy this and instead of a let
 me copy this now I need parentheses around it let me do it slower put parenthes
es and then copy it in there now there are no mistakes so this is actually
 the type of Q of Q it's a complicated type it's a higher order function
 a function that takes as its first argument this function that takes as
 its first argument this function that takes as its first argument this
 of type C and the second argument this so the complicated matching of types
 that we'll all be performed automatically by the Scala compiler so the
 way that scholar can do it for you is first you write this so we have just
 figured out it a must be equal to this so let's put that in the type parameters
 and then put all the type parameters explicitly and then say option enter
 and add type annotations so the Scala compiler will infer this type correctly
 in the same way reasoning about Q of Q of Q gives you this set of type
 parameters and so I'm not going to go through this but you're encouraged
 to travel now something that doesn't work is this now you see there's a
 difference between this and this here I take Q of Q and I apply Q to the
 result here I take Q of Q and apply that again this does not compile because
 Scala cannot infer the correct type arguments for these two cues so I can
 put arbitrary a and B but it's complicated so how do it reason about this
 it is not clear actually at the beginning whether this expression can be
 typed so in programming languages such as Oh camel and Haskell I'm pretty
 sure this would be done by the compiler because their type systems are
 different and these examples can be typed automatically but in Scala this
 is not automatic so let's reason about it and this is also a good exercise
 so what is this expression is the same as QQ applied to Q here we have
 a type of QQ with three type argument so let's put it here and this Q has
 two type arguments so let's take this expression so basically our [Music]
 question is can we find ABC F and T so that this is a well typed expression
 now expression is well typed when all functions receive arguments of the
 correct types that's basically the definition here we have this function
 which is applied to this argument of this type so the only condition is
 whether this function QQ o of types ABC has the first argument which can
 be matched with this type let's check what is the type of QQ of ABC it
 is this this is a function whose first argument is yes parentheses so let's
 copy that so this must equal this if that can be matched with some choice
 of ABC F T then we're done there are no other problems how can this be
 matched so again the only way that this can be matched is when the left
 is a function of some X to some Y and the right also is a function from
 some X to some one the same x and y now the left is a function from this
 to see the right is a function from F to this remember there's implicitly
 there are these parentheses here therefore f must equal this and C must
 equal this okay can we do this of course we can F can be equal to this
 and once that is true C must be equal to that so let's put parentheses
 here and I'll paste it in alright so now we can put this instead of F in
 here so that's right code actually some parameters C T whatever actually
 C will be equal to that so a B and T will remain and then we get QQ of
 a B C of Q of F C right now let's paste so f is equal to this and C is
 equal to that and now everything is green so now we can do option enter
 here and it will infer the type so the type of this expression is actually
 this which is the same as the type of QQ up to changing C 2 T so we can
 rename this to C and it will be exactly the same type so this is very interesti
ng we we have Q of Q of this type and Q of Q of Q is again of this type
 so clearly we can continue doing this Q of Q of Q of Q of Q and it will
 still have the same type up to some complicated substitutions in the types
 now this example I admit is quite artificial but this serves to show you
 how type reasoning works here are some exercises for you and you can apply
 the typed reasoning as I just showed you in the same way and I encourage
 you to do these exercises 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solved examples: higher-order functions
\end_layout

\begin_layout Standard
Implement a function that applies a given function 
\begin_inset Formula $f$
\end_inset

 repeatedly to an initial value 
\begin_inset Formula $x_{0}$
\end_inset

, until a given condition function cond returns true:
\end_layout

\begin_layout Standard
def converge[X](f: X 
\begin_inset Formula $\Rightarrow$
\end_inset

 X, x0: X, cond: X 
\begin_inset Formula $\Rightarrow$
\end_inset

 Boolean): X = ???
\end_layout

\begin_layout Enumerate
Using both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

, define a function that...
\end_layout

\begin_deeper
\begin_layout Enumerate
...adds 
\begin_inset Formula $20$
\end_inset

 to its integer argument.
\end_layout

\begin_deeper
\begin_layout LyX-Code
def fa(i: Int): Int = i + 20
\end_layout

\begin_layout LyX-Code
val fa_v: (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) = k 
\begin_inset Formula $\Rightarrow$
\end_inset

 k + 20
\end_layout

\begin_layout Standard
It is not necessary to specify the type of the argument 
\family typewriter
k
\family default
 because we already fully specified the type 
\family typewriter
(Int => Int)
\family default
 of 
\family typewriter
fa_v
\family default
.
 The parentheses around the type of 
\family typewriter
fa_v
\family default
 are optional, I added them for clarity.
\end_layout

\end_deeper
\begin_layout Enumerate
...takes an integer 
\begin_inset Formula $x$
\end_inset

, and returns a 
\emph on
function
\emph default
 that adds 
\begin_inset Formula $x$
\end_inset

 to 
\emph on
its
\emph default
 argument.
\end_layout

\begin_deeper
\begin_layout LyX-Code
def fb(x: Int): (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) = k 
\begin_inset Formula $\Rightarrow$
\end_inset

 k + x
\end_layout

\begin_layout LyX-Code
val fb_v: (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 k 
\begin_inset Formula $\Rightarrow$
\end_inset

 k + x
\end_layout

\begin_layout LyX-Code
def fb_v2(x: Int)(k: Int): Int = k + x
\end_layout

\begin_layout Standard
Since functions are values, we can directly return new functions.
 When defining the right-hand sides as function expressions in 
\family typewriter
fb
\family default
 and 
\family typewriter
fb_v
\family default
, it is not necessary to specify the type of the arguments 
\family typewriter
x
\family default
 and 
\family typewriter
k
\family default
 because we already fully specified the type signatures of 
\family typewriter
fb
\family default
 and 
\family typewriter
fb_v
\family default
.
 The last version, 
\family typewriter
fb_v2
\family default
, may be easier to read and is equivalent to 
\family typewriter
fb_v.
\end_layout

\end_deeper
\begin_layout Enumerate
...takes an integer 
\begin_inset Formula $x$
\end_inset

 and returns 
\family typewriter
true
\family default
 iff 
\begin_inset Formula $x+1$
\end_inset

 is a prime.
 Use the function 
\family typewriter
is_prime
\family default
 defined previously.
\end_layout

\begin_deeper
\begin_layout LyX-Code
def fc(x: Int): Boolean = is_prime(x + 1)
\end_layout

\begin_layout LyX-Code
val fc_v: (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Boolean) = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 is_prime(x + 1)
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Define a function 
\family typewriter
comp
\family default
 that takes two functions 
\begin_inset Formula $f:$
\end_inset


\family typewriter
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Double
\family default
 and 
\begin_inset Formula $g:$
\end_inset


\family typewriter
Double 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\family default
 as arguments, and returns a new function that computes 
\begin_inset Formula $g(f(x))$
\end_inset

.
 What is the type of the function 
\family typewriter
comp
\family default
?
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
def comp(f: Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Double, g: Double 
\begin_inset Formula $\Rightarrow$
\end_inset

 String): (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String) =
\end_layout

\begin_layout LyX-Code

\size footnotesize
  x 
\begin_inset Formula $\Rightarrow$
\end_inset

 g(f(x))
\end_layout

\begin_layout LyX-Code

\size footnotesize
scala> val f: Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Double = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 5.67 + x
\end_layout

\begin_layout LyX-Code

\size footnotesize
scala> val g: Double 
\begin_inset Formula $\Rightarrow$
\end_inset

 String = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 f"x=%3.2f"
\end_layout

\begin_layout LyX-Code

\size footnotesize
scala> val h = comp(f, g)
\end_layout

\begin_layout LyX-Code

\size footnotesize
scala> h(10)
\end_layout

\begin_layout Standard
The function 
\family typewriter
comp
\family default
 has two arguments, of types 
\family typewriter
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Double
\family default
 and 
\family typewriter
Double 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\family default
.
 The result value of 
\family typewriter
comp
\family default
 is of type 
\family typewriter
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\family default
, because 
\family typewriter
comp
\family default
 returns a new function that takes an argument 
\begin_inset Formula $x$
\end_inset

 of type 
\family typewriter
Int
\family default
 and returns a 
\family typewriter
String
\family default
.
 So the full type signature of the function 
\family typewriter
comp
\family default
 is written as
\end_layout

\begin_layout LyX-Code
/// (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Double, Double 
\begin_inset Formula $\Rightarrow$
\end_inset

 String) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String)
\end_layout

\begin_layout Standard
This is an example of a function that both takes other functions as arguments
 
\emph on
and
\emph default
 returns a new function.
\end_layout

\end_deeper
\begin_layout Subsection
Exercises
\end_layout

\begin_layout Standard
For the function id defined above, what is id(id) and what is its type?
 Same question for id(const).
 Are id(id)(id) or id(id(id)) well-typed? 
\end_layout

\begin_layout Standard
For the function const above, what is const(const), and what is its type?
\end_layout

\begin_layout Standard
For the function twice above, what does twice(twice(twice))) do? Write out
 the type parameters.
 Test your answer on an example.
\end_layout

\begin_layout Standard
Define a function thrice that applies its argument function 3 times, similarly
 to twice.
 What does thrice(thrice(thrice))) do?
\end_layout

\begin_layout Standard
Define a function ence that applies a given function 
\begin_inset Formula $n$
\end_inset

 times.
\end_layout

\begin_layout Standard
Define a function flip(f) with fully parametric types, which swaps arguments
 for any given function f of two arguments.
 To test: 
\end_layout

\begin_layout Standard
def f(x: Int, y: Int) = x - y // check that f(10, 2) gives 8
\end_layout

\begin_layout Standard
val g = flip(f)  // now check that g(10, 2) gives (– 8)
\end_layout

\begin_layout Enumerate
Implement a function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => List[List[Int]] => List[List[Int]]
\end_layout

\end_inset


\family default
 similar to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 except that the hard-coded number 
\begin_inset Formula $100$
\end_inset

 must be a 
\emph on
curried
\emph default
 first argument.
 Implement Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using this function.
\end_layout

\begin_layout Enumerate
Implement a function thrice that takes a function 
\begin_inset Formula $f^{:\text{Int}\Rightarrow\text{Int}}$
\end_inset

 as its argument and returns a new function that computes 
\begin_inset Formula $f(f(f(x)))$
\end_inset

 for any given 
\begin_inset Formula $x$
\end_inset

.
 What is the required type of the function 
\begin_inset Formula $q$
\end_inset

?
\end_layout

\begin_layout Enumerate
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curry2
\end_layout

\end_inset

 that takes an uncurried function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int) => Int
\end_layout

\end_inset


\family default
 and returns an equivalent curried function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Subsection
Higher-order functions
\end_layout

\begin_layout Standard
The 
\series bold
order
\begin_inset Index idx
status open

\begin_layout Plain Layout
order of a function
\end_layout

\end_inset


\series default
 of a function is the number of function arrows 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 contained in the type signature of that function.
 If a function's type signature contains more than one function arrow, the
 function is called a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
higher-order function
\end_layout

\end_inset

higher-order
\series default
 function.
 A higher-order function takes a function as argument and/or returns a function
 as its result value.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

andThen
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compose
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curried
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

uncurried
\end_layout

\end_inset

 are examples of higher-order functions that both take other functions as
 arguments 
\emph on
and
\emph default
 return a new function.
\end_layout

\begin_layout Standard
Examples:
\end_layout

\begin_layout LyX-Code
def f1(x: Int): Int = x + 10
\end_layout

\begin_layout Standard
The function 
\family typewriter
f1
\family default
 has type signature 
\family typewriter
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int
\family default
 and order 1, so it is 
\emph on
not
\emph default
 a higher-order function.
\end_layout

\begin_layout LyX-Code
def f2(x: Int): Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int = z 
\begin_inset Formula $\Rightarrow$
\end_inset

 z + x
\end_layout

\begin_layout Standard
The function 
\family typewriter
f2
\family default
 has type signature 
\family typewriter
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int
\family default
 and is a higher-order function, of order 2.
 
\end_layout

\begin_layout LyX-Code
def f3(g: Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int): Int = g(123)
\end_layout

\begin_layout Standard
The function 
\family typewriter
f3
\family default
 has type signature 
\family typewriter
(Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int
\family default
 and is a higher-order function of order 2.
\end_layout

\begin_layout Standard
Although 
\family typewriter
f2
\family default
 is a higher-order function, its higher-orderness comes from the fact that
 the return value is of function type.
 An equivalent computation can be performed by an uncurried function that
 is not higher-order:
\end_layout

\begin_layout LyX-Code
scala> def f2u(x: Int, z: Int): Int = z + x
\end_layout

\begin_layout Standard
The Scala library defines methods to transform between curried and uncurried
 functions:
\end_layout

\begin_layout LyX-Code
scala> def f2u(x: Int, z: Int): Int = z + x
\end_layout

\begin_layout LyX-Code
scala> val f2c = (f2u _).curried
\end_layout

\begin_layout LyX-Code
scala> val f2u1 = Function.uncurried(f2c)
\end_layout

\begin_layout Standard
The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f2u _)
\end_layout

\end_inset

 is used in Scala to convert methods to function values.
 Recall that Scala has two ways of defining a function: one as a method
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala method
\end_layout

\end_inset

 (defined using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

), another as a function value
\begin_inset Index idx
status open

\begin_layout Plain Layout
function value
\end_layout

\end_inset

 (defined using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.curried
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.uncurried
\end_layout

\end_inset

 can be easily implemented in Scala code, as we will see in the solved examples.
\end_layout

\begin_layout Standard
Unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset

 cannot be converted to a non-higher-order function because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset

 has an argument of function type, rather than a return value of function
 type.
 Converting to an uncurried form cannot eliminate an argument of function
 type.
\end_layout

\begin_layout Subsection
Scope of bound variables
\end_layout

\begin_layout Standard
A bound variable is invisible outside the scope of the expression (called
 
\series bold
local scope
\begin_inset Index idx
status open

\begin_layout Plain Layout
local scope
\end_layout

\end_inset


\series default
 whenever it is clear which expression is being considered).
 This is why bound variables may be renamed at will: no outside code could
 possibly use them and depend on their values.
 However, outside code may define variables that (by chance or by mistake)
 have the same name as a bound variable inside the scope.
\end_layout

\begin_layout Standard
Consider this example from calculus: In the integral
\begin_inset Formula 
\[
f(x)=\int_{0}^{x}\frac{dx}{1+x}\quad,
\]

\end_inset

a bound variable named 
\begin_inset Formula $x$
\end_inset

 is defined in 
\emph on
two
\emph default
 local scopes: in the scope of 
\begin_inset Formula $f$
\end_inset

 and in the scope of the nameless function 
\begin_inset Formula $x\Rightarrow\frac{1}{1+x}$
\end_inset

.
 The convention in mathematics is to treat these two 
\begin_inset Formula $x$
\end_inset

's as two 
\emph on
completely
\emph default
 
\emph on
different
\emph default
 variables that just happen to have the same name.
 In sub-expressions where both of these bound variables are visible, priority
 is given to the bound variable defined in the closest inner scope.
 The outer definition of 
\begin_inset Formula $x$
\end_inset

 is 
\series bold
shadowed
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
name shadowing
\end_layout

\end_inset

, i.e.
\begin_inset space \space{}
\end_inset

hidden, by the definition of the inner 
\begin_inset Formula $x$
\end_inset

.
 For this reason, mathematicians expect that evaluating 
\begin_inset Formula $f(10)$
\end_inset

 will give
\begin_inset Formula 
\[
f(10)=\int_{0}^{10}\frac{dx}{1+x}\quad,
\]

\end_inset

rather than 
\begin_inset Formula $\int_{0}^{10}\frac{dx}{1+10}$
\end_inset

, because the outer definition 
\begin_inset Formula $x=10$
\end_inset

 is shadowed, within the expression 
\begin_inset Formula $\frac{1}{1+x}$
\end_inset

, by the closer definition of 
\begin_inset Formula $x$
\end_inset

 in the local scope of 
\begin_inset Formula $x\Rightarrow\frac{1}{1+x}$
\end_inset

.
\end_layout

\begin_layout Standard
Since this is the prevailing mathematical convention, the same convention
 is adopted in FP.
 A variable defined in a local scope (i.e.
\begin_inset space \space{}
\end_inset

a bound variable) is invisible outside that scope but will shadow any outside
 definitions of a variable with the same name.
 
\end_layout

\begin_layout Standard
It is better to avoid name shadowing
\begin_inset Index idx
status open

\begin_layout Plain Layout
name shadowing
\end_layout

\end_inset

, because it usually decreases the clarity of code and so invites errors.
 Consider the function
\begin_inset Formula 
\[
x\Rightarrow x\Rightarrow x\quad.
\]

\end_inset

Let us decipher this confusing syntax.
 The symbol 
\begin_inset Formula $\Rightarrow$
\end_inset

 associates to the right, so 
\begin_inset Formula $x\Rightarrow x\Rightarrow x$
\end_inset

 is the same as 
\begin_inset Formula $x\Rightarrow\left(x\Rightarrow x\right)$
\end_inset

.
 So, it is a function that takes 
\begin_inset Formula $x$
\end_inset

 and returns 
\begin_inset Formula $x\Rightarrow x$
\end_inset

.
 Since the returned nameless function, 
\begin_inset Formula $\left(x\Rightarrow x\right)$
\end_inset

, may be renamed to 
\begin_inset Formula $\left(y\Rightarrow y\right)$
\end_inset

 without changing its value, we can rewrite the code to
\begin_inset Formula 
\[
x\Rightarrow\left(y\Rightarrow y\right)\quad.
\]

\end_inset

It is now easier to understand this code and reason about it.
 For instance, it becomes clear that this function actually ignores its
 argument 
\begin_inset Formula $x$
\end_inset

 and always returns the same value (the identity function 
\begin_inset Formula $y\Rightarrow y$
\end_inset

).
\end_layout

\begin_layout Subsection
Operator syntax for function applications
\end_layout

\begin_layout Standard
In mathematics, function applications are sometimes written without parentheses,
 for instance 
\begin_inset Formula $\cos x$
\end_inset

 or 
\begin_inset Formula $\text{arg}\,z$
\end_inset

.
 There are also cases where formulas such as 
\begin_inset Formula $\sin2x=2\sin x\cos x$
\end_inset

 imply parentheses as 
\begin_inset Formula $\sin\left(2x\right)=2\cdot\sin\left(x\right)\cdot\cos\left(x\right)$
\end_inset

.
 The functions such as 
\begin_inset Formula $\cos$
\end_inset

 or 
\begin_inset Formula $\arg$
\end_inset

 are treated as syntactic 
\begin_inset Quotes eld
\end_inset

operators
\begin_inset Quotes erd
\end_inset

 that can be applied to their arguments without parenthesis, similar to
 the operators of summation, 
\begin_inset Formula $\sum_{k}k$
\end_inset

, and differentiation, 
\begin_inset Formula $\partial_{x}f$
\end_inset

.
\end_layout

\begin_layout Standard
Many programming languages (such as ML, OCaml, F#, Haskell, Elm, PureScript)
 have adopted this 
\begin_inset Quotes eld
\end_inset

operator syntax
\begin_inset Index idx
status open

\begin_layout Plain Layout
operator syntax
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, where parentheses are optional for function arguments.
 The result is a concise notation where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f x
\end_layout

\end_inset

 means the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

.
 Parentheses are still used where necessary to avoid ambiguity or for readabilit
y.
\begin_inset Foot
status open

\begin_layout Plain Layout
The operator syntax has a long history.
 It is used in Unix shell commands, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cp file1 file2
\end_layout

\end_inset

, as well as in the programming language Tcl/Tk.
 In LISP and Scheme, each function application is enclosed in parentheses
 but the arguments are separated by spaces, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(+ 1 2 3)
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The conventions for nameless functions in the operator syntax become:
\end_layout

\begin_layout Itemize
Function expressions group everything to the right:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $x\Rightarrow y\Rightarrow z\Rightarrow e$
\end_inset

 means 
\begin_inset Formula $x\Rightarrow\left(y\Rightarrow\left(z\Rightarrow e\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Function applications group everything to the left:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $f\,x\,y\,z$
\end_inset

 means 
\begin_inset Formula $\big((f\,x)\:y\big)\:z$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Function applications group stronger than infix operations: 
\begin_inset Formula $x+f\,y$
\end_inset

 means 
\begin_inset Formula $x+(f\,y)$
\end_inset

, just like in mathematics 
\begin_inset Formula $x+\cos y$
\end_inset

 groups 
\begin_inset Formula $\cos y$
\end_inset

 stronger than the infix 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $+$
\end_inset


\begin_inset Quotes erd
\end_inset

 operation.
\end_layout

\begin_layout Standard
So, 
\begin_inset Formula $x\Rightarrow y\Rightarrow a\,b\,c+p\,q$
\end_inset

 means 
\begin_inset Formula $x\Rightarrow\left(y\Rightarrow\left(\left(a\,b\right)\,c\right)+(p\,q)\right)$
\end_inset

.
 When this notation becomes hard to read correctly, one needs to add parentheses
, e.g.
\begin_inset space \space{}
\end_inset

to write 
\begin_inset Formula $f(x\Rightarrow g\,h)$
\end_inset

 instead of 
\begin_inset Formula $f\,x\Rightarrow g\,h$
\end_inset

.
\end_layout

\begin_layout Standard
In this book, I will sometimes use this 
\begin_inset Quotes eld
\end_inset

operator syntax
\begin_inset Quotes erd
\end_inset

 when reasoning about code.
 Scala does not support the operator syntax; in Scala, parentheses need
 to be put around every curried argument.
 The Scala infix method syntax such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1,2,3) map func1
\end_layout

\end_inset


\family default
 does not work with curried functions.
\end_layout

\begin_layout Subsection
Curried functions in other programming languages
\end_layout

\begin_layout Standard
From the point of view of programming language theory, curried functions
 are 
\begin_inset Quotes eld
\end_inset

simpler
\begin_inset Quotes erd
\end_inset

 because they always have a 
\emph on
single
\emph default
 argument (and may return a function that will consume further arguments).
 From the point of view of programming practice, curried functions are often
 harder to read and to write.
\end_layout

\begin_layout Standard
In the syntax used e.g.
\begin_inset space \space{}
\end_inset

in OCaml and Haskell, a curried function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is applied to its arguments as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2 20 4
\end_layout

\end_inset

.
 This departs further from the mathematical tradition and requires some
 getting used to.
 If the two arguments are more complicated than just 
\begin_inset Formula $20$
\end_inset

 and 
\begin_inset Formula $4$
\end_inset

, the resulting expression may become significantly harder to read, compared
 with the syntax where commas are used to separate the arguments.
 (Consider, for example, the Haskell expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2 (g 10) (h 20) + 30
\end_layout

\end_inset

.) To improve readability of code, programmers may prefer to first define
 short names for complicated expressions and then use these names as curried
 arguments.
\end_layout

\begin_layout Standard
In Scala, the choice of whether to use curried or uncurried function signatures
 is largely a matter of syntactic convenience.
 Most Scala code tends to be written with uncurried functions, while curried
 functions are used when they produce more easily readable code.
\end_layout

\begin_layout Standard
One of the syntactic features for curried functions in Scala is the ability
 to specify a curried argument using the curly brace syntax.
 Compare the two definitions of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

summation
\end_layout

\end_inset

 described earlier:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def summation1(a: Int, b: Int, g: Int => Int): Int =
\end_layout

\begin_layout Plain Layout

  (a to b).map(g).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def summation2(a: Int, b: Int)(g: Int => Int): int =
\end_layout

\begin_layout Plain Layout

  (a to b).map(g).sum
\end_layout

\begin_layout Plain Layout

summation1(1, 10, { x => x*x*x + 2*x })
\end_layout

\begin_layout Plain Layout

summation2(1, 10){ x => x*x*x + 2*x }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code that calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

summation2
\end_layout

\end_inset

 may be easier to read because the curried argument is syntactically separated
 from the rest of the code by curly braces.
 This is especially useful when the curried argument is itself a function
 with a complicated body, since Scala's curly braces syntax allows function
 bodies to contain their own local definitions (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Another feature of Scala is the 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 method syntax: for example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs map f
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.map(f)
\end_layout

\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 syntax works only for infix methods, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, defined on specific types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

.
 Do not confuse Scala's 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 method syntax with the operator syntax such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap f xs
\end_layout

\end_inset

, used in Haskell and some other languages.
\end_layout

\begin_layout Subsection
Deriving a function's code from its type signature
\end_layout

\begin_layout Standard
We have seen how the procedure of type inference
\begin_inset Index idx
status open

\begin_layout Plain Layout
type inference
\end_layout

\end_inset

 derives the type of a fully parametric function from the function's code.
 It is remarkable that one can sometimes derive the function's 
\emph on
code
\emph default
 from the function's type signature.
 We will now look at some examples of this.
\end_layout

\begin_layout Standard
Consider a fully parametric function that performs a partial application
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial application
\end_layout

\end_inset

.
 A possible type signature is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pa[A, B, C](x: A)(f: (A, B) => C): B => C = ???
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa
\end_layout

\end_inset

 will substitute a fixed argument value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 into another given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
How can we implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa
\end_layout

\end_inset

? Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa(x)(f)
\end_layout

\end_inset

 must return a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => C
\end_layout

\end_inset

, we have no choice other than to begin writing the function body as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { b: B =>
\end_layout

\begin_layout Plain Layout

  ??? // Need to compute a value of type C here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the inner scope, we need to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, and we have values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b: B
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f:(A, B)=>C
\end_layout

\end_inset

.
 Since the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is arbitrary, we cannot produce any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 from scratch.
 The only way of producing any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is by applying the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to arguments of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Since the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are arbitrary, we cannot obtain any values of these types other than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b: B
\end_layout

\end_inset

.
 So, the only way of obtaining a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x, b)
\end_layout

\end_inset

, and the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa
\end_layout

\end_inset

 
\emph on
must
\emph default
 be
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { b => f(x, b) }
\end_layout

\end_inset

In this way, we have unambiguously derived the body of this function from
 its type signature.
\end_layout

\begin_layout Standard
Another example is the operation of forward composition 
\begin_inset Formula $f\bef g$
\end_inset

, viewed as a fully parametric function with type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = ???
\end_layout

\end_inset

The only way of implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

 is by returning a nameless function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = { a: A =>
\end_layout

\begin_layout Plain Layout

  ??? // Need to compute a value of type C here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the inner scope, we need to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, and we have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: B => C
\end_layout

\end_inset

.
 Since the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is arbitrary, the only way of obtaining a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 to an argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 The only way of obtaining a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 is to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to an argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Finally, we have only one value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, namely 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

.
 So, the only way of obtaining the required result is to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(f(a))
\end_layout

\end_inset

.
 We have again unambiguously derived the body of the function before from
 its type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = { a => g(f(a)) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:3-3-The-formal-logic-curry-howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:The-Curry-Howard-correspondence"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we will see how function bodies can be derived from type signatures for
 a wide range of fully parametric functions.
\end_layout

\end_body
\end_document
