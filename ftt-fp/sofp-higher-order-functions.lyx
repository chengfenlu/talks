#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% Better formatting of tables.
%\usepackage{booktabs}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.0pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.
\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt,utf8
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7in
\paperheight 9in
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Success,Failure,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The formal logic of types II.
 Higher-order functions
\begin_inset CommandInset label
LatexCommand label
name "chap:Higher-order-functions"

\end_inset

 
\end_layout

\begin_layout Subsection
Types and syntax of functions that return functions
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Curried functions
\begin_inset Quotes erd
\end_inset

 in Scala
\end_layout

\begin_layout Standard
A function that returns a function:
\end_layout

\begin_layout Standard
def logWith(topic: String): (String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Unit) = {
\end_layout

\begin_layout Standard
   x 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"$topic: $x")
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
Calling this function:
\end_layout

\begin_layout Standard
val statusLogger: (String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Unit) = logWith("Result status")
\end_layout

\begin_layout Standard
statusLogger("success")
\end_layout

\begin_layout Standard
One-line syntax: logWith("Result status")("success") 
\end_layout

\begin_layout Standard
Alternative syntax – 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Curried"
target "https://en.wikipedia.org/wiki/Currying"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 function:
\end_layout

\begin_layout Standard
val logWith: String 
\begin_inset Formula $\Rightarrow$
\end_inset

 String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Unit = 
\end_layout

\begin_layout Standard
  topic 
\begin_inset Formula $\Rightarrow$
\end_inset

 x 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"$topic: $x")
\end_layout

\begin_layout Standard
Syntax conventions: x 
\begin_inset Formula $\Rightarrow$
\end_inset

 y 
\begin_inset Formula $\Rightarrow$
\end_inset

 z means x 
\begin_inset Formula $\Rightarrow$
\end_inset

 (y 
\begin_inset Formula $\Rightarrow$
\end_inset

 z)
\end_layout

\begin_layout Standard
This is so because f(g)(h) means (f(g))(h) 
\end_layout

\begin_layout Subsection
Functions with fully parametric types
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

No argument type left non-parametric
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Compare these two functions (note tuple type syntax):
\end_layout

\begin_layout Standard
def hypothenuse = (x: Double, y: Double) 
\begin_inset Formula $\Rightarrow$
\end_inset

 math.sqrt(x*x + y*y)
\end_layout

\begin_layout Standard
def swap: ((Double, Double)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (Double, Double) =
\end_layout

\begin_layout Standard
  { case (x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (y, x) } 
\end_layout

\begin_layout Standard
We can rewrite swap to make the argument types fully parametric:
\end_layout

\begin_layout Standard
def swap[X, Y]: ((X, Y)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (Y, X) = { case (x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (y, x) } 
\end_layout

\begin_layout Standard
(The first function is too specific to generalize the argument types.)
\end_layout

\begin_layout Standard
Note: Scala does not support a val with type parameters
\end_layout

\begin_layout Standard
Instead we can use def or parametric classes/traits
\end_layout

\begin_layout Standard
More examples:
\end_layout

\begin_layout Standard
def id[T]: (T 
\begin_inset Formula $\Rightarrow$
\end_inset

 T) = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 x
\end_layout

\begin_layout Standard
def const[C, X]: (C 
\begin_inset Formula $\Rightarrow$
\end_inset

 X 
\begin_inset Formula $\Rightarrow$
\end_inset

 C) = c 
\begin_inset Formula $\Rightarrow$
\end_inset

 x 
\begin_inset Formula $\Rightarrow$
\end_inset

 c
\end_layout

\begin_layout Standard
def before[X, Y, Z](f: X 
\begin_inset Formula $\Rightarrow$
\end_inset

 Y, g: Y 
\begin_inset Formula $\Rightarrow$
\end_inset

 Z): X 
\begin_inset Formula $\Rightarrow$
\end_inset

 Z = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 g(f(x))
\end_layout

\begin_layout Standard
Functions with fully parametric types are useful despite appearances!
\end_layout

\begin_layout Subsection
Solved examples
\end_layout

\begin_layout Standard
For the functions const and id defined above, what is the value const(id)
 and what is its type? Write out the type parameters.
\end_layout

\begin_layout Standard
Define a function twice that takes a function 
\begin_inset Formula $f$
\end_inset

 as its argument and returns a function that applies 
\begin_inset Formula $f$
\end_inset

 twice.
 E.g., twice((x:Int) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x+3) must return a function equivalent to x 
\begin_inset Formula $\Rightarrow$
\end_inset

 x+6.
 Find the type of twice.
\end_layout

\begin_layout Standard
What does twice(twice) do? Test your answer on this expression: twice(twice[Int]
)(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 x+3)(10).
 What are the type parameters here?
\end_layout

\begin_layout Standard
Take a function with two arguments, fix the value of the first argument,
 and return the function of the remaining one argument.
 Define this operation as a function with fully parametric types:
\begin_inset Newline newline
\end_inset

def firstArg[X, Y, Z](f:
\begin_inset space ~
\end_inset

(X, Y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Z, x0:
\begin_inset space ~
\end_inset

X):
\begin_inset space ~
\end_inset

Y 
\begin_inset Formula $\Rightarrow$
\end_inset

 Z = ???
\end_layout

\begin_layout Standard
Implement a function that applies a given function 
\begin_inset Formula $f$
\end_inset

 repeatedly to an initial value 
\begin_inset Formula $x_{0}$
\end_inset

, until a given condition function cond returns true:
\end_layout

\begin_layout Standard
def converge[X](f: X 
\begin_inset Formula $\Rightarrow$
\end_inset

 X, x0: X, cond: X 
\begin_inset Formula $\Rightarrow$
\end_inset

 Boolean): X = ???
\end_layout

\begin_layout Standard
Infer types in def p[...]:...
 = f 
\begin_inset Formula $\Rightarrow$
\end_inset

 f(2).
 Does p(p) work?
\end_layout

\begin_layout Standard
Infer types in def q[...]:...
 = f 
\begin_inset Formula $\Rightarrow$
\end_inset

 g 
\begin_inset Formula $\Rightarrow$
\end_inset

 g(f).
 What are q(q), q(q(q))?
\end_layout

\begin_layout Subsection
Exercises
\end_layout

\begin_layout Standard
For the function id defined above, what is id(id) and what is its type?
 Same question for id(const).
 Does id(id)(id) or id(id(id)) work? 
\end_layout

\begin_layout Standard
For the function const above, what is const(const), what is its type?
\end_layout

\begin_layout Standard
For the function twice above, what does twice(twice(twice))) do? Write out
 the type parameters.
 Test your answer on an example.
\end_layout

\begin_layout Standard
Define a function thrice that applies its argument function 3 times, similarly
 to twice.
 What does thrice(thrice(thrice))) do?
\end_layout

\begin_layout Standard
Define a function ence that applies a given function 
\begin_inset Formula $n$
\end_inset

 times.
\end_layout

\begin_layout Standard
Define a function swapFunc(f) with fully parametric types, which swaps arguments
 for any given function f of two arguments.
 To test: 
\end_layout

\begin_layout Standard
def f(x: Int, y: Int) = x - y // check that f(10, 2) gives 8
\end_layout

\begin_layout Standard
val g = swapFunc(f)  // now check that g(10, 2) gives (– 8)
\end_layout

\begin_layout Standard
Infer types in def r[...]:...
 = p 
\begin_inset Formula $\Rightarrow$
\end_inset

 q 
\begin_inset Formula $\Rightarrow$
\end_inset

 p(t 
\begin_inset Formula $\Rightarrow$
\end_inset

 t(q))
\end_layout

\begin_layout Standard
Show that def s[...]:...
 = p 
\begin_inset Formula $\Rightarrow$
\end_inset

 p(q 
\begin_inset Formula $\Rightarrow$
\end_inset

 q(p)) is not well-typed
\end_layout

\begin_layout Standard
Infer types in def u[...]:...
 = p 
\begin_inset Formula $\Rightarrow$
\end_inset

 q 
\begin_inset Formula $\Rightarrow$
\end_inset

 q(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 x(p(q)))
\end_layout

\begin_layout Standard
Show that def v[...]:...
 = p 
\begin_inset Formula $\Rightarrow$
\end_inset

 q 
\begin_inset Formula $\Rightarrow$
\end_inset

 q(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 p(q(x))) is not well-typed
\end_layout

\begin_layout Section
Types of higher-order functions
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
we will talk about the types of higher-order functions higher-order functions
 are functions that return functions or that take functions as arguments
 it very interesting thing happens when you consider functions that return
 a function here is an example the function log width it takes a string
 argument which is not itself a function so that's just a normal argument
 non function but it returns the type which is a function so it returns
 the value of type function from string to unit why would we want to use
 such a function well for example we want a logger function we want something
 that prints logging statements and we want to prepare this logger so that
 whatever statemented prints before that statement it also writes the topic
 of the statement let's say some topics such as result or intermediate or
 something like this to prepare this function we give a topic and then we
 return an expression which is itself a function the function takes some
 argument X and prints a string which is topic : X so then in the code we
 will say something like this a status logger is a function from string
 to unit well it's just going from strength to unit because println returns
 unit it does not return any you school value this is just an example so
 status logger is a function from string to unit which we obtain by calling
 log width on the string argument result status and the result will be that
 status logger will be a function that prints let's say success but before
 success it prints result status so this is a mistake actually this should
 be status log you're not a primary logger I will fix that in the slides
 so this must be primary not primary logging about status vulgar for this
 code to work so the result is that status logger called on success will
 print result status which is the topic : success and we can call the same
 function in the syntax that is in one line so you see here we first made
 this call which returns this value and then we call that same value sorry
 about this area we call that same value on a success and we can do the
 same since these are all values by first doing this first calling this
 function getting the result which is a logging function and then calling
 this login function on the success argument let's see how this works in
 interactive scholar mode so you define a function takes topic of type string
 and returns let's say string to unity as we discount decided and that is
 going to be X going to print println topic X so we evaluate this and then
 we say well status blogger equals walk with result status then we say status
 lager or success so let's see now okay so we got a printed value result
 status equals success so the same thing can be done if we call logged with
 without status success so yeah same same thing so you see what happens
 here is that the function log with when called on this argument return
 the function which is this expression so we're using we're using expressions
 that are anonymous functions we could have a syntax that is like this as
 well just be I have done something wrong this right so the syntax could
 be like this it's exactly the same result so log West returns this expression
 which is itself a function that function takes some X and prints this message
 which is topic X the topic was already given as the argument here so here
 we put in the topic right and in this function that we returned so when
 we say status logger.log with result status the result Stiles is already
 in that status logger inside this expression so when we say status logger
 success it prints results that of success and exactly the same is happening
 when we do this so first we do list log with of result status that returns
 a function and that function can be called on its argument which is success
 so that results in the syntax that looks a little odd maybe which is a
 function with two pairs of parenthesis that syntax is what I'm going to
 talk about next this syntax is actually very important in functional programmin
g because we can write it in a much shorter way namely like this and why
 is that well you see there are two ways of defining functions in Scala
 in terms of syntax one way is to define deft right def and then function
 name and then in parenthesis the right arguments the other way is to say
 Val or let's say Val and then the type say that the type of this Val is
 a function and then equals so still have echoes here but it's going to
 be a function expression so here it's not so obvious what the type is of
 log width because log with actually has two sets of arguments one which
 you can see here log with is a function that looks like it has two sets
 of arguments the first set of argument here in the first pair of parentheses
 and the second set of arguments here in the second set it's like a second
 pair of parentheses so an alternative syntax for that is to write let me
 show you how to write that so I would say Val log with let's call this
 log with one just to make it a different name and the type of that I'm
 going to show you different ways of putting types in it but let's say I
 want to have a function that takes a topic and returns this so we can do
 this right so we take a function which was returned here and we say that
 function is returned when we give topic as argument so now if we use this
 syntax IntelliJ is unhappy because it wants parameter types so you need
 to specify types there are two ways of doing this I mean this would not
 compile it's not just IntelliJ that's not happy you need to specify types
 so in scala you need to specify the types in quite a few situations although
 not everywhere so we will go through this more slowly so what is the parameter
 type well the syntax for parameters is that you put parentheses and you
 say type let's say this is string so now it's happy about this but it's
 not happy about this X let's put a parameter type in here as well now it's
 completely happy and now look with one the type is string to string to
 unit now we see it put parentheses here which is kind of more clear maybe
 so we take us it's a look with one as a function that takes a string and
 returns this which is itself a function that takes a string and returns
 unit now there is a syntax convention where the second pair of parenthesis
 this last one can be omitted so let me show you how to do that I call this
 log with two and I specify the type string string unit and then I say topic
 and then I do the same as I did here topic returns this value okay it's
 happy you know red actually tells me there are unnecessary parentheses
 so this is the syntax convention I'm talking about the second to the well
 as the second pair of types don't need parentheses around them so neither
 here I need parentheses around these two although IntelliJ will not mind
 if I put them here but they are not necessary it's exactly the same thing
 this is the syntax convention basically the syntax convention is that this
 syntax XYZ means this the parentheses are implied on the last pair not
 on the first one now what would be the first type let me write this as
 a comment so what is string to string to unit what would that mean that
 would be a function that takes a string to string function as the first
 argument or the only argument and returns unit so that would be also a
 higher-order function but that function does not return a function that
 returns unit it's argument is a function that's a difference right the
 function that is an argument or a function that is a return value so here
 we have a function whose return value is a function here we I'm writing
 a type of a function whose argument is a function in this case you need
 parentheses around the first pair in the second case you don't so this
 don't need the parentheses around these two this is not necessary so this
 is the syntax convention I'm talking about the reason for the syntax convention
 is what we just saw the natural way in which we call a function that returns
 a function is that we want to write things like this we want to call the
 function with an argument that returns a function we want to call that
 function again with some other argument just like we did in this example
 we we say status logger equals this and we call status logger of success
 so we should be able to replace when we write status logger of success
 we should be able to replace status logger with this expression right so
 status logger is equal to this so what we can replace status longer here
 with what it's equal to it will be very convenient if we didn't need to
 write parenthesis like this again so these parentheses are unnecessary
 as intellij tells me that's the convention so because we don't write these
 parenthesis but that is natural because of this replacement of the expression
 right so I can write this or I can write this these expressions are equal
 inside you find status logger to be that other thing because of the natural
 way in which we write this naturally the type of this must be a function
 which is which is this and so we don't want to write extra parentheses
 here either since we don't write them here so if we did the opposite convention
 here then we would have to write parentheses like this all the time and
 that's not going to be well that's not going to bring us any advantage
 so these two syntactic conventions go hand-in-hand for the reason I just
 described very natural not to write extra parentheses here and once we
 do that the type of F is actually this and we don't want to write extra
 parentheses in that type either so this syntax is called curried I put
 here a link to the Wikipedia page if you want to write about why this is
 called like this is in faith in honor of a mathematician whose name was
 curry now having understood how we write the syntax for higher-order functions
 let's do something with these types with the types of the functions to
 understand what we do in functional programming let's contrast two different
 kinds of functions and I selected this example of two functions the first
 function in the hypotenuse is a calculation of the Pythagoras theorem so
 you take x and y as two arguments and you return the lengths of the diagonal
 of a rectangle with sides x and y now note again the syntax I'd like to
 call your attention to the syntax in Scala this is a little quirky this
 function actually has two arguments this is like a tuple but it is actually
 not a tuple so in Scala there is a difference between a function that takes
 two arguments like this one and the function that takes a tuple as it's
 one argument in other words a function with one argument whose type the
 function the type of that argument being a tuple of two elements the difference
 in the syntax is extra parentheses so the next example called swap is a
 function that takes a tuple as its own only sorry as its only argument
 and returns a tuple also so this is a type expression which means we take
 a tuple and we return a tuple extra pair an extra pair of parentheses is
 necessary on the left but it is not necessary on the right this is because
 of Scala's special feature that distinguishes between two different function
 types so that we could rewrite the first function as a function that takes
 a tuple of two doubles and then I would have to put extra parentheses here
 and then I would have to do pattern matching on the tuple on the right-hand
 side which would make a code a little longer but it would be possible just
 a little extra writing so in Scala usually arguments of functions are not
 tuples it's not usually necessary but sometimes it is and then we do so
 this walk is an example it takes a tuple of two doubles and returns again
 a tuple of two doubles and in that tuple the order of two numbers is reversed
 that's a very simple function now the interesting thing about this function
 is that it doesn't actually use the fact that its arguments have type double
 all that function does is exchange the order the order of these two arguments
 so in principle this function could with the same code this code remains
 the same it could work on a tuple of any type let's say a tuple of types
 x and y and in order to write this in scala we parameterize the argument
 types so the syntax looks like this we introduce type parameters in square
 brackets and once we introduce them we use them in the type and notation
 for this function type annotation is whatever you write after the colon
 so this is a type annotation in the type annotation and also on the right
 hand side if you want you can use x and y as if they are defined but actually
 these are type parameters so this function can work with any two different
 types x and y it could be even they could be the same or they could be
 different right now there's no convention sorry no specification about
 them there's just two different type variables x and y so you see the code
 of the function is exactly the same as we had here so we just we we kept
 the same code we just changed the type of this function and we made it
 very general so this is what I would call a function with full appellate
 parametric type in other words this function doesn't have any type in its
 signature that is not a type of parameter it doesn't use any specific types
 like doubles integers boolean so it only uses type parameters and no informatio
n about what these types are so this is a fully parametric function by my
 definition now notice that the first function the hypotenuse the hypotenuse
 cannot be generalized in this way the first function is very specific in
 what it does and so this kind of calculation makes no sense for instance
 for string arguments or boolean arguments or even integer arguments because
 you cannot very meaningfully extract square roots from integers I mean
 you can do it in a very rough approximation so we cannot easily make this
 function work let's say for string and boolean instead of double and double
 but this function we can so so this the first function cannot be very usefully
 generalized it's too specific in what it does but the second function can
 can be generalized so there's one little quirk a detail or about Scala
 notice we could previously write this as a vowel so this we could say Deaf's
 walk or look it's a Val swap because this is just a function it is defined
 by a function expression on the right hand side so we could date we could
 say Val hypotenuse or Val swap but here we cannot say well we must say
 def this is so because Scala does not actually support Val's with type
 parameters this is a limitation of the language in practice this is not
 very serious you just used if there are other ways of going over this limitatio
n which is to use type parametric classes or traits I'm not going to talk
 about this right now but later we will see classes and traits with type
 parameters inside these classes and traits you can define the Val's and
 then these vowels could have types involving two type parameters but you
 cannot say for example Val swap of X Y that just doesn't work like this
 so in this tutorial we're just going to use diff but think about this as
 a vowel or as a value it's an important it's important that we think about
 functions as values and so it's emphasized that this is a value because
 it's although it's a def there are no arguments so it's basically like
 if L it has a type so it's like Val blah colon blah equals expression so
 we are going to think about these as values with this type equal to this
 expression just like Val X colon int equals 5 def eid : this equals this
 so we think about functions as values here are more examples it is a function
 that takes X of type T and returns the same X not a very interesting function
 perhaps but it's quite useful in certain in certain cases Const is another
 interesting function has two type parameters C and X and the type of this
 function I put this in parenthesis here just for clarity like this and
 like this but in actual code you don't need these parenthesis if you don't
 like them just to make clear visually that this is the type of this and
 these are the type parameters so what is this is a function that takes
 a value of type C and returns a function the tape's takes a value of type
 X and returns a value of type C how does it work well it takes a C and
 then it takes an x and then it returns that C so the X is ignored that's
 how it works okay well this function may seem to be very strange it takes
 an argument it ignores that and returns the first argument but this is
 a actually also called an interesting and useful function a final example
 on this slide compose is a is a function that takes two functions as arguments
 and returns a function which is their composition we have seen this in
 a previous tutorial perhaps but let me write a full general form of it
 so it has three type parameters X Y Z the first parameter sorry the first
 argument of composed is a function that goes from X to Y and the second
 argument is a function that goes from Y to Z and the result is a functional
 goes from X to Z and then the code of this function is very simple it's
 this expression very short takes argument X of type X and returns G of
 f of X so f of X will have type Y G of f of X will have typed Z I would
 like to emphasize that the Scala compiler will not allow you to use these
 types incorrectly these type parameters are going to be checked by the
 Scala compiler let me show how that works so I define this compose function
 and I suppose I wanted to well suppose I made a mistake here I did F of
 G instead of G of F there is a mistake and IntelliJ shows me that in red
 actually this also will not compile it's not just IntelliJ this will not
 compile expression of type Y does not conform to expected type Z so G of
 X is a function that takes Y and returns Z I did not say what type X was
 but actually it doesn't matter so G always returns Z f always returns Y
 and I said so whatever the argument of F is it will return Y and but I
 said that the function returns Z so it says expression of type Y doesn't
 conform to expected type Z so Z was specified as the return type side expected
 Z but I did not give you an expression of type Z as a result let's correct
 this error and test that this works to test we will define two functions
 let's say a function going from integer to boolean and the function going
 from boolean to string will compose them and get a function going from
 integer to string so let's say first function is going to be from int bool
 it's just going to be X going to whether X is even so X remainder in division
 by 2 is 0 and B will be a function from boolean to string it's just going
 to be printing the boolean let's say I forgot the syntax B is going to
 be to string alright so now let's say C equals compose a B now what type
 is C let's press control shift P which is IntelliJ and it tells me it's
 from integer string so that's fine let me compute C of 12 so the string
 true and that's incomplete C of 11 that's so these are my working examples
 now suppose I made a mistake here I said compose be a what would happens
 right away I've got red here but actually we see here an interesting thing
 intelligent it does not show you the error correctly if I press this button
 I get a different error it does not show me here red but actually it's
 a type mismatch so this code actually won't compile on line six line eight
 and nine also have a type mismatch but actually line six doesn't compile
 because the functions have the wrong types B and a must be composed in
 this order similarly if I wanted if I made a mistake here and I said G
 of X not just G of f of X then if I compile this there's a type mismatch
 so just to warn you that IntelliJ doesn't always show red in your in your
 editing window but actually the Scala compiler will not allow you to compile
 code that is having a type mismatch of any kind so the correct code would
 be G of f of X denied then then you get the result here so actually this
 button will then run and this was just a digression to show you that the
 Scala compiler would strictly check all the types that you specify and
 will prevent many errors happening by oversight if you input functions
 and in correct order when you compose them or something like this so at
 first it could appear that these functions like this taking extra and returning
 X again or this are pretty useless this is not so we will see later so
 that these functions are building blocks in several in several ways of
 interesting programs but for now these are just examples of function types
 let us go through some more worked examples all these examples are implemented
 as tests in the test code here so here are the hypotenuse examples the
 swap example there are some more examples here with a Const using the Const
 and using compose you can use compose in line like this so you do in line
 two functions like that function expressions and the result is a function
 of this type and one interesting thing is that you don't necessarily need
 to specify the type if I delete this type here and I press control shift
 P if the intellij then shows me the type so what's happening here IntelliJ
 and the Scala compiler both they will infer the type from the code that
 you write so you write some code do specify some types like this and then
 clearly this is a string since you're doing two strings so if you if you
 do control shift P it knows is that to strain in the function it turns
 the string so compose has type parameters the Scala compiler will find
 the values of these type parameters that fit in this case so for example
 this function obviously you're returning a boolean here because this expression
 is a boolean expression so this first argument has type integer - boolean
 this is inferred from the code that you wrote you don't have to say explicitly
 that this is integer - boolean you just say this is integer then it knows
 this must be boolean so it infers that this expression is integer to boolean
 and the compose function has the first argument text Y therefore X the
 type parameter the capital X must be equal to the type integer as a type
 variable capital X and the capital y must be equal to the type boolean
 similarly the second argument of compose is this expression and it has
 type of a function from boolean to string which follows from the code so
 the skeleton Pilar then looks at your definition of the function compose
 and finds that G has typed Y to Z so obviously the type variable y must
 be equal to the type boolean and the type variable Z must be equal to the
 type string in the previous argument Y was also equal to boolean so that
 fits Y is the same one as this it has value blue in Z has value string
 X has value int if any of these types did not match like for example the
 first argument gave you from integer to integer and a second from boolean
 to strengthen this y must be integer but this y must be boolean that does
 not match this woman this must be the value of the type variable the compiler
 will then give you an error in this way the compiler in first the type
 that this is integer to string and so f if you do control shift P it tells
 you it's integer to string another function in IntelliJ is option enter
 which says add type annotation it automatically inserts the type annotation
 that it inferred from your code this is also a very useful function to
 check that the compiler understands your code in the same way as you think
 your code is supposed to be working in terms of types so this will give
 you a check that the function f has the type you think it should help but
 you don't once you check that maybe you don't need to write this type a
 Scala compiler does not infer every type it in first most but not all types
 in many cases you have to specify some types for example type of argument
 in a function often needs to be specified alternatively you could specify
 type arguments of the compose function let me show you how that works let's
 call as f f1 now I'm going to delete the type annotation here and now once
 I delete them things become red because it doesn't know that X is integer
 you see compose has a fully parametric type so the first function is X
 2y it has no clue that X you think must be integer but if I write here
 I can with this syntax I can say it's integer so I I have to specify these
 three arguments integer boolean string once I do that the Scala compiler
 will check that everything I wrote here fits what I just said so what I
 said is that compose in this line is called with type arguments int boolean
 string so F must be in two boolean and then this fits X is in let me do
 ctrl shift key so now Scala knows that this X is integer this Y is boolean
 so it knows that once it knows that I can write it in the shorter format
 which I showed you in a previous tutorial this format of the functions
 typically if you have a function that looks like X going to X something
 you just replace this by underscore this is a special syntax that Scala
 provides to write functions in a shorter way and now since all types are
 specified you don't need to specify in the don't need to write type annotations
 in this long format so this is a shorter format and then F 1 of 23 should
 equal false F 1 of 22 and equal true let's run this test and see that it
 passes and let it compiles of course even though we don't see in your head
 there might be errors but the Scala compiler will catch everything is great
 good so let's look at our first worked example I define the functions constant
 Eid as in the previous slide what is coin stop it and what is the type
 of that value cost of it so how do we find out well this looks like an
 idle question but it's a useful exercise so let's reason about constant
 it constant it are defined here so what would be cost of it const has the
 first argument of type C so when we say Const of it it means that C is
 the type of it now the type of it is T two T is a function it means that
 C must be equal to the function T two T let's write this as a comment constant
 get so C Const has two type parameters and it has one type to another so
 let's try to put these parameters in so it can have any parameter T constant
 must have the trend or C of X so the first argument C must be equal to
 the type of Eid of T which is C 2 T so C must be T 2 T 2 good then when
 we apply constitu its first argument of type C it returns a function of
 type X to see where X is anything so it means that the result of applying
 constant to its argument is something of type X 2 C now C we know is T
 2 T so the result is this I don't write parentheses because by convention
 these parentheses are unnecessary on the right side of the error so this
 is the type of Const of it it has still two unknown type parameters X and
 T and the type is X 2 T 2 T so that is our reasoning let me go to the actual
 code that I prepared so Const of it so that let me put the comment here
 and let's see what happens if we just start writing I will delete this
 let's see what happens if we write code like this Const of it what would
 be the type of this so let me press option enter and add the type and notation
 it's a very curious type it inferred any - nothing - nothing so it looks
 like X 2 T 2 T except it didn't introduce type parameters so Scala does
 not infer the most general type which we inferred well scholars compiler
 is limited in this way its type inference is limited so this is certainly
 not going to work nothing isn't very useless type in this case we actually
 don't need one test type but that's what Scala in first because it has
 no information now the second attempt we made I made was this I put a type
 parameter here and then I say it has that parameter here so what the result
 of this is any Tootsie Tootsie so it instead of it did not infer type tramp
 your ex like I said Scala cannot really do this it will infer nothing or
 any it cannot infer that there is a type parameter okay so that is a little
 better any is really any type it's a type that fits anything is also not
 very useful it doesn't check any any correct types so that's not great
 let's try this so you see we had this idea that this works when C is T
 - t let's put explicitly name this - T so this is what we wrote okay so
 let's see if this makes intelligent infer the type es so let me rename
 this to X and then we have exactly what I have here in the comment so another
 way of achieving the same result is that I write the type here and then
 I don't write any type parameters on the right hand side that works too
 so here what happens is that I specify the type and IntelliJ or Scala compiler
 rather will fit the types so it knows this is T 2 T this is C 2 X 2 C and
 C will be equal to T 2 T so until now I've only looked at types I don't
 actually talk about didn't talk talk about what this value does this constant
 it well it's a function it takes an argument of any type and returns this
 which is the identity function let's check that it works actually so let
 me say C equals example 0 1 B of let's say some number okay so something
 is wrong here yes so I define this method twice let's go see okay now the
 result of calling this function which is constant of it on the number is
 a function which has no type nothing to nothing so I need to specify type
 parameters here so let me say this is int and this is moving then C will
 have type boolean tubulin so in this way I get an identity function of
 type boolean to boolean now this is more flexible I can define a function
 which is of type C you know where I I say this is of type T and then I
 can have a function of type t - t right so this is an identity so I can
 say for example C of ABC that should be call ABC let me run this test so
 now C is identity function now this identity function is fully parametric
 because I put all the types in here so green to run the test I press control-sh
ift are by the way very useful thing you are in in a test code then you
 just press control shift or it only runs one test all right so these are
 the types and this is the value it's an identity function of some arbitrary
 type second example define a function twice that takes the function f as
 its argument returns a new function it applies F twice for example twice
 of this must return a new function which is equivalent to that is equivalent
 to adding six so adding three twice so let's implement this function here
 is the implementation basically what we remove the type now it's red so
 the function twice takes a function f as an argument and function f has
 some type which type should it have what's reason about this so this is
 a solution let's find out how we reason about the problem to derive the
 solution so let me write this as a comment I want to do a a function twice
 must take some F as an argument so let's say this is a 2b and it must return
 some C so what does it do what is this C well we return required to return
 the function okay so that's this function should be applying F twice to
 some argument so f of f of X now what is X well obviously X must be the
 argument so we need to return this code so this code seems to be clear
 we need to return a function that takes X and applies F twice 2x so what
 remains is to determine the types here right now I just said ABC because
 I don't know yet what they are the code is already fixed this is what we
 want now what is the type of X well it can be any type so let's say that
 the type of X is deep for example well then we need to apply F to X and
 F has type A to B the only way that can work is when X has type a then
 f of X will have type B okay so D actually needs to be a now the result
 is that f of X has type B now we apply F to that but F means type a has
 argument this can only work when a is the same as B all right now F of
 a is a so the result of this whole thing must be a so C is not actually
 a different type it's also a alright so now we need an a as a parameter
 just one parameter in this way we derived the code and actually oh actually
 this is a to AML today sorry about that because we are returning a function
 right now you see there are two ways of defining this they are different
 only by syntax one is that we say define twice and then we specify argument
 in parenthesis then we specify the return type and when we write the code
 second way is just different syntax is to say this is a kind of a value
 of this type so the first argument this type which is the same as this
 it takes this argument and returns this and here we could write parentheses
 again like that but this is not necessary by the syntax convention the
 first pair of parentheses is required it is necessary okay and what is
 the value of twice V it is a function that takes this so it takes F of
 this type and return the function that takes X of type T and returns this
 so these are two I I not identical but equivalent ways of defining this
 function which one is more convenient well the first one is less code to
 read plus code to write and however the second one emphasizes the value
 nature of functions so sometimes for clarity you would do this but most
 of the time you undo this because it's shorter and also easier to read
 as a function its argument its value and its code that takes argument and
 so on and you could even declare this function with the syntax with two
 pairs of parenthesis so let me show you how that works so I declare the
 first argument I declare the second argument which is of type T in the
 second pair of parenthesis so this is this X which was here which must
 be of type T so I declare it here and then the result is of type T and
 then I type this as the code now let's call it twice zero so the tests
 don't stop working now all of these three definitions declare exactly the
 same function which has effectively two pairs of arguments at first sorry
 two sets of arguments the first set is this the second set is that so in
 Scala you can have functions that have any number of sets of arguments
 in this case each set has just one argument so now notice this is not the
 same as twice f T goes to T X T that's not the same that function is not
 returning a function it just returns a value and it has two arguments you
 cannot call this function with one argument at a time with this syntax
 with two sets of arguments you can call as function with the first set
 of argument and get a function back this is the curried syntax this is
 not curried so this is not what we want if we wanted a function that returns
 a function the only way to do that is to use this syntax or this syntax
 or list syntax Scala gives you all these possibilities most people would
 prefer this because this is the smallest code to write but I just wanted
 to make it clear this is the same these all three are the same thing and
 this is not the same all right so let me delete that and now let's test
 so let's call twice on this function right so we apply this function twice
 to ten we get 16 let's see how we can specify types while Scala Allah requires
 you to specify types somewhere so you can specify it here it will then
 infer that the type arguments T on twice must be int or you can specify
 the type argument T on twice it will then infer that this X must be int
 if you don't do that things won't compile because it won't you know that
 T must be int both are the same so another way of writing it is to write
 both arguments at once so twice of this applied to 10 same answer is 16
 now I'm just testing twice V which I put over there let me just doing this
 it's unnecessary to define it twice just to see that it gives you the same
 results 16 another syntax for the same as this remember in Scala when you
 have a function that looks like X goes to X something then you can replace
 this entire thing next to X by underscore so that is just making it shorter
 like this is a function that adds 3 to its arguments so this underscore
 means argument this is just fancy syntax a lot of people like it um so
 here the tests basically show you all the different ways in which you can
 write the same thing here's another interesting syntax that scholar gives
 you again it's exactly the same thing it's twice V or applying which is
 syntactic they are a variant of twice applied to the same argument the
 function that takes X and goes to X plus 3 however now I put early braces
 around this function which is possible acceptable and note I don't need
 parentheses around the type anymore now this is a syntactic convenience
 in Scala in most cases you want parentheses round round parentheses for
 very simple functions and you want curly braces for complicated functions
 functions in a curly brace can be multi-line they can introduce new web
 new names like vowels you can do new depths you can do whatever you want
 you cannot do this if you write that in ordinary round parentheses that
 just won't work you are not allowed to have multi-line expressions with
 vowels and deaths inside this kind of parentheses Scala sandbox requires
 you in this case the right curly brace once you write the curly brace we
 can't have multi-line code with all kinds of stuff in it so we can here
 you can define new things whatever you want it can be very complicated
 so for this reason the Scala convention is that if your function is complicated
 use curly braces if your function is extremely simple use round parentheses
 let me undo all this and show you so this is a very simple function that
 adds 3 to the argument for such things Scala provides a short syntax and
 this syntax is equivalent but normally used for complicated functions alright
 so much about cindex so Scala gives you all these syntactic possibilities
 no matter how you define if and the syntax works I just have all these
 tests that check that this all combinations of syntax always worked in
 other programming languages there are fewer versions of syntax in Scala
 der quite a lot don't think that I don't think this is a drawback you can
 choose the one you like most the most important thing however is the type
 that always needs to be given when you have functions with fully parametric
 types Scala don't doesn't usually know what X is in an anonymous function
 expression such as this the next question is to derive what twice of twice
 is what does it do well it's a function right twice returns a function
 so when you call twice on something that returns a function so what does
 that function do so if we reason about this twice applies its argument
 two times to something so twice of twice will apply twice two times to
 something so it will be like twice of twice of something now twice of something
 is that something applied two times so twice of twice of something means
 that itself applied to x so now I'm getting already confused so let's write
 it down actually so these are the various definitions of twice twice but
 before we start writing code let's reason about what it should be so mathematic
ally twice of twice is a action that should be applied to some F so what
 is that first we compute this so twice of something is going to be applying
 this two times to that so this is the same as twice of twice all right
 now twice of F is a function so this entire thing needs to be applied to
 some X so this is equal to twice of X going to F of f of X now this twice
 is going to apply this function two times to some argument in other words
 this is some argument let's say X and it's going to be applying this function
 two times to this argument so this is F of F of F of f of X so that applies
 the function f for x to the argument well maybe sense so these are the
 tests if you apply this twice twice to a function like that it it applies
 this four times so it adds 12 and so the result of adding to a 12 to 10
 is 22 now the interesting thing is to apply it three times I leave that
 to you as an exercise apply twice of twice of twice so I'm going to leave
 that and let's concentrate now on types so we figured out what this function
 does it just applies four times how to write it well if we just write twice
 of twice things don't work the way we don't we see that as it doesn't work
 if we do ctrl shift P that's the type it inferred and that's no good it's
 nothing nothing nothing nothing so that's no good that's no good now that's
 better so the type why is that type what is that so let's reason about
 the type so twice has the type which we derived over there the easiest
 way of thinking about the type of a function is to write it like this as
 a kind of a value with parameter with no explicit arguments and just as
 a value but of this type so this is the type of twice now if I want to
 apply it twice to itself what does it mean well this is that argument so
 the first argument is actually t - t and in here it's again the same type
 so this cannot be the same T in here and in here because the first argument
 of twice is T - t and twice is this so the first realization is that these
 two instances of twice cannot have the same type parameter let's call this
 type parameter a let's call this type parameter B or or what's called as
 T just to make it a little easier all right so twice T is is of this type
 now what is a what can it be well the first argument of twice a is of type
 so let me repeat this comment and say what is twice a twice a has this
 type if it's a function whose first argument is this the second argument
 is that so the first argument of twice a is this so it has this type I
 remind you by convention this is how we interpret this syntax with these
 parentheses so clearly this can be a to a only when a is actually T to
 T and then a to a is this alright so now we figured out that the type parameter
 a here must be actually t to t okay so what is the result of : twice with
 argument twice well we put this in here so this is twice of a right so
 we put this argument here the result is this type so it's a to a a is this
 so it's again that so a to a is equal to this now I'm this is not Scala
 code in their comments that I wrote while I was thinking about the type
 of this expression in Scala code you don't write this you cannot do that
 so you can write that but you cannot write what I need so these are just
 my notes for myself [Music] so now intelligent agrees there are two ways
 to make or even three ways to make IntelliJ in further types if I just
 write this IntelliJ doesn't infer the type if I write this it doesn't improve
 the type which I verify here because this example doesn't compile this
 example doesn't compile so three ways that it works in terms of syntax
 first well obviously we have to specify a type somewhere first we specify
 this parameter so we specify a remember this was our a a second is we specified
 T the third is we specified the entire thing on the left now maybe this
 is the best way because it serves at the same time as documentation and
 as code if somebody reads this code later it will be very helpful if they
 don't have to go through this consideration again this is a calculation
 really what we just did here is a calculation and I would say it's very
 nice that we determine things by calculation in our programs we're not
 guessing anything but once this calculation is done it is nice to document
 its results so that other people don't have to repeat this calculation
 again so however all these three things define exactly the same function
 which I verify here in the tests calling this function again requires you
 since this function is fully generic it doesn't have any non generic parameters
 non parametric types generic and parametric is synonymous it's I prefer
 to say parametric but in some programming languages people use the word
 generic in terms of generic type nice parametric type or type parameters
 so when you use this function you supply anonymous function as the argument
 Scala needs to know the type of that function either that type is inferred
 because you specify this where the type is inferred because you specify
 this you can specify both that's not an error it's just not necessary so
 that's how it works so now we found out the type of twice twice let's go
 on the next example is that we need to take a function with two arguments
 fix the value of the first argument and return the function of the remaining
 one argument we define this operation as a function with fully parametric
 types and here is what we were supposed to do so we are supposed to have
 a function first Arg with three type parameters the first argument is a
 function from two arguments of types x and y to a z value x z a second
 argument of the function is a value of type x and the result must be a
 function from Y to Z so we fix the value of the first argument of this
 F we call F on the x0 and the supplied Y so that results in a new function
 that takes Y as an argument and returns Z so that is the most general type
 that we could imagine for this kind of function the code for this function
 is extremely simple just for readability sometimes I like to put the code
 of the function on the next line and also sometimes I like to put this
 into curly brackets in the curly braces you saw that it's written or readable
 this is the code of the function and this is the type of this return value
 but it's just syntax it's exactly the same thing if the function is very
 simple like this function for example it's okay to have it in all in one
 line all right so this is it this is the reason this is the solution so
 how do we reason about this problem how do we derive this solution so let
 me see if I didn't know how to write this what would I do well I would
 write the first part so we're supposed to have two arguments first is a
 function of some type x and y sub two arguments function and this is a
 general type of any function so that has two arguments then the general
 type is XY going to Z I remind you this is not a to problem XY Scala has
 a distinction if I wanted the tuple of XY I would have done this and that
 means that the function f takes a single argument that is a tuple of F
 of two parts having types x and y but in my problem statement i was not
 supposed to do that i was supposed to define a first arc whose argument
 is a function of two organs so that's a general type and then the value
 x0 has type X and I'm then I'll return what you can I return well there
 is not much I can return really all the types are fully parametric so I
 cannot return Y for example because I don't have any values of type Y I
 could return X but that's not what I mean required to do and require to
 call F put in X 0 in it so I don't know what that is but I need to call
 f of X 0 and y and Y should be an argument of this new function so what
 is the type of Y well obviously it must have type capital y there's no
 by the way so this must be a capital y going to Z because F returns Z so
 in this way I'm forced to have this as a return type and then I need to
 introduce X Y Z as type variable since I'm using them here so in this way
 I derive first well the code of the function is kind of clear from the
 problem statement but then I derived the most general type signature for
 this function a fully parameterised function type it does not have any
 specific types like integers or emporia string or anything all types are
 parameters alright so that is how I reason about this solution and then
 I just check that this works so for example I have a function try one that
 prints this and then I fix the argument of the first argument the integer
 argument of try 1 to be 123 and then the result is that so that works and
 also this syntax works so I can call first Arg with two sets of arguments
 the first set of arguments having two arguments the second set of arguments
 having a single argument so now but by now I hope you can understand how
 this works and how the syntax works alternative way of writing this function
 would be to have a value like let's just call it first Arg 1 to make things
 don't break a value like syntax where this doesn't have parameters but
 it equals an expression which is a function so f okay so first I say the
 type which is why point to Z and X so this is the first set of arguments
 when I have a second set of arguments which is just Y and then Z and then
 I say it's f going to Y going to I'm sorry F comma X zero going to Y going
 to type of X near Y alright so this is an alternative syntax for exactly
 the same function it has two sets of arguments which means that here's
 the first set of arguments arrow second set of arguments arrow result type
 this is a typical thing for curried functions with multiple arrows and
 then the first set of arguments actually has two arguments of these types
 the first type is less the second type is this this is a bit harder to
 read than that so I would not prefer to write things this way but this
 is equivalent so it's important that you understand why this is equivalent
 and how this works I can exactly the same syntax can be used for the second
 function let's run this test to make sure this runs so this is a solution
 of this example let me just wait until tests finish component and then
 we'll go on moment the next example is we need to implement a function
 that applies given function f repeatedly to an initial value x0 until a
 given condition function returns true so a hint is that this would be a
 signature so we'll have parameter X type parameter X and then three arguments
 a function from X to X initial value of type X and the condition from X
 to boolean now notice we have this boolean so this is not a fully parametric
 function it has a specific logic which is tied to this boolean type so
 that's fine boolean is a very special type and that's probably okay so
 this function is still widely usable for many different types X how would
 we implement this function so there are two ways of implementing it if
 you have gone through the previous tutorial we have seen how that works
 the first way is using iterator which is a library function second is to
 write explicit recursion let me go through the iterator first I use the
 iterated function which is a standard library parameterize by type X which
 is given to me here and iterate has two sets of arguments it's a curried
 function the first argument is start which is of type T which I called
 X here you see X is a type variable so this is like an argument or a function
 as well so the type argument so these are value arguments and this is a
 type argument and like in any function argument I can rename this to anything
 I want I can rename this to T I can reveal this to LA I can rename this
 to anything so by convention these are single capital letters but it doesn't
 have to be this way so iterate is the first argument which is start second
 argument is a function from T to T so we have exactly the same arguments
 here so I give X 0 and f as the arguments so what does iterate do it creates
 an iterator that takes X 0 as the first value and then applies f repeatedly
 getting the next value and again getting the next value and so on that's
 exactly what we want however this will generate an infinite iterators will
 never stop so what we need is to stop when this condition is true so we
 filter which means we skip all the elements in the iterator sequence for
 which the condition is not true after the filter I still have an iterator
 of T but now all elements in this iterator sequence are such that the condition
 returns true we actually only need the first one so let's take one element
 the result of this is still an iterator you see to see that I press command
 and I hover my mouse over this symbol and then I see what type it would
 definition it has an type in everything so after this I have a still an
 iterator of T with just one element in it so now I can convert this to
 sequence the result of that would be sequence of T having just one element
 now I take a head of this sequence which is just one value it's safe to
 take head because well either this condition is never true or it's true
 sometimes if it's true sometimes we'll get that value this sequence will
 be non-empty and head can be done on an on two secrets if this condition
 is never true and this iterator will iterate forever the filter will be
 never true so this entire thing will never return we cannot do very much
 about this while we could in principle first specify some max number of
 elements take that so we could do this to be safe take 1 million elements
 and but that would is not what we were told to do in the problem setting
 so in some real situation we should think about limiting the number of
 iterations of course let's just forget about this for now ok so this is
 a reasonably simple implementation the second implementation uses tail
 recursion so that is a direct translation of mathematical induction which
 is if the condition is true already on the initial element that's the base
 case of the induction and then we return that initial element otherwise
 we apply one function f1 x and a function f to x0 and call the same function
 again so we do the inductive step the the value is the same procedure applied
 to the next value after the initial value now this is a little more difficult
 to reason about perhaps than this and also what if I wanted to limit the
 number of iterations then I have to complicate this code significantly
 so tail recursion is not very nice to maintain its or rather not Taylor
 just recursion at all recursive functions generally take more work to write
 and more work to maintain that is to to make the curve to make changes
 if you want to do other things or make things different I'll do things
 differently it's more difficult to make changes to recursive function then
 it is - this kind of code which is on the surface it's not recursive was
 just calling library functions and working directly on a sequence so iterator
 produces a sequence and we just call functions on a sequence - nothing
 is recursive here recursion is hidden somewhere in the library and it's
 safe so it's very easy to change this code to do whatever we want so I
 would prefer this implementation in production code it's easier to maintain
 how do I test this well I test this using the procedure to compute approximate
 square roots with the saturation so this is known from numerical methods
 i iterate a square root sequence so given X and if given Y which is an
 approximation to the square root then this formula gives a better approximation
 to the square root of x and I iterate that with initial value equal to
 1/2 of X just randomly kind of chosen as Peralta strongly not equal to
 x over 2 min most cases but anyway that's okay as an initial guess and
 then the condition the condition is that Y times y minus x is less than
 the given precision so I need to specify the precision just write it like
 this with all s spaced out how do I test this so I say precision is 10
 to the minus 8 and then let's compute square root of 25 that should be
 equal to 5 plus - precision so this is test library that gives me their
 syntax and this test passes final - worked examples are to infer types
 in a function so this is something we have done when we were reasoning
 about twice and let's just do this a little more to get practice to understand
 how types work in functions alright so what is this let's reason about
 this I already wrote of course the solution before but let's pretend we
 don't see that so how do we reason about it so here's what we need right
 this code is given what is the type of this value well obviously it's a
 function what is the type of the argument of this function well this is
 some kind of a so f has type a and then the code of the function the expression
 is f of 2 well that can only work if F is itself a function and this function
 has an argument that is an integer so a must be actually int going to some
 B that's the only way that this could make any sense all right now what
 is the result of applying F to 2 the result is of type D so this will return
 B so what is the type of this entire expression it's a function that takes
 F this and returns this which is of type B so so it returns B and it takes
 this does it type okay so it's let me write it a little more formatted
 so this is the actual type now it has an unknown type B which is not fixed
 by the code it could be any type so therefore we need this B as a type
 parameter here this is how we derive the type now I wrote this solution
 exactly the same code except I used T instead of B so as we know this is
 a type variable so it can be renamed and we know in mathematics our function
 arguments can be renamed type arguments are the kind of function arguments
 as well although there are different different sort so it's the same if
 we write B or T or any other letter so in this way we infer the missing
 types so let's find out if this works so how do we test well we need to
 supply a function of type into T so I'd say T is boolean so let's supply
 this function which is defined as this again this is a function I used
 before which checks that X is even X going to this expression which is
 true only when X is even so then P of F should equal true because 2 is
 even so the function P applies def to a fixed argument which is 2 fixed
 value which is 2 so then P of F is true because F in our example is checking
 whether its argument is even another question here is whether P of P works
 and I have a test here that says it does not compile so why does P of P
 not compile let's reason about the type of P of P so P of P let's write
 out the type arguments well it could be different type arguments correct
 we don't know that so it could be different type arguments since they're
 not written in this expression could we find any type arguments a and B
 that would make this expression well typed let's reason about this let's
 replace the expression P of B with its type just for our own notes this
 is not going to be Scala code it's going to be our reasoning which is some
 mathematical like notation so we replace this with the type so the type
 of P of B is this int going to be going to be and P of a is int going to
 a going to a so this type is a function which is applied to this type now
 the only way this can work is when the type of the argument of this function
 is the same as the type of the expression that we are applying it to so
 can it be that int int going to a is the same as int going to be to be
 so the left hand side is something going to something a function type mapping
 into a lab the right hand side is again against something going to something
 so the only way this can work is if a is the same as be yeah but now it
 doesn't worry because int is not the same type as int going to 84 no possible
 type a we could have int equal to this because this is a function type
 and this is not a function type so there are no more type variables there
 is nothing we can do to make this match so for this reason there are no
 possibilities to find types or type parameters in this expression so that
 the types match the compiler finds this and gives us an error so if I write
 something like this I will have read type mismatch cannot resolve reference
 be with such signature so it tries to find values of type parameters that
 would match but it can't and so it gives me read right away now this read
 is different from the read I would get if I emitted type parameters somewhere
 because actually this can never work whatever type parameters you put in
 it just will never match because what we just saw well we just saw int
 cannot be equal to int to me so that's why it will not compile the final
 worked example is this inferred types in this code and ask questions about
 key of Q and Q of Q of Q so this is kind of a puzzle a bit so let's go
 through this just as an illustration of type directed reason so Q is given
 as sowhat's again start reasoning q is given as f going to G going to G
 of F f going to G going to G of F so this is the code that we are given
 we should be able to put types on it so let me put this into braces and
 let's put types so f is some type a maybe G is of some type B I don't know
 what types so right now I just put some arbitrary type various type of
 variables okay now G of F is in the code so it means G must be a function
 such that its first argument is of type a so this B must be of type a going
 to some C so let's call let's put it more explicitly it's not helping to
 so okay so we assumed F is of type a therefore G must be of type a to something
 so let's call that something C without loss of generality the result is
 of type C therefore so this whole thing is F type a going to a to C going
 to C so the first argument is a the second is well it's a curried function
 so it's the syntax with something arrow something arrow something where
 the parentheses around the last pair are assumed so I'm not going to write
 down but these parentheses are assumed and therefore the type of Q must
 be this and that's the most general type I have not assumed anything about
 any type so for example G is a function it must be a function because it's
 applied to F but the result of genius any types it could be any complicated
 type could be itself a function I don't care so Q must have two type parameters
 a and C therefore and that is the solution so this is exactly what I wrote
 here except I used letters F and T instead of a and C and I have two versions
 of syntax first is when I specify the types on the right hand side the
 second if I specify the types on the left hand side other than that it's
 exactly the same thing so Scala would not work if I don't specify types
 it cannot infer type parameters so I have to specify type parameters and
 I have to specify either this or this if I specify this it will infer the
 right type if I specify that it will infer types of F and type on G I prefer
 the second form because it shows what type this value is so this computation
 doesn't have to be repeated by people who will look at this code later
 and actually I would even prefer q1 let's say which has two sets of our
 means one is f-type F 1 and G of type F going to T and that's of type T
 so I would actually prefer to write code like this because that is easier
 to read I clearly show there two groups of arguments two sets of arguments
 we are not actually mathematical sets leader sequences of arguments as
 arguments are ordering here so first and second and I clearly separate
 languages easier to read the types are given the result type in women and
 the code is shortened so I don't have this longer expression which is somewhat
 more difficult to read and I don't have this expression however it's nice
 to understand that this is actually the function value unworthiness all
 right so when I use this skill I need to specify type parameters fmt otherwise
 it doesn't know what to do and that means don't work well as we have seen
 before so let me just emphasize two things first these three syntactic
 forms define exactly equivalent code there's no difference between the
 code except the syntax second thing I'd like to emphasize is that this
 function exists once in the code and it can be used many times specifying
 different type parameters so I could use it in this place in the code with
 these type parameters at another place in the code with different type
 parameters I don't have to repeat the definition of this function and it's
 not duplicate it's called with different types so really type parameters
 are like arguments where you call function call this function many times
 of different audience you can call this function many tests also with different
 type turnovers and different arguments here I show different ways of using
 it so a has the type insta boolean - boolean and then I use it on a function
 which is into the boolean I get boolean now if I don't specify types then
 this doesn't work I have to specify types here it works because I specified
 that this is returning boolean so it could get both type parameters so
 you see sometimes you have to specify types at other times if you give
 both arguments at once then this is fine you don't have to specify type
 it's never an error to specify type parameters just makes your code longer
 so it knows this is an int because this is an int and then that is a boolean
 so it knows this is a boy so in this case you didn't have to specify this
 in here but you could and if you do the error message would probably be
 easier to understand so I put here for example 10.0 type mismatch expected
 int actual double but why does it expect int it's because of this int that
 I wrote if I didn't write this this error wouldn't be noticed so it's never
 a mistake to write types it's safer it guards against mistakes in the code
 earlier but it's just more typing so it's not always necessary alright
 now what is Q of Q well that's an interesting same Q of Q and you see things
 are getting very long very easy but I will not go through a key of P of
 Q perhaps because it's very similar so let us go through Q of Q so that's
 reason about it so what is Q of Q well first of all we need to put type
 parameters Q has to type parameters a and B and this is C only right because
 the two instances of Q could have completely different type parameters
 the Scala compiler will try to find combinations of type parameters that
 work together it may fail or it may succeed let's see if this succeeds
 just as I did before I'm going to replace this expression with its type
 just for the purposes of reasoning so what is the type the easiest way
 to see the type is to look at this syntax so this is the type F T is f
 f - t t so so this is going to be C going to see me going through D and
 this is I'm just going to copy this in here and replace CMD with mV so
 now I'm going to try to fit the types together this function has the first
 argument which is of type a and it's applied to this expression of this
 type so the only way this can work if a equals this that's already something
 but once that is so once a is equal to this then there is no more constraint
 so this argument has been substituted it has the right type B is an is
 not fixed so B can be anything so actually we have three arbitrate type
 parameters now B CMD now I can rename them but I have three type parameter
 so Q Q which is Q of Q has this type which is applying Q to this expression
 and the result is this type now a is equal to that so I thought it I'm
 dating just recently didn't it so let me copy this and instead of a let
 me copy this now I need parentheses around it let me do it slower put parenthes
es and then copy it in there now there are no mistakes so this is actually
 the type of Q of Q it's a complicated type it's a higher order function
 a function that takes as its first argument this function that takes as
 its first argument this function that takes as its first argument this
 of type C and the second argument this so the complicated matching of types
 that we'll all be performed automatically by the Scala compiler so the
 way that scholar can do it for you is first you write this so we have just
 figured out it a must be equal to this so let's put that in the type parameters
 and then put all the type parameters explicitly and then say option enter
 and add type annotations so the Scala compiler will infer this type correctly
 in the same way reasoning about Q of Q of Q gives you this set of type
 parameters and so I'm not going to go through this but you're encouraged
 to travel now something that doesn't work is this now you see there's a
 difference between this and this here I take Q of Q and I apply Q to the
 result here I take Q of Q and apply that again this does not compile because
 Scala cannot infer the correct type arguments for these two cues so I can
 put arbitrary a and B but it's complicated so how do it reason about this
 it is not clear actually at the beginning whether this expression can be
 typed so in programming languages such as Oh camel and Haskell I'm pretty
 sure this would be done by the compiler because their type systems are
 different and these examples can be typed automatically but in Scala this
 is not automatic so let's reason about it and this is also a good exercise
 so what is this expression is the same as QQ applied to Q here we have
 a type of QQ with three type argument so let's put it here and this Q has
 two type arguments so let's take this expression so basically our [Music]
 question is can we find ABC F and T so that this is a well typed expression
 now expression is well typed when all functions receive arguments of the
 correct types that's basically the definition here we have this function
 which is applied to this argument of this type so the only condition is
 whether this function QQ o of types ABC has the first argument which can
 be matched with this type let's check what is the type of QQ of ABC it
 is this this is a function whose first argument is yes parentheses so let's
 copy that so this must equal this if that can be matched with some choice
 of ABC F T then we're done there are no other problems how can this be
 matched so again the only way that this can be matched is when the left
 is a function of some X to some Y and the right also is a function from
 some X to some one the same x and y now the left is a function from this
 to see the right is a function from F to this remember there's implicitly
 there are these parentheses here therefore f must equal this and C must
 equal this okay can we do this of course we can F can be equal to this
 and once that is true C must be equal to that so let's put parentheses
 here and I'll paste it in alright so now we can put this instead of F in
 here so that's right code actually some parameters C T whatever actually
 C will be equal to that so a B and T will remain and then we get QQ of
 a B C of Q of F C right now let's paste so f is equal to this and C is
 equal to that and now everything is green so now we can do option enter
 here and it will infer the type so the type of this expression is actually
 this which is the same as the type of QQ up to changing C 2 T so we can
 rename this to C and it will be exactly the same type so this is very interesti
ng we we have Q of Q of this type and Q of Q of Q is again of this type
 so clearly we can continue doing this Q of Q of Q of Q of Q and it will
 still have the same type up to some complicated substitutions in the types
 now this example I admit is quite artificial but this serves to show you
 how type reasoning works here are some exercises for you and you can apply
 the typed reasoning as I just showed you in the same way and I encourage
 you to do these exercises 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Curried functions
\end_layout

\begin_layout Standard
Consider a function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => (Int => Int)
\end_layout

\end_inset

.
 This is a function that takes an integer and returns a 
\emph on
function
\emph default
 that again takes an integer and then returns an integer.
 So, we obtain an integer result only after we apply the function to 
\emph on
two
\emph default
 integer values, one after another.
 This is, in a sense, equivalent to a function having two arguments, except
 the application of the function needs to be done in two steps, applying
 it to one argument at a time.
 Functions of this sort are called 
\series bold
curried
\series default
 functions
\begin_inset Index idx
status open

\begin_layout Plain Layout
curried function
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
One way of defining such a function is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f0(x: Int): Int => Int = { y => x - y }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function takes an integer argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returns the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y => x - y
\end_layout

\end_inset

, which is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
 So the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f0
\end_layout

\end_inset

 is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => (Int => Int)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f0
\end_layout

\end_inset

, we must apply it to an integer value.
 The result is a value of function type:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val r = f0(20)
\end_layout

\end_inset

The value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

 can be now applied to another integer argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> r(4)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset

 means the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => (Int => Int)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => x - y
\end_layout

\end_inset

 means the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => (y => x - y)
\end_layout

\end_inset

.
 In other words, the function symbol 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 associates to the right.
 Thus, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f0
\end_layout

\end_inset

 may be equivalently written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
An equivalent way of defining a function with the same type signature is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f1: Int => Int => Int = x => y => x - y
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us compare the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 with a function that takes its two arguments at once.
 Such a function will have a different type signature, for instance
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2(x: Int, y: Int): Int = x - y
\end_layout

\end_inset

has type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int) => Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The syntax for calling the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is different:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f1(20)(4)
\end_layout

\begin_layout Plain Layout

scala> f2(20, 4)
\end_layout

\end_inset

The main difference between the usage of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 must be applied 
\emph on
at once
\emph default
 to both arguments, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1(20)
\end_layout

\end_inset

 can be evaluated separately, – that is, applied only to its first argument,
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

.
 The result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1(20)
\end_layout

\end_inset

 is a 
\emph on
function
\emph default
 that can be later applied to another argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val r = f1(20)
\end_layout

\begin_layout Plain Layout

scala> r(4)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Applying a curried function to some but not all of possible arguments is
 called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
partial application
\end_layout

\end_inset

partial application
\series default
.
\end_layout

\begin_layout Standard
More generally, a curried function may have a type signature of the form
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => P => Z
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, ..., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 are some types.
 I prefer to think about this kind of type signature as having arguments
 of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, ..., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

, called the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
curried arguments
\end_layout

\end_inset

curried arguments
\series default
 of the function, and the 
\begin_inset Quotes eld
\end_inset

final
\begin_inset Quotes erd
\end_inset

 return value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

final
\begin_inset Quotes erd
\end_inset

 return value of the function is returned after supplying all arguments.
\end_layout

\begin_layout Standard
A function with this type signature is, in a sense, equivalent to an 
\series bold
uncurried
\begin_inset Index idx
status open

\begin_layout Plain Layout
uncurried function
\end_layout

\end_inset


\series default
 function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B,C,...,P) => Z
\end_layout

\end_inset

.
 The uncurried function takes all arguments at once.
 The equivalence of curried and uncurried functions is not 
\emph on
equality
\emph default
  –  these functions are 
\emph on
different
\emph default
; but one of them can be easily reconstructed from the other if necessary.
 One says that a curried function is 
\begin_inset Index idx
status open

\begin_layout Plain Layout
isomorphic
\end_layout

\end_inset


\series bold
isomorphic
\series default
 or 
\series bold
equivalent
\series default
 to an uncurried function.
\end_layout

\begin_layout Standard
From the point of view of programming language theory, curried functions
 are 
\begin_inset Quotes eld
\end_inset

simpler
\begin_inset Quotes erd
\end_inset

 because they always have a 
\emph on
single
\emph default
 argument (and may return a function that will consume further arguments).
 From the point of view of programming practice, curried functions are sometimes
 harder to read.
\end_layout

\begin_layout Standard
In the syntax used e.g.
\begin_inset space \space{}
\end_inset

in OCaml and Haskell, a curried function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is applied to its arguments as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2 20 4
\end_layout

\end_inset

.
 This departs further from the mathematical tradition and requires some
 getting used to.
 If the two arguments are more complicated than just 
\begin_inset Formula $20$
\end_inset

 and 
\begin_inset Formula $4$
\end_inset

, the resulting expression may become significantly harder to read, compared
 with the syntax where commas are used to separate the arguments.
 (Consider, for example, the Haskell expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2 (g 10) (h 20) + 30
\end_layout

\end_inset

.) To improve readability of code, programmers may prefer to first define
 short names for complicated expressions and then use these names as curried
 arguments.
\end_layout

\begin_layout Standard
In Scala, the choice of whether to use curried or uncurried function signatures
 is largely a matter of syntactic convenience.
 Most Scala code tends to be written with uncurried functions, while curried
 functions are used when they produce more easily readable code.
\end_layout

\begin_layout Standard
One of the syntactic features for curried functions in Scala is the ability
 to give a curried argument using the curly brace syntax.
 Compare the two definitions of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

summation
\end_layout

\end_inset

 described earlier:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def summation1(a: Int, b: Int, g: Int => Int): Int =
\end_layout

\begin_layout Plain Layout

  (a to b).map(g).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def summation2(a: Int, b: Int)(g: Int => Int): int =
\end_layout

\begin_layout Plain Layout

  (a to b).map(g).sum
\end_layout

\begin_layout Plain Layout

summation1(1, 10, x => x*x*x + 2*x)
\end_layout

\begin_layout Plain Layout

summation2(1, 10){ x => x*x*x + 2*x }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code that calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

summation2
\end_layout

\end_inset

 may be easier to read because the curried argument is syntactically separated
 from the rest of the code by curly braces.
 This is especially useful when the curried argument is itself a function,
 since the Scala curly braces syntax allows function bodies to contain their
 own local definitions (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
A feature of Scala is the 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 method syntax: for example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs map f
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.map(f)
\end_layout

\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 syntax works only for infix methods, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, defined on specific types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

.
 Do not confuse Scala's 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 method syntax with the short function application syntax such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap f xs
\end_layout

\end_inset

, used in Haskell and some other languages.
\end_layout

\begin_layout Subsection
Calculations with nameless functions
\end_layout

\begin_layout Standard
We now need to gain experience working with nameless functions.
\end_layout

\begin_layout Standard
In mathematics, functions are evaluated by substituting their argument values
 into their body.
 Nameless functions are evaluated in the same way.
 For example, applying the nameless function 
\begin_inset Formula $x\Rightarrow x+10$
\end_inset

 to an integer 
\begin_inset Formula $2$
\end_inset

, we substitute 
\begin_inset Formula $2$
\end_inset

 instead of 
\begin_inset Formula $x$
\end_inset

 in “
\begin_inset Formula $x+10$
\end_inset

” and get “
\begin_inset Formula $2+10$
\end_inset

”, which we then evaluate to 
\begin_inset Formula $12$
\end_inset

.
 The computation is written like this, 
\begin_inset Formula 
\[
(x\Rightarrow x+10)(2)=2+10=12\quad.
\]

\end_inset

Nameless functions are 
\emph on
values
\emph default
 and can be used as part of larger expressions, just as any other values.
 For instance, nameless functions can be arguments of other functions (nameless
 or not).
 Here is an example of applying a nameless function 
\begin_inset Formula $f\Rightarrow f(2)$
\end_inset

 to a nameless function 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

:
\begin_inset Formula 
\[
\left(f\Rightarrow f(2)\right)(x\Rightarrow x+4)=(x\Rightarrow x+4)(2)=6\quad.
\]

\end_inset

In the nameless function 
\begin_inset Formula $f\Rightarrow f(2)$
\end_inset

, the argument 
\begin_inset Formula $f$
\end_inset

 has to be itself a function, otherwise the expression 
\begin_inset Formula $f(2)$
\end_inset

 would make no sense.
 In this example, 
\begin_inset Formula $f$
\end_inset

 must have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
There are some standard conventions for reducing the number of parentheses
 when writing expressions involving nameless functions, especially curried
 functions:
\end_layout

\begin_layout Itemize
Function expressions group everything to the right:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $x\Rightarrow y\Rightarrow z\Rightarrow e$
\end_inset

 means the same as 
\begin_inset Formula $x\Rightarrow\left(y\Rightarrow\left(z\Rightarrow e\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Function applications group everything to the left:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $f(x)(y)(z)$
\end_inset

 means 
\begin_inset Formula $\big((f(x))(y)\big)(z)$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Function applications group stronger than infix operations:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $x+f(y)$
\end_inset

 means 
\begin_inset Formula $x+(f(y))$
\end_inset

, just like in mathematics.
\end_layout

\begin_layout Standard
To specify the type of the argument, I will use a colon in the superscript,
 for example: 
\begin_inset Formula $x^{:\text{Int}}\Rightarrow x+2$
\end_inset

.
\end_layout

\begin_layout Standard
The convention of grouping functions to the right reduces the number of
 parentheses for curried function types used most often.
 It is rare to find use for function types such as 
\begin_inset Formula $(\left(a\Rightarrow b\right)\Rightarrow c)\Rightarrow d$
\end_inset

 that require many parentheses with this convention.
\end_layout

\begin_layout Standard
Here are some more examples of performing function applications symbolically.
 I will omit types for brevity, since every non-function value is of type
 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset


\family default
 in these examples.
\begin_inset Formula 
\begin{align*}
\left(x^{:\text{Int}}\Rightarrow x*2\right)(10) & =10*2=20\quad.\\
\left(p\Rightarrow z\Rightarrow z*p\right)\left(t\right) & =(z\Rightarrow z*t)\quad.\\
\left(p\Rightarrow z\Rightarrow z*p\right)(t)(4) & =(z\Rightarrow z*t)(4)=4*t\quad.
\end{align*}

\end_inset

Some results of these computation are integer values such as 
\begin_inset Formula $20$
\end_inset

; in other cases, results are 
\emph on
function
\emph default
 
\emph on
values
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
function value
\end_layout

\end_inset

 such as 
\begin_inset Formula $z\Rightarrow z*t$
\end_inset

.
\end_layout

\begin_layout Standard
In the following examples, some function arguments are themselves functions:
\begin_inset Formula 
\begin{align*}
\left(f\Rightarrow p\Rightarrow f(p)\right)\left(g\Rightarrow g(2)\right) & =\left(p\Rightarrow p(2)\right)\quad.\\
\left(f\Rightarrow p\Rightarrow f(p)\right)\left(g\Rightarrow g(2)\right)\left(x\Rightarrow x+4\right) & =\left(p\Rightarrow p(2)\right)\left(x\Rightarrow x+4\right)\\
 & =2+4=6\quad.
\end{align*}

\end_inset

Here I have been performing calculations step by step, as usual in mathematics.
 A Scala program is evaluated in a similar way at run time.
\end_layout

\begin_layout Subsection
Short syntax for function applications
\end_layout

\begin_layout Standard
In mathematics, function applications are sometimes written without parentheses,
 for instance 
\begin_inset Formula $\cos x$
\end_inset

 or 
\begin_inset Formula $\text{arg}\,z$
\end_inset

.
 There are also cases where formulas such as 
\begin_inset Formula $\sin2x=2\sin x\cos x$
\end_inset

 imply parentheses as 
\begin_inset Formula $\sin\left(2x\right)=2\cdot\sin\left(x\right)\cdot\cos\left(x\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Many programming languages (such as ML, OCaml, F#, Haskell, Elm, PureScript)
 have adopted this 
\begin_inset Quotes eld
\end_inset

short syntax
\begin_inset Quotes erd
\end_inset

, in which parentheses are optional for function arguments.
 The result is a concise notation where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f x
\end_layout

\end_inset

 means the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

.
 Parentheses are still used where necessary to avoid ambiguity or for readabilit
y.
\begin_inset Foot
status open

\begin_layout Plain Layout
The no-parentheses syntax has a long history.
 It is used in Unix shell commands, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cp file1 file2
\end_layout

\end_inset

, as well as in the programming language Tcl/Tk.
 In LISP and Scheme, each function application is enclosed in parentheses
 but the arguments are separated by spaces, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(+ 1 2 3)
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The conventions for nameless functions in the short syntax become:
\end_layout

\begin_layout Itemize
Function expressions group everything to the right:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $x\Rightarrow y\Rightarrow z\Rightarrow e$
\end_inset

 means 
\begin_inset Formula $x\Rightarrow\left(y\Rightarrow\left(z\Rightarrow e\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Function applications group everything to the left:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $f\,x\,y\,z$
\end_inset

 means 
\begin_inset Formula $\big((f\,x)\:y\big)\:z$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Function applications group stronger than infix operations: 
\begin_inset Formula $x+f\,y$
\end_inset

 means 
\begin_inset Formula $x+(f\,y)$
\end_inset

, just like in mathematics 
\begin_inset Formula $x+\cos y$
\end_inset

 groups 
\begin_inset Formula $\cos y$
\end_inset

 stronger than the infix 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $+$
\end_inset


\begin_inset Quotes erd
\end_inset

 operation.
\end_layout

\begin_layout Standard
So, 
\begin_inset Formula $x\Rightarrow y\Rightarrow a\,b\,c+p\,q$
\end_inset

 means 
\begin_inset Formula $x\Rightarrow\left(y\Rightarrow\left(\left(a\,b\right)\,c\right)+(p\,q)\right)$
\end_inset

.
 When this notation becomes hard to read correctly, one needs to add parentheses
, e.g.
\begin_inset space \space{}
\end_inset

to write 
\begin_inset Formula $f(x\Rightarrow g\,h)$
\end_inset

 instead of 
\begin_inset Formula $f\,x\Rightarrow g\,h$
\end_inset

.
\end_layout

\begin_layout Standard
In this book, I will sometimes use this 
\begin_inset Quotes eld
\end_inset

short syntax
\begin_inset Quotes erd
\end_inset

 when reasoning about code.
 Scala does not support the short syntax; in Scala, parentheses need to
 be put around every curried argument.
 The infix method syntax such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1,2,3) map func1
\end_layout

\end_inset


\family default
 does not work with curried functions in Scala.
\end_layout

\begin_layout Subsection
Higher-order functions
\end_layout

\begin_layout Standard
The 
\series bold
order
\begin_inset Index idx
status open

\begin_layout Plain Layout
order of a function
\end_layout

\end_inset


\series default
 of a function is the number of function arrows 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 contained in the type signature of that function.
 If a function's type signature contains more than one function arrow, the
 function is called a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
higher-order function
\end_layout

\end_inset

higher-order
\series default
 function.
 A higher-order function takes a function as argument and/or returns a function
 as its result value.
\end_layout

\begin_layout Standard
Examples:
\end_layout

\begin_layout LyX-Code
def f1(x: Int): Int = x + 10
\end_layout

\begin_layout Standard
The function 
\family typewriter
f1
\family default
 has type signature 
\family typewriter
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int
\family default
 and order 1, so it is 
\emph on
not
\emph default
 a higher-order function.
\end_layout

\begin_layout LyX-Code
def f2(x: Int): Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int = z 
\begin_inset Formula $\Rightarrow$
\end_inset

 z + x
\end_layout

\begin_layout Standard
The function 
\family typewriter
f2
\family default
 has type signature 
\family typewriter
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int
\family default
 and is a higher-order function, of order 2.
 
\end_layout

\begin_layout LyX-Code
def f3(g: Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int): Int = g(123)
\end_layout

\begin_layout Standard
The function 
\family typewriter
f3
\family default
 has type signature 
\family typewriter
(Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int
\family default
 and is a higher-order function of order 2.
\end_layout

\begin_layout Standard
Although 
\family typewriter
f2
\family default
 is a higher-order function, its higher-orderness comes from the fact that
 the return value is of function type.
 An equivalent computation can be performed by an uncurried function that
 is not higher-order:
\end_layout

\begin_layout LyX-Code
scala> def f2u(x: Int, z: Int): Int = z + x
\end_layout

\begin_layout Standard
The Scala library defines methods to transform between curried and uncurried
 functions:
\end_layout

\begin_layout LyX-Code
scala> def f2u(x: Int, z: Int): Int = z + x
\end_layout

\begin_layout LyX-Code
scala> val f2c = (f2u _).curried
\end_layout

\begin_layout LyX-Code
scala> val f2u1 = Function.uncurried(f2c)
\end_layout

\begin_layout Standard
The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f2u _)
\end_layout

\end_inset

 is used in Scala to convert methods to function values.
 Recall that Scala has two ways of defining a function: one as a method
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala method
\end_layout

\end_inset

 (defined using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

), another as a function value
\begin_inset Index idx
status open

\begin_layout Plain Layout
function value
\end_layout

\end_inset

 (defined using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.curried
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.uncurried
\end_layout

\end_inset

 can be easily implemented in Scala code, as we will see in the worked examples.
\end_layout

\begin_layout Standard
Unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset

 cannot be converted to a non-higher-order function because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset

 has an argument of function type, rather than a return value of function
 type.
 Converting to an uncurried form cannot eliminate an argument of function
 type.
\end_layout

\begin_layout Subsection
Worked examples: higher-order functions
\end_layout

\begin_layout Enumerate
Using both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

, define a function that...
\end_layout

\begin_deeper
\begin_layout Enumerate
...adds 
\begin_inset Formula $20$
\end_inset

 to its integer argument.
\end_layout

\begin_deeper
\begin_layout LyX-Code
def fa(i: Int): Int = i + 20
\end_layout

\begin_layout LyX-Code
val fa_v: (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) = k 
\begin_inset Formula $\Rightarrow$
\end_inset

 k + 20
\end_layout

\begin_layout Standard
It is not necessary to specify the type of the argument 
\family typewriter
k
\family default
 because we already fully specified the type 
\family typewriter
(Int => Int)
\family default
 of 
\family typewriter
fa_v
\family default
.
 The parentheses around the type of 
\family typewriter
fa_v
\family default
 are optional, I added them for clarity.
\end_layout

\end_deeper
\begin_layout Enumerate
...takes an integer 
\begin_inset Formula $x$
\end_inset

, and returns a 
\emph on
function
\emph default
 that adds 
\begin_inset Formula $x$
\end_inset

 to 
\emph on
its
\emph default
 argument.
\end_layout

\begin_deeper
\begin_layout LyX-Code
def fb(x: Int): (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) = k 
\begin_inset Formula $\Rightarrow$
\end_inset

 k + x
\end_layout

\begin_layout LyX-Code
val fb_v: (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 k 
\begin_inset Formula $\Rightarrow$
\end_inset

 k + x
\end_layout

\begin_layout LyX-Code
def fb_v2(x: Int)(k: Int): Int = k + x
\end_layout

\begin_layout Standard
Since functions are values, we can directly return new functions.
 When defining the right-hand sides as function expressions in 
\family typewriter
fb
\family default
 and 
\family typewriter
fb_v
\family default
, it is not necessary to specify the type of the arguments 
\family typewriter
x
\family default
 and 
\family typewriter
k
\family default
 because we already fully specified the type signatures of 
\family typewriter
fb
\family default
 and 
\family typewriter
fb_v
\family default
.
 The last version, 
\family typewriter
fb_v2
\family default
, may be easier to read and is equivalent to 
\family typewriter
fb_v.
\end_layout

\end_deeper
\begin_layout Enumerate
...takes an integer 
\begin_inset Formula $x$
\end_inset

 and returns 
\family typewriter
true
\family default
 iff 
\begin_inset Formula $x+1$
\end_inset

 is a prime.
 Use the function 
\family typewriter
is_prime
\family default
 defined previously.
\end_layout

\begin_deeper
\begin_layout LyX-Code
def fc(x: Int): Boolean = is_prime(x + 1)
\end_layout

\begin_layout LyX-Code
val fc_v: (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Boolean) = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 is_prime(x + 1)
\end_layout

\end_deeper
\begin_layout Enumerate
...returns its integer argument unchanged.
 (This is called the 
\series bold
identity function
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity function
\end_layout

\end_inset


\series default
 for integer type.)
\end_layout

\begin_deeper
\begin_layout LyX-Code
def fd(i: Int): Int = i
\end_layout

\begin_layout LyX-Code
val fd_v: (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) = k 
\begin_inset Formula $\Rightarrow$
\end_inset

 k
\end_layout

\end_deeper
\begin_layout Enumerate
...takes 
\begin_inset Formula $x$
\end_inset

 and always returns 123, ignoring its argument 
\begin_inset Formula $x$
\end_inset

.
 (This is called a 
\series bold
constant function
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant function
\end_layout

\end_inset


\series default
.)
\end_layout

\begin_deeper
\begin_layout LyX-Code
def fe(x: Int): Int = 123
\end_layout

\begin_layout LyX-Code
val fe_v: (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 123
\end_layout

\begin_layout Standard
To emphasize the fact that the argument 
\begin_inset Formula $x$
\end_inset

 is ignored, use the special syntax where 
\begin_inset Formula $x$
\end_inset

 is replaced by the underscore:
\end_layout

\begin_layout LyX-Code
val fe_v1: (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) = _ 
\begin_inset Formula $\Rightarrow$
\end_inset

 123
\end_layout

\end_deeper
\begin_layout Enumerate
...takes 
\begin_inset Formula $x$
\end_inset

 and returns a constant function that always returns the fixed value 
\begin_inset Formula $x$
\end_inset

.
 (This is called the 
\series bold
constant combinator
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant combinator
\end_layout

\end_inset


\series default
.)
\end_layout

\begin_deeper
\begin_layout LyX-Code
def ff(x: Int): Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int = _ 
\begin_inset Formula $\Rightarrow$
\end_inset

 x
\end_layout

\begin_layout LyX-Code
val ff_v: (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 _ 
\begin_inset Formula $\Rightarrow$
\end_inset

 x
\end_layout

\begin_layout LyX-Code
def ff_v2(x: Int)(y: Int): Int = x
\end_layout

\begin_layout Standard
The syntax of 
\family typewriter
ff_v2
\family default
 may be easier to read, but then we cannot omit the name 
\family typewriter
y
\family default
 for the unused argument.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Define a function 
\family typewriter
comp
\family default
 that takes two functions 
\begin_inset Formula $f:$
\end_inset


\family typewriter
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Double
\family default
 and 
\begin_inset Formula $g:$
\end_inset


\family typewriter
Double 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\family default
 as arguments, and returns a new function that computes 
\begin_inset Formula $g(f(x))$
\end_inset

.
 What is the type of the function 
\family typewriter
comp
\family default
?
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
def comp(f: Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Double, g: Double 
\begin_inset Formula $\Rightarrow$
\end_inset

 String): (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String) =
\end_layout

\begin_layout LyX-Code

\size footnotesize
  x 
\begin_inset Formula $\Rightarrow$
\end_inset

 g(f(x))
\end_layout

\begin_layout LyX-Code

\size footnotesize
scala> val f: Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Double = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 5.67 + x
\end_layout

\begin_layout LyX-Code

\size footnotesize
scala> val g: Double 
\begin_inset Formula $\Rightarrow$
\end_inset

 String = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 f"x=%3.2f"
\end_layout

\begin_layout LyX-Code

\size footnotesize
scala> val h = comp(f, g)
\end_layout

\begin_layout LyX-Code

\size footnotesize
scala> h(10)
\end_layout

\begin_layout Standard
The function 
\family typewriter
comp
\family default
 has two arguments, of types 
\family typewriter
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Double
\family default
 and 
\family typewriter
Double 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\family default
.
 The result value of 
\family typewriter
comp
\family default
 is of type 
\family typewriter
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\family default
, because 
\family typewriter
comp
\family default
 returns a new function that takes an argument 
\begin_inset Formula $x$
\end_inset

 of type 
\family typewriter
Int
\family default
 and returns a 
\family typewriter
String
\family default
.
 So the full type signature of the function 
\family typewriter
comp
\family default
 is written as
\end_layout

\begin_layout LyX-Code
/// (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Double, Double 
\begin_inset Formula $\Rightarrow$
\end_inset

 String) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String)
\end_layout

\begin_layout Standard
This is an example of a function that both takes other functions as arguments
 
\emph on
and
\emph default
 returns a new function.
\end_layout

\end_deeper
\begin_layout Enumerate
Define a function 
\family typewriter
uncurry2
\family default
 that takes a curried function of type 
\family typewriter
Int => Int => Int
\family default
 and returns an uncurried equivalent function of type 
\family typewriter
(Int, Int) => Int
\family default
.
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
def uncurry2(f: Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int): (Int, Int) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int =
\end_layout

\begin_layout LyX-Code

\size footnotesize
  (x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 f(x)(y)
\end_layout

\end_deeper
\begin_layout Section
Discussion
\end_layout

\begin_layout Subsection
Scope of bound variables
\end_layout

\begin_layout Standard
A bound variable is invisible outside the scope of the expression (often
 called 
\series bold
local scope
\begin_inset Index idx
status open

\begin_layout Plain Layout
local scope
\end_layout

\end_inset


\series default
 whenever it is clear which expression is being considered).
 This is why bound variables may be renamed at will: no outside code could
 possibly use them and depend on their values.
 However, outside code may define variables that (by chance or by mistake)
 have the same name as a bound variable inside the scope.
\end_layout

\begin_layout Standard
Consider this example from calculus: In the integral
\begin_inset Formula 
\[
f(x)=\int_{0}^{x}\frac{dx}{1+x}\quad,
\]

\end_inset

a bound variable named 
\begin_inset Formula $x$
\end_inset

 is defined in 
\emph on
two
\emph default
 local scopes: in the scope of 
\begin_inset Formula $f$
\end_inset

 and in the scope of the nameless function 
\begin_inset Formula $x\Rightarrow\frac{1}{1+x}$
\end_inset

.
 The convention in mathematics is to treat these two 
\begin_inset Formula $x$
\end_inset

's as two 
\emph on
completely
\emph default
 
\emph on
different
\emph default
 variables that just happen to have the same name.
 In sub-expressions where both of these bound variables are visible, priority
 is given to the bound variable defined in the closest inner scope.
 The outer definition of 
\begin_inset Formula $x$
\end_inset

 is 
\series bold
shadowed
\begin_inset Index idx
status open

\begin_layout Plain Layout
name shadowing
\end_layout

\end_inset


\series default
, i.e.
\begin_inset space \space{}
\end_inset

hidden, by the definition of the inner 
\begin_inset Formula $x$
\end_inset

.
 For this reason, mathematicians expect that evaluating 
\begin_inset Formula $f(10)$
\end_inset

 will give
\begin_inset Formula 
\[
f(10)=\int_{0}^{10}\frac{dx}{1+x}\quad,
\]

\end_inset

rather than 
\begin_inset Formula $\int_{0}^{10}\frac{dx}{1+10}$
\end_inset

, because the outer definition 
\begin_inset Formula $x=10$
\end_inset

 is shadowed, within the expression 
\begin_inset Formula $\frac{1}{1+x}$
\end_inset

, by the closer definition of 
\begin_inset Formula $x$
\end_inset

 in the local scope of 
\begin_inset Formula $x\Rightarrow\frac{1}{1+x}$
\end_inset

.
\end_layout

\begin_layout Standard
Since this is the prevailing mathematical convention, the same convention
 is adopted in FP.
 A variable defined in a local scope (i.e.
\begin_inset space \space{}
\end_inset

a bound variable) is invisible outside that scope but will shadow any outside
 definitions of a variable with the same name.
 
\end_layout

\begin_layout Standard
It is better to avoid name shadowing, because it usually decreases the clarity
 of code and thus invites errors.
 Consider this function,
\begin_inset Formula 
\[
x\Rightarrow x\Rightarrow x\quad.
\]

\end_inset

Let us decipher this confusing syntax.
 The symbol 
\begin_inset Formula $\Rightarrow$
\end_inset

 associates to the right, so 
\begin_inset Formula $x\Rightarrow x\Rightarrow x$
\end_inset

 is the same as 
\begin_inset Formula $x\Rightarrow\left(x\Rightarrow x\right)$
\end_inset

.
 So, it is a function that takes 
\begin_inset Formula $x$
\end_inset

 and returns 
\begin_inset Formula $x\Rightarrow x$
\end_inset

.
 Since the returned nameless function, 
\begin_inset Formula $\left(x\Rightarrow x\right)$
\end_inset

, may be renamed to 
\begin_inset Formula $\left(y\Rightarrow y\right)$
\end_inset

 without changing its value, we can rewrite the code to
\begin_inset Formula 
\[
x\Rightarrow\left(y\Rightarrow y\right)\quad.
\]

\end_inset

It is now easier to understand this code and reason about it.
 For instance, it becomes clear that this function actually ignores its
 argument 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Section
Exercises
\end_layout

\begin_layout Enumerate
Define a function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => List[List[Int]] => List[List[Int]]
\end_layout

\end_inset


\family default
 similar to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 except that the hard-coded number 
\begin_inset Formula $100$
\end_inset

 must be a 
\emph on
curried
\emph default
 first argument.
 Implement Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using this function.
\end_layout

\begin_layout Enumerate
Define a function 
\begin_inset Formula $q$
\end_inset

 that takes a function 
\begin_inset Formula $f^{:\text{Int}\Rightarrow\text{Int}}$
\end_inset

 as its argument and returns a new function that computes 
\begin_inset Formula $f(f(f(x)))$
\end_inset

 for any given 
\begin_inset Formula $x$
\end_inset

.
 What is the required type of the function 
\begin_inset Formula $q$
\end_inset

?
\end_layout

\begin_layout Enumerate
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curry2
\end_layout

\end_inset

 that takes an uncurried function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int) => Int
\end_layout

\end_inset


\family default
 and returns an equivalent but 
\emph on
curried
\emph default
 function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset


\family default
.
\end_layout

\end_body
\end_document
